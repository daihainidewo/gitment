<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>golang-协程栈</title>
      <link href="/golang/golang-xie-cheng-zhan.html"/>
      <url>/golang/golang-xie-cheng-zhan.html</url>
      
        <content type="html"><![CDATA[<p>golang栈的增长方向</p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    a <span class="token operator">:=</span> <span class="token number">1</span>    b <span class="token operator">:=</span> <span class="token number">2</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// output: 0xc00036a2b0 0xc00036a2b8</span></code></pre><p>由此可见栈的增长方向是由低地址向高地址增长</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> runtime </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-sar命令</title>
      <link href="/linux/linux-sar-ming-ling.html"/>
      <url>/linux/linux-sar-ming-ling.html</url>
      
        <content type="html"><![CDATA[<h1 id="sar简介"><a href="#sar简介" class="headerlink" title="sar简介"></a>sar简介</h1><p>centos安装sar命令</p><pre class=" language-sh"><code class="language-sh">➜ yum install sysstat -y</code></pre><p>安装后执行sar会报错找不到<code>/var/log/sa/sa14</code>文件，需要等几分钟就好了。</p><pre class=" language-sh"><code class="language-sh">➜ sar -h用法: sar [ 选项 ] [ <时间间隔> [ <次数> ] ]主选项和报告：    -b    I/O 和传输速率信息状况    -B    分页状况    -d    块设备状况    -F [ MOUNT ]        Filesystems statistics    -H    交换空间利用率    -I { <中断> | SUM | ALL | XALL }        中断信息状况    -m { <关键词> [,...] | ALL }        电源管理统计信息        关键字:        CPU    CPU 频率        FAN    风扇速度\t\tFREQ\tCPU 平均时钟频率        IN    输入电压        TEMP    设备温度\t\tUSB\t连接的USB 设备    -n { <关键词> [,...] | ALL }        网络统计信息        关键词可以是：        DEV    网卡        EDEV    网卡 (错误)        NFS    NFS 客户端        NFSD    NFS 服务器        SOCK    Sockets (套接字)    (v4)        IP    IP 流    (v4)        EIP    IP 流    (v4) (错误)        ICMP    ICMP 流    (v4)        EICMP    ICMP 流    (v4) (错误)        TCP    TCP 流    (v4)        ETCP    TCP 流    (v4) (错误)        UDP    UDP 流    (v4)        SOCK6    Sockets (套接字)    (v6)        IP6    IP 流    (v6)        EIP6    IP 流    (v6) (错误)        ICMP6    ICMP 流    (v6)        EICMP6    ICMP 流    (v6) (错误)        UDP6    UDP 流    (v6)    -q    队列长度和平均负载    -r    内存利用率    -R    内存状况    -S    交换空间利用率    -u [ ALL ]        CPU 利用率    -v    Kernel table 状况    -w    任务创建与系统转换统计信息    -W    交换信息    -y    TTY 设备状况</code></pre><h1 id="sar参数"><a href="#sar参数" class="headerlink" title="sar参数"></a>sar参数</h1><h2 id="查看CPU使用情况"><a href="#查看CPU使用情况" class="headerlink" title="查看CPU使用情况"></a>查看CPU使用情况</h2><p>当选项为空时则打印CPU使用情况，或使用<code>sar -u n m</code>每过n获取一次cpu指标，总共获取m次</p><p>指标说明</p><ul><li><code>%user</code>：用户模式下消耗的CPU时间的比例</li><li><code>%nice</code>：通过nice改变了进程调度优先级的进程，在用户模式下消耗的CPU时间的比例</li><li><code>%system</code>：系统模式下消耗的CPU时间的比例</li><li><code>%iowait</code>：CPU等待磁盘I/O导致空闲状态消耗的时间比例</li><li><code>%steal</code>：利用Xen等操作系统虚拟化技术，等待其它虚拟CPU计算占用的时间比例</li><li><code>%idle</code>：CPU空闲时间比例</li></ul><h2 id="查看内存使用情况"><a href="#查看内存使用情况" class="headerlink" title="查看内存使用情况"></a>查看内存使用情况</h2><p>使用<code>sar -r n m</code>可以每过n秒获取一次内存指标，总共获取m次</p><ul><li><code>kbmemfree</code>：这个值和free命令中的free值基本一致,所以它不包括buffer和cache的空间.</li><li><code>kbmemused</code>：这个值和free命令中的used值基本一致,所以它包括buffer和cache的空间.</li><li><code>%memused</code>：物理内存使用率，这个值是kbmemused和内存总量(不包括swap)的一个百分比.</li><li><code>kbbuffers</code>和<code>kbcached</code>：这两个值就是free命令中的buffer和cache.</li><li><code>kbcommit</code>：保证当前系统所需要的内存,即为了确保不溢出而需要的内存(RAM+swap).</li><li><code>%commit</code>：这个值是kbcommit与内存总量(包括swap)的一个百分比.</li></ul><h2 id="查看网卡使用情况"><a href="#查看网卡使用情况" class="headerlink" title="查看网卡使用情况"></a>查看网卡使用情况</h2><p>使用<code>sar -n DEV n m</code>可以每过n秒获取一次网卡指标，总共获取m次</p><p>指标说明</p><ul><li><code>IFACE</code>：网卡名</li><li><code>rxpck/s</code>：每秒钟接收的数据包</li><li><code>txpck/s</code>：每秒钟发送的数据包</li><li><code>rxbyt/s</code>：每秒钟接收的字节数</li><li><code>txbyt/s</code>：每秒钟发送的字节数</li><li><code>rxcmp/s</code>：每秒钟接收的压缩数据包</li><li><code>txcmp/s</code>：每秒钟发送的压缩数据包</li><li><code>rxmcst/s</code>：每秒钟接收的多播数据包</li></ul><p><code>-n</code>选项下面还有一些子选项，可以更细致的获取相关数据的指标</p><h2 id="查看系统负载情况"><a href="#查看系统负载情况" class="headerlink" title="查看系统负载情况"></a>查看系统负载情况</h2><p>使用<code>sar -r n m</code>可以每过n秒获取一次内存指标，总共获取m次</p><p>指标说明</p><ul><li><code>runq-sz</code>：运行队列的长度（等待运行的进程数）</li><li><code>plist-sz</code>：进程列表中进程（processes）和线程（threads）的数量</li><li><code>ldavg-1</code>：最后1分钟的系统平均负载 </li><li><code>ldavg-5</code>：过去5分钟的系统平均负载</li><li><code>ldavg-15</code>：过去15分钟的系统平均负载</li></ul><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/sar.html" target="_blank" rel="noopener">12. sar 找出系统瓶颈的利器</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cmd </tag>
            
            <tag> command </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang 调度过程源码分析</title>
      <link href="/golang/golang-xie-cheng-diao-du-guan-li-yuan-ma-fen-xi.html"/>
      <url>/golang/golang-xie-cheng-diao-du-guan-li-yuan-ma-fen-xi.html</url>
      
        <content type="html"><![CDATA[<p>golang 版本：go version go1.15.2 darwin/amd64</p><p>根据启动函数来分析golang MPG的生存周期，忽略cgo相关代码。</p><h1 id="MPG"><a href="#MPG" class="headerlink" title="MPG"></a>MPG</h1><p>MPG是golang调度的重要对象：</p><ul><li>M，表示一个内核线程，是执行用户代码的实际场所</li><li>P，表示一个处理器，管理M需要运行G的相关资源，如内存分配，G的可执行列表，G的空闲列表等</li><li>G，表示一个goroutine，调度基本单元，维护goroutine内部资源，如栈信息，defer列表等</li></ul><h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><p>启动汇编函数</p><pre class=" language-asm"><code class="language-asm">// runtime/asm_amd64.sTEXT runtime·rt0_go(SB),NOSPLIT,$0    // ... 省略 ...    // create istack out of the given (operating system) stack.    // _cgo_init may update stackguard.    // 给 runtime.g0 创建栈    MOVQ    $runtime·g0(SB), DI    LEAQ    (-64*1024+104)(SP), BX    MOVQ    BX, g_stackguard0(DI)    MOVQ    BX, g_stackguard1(DI)    MOVQ    BX, (g_stack+stack_lo)(DI)    MOVQ    SP, (g_stack+stack_hi)(DI)    // ... 省略 ...    // set the per-goroutine and per-mach "registers"    get_tls(BX)    LEAQ    runtime·g0(SB), CX    MOVQ    CX, g(BX)    LEAQ    runtime·m0(SB), AX    // save m->g0 = g0    // 绑定 m0 和 g0    MOVQ    CX, m_g0(AX)    // save m0 to g0->m    MOVQ    AX, g_m(CX)    CLD                // convention is D is always left cleared    CALL    runtime·check(SB)    MOVL    16(SP), AX        // copy argc    MOVL    AX, 0(SP)    MOVQ    24(SP), AX        // copy argv    MOVQ    AX, 8(SP)    CALL    runtime·args(SB)       // 解析命令行参数    CALL    runtime·osinit(SB)     // 获取CPU核数    CALL    runtime·schedinit(SB)  // 初始化调度    // create a new goroutine to start program    MOVQ    $runtime·mainPC(SB), AX        // entry    PUSHQ    AX    PUSHQ    $0            // arg size    CALL    runtime·newproc(SB)// 执行runtime.main    POPQ    AX    POPQ    AX    // start this M    CALL    runtime·mstart(SB) // 启动m0    CALL    runtime·abort(SB)    // mstart should never return    RET</code></pre><p><code>rt0_go</code>函数主要流程：</p><ul><li>初始化<code>g0</code>、<code>m0</code></li><li><code>g0</code>和<code>m0</code>互相绑定</li><li>初始化相关数据，初始化指定个数的<code>p</code></li><li>创建新<code>g</code>绑定<code>runtime.main</code>函数，加入<code>p</code>的可执行列表中</li><li>启动<code>m0</code>开始循环调度。</li></ul><h2 id="schedinit"><a href="#schedinit" class="headerlink" title="schedinit"></a>schedinit</h2><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">// runtime/proc.go</span><span class="token keyword">func</span> <span class="token function">schedinit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ... 省略 ...</span>    _g_ <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 获取当前绑定的g</span>    <span class="token comment" spellcheck="true">// 限制M的数量</span>    sched<span class="token punctuation">.</span>maxmcount <span class="token operator">=</span> <span class="token number">10000</span>    <span class="token comment" spellcheck="true">// ... 省略 ...</span>    <span class="token comment" spellcheck="true">// 创建 p</span>    <span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>    sched<span class="token punctuation">.</span>lastpoll <span class="token operator">=</span> <span class="token function">uint64</span><span class="token punctuation">(</span><span class="token function">nanotime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    procs <span class="token operator">:=</span> ncpu    <span class="token keyword">if</span> n<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token function">atoi32</span><span class="token punctuation">(</span><span class="token function">gogetenv</span><span class="token punctuation">(</span><span class="token string">"GOMAXPROCS"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token operator">&amp;&amp;</span> n <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">{</span>        procs <span class="token operator">=</span> n    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token function">procresize</span><span class="token punctuation">(</span>procs<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"unknown runnable goroutine during bootstrap"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p><code>schedinit</code>函数主要流程：</p><ul><li>初始化全局调度相关值</li><li>限制<code>m</code>的最多个数</li><li>初始化指定个数的<code>p</code></li></ul><h2 id="newproc"><a href="#newproc" class="headerlink" title="newproc"></a>newproc</h2><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">// runtime/proc.go</span><span class="token keyword">func</span> <span class="token function">newproc</span><span class="token punctuation">(</span>siz <span class="token builtin">int32</span><span class="token punctuation">,</span> fn <span class="token operator">*</span>funcval<span class="token punctuation">)</span> <span class="token punctuation">{</span>    argp <span class="token operator">:=</span> <span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fn<span class="token punctuation">)</span><span class="token punctuation">,</span> sys<span class="token punctuation">.</span>PtrSize<span class="token punctuation">)</span>    gp <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    pc <span class="token operator">:=</span> <span class="token function">getcallerpc</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">systemstack</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        newg <span class="token operator">:=</span> <span class="token function">newproc1</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> argp<span class="token punctuation">,</span> siz<span class="token punctuation">,</span> gp<span class="token punctuation">,</span> pc<span class="token punctuation">)</span>        _p_ <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token function">runqput</span><span class="token punctuation">(</span>_p_<span class="token punctuation">,</span> newg<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> mainStarted <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// mainStarted 是在 runtime.main 中设置为 true </span>            <span class="token function">wakep</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 尝试找一个p绑定m</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p><code>newproc</code>函数主要流程：</p><ul><li>创建栈大小为<code>siz</code>的新<code>g</code>，并关联<code>fn</code></li><li>将新<code>g</code>存放于<code>_p_</code>的可执行队列中</li><li>此时刚初始化，并没有执行<code>runtime.main</code>所以不会执行<code>wakep</code></li></ul><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">// runtime/proc.go</span><span class="token keyword">func</span> <span class="token function">newproc1</span><span class="token punctuation">(</span>fn <span class="token operator">*</span>funcval<span class="token punctuation">,</span> argp unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">,</span> narg <span class="token builtin">int32</span><span class="token punctuation">,</span> callergp <span class="token operator">*</span>g<span class="token punctuation">,</span> callerpc <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token operator">*</span>g <span class="token punctuation">{</span>    _g_ <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">acquirem</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// disable preemption because it can be holding p in a local var</span>    siz <span class="token operator">:=</span> narg    siz <span class="token operator">=</span> <span class="token punctuation">(</span>siz <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">&amp;^</span> <span class="token number">7</span>    _p_ <span class="token operator">:=</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 获取 p</span>    newg <span class="token operator">:=</span> <span class="token function">gfget</span><span class="token punctuation">(</span>_p_<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">// 从 p 的空闲 g 列表中获取 g</span>    <span class="token keyword">if</span> newg <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 没有空闲的 g</span>        newg <span class="token operator">=</span> <span class="token function">malg</span><span class="token punctuation">(</span>_StackMin<span class="token punctuation">)</span>           <span class="token comment" spellcheck="true">// 创建一个拥有最小栈的 g</span>        <span class="token function">casgstatus</span><span class="token punctuation">(</span>newg<span class="token punctuation">,</span> _Gidle<span class="token punctuation">,</span> _Gdead<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 转换状态</span>        <span class="token function">allgadd</span><span class="token punctuation">(</span>newg<span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true">// 向全局 g 列表中添加 g</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// ... 省略 ...</span>    <span class="token comment" spellcheck="true">// 填充 g</span>    <span class="token function">memclrNoHeapPointers</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>newg<span class="token punctuation">.</span>sched<span class="token punctuation">)</span><span class="token punctuation">,</span> unsafe<span class="token punctuation">.</span><span class="token function">Sizeof</span><span class="token punctuation">(</span>newg<span class="token punctuation">.</span>sched<span class="token punctuation">)</span><span class="token punctuation">)</span>    newg<span class="token punctuation">.</span>sched<span class="token punctuation">.</span>sp <span class="token operator">=</span> sp    newg<span class="token punctuation">.</span>stktopsp <span class="token operator">=</span> sp    newg<span class="token punctuation">.</span>sched<span class="token punctuation">.</span>pc <span class="token operator">=</span> <span class="token function">funcPC</span><span class="token punctuation">(</span>goexit<span class="token punctuation">)</span> <span class="token operator">+</span> sys<span class="token punctuation">.</span>PCQuantum <span class="token comment" spellcheck="true">// 当g执行完后的处理函数</span>    newg<span class="token punctuation">.</span>sched<span class="token punctuation">.</span>g <span class="token operator">=</span> <span class="token function">guintptr</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>newg<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token function">gostartcallfn</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>newg<span class="token punctuation">.</span>sched<span class="token punctuation">,</span> fn<span class="token punctuation">)</span>    newg<span class="token punctuation">.</span>gopc <span class="token operator">=</span> callerpc    newg<span class="token punctuation">.</span>ancestors <span class="token operator">=</span> <span class="token function">saveAncestors</span><span class="token punctuation">(</span>callergp<span class="token punctuation">)</span>    newg<span class="token punctuation">.</span>startpc <span class="token operator">=</span> fn<span class="token punctuation">.</span>fn    <span class="token keyword">if</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>curg <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        newg<span class="token punctuation">.</span>labels <span class="token operator">=</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>curg<span class="token punctuation">.</span>labels    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token function">isSystemGoroutine</span><span class="token punctuation">(</span>newg<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        atomic<span class="token punctuation">.</span><span class="token function">Xadd</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>ngsys<span class="token punctuation">,</span> <span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token function">casgstatus</span><span class="token punctuation">(</span>newg<span class="token punctuation">,</span> _Gdead<span class="token punctuation">,</span> _Grunnable<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 切换成可执行状态</span>    <span class="token comment" spellcheck="true">// 分配goid，如果没有则向p批量获取</span>    <span class="token keyword">if</span> _p_<span class="token punctuation">.</span>goidcache <span class="token operator">==</span> _p_<span class="token punctuation">.</span>goidcacheend <span class="token punctuation">{</span>        _p_<span class="token punctuation">.</span>goidcache <span class="token operator">=</span> atomic<span class="token punctuation">.</span><span class="token function">Xadd64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>goidgen<span class="token punctuation">,</span> _GoidCacheBatch<span class="token punctuation">)</span>        _p_<span class="token punctuation">.</span>goidcache <span class="token operator">-=</span> _GoidCacheBatch <span class="token operator">-</span> <span class="token number">1</span>        _p_<span class="token punctuation">.</span>goidcacheend <span class="token operator">=</span> _p_<span class="token punctuation">.</span>goidcache <span class="token operator">+</span> _GoidCacheBatch    <span class="token punctuation">}</span>    newg<span class="token punctuation">.</span>goid <span class="token operator">=</span> <span class="token function">int64</span><span class="token punctuation">(</span>_p_<span class="token punctuation">.</span>goidcache<span class="token punctuation">)</span>    _p_<span class="token punctuation">.</span>goidcache<span class="token operator">++</span>    <span class="token function">releasem</span><span class="token punctuation">(</span>_g_<span class="token punctuation">.</span>m<span class="token punctuation">)</span>    <span class="token keyword">return</span> newg<span class="token punctuation">}</span></code></pre><p><code>newproc1</code>函数主要流程：</p><ul><li>从空闲<code>g</code>列表中获取或新建<code>g</code>，将<code>g</code>的信息填充</li></ul><h2 id="mstart"><a href="#mstart" class="headerlink" title="mstart"></a>mstart</h2><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">// runtime/proc.go</span><span class="token keyword">func</span> <span class="token function">mstart</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    _g_ <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 设置 _g_ 的栈信息</span>    osStack <span class="token operator">:=</span> _g_<span class="token punctuation">.</span>stack<span class="token punctuation">.</span>lo <span class="token operator">==</span> <span class="token number">0</span>    <span class="token keyword">if</span> osStack <span class="token punctuation">{</span>        size <span class="token operator">:=</span> _g_<span class="token punctuation">.</span>stack<span class="token punctuation">.</span>hi        <span class="token keyword">if</span> size <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>            size <span class="token operator">=</span> <span class="token number">8192</span> <span class="token operator">*</span> sys<span class="token punctuation">.</span>StackGuardMultiplier        <span class="token punctuation">}</span>        _g_<span class="token punctuation">.</span>stack<span class="token punctuation">.</span>hi <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span><span class="token function">noescape</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        _g_<span class="token punctuation">.</span>stack<span class="token punctuation">.</span>lo <span class="token operator">=</span> _g_<span class="token punctuation">.</span>stack<span class="token punctuation">.</span>hi <span class="token operator">-</span> size <span class="token operator">+</span> <span class="token number">1024</span>    <span class="token punctuation">}</span>    _g_<span class="token punctuation">.</span>stackguard0 <span class="token operator">=</span> _g_<span class="token punctuation">.</span>stack<span class="token punctuation">.</span>lo <span class="token operator">+</span> _StackGuard    _g_<span class="token punctuation">.</span>stackguard1 <span class="token operator">=</span> _g_<span class="token punctuation">.</span>stackguard0    <span class="token function">mstart1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 不会返回</span><span class="token punctuation">}</span></code></pre><p><code>mstart</code>函数主要流程：</p><ul><li>填充<code>g</code>的栈信息</li><li>让<code>m</code>开始执行<code>g</code>上的代码</li></ul><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">// runtime/proc.go</span><span class="token keyword">func</span> <span class="token function">mstart1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    _g_ <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// ... 省略 ...</span>    <span class="token keyword">if</span> _g_<span class="token punctuation">.</span>m <span class="token operator">==</span> <span class="token operator">&amp;</span>m0 <span class="token punctuation">{</span>        <span class="token function">mstartm0</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 启动 m0 初始化信号处理</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> fn <span class="token operator">:=</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>mstartfn<span class="token punctuation">;</span> fn <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 执行m绑定的启动时调用的函数</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> _g_<span class="token punctuation">.</span>m <span class="token operator">!=</span> <span class="token operator">&amp;</span>m0 <span class="token punctuation">{</span>        <span class="token function">acquirep</span><span class="token punctuation">(</span>_g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>nextp<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>nextp <span class="token operator">=</span> <span class="token number">0</span>    <span class="token punctuation">}</span>    <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 开始调度</span><span class="token punctuation">}</span></code></pre><p><code>mstart1</code>函数主要流程：</p><ul><li>如果是<code>m0</code>，则初始化信号处理</li><li>如果有<code>mstartfn</code>，则执行</li><li>如果不是<code>m0</code>，则绑定<code>p</code></li><li>调用<code>schedule</code>启动golang进程的调度。</li></ul><h2 id="runtime-main"><a href="#runtime-main" class="headerlink" title="runtime.main"></a>runtime.main</h2><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">// runtime/proc.go</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    g <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 确认栈的最大值</span>    <span class="token keyword">if</span> sys<span class="token punctuation">.</span>PtrSize <span class="token operator">==</span> <span class="token number">8</span> <span class="token punctuation">{</span>        maxstacksize <span class="token operator">=</span> <span class="token number">1000000000</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        maxstacksize <span class="token operator">=</span> <span class="token number">250000000</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Allow newproc to start new Ms.</span>    mainStarted <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token comment" spellcheck="true">// 标志 newproc 时可以启动 m</span>    <span class="token keyword">if</span> GOARCH <span class="token operator">!=</span> <span class="token string">"wasm"</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// no threads on wasm yet, so no sysmon</span>        <span class="token function">systemstack</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">newm</span><span class="token punctuation">(</span>sysmon<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 新建 m 去执行 sysmon</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token function">lockOSThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">doInit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>runtime_inittask<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 执行runtime包中的init函数</span>    <span class="token comment" spellcheck="true">// Record when the world started.</span>    runtimeInitTime <span class="token operator">=</span> <span class="token function">nanotime</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">gcenable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 开启GC</span>    main_init_done <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">bool</span><span class="token punctuation">)</span>    <span class="token function">doInit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>main_inittask<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 执行main包中的init函数</span>    <span class="token function">close</span><span class="token punctuation">(</span>main_init_done<span class="token punctuation">)</span>    <span class="token function">unlockOSThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    fn <span class="token operator">:=</span> main_main <span class="token comment" spellcheck="true">// fn 指向main包的main函数</span>    <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 执行main包的main函数</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>runtime.main函数主要功能：</p><ul><li>设置了栈的最大值</li><li>创建m去执行sysmon</li><li>调用runtime包的init函数</li><li>启动GC</li><li>执行main包的init函数</li><li>退出</li></ul><h2 id="startm"><a href="#startm" class="headerlink" title="startm"></a>startm</h2><p>除了m0是汇编初始化的，其他的m都是由startm创建的。</p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">startm</span><span class="token punctuation">(</span>_p_ <span class="token operator">*</span>p<span class="token punctuation">,</span> spinning <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>    <span class="token keyword">if</span> _p_ <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// _p_ 为空</span>        _p_ <span class="token operator">=</span> <span class="token function">pidleget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 从p空闲列表中获取一个</span>        <span class="token keyword">if</span> _p_ <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 获取失败</span>            <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>            <span class="token keyword">if</span> spinning <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 如果是自旋状态，调用方增加了nmspinning，但是没有空闲的P，因此可以取消增量并放弃</span>                <span class="token keyword">if</span> <span class="token function">int32</span><span class="token punctuation">(</span>atomic<span class="token punctuation">.</span><span class="token function">Xadd</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>nmspinning<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">{</span>                    <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"startm: negative nmspinning"</span><span class="token punctuation">)</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    mp <span class="token operator">:=</span> <span class="token function">mget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 从m空闲列表中获取m</span>    <span class="token keyword">if</span> mp <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果空闲列表没有</span>        id <span class="token operator">:=</span> <span class="token function">mReserveID</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 获取 m id</span>        <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>        <span class="token keyword">var</span> fn <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> spinning <span class="token punctuation">{</span>            fn <span class="token operator">=</span> mspinning <span class="token comment" spellcheck="true">// 设置 m 的自旋状态函数</span>        <span class="token punctuation">}</span>        <span class="token function">newm</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> _p_<span class="token punctuation">,</span> id<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 创建一个m对象</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>    <span class="token keyword">if</span> mp<span class="token punctuation">.</span>spinning <span class="token punctuation">{</span>        <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"startm: m is spinning"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> mp<span class="token punctuation">.</span>nextp <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"startm: m has p"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> spinning <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">runqempty</span><span class="token punctuation">(</span>_p_<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"startm: p has runnable gs"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 由调用者确定是否自旋，并将m.nextp设置为p</span>    mp<span class="token punctuation">.</span>spinning <span class="token operator">=</span> spinning    mp<span class="token punctuation">.</span>nextp<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>_p_<span class="token punctuation">)</span>    <span class="token function">notewakeup</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mp<span class="token punctuation">.</span>park<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p><code>startm</code>函数主要流程：</p><ul><li>获取一个<code>p</code>，失败则返回<ul><li>获取一个<code>m</code>，如果失败就创建<code>m</code>并返回</li></ul></li><li><code>m</code>暂存<code>p</code></li></ul><h3 id="newm"><a href="#newm" class="headerlink" title="newm"></a>newm</h3><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">newm</span><span class="token punctuation">(</span>fn <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> _p_ <span class="token operator">*</span>p<span class="token punctuation">,</span> id <span class="token builtin">int64</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    mp <span class="token operator">:=</span> <span class="token function">allocm</span><span class="token punctuation">(</span>_p_<span class="token punctuation">,</span> fn<span class="token punctuation">,</span> id<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 创建新m</span>    mp<span class="token punctuation">.</span>nextp<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>_p_<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 暂存p</span>    mp<span class="token punctuation">.</span>sigmask <span class="token operator">=</span> initSigmask <span class="token comment" spellcheck="true">// 信号掩码</span>    <span class="token function">newm1</span><span class="token punctuation">(</span>mp<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 绑定操作系统线程</span><span class="token punctuation">}</span></code></pre><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">allocm</span><span class="token punctuation">(</span>_p_ <span class="token operator">*</span>p<span class="token punctuation">,</span> fn <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> id <span class="token builtin">int64</span><span class="token punctuation">)</span> <span class="token operator">*</span>m <span class="token punctuation">{</span>    _g_ <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">acquirem</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// disable GC because it can be called from sysmon</span>    <span class="token keyword">if</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token function">acquirep</span><span class="token punctuation">(</span>_p_<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 临时绑定p</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 清理可以安全删除的m的g0栈信息</span>    <span class="token keyword">if</span> sched<span class="token punctuation">.</span>freem <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>         <span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>        <span class="token keyword">var</span> newList <span class="token operator">*</span>m        <span class="token keyword">for</span> freem <span class="token operator">:=</span> sched<span class="token punctuation">.</span>freem<span class="token punctuation">;</span> freem <span class="token operator">!=</span> <span class="token boolean">nil</span><span class="token punctuation">;</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> freem<span class="token punctuation">.</span>freeWait <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>                next <span class="token operator">:=</span> freem<span class="token punctuation">.</span>freelink                freem<span class="token punctuation">.</span>freelink <span class="token operator">=</span> newList                newList <span class="token operator">=</span> freem                freem <span class="token operator">=</span> next                <span class="token keyword">continue</span>            <span class="token punctuation">}</span>            <span class="token function">stackfree</span><span class="token punctuation">(</span>freem<span class="token punctuation">.</span>g0<span class="token punctuation">.</span>stack<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 清空freem.g0的栈信息</span>            freem <span class="token operator">=</span> freem<span class="token punctuation">.</span>freelink        <span class="token punctuation">}</span>        sched<span class="token punctuation">.</span>freem <span class="token operator">=</span> newList <span class="token comment" spellcheck="true">// 更新已被释放的m列表</span>        <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    mp <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span>    mp<span class="token punctuation">.</span>mstartfn <span class="token operator">=</span> fn <span class="token comment" spellcheck="true">// 绑定m启动函数</span>    <span class="token function">mcommoninit</span><span class="token punctuation">(</span>mp<span class="token punctuation">,</span> id<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 绑定mp的id</span>    <span class="token comment" spellcheck="true">// 初始化g0栈信息</span>    <span class="token keyword">if</span> iscgo <span class="token operator">||</span> GOOS <span class="token operator">==</span> <span class="token string">"solaris"</span> <span class="token operator">||</span> GOOS <span class="token operator">==</span> <span class="token string">"illumos"</span> <span class="token operator">||</span> GOOS <span class="token operator">==</span> <span class="token string">"windows"</span> <span class="token operator">||</span> GOOS <span class="token operator">==</span> <span class="token string">"plan9"</span> <span class="token operator">||</span> GOOS <span class="token operator">==</span> <span class="token string">"darwin"</span> <span class="token operator">||</span> GOOS <span class="token operator">==</span> <span class="token string">"ios"</span> <span class="token punctuation">{</span>        mp<span class="token punctuation">.</span>g0 <span class="token operator">=</span> <span class="token function">malg</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        mp<span class="token punctuation">.</span>g0 <span class="token operator">=</span> <span class="token function">malg</span><span class="token punctuation">(</span><span class="token number">8192</span> <span class="token operator">*</span> sys<span class="token punctuation">.</span>StackGuardMultiplier<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    mp<span class="token punctuation">.</span>g0<span class="token punctuation">.</span>m <span class="token operator">=</span> mp    <span class="token keyword">if</span> _p_ <span class="token operator">==</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">releasep</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 解绑p</span>    <span class="token punctuation">}</span>    <span class="token function">releasem</span><span class="token punctuation">(</span>_g_<span class="token punctuation">.</span>m<span class="token punctuation">)</span>    <span class="token keyword">return</span> mp<span class="token punctuation">}</span></code></pre><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">newm1</span><span class="token punctuation">(</span>mp <span class="token operator">*</span>m<span class="token punctuation">)</span> <span class="token punctuation">{</span>    execLock<span class="token punctuation">.</span><span class="token function">rlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// Prevent process clone.</span>    <span class="token function">newosproc</span><span class="token punctuation">(</span>mp<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 绑定操作系统线程</span>    execLock<span class="token punctuation">.</span><span class="token function">runlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p><code>newm</code>函数主要流程：</p><ul><li>释放可以清理的<code>m</code>的<code>g0</code>栈空间</li><li>新建<code>m</code>，绑定<code>id</code>和启动函数，申请<code>g0</code>栈空间</li><li><code>m</code>暂存当前<code>p</code></li><li>创建与<code>m</code>对应的操作系统线程</li></ul><h2 id="netpoll"><a href="#netpoll" class="headerlink" title="netpoll"></a>netpoll</h2><p><code>netpoll</code>可以让调度器从就绪的网络事件中获取可执行的goroutine。<br>由于golang对每个系统的netpoll做了条件编译，这里就拿linux的实现来说明。</p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">netpoll</span><span class="token punctuation">(</span>delay <span class="token builtin">int64</span><span class="token punctuation">)</span> gList <span class="token punctuation">{</span>    <span class="token keyword">var</span> events <span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">]</span>epolleventretry<span class="token punctuation">:</span>    n <span class="token operator">:=</span> <span class="token function">epollwait</span><span class="token punctuation">(</span>epfd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>events<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">int32</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>events<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> waitms<span class="token punctuation">)</span>    <span class="token keyword">var</span> toRun gList    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token function">int32</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        ev <span class="token operator">:=</span> <span class="token operator">&amp;</span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">var</span> mode <span class="token builtin">int32</span>        <span class="token keyword">if</span> ev<span class="token punctuation">.</span>events<span class="token operator">&amp;</span><span class="token punctuation">(</span>_EPOLLIN<span class="token operator">|</span>_EPOLLRDHUP<span class="token operator">|</span>_EPOLLHUP<span class="token operator">|</span>_EPOLLERR<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>            mode <span class="token operator">+=</span> <span class="token string">'r'</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> ev<span class="token punctuation">.</span>events<span class="token operator">&amp;</span><span class="token punctuation">(</span>_EPOLLOUT<span class="token operator">|</span>_EPOLLHUP<span class="token operator">|</span>_EPOLLERR<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>            mode <span class="token operator">+=</span> <span class="token string">'w'</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> mode <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>            pd <span class="token operator">:=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token operator">*</span>pollDesc<span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ev<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span>            pd<span class="token punctuation">.</span>everr <span class="token operator">=</span> <span class="token boolean">false</span>            <span class="token keyword">if</span> ev<span class="token punctuation">.</span>events <span class="token operator">==</span> _EPOLLERR <span class="token punctuation">{</span>                pd<span class="token punctuation">.</span>everr <span class="token operator">=</span> <span class="token boolean">true</span>            <span class="token punctuation">}</span>            <span class="token function">netpollready</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>toRun<span class="token punctuation">,</span> pd<span class="token punctuation">,</span> mode<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 将符合的g填充进toRun中</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> toRun<span class="token punctuation">}</span></code></pre><p><code>netpoll</code>函数主要流程：</p><ul><li>调用<code>epollwait</code>获取就绪的文件描述符</li><li>将<code>pd</code>中的就绪<code>g</code>追加进<code>toRun</code>里面</li><li>返回<code>toRun</code></li></ul><h1 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h1><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">// runtime/proc.go</span><span class="token keyword">func</span> <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    _g_ <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 如果_g_绑定的m有锁定的g，则抛弃_g_，转而执行锁定的g</span>    <span class="token keyword">if</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>lockedg <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token function">stoplockedm</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token function">execute</span><span class="token punctuation">(</span>_g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>lockedg<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// Never returns.</span>    <span class="token punctuation">}</span>top<span class="token punctuation">:</span>    pp <span class="token operator">:=</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    pp<span class="token punctuation">.</span>preempt <span class="token operator">=</span> <span class="token boolean">false</span>    <span class="token comment" spellcheck="true">// 如果准备GC，则休眠当前m，直到被唤醒</span>    <span class="token keyword">if</span> sched<span class="token punctuation">.</span>gcwaiting <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token function">gcstopm</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">goto</span> top    <span class="token punctuation">}</span>    <span class="token keyword">if</span> pp<span class="token punctuation">.</span>runSafePointFn <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token function">runSafePointFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token function">checkTimers</span><span class="token punctuation">(</span>pp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">var</span> gp <span class="token operator">*</span>g    <span class="token keyword">var</span> inheritTime <span class="token builtin">bool</span>    tryWakeP <span class="token operator">:=</span> <span class="token boolean">false</span>    <span class="token keyword">if</span> trace<span class="token punctuation">.</span>enabled <span class="token operator">||</span> trace<span class="token punctuation">.</span>shutdown <span class="token punctuation">{</span>        gp <span class="token operator">=</span> <span class="token function">traceReader</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> gp <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>            <span class="token function">casgstatus</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> _Gwaiting<span class="token punctuation">,</span> _Grunnable<span class="token punctuation">)</span>            <span class="token function">traceGoUnpark</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>            tryWakeP <span class="token operator">=</span> <span class="token boolean">true</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> gp <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> gcBlackenEnabled <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 找GCWorker</span>        gp <span class="token operator">=</span> gcController<span class="token punctuation">.</span><span class="token function">findRunnableGCWorker</span><span class="token punctuation">(</span>_g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        tryWakeP <span class="token operator">=</span> tryWakeP <span class="token operator">||</span> gp <span class="token operator">!=</span> <span class="token boolean">nil</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> gp <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 为了让全局可执行队列的g能够运行，这里每操作一定次数就从全局队列中获取</span>        <span class="token keyword">if</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>schedtick<span class="token operator">%</span><span class="token number">61</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> sched<span class="token punctuation">.</span>runqsize <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">{</span>            <span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>            gp <span class="token operator">=</span> <span class="token function">globrunqget</span><span class="token punctuation">(</span>_g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>            <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> gp <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 从本地可执行队列中获取</span>        gp<span class="token punctuation">,</span> inheritTime <span class="token operator">=</span> <span class="token function">runqget</span><span class="token punctuation">(</span>_g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> gp <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 从其他地方找一个g来执行，如果没有则阻塞在这里</span>        gp<span class="token punctuation">,</span> inheritTime <span class="token operator">=</span> <span class="token function">findrunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// blocks until work is available</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// This thread is going to run a goroutine and is not spinning anymore,</span>    <span class="token comment" spellcheck="true">// so if it was marked as spinning we need to reset it now and potentially</span>    <span class="token comment" spellcheck="true">// start a new spinning M.</span>    <span class="token keyword">if</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>spinning <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果当前m正在自旋，则重置自旋状态</span>        <span class="token function">resetspinning</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> tryWakeP <span class="token punctuation">{</span>        <span class="token function">wakep</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// GCworker 或 tracereader 需要唤醒p</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> gp<span class="token punctuation">.</span>lockedm <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// m将自己的p让给gp锁定的m，自己阻塞等待新p</span>        <span class="token function">startlockedm</span><span class="token punctuation">(</span>gp<span class="token punctuation">)</span>        <span class="token keyword">goto</span> top    <span class="token punctuation">}</span>    <span class="token function">execute</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> inheritTime<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 执行gp</span><span class="token punctuation">}</span></code></pre><p><code>schedule</code>函数主要流程：</p><ul><li>如果<code>g</code>有绑定的<code>m</code>，则直接让绑定<code>m</code>执行<code>g</code></li><li>如果要GC，则休眠当前<code>m</code>，等待唤醒</li><li>从<code>traceReader</code>、<code>GCWorker</code>、<code>globrunqget</code>、<code>runqget</code>、<code>findrunnable</code>函数中获取一个可执行gp</li><li>重置自旋状态</li><li>如果需要唤醒<code>p</code>，则尝试唤醒<code>p</code></li><li>如果获取的<code>gp</code>有锁定的<code>m</code>，则让出自己的<code>p</code>给<code>gp</code>锁定的<code>m</code>，自己则阻塞等待被唤醒</li><li>执行<code>gp</code></li></ul><h2 id="findrunnable"><a href="#findrunnable" class="headerlink" title="findrunnable"></a>findrunnable</h2><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">// runtime/proc.go</span><span class="token keyword">func</span> <span class="token function">findrunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>gp <span class="token operator">*</span>g<span class="token punctuation">,</span> inheritTime <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    _g_ <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>top<span class="token punctuation">:</span>    _p_ <span class="token operator">:=</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> sched<span class="token punctuation">.</span>gcwaiting <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token function">gcstopm</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">goto</span> top    <span class="token punctuation">}</span>    <span class="token keyword">if</span> _p_<span class="token punctuation">.</span>runSafePointFn <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token function">runSafePointFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    now<span class="token punctuation">,</span> pollUntil<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> <span class="token function">checkTimers</span><span class="token punctuation">(</span>_p_<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 如果有finalizer可用，直接唤醒</span>    <span class="token keyword">if</span> fingwait <span class="token operator">&amp;&amp;</span> fingwake <span class="token punctuation">{</span>        <span class="token keyword">if</span> gp <span class="token operator">:=</span> <span class="token function">wakefing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> gp <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>            <span class="token function">ready</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 本地获取</span>    <span class="token keyword">if</span> gp<span class="token punctuation">,</span> inheritTime <span class="token operator">:=</span> <span class="token function">runqget</span><span class="token punctuation">(</span>_p_<span class="token punctuation">)</span><span class="token punctuation">;</span> gp <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> gp<span class="token punctuation">,</span> inheritTime    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 全局获取</span>    <span class="token comment" spellcheck="true">// global runq</span>    <span class="token keyword">if</span> sched<span class="token punctuation">.</span>runqsize <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>        gp <span class="token operator">:=</span> <span class="token function">globrunqget</span><span class="token punctuation">(</span>_p_<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>        <span class="token keyword">if</span> gp <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> gp<span class="token punctuation">,</span> <span class="token boolean">false</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 没有可以执行的goroutine</span>    <span class="token comment" spellcheck="true">// 获取网络事件完成的gp，优化</span>    <span class="token keyword">if</span> <span class="token function">netpollinited</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>netpollWaiters<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> atomic<span class="token punctuation">.</span><span class="token function">Load64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lastpoll<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> list <span class="token operator">:=</span> <span class="token function">netpoll</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">!</span>list<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// non-blocking</span>            gp <span class="token operator">:=</span> list<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token function">injectglist</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>list<span class="token punctuation">)</span>            <span class="token function">casgstatus</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> _Gwaiting<span class="token punctuation">,</span> _Grunnable<span class="token punctuation">)</span>            <span class="token keyword">if</span> trace<span class="token punctuation">.</span>enabled <span class="token punctuation">{</span>                <span class="token function">traceGoUnpark</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> gp<span class="token punctuation">,</span> <span class="token boolean">false</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 从其他的P偷取</span>    <span class="token comment" spellcheck="true">// Steal work from other P's.</span>    procs <span class="token operator">:=</span> <span class="token function">uint32</span><span class="token punctuation">(</span>gomaxprocs<span class="token punctuation">)</span>    ranTimer <span class="token operator">:=</span> <span class="token boolean">false</span>    <span class="token comment" spellcheck="true">// 将m置为自旋状态</span>    <span class="token keyword">if</span> <span class="token operator">!</span>_g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>spinning <span class="token punctuation">{</span>        _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>spinning <span class="token operator">=</span> <span class="token boolean">true</span>        atomic<span class="token punctuation">.</span><span class="token function">Xadd</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>nmspinning<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 随机从别的p中偷取4次</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> enum <span class="token operator">:=</span> stealOrder<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token function">fastrand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">!</span>enum<span class="token punctuation">.</span><span class="token function">done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> enum<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> sched<span class="token punctuation">.</span>gcwaiting <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>                <span class="token keyword">goto</span> top            <span class="token punctuation">}</span>            stealRunNextG <span class="token operator">:=</span> i <span class="token operator">></span> <span class="token number">2</span> <span class="token comment" spellcheck="true">// first look for ready queues with more than 1 g</span>            p2 <span class="token operator">:=</span> allp<span class="token punctuation">[</span>enum<span class="token punctuation">.</span><span class="token function">position</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>            <span class="token keyword">if</span> _p_ <span class="token operator">==</span> p2 <span class="token punctuation">{</span>                <span class="token keyword">continue</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> gp <span class="token operator">:=</span> <span class="token function">runqsteal</span><span class="token punctuation">(</span>_p_<span class="token punctuation">,</span> p2<span class="token punctuation">,</span> stealRunNextG<span class="token punctuation">)</span><span class="token punctuation">;</span> gp <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> gp<span class="token punctuation">,</span> <span class="token boolean">false</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> i <span class="token operator">></span> <span class="token number">2</span> <span class="token operator">||</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token function">shouldStealTimers</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                tnow<span class="token punctuation">,</span> w<span class="token punctuation">,</span> ran <span class="token operator">:=</span> <span class="token function">checkTimers</span><span class="token punctuation">(</span>p2<span class="token punctuation">,</span> now<span class="token punctuation">)</span>                now <span class="token operator">=</span> tnow                <span class="token keyword">if</span> w <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>pollUntil <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> w <span class="token operator">&lt;</span> pollUntil<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    pollUntil <span class="token operator">=</span> w                <span class="token punctuation">}</span>                <span class="token keyword">if</span> ran <span class="token punctuation">{</span>                    <span class="token keyword">if</span> gp<span class="token punctuation">,</span> inheritTime <span class="token operator">:=</span> <span class="token function">runqget</span><span class="token punctuation">(</span>_p_<span class="token punctuation">)</span><span class="token punctuation">;</span> gp <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>                        <span class="token keyword">return</span> gp<span class="token punctuation">,</span> inheritTime                    <span class="token punctuation">}</span>                    ranTimer <span class="token operator">=</span> <span class="token boolean">true</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> ranTimer <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Running a timer may have made some goroutine ready.</span>        <span class="token keyword">goto</span> top    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// ... 省略 ...    </span><span class="token punctuation">}</span></code></pre><p><code>findrunnable</code>函数主要流程：</p><ul><li>如果有<code>finalizer</code>可执行<code>gp</code>，直接唤醒</li><li>如果从本地可执行队列中获取可执行<code>gp</code>，返回<code>gp</code></li><li>如果从全局可执行队列中获取可执行<code>gp</code>，返回<code>gp</code></li><li>如果有就绪的网络事件的<code>gp</code>，返回<code>gp</code></li><li>从其他的<code>p</code>中偷取部分<code>gp</code>，返回<code>gp</code></li></ul><h3 id="runqsteal"><a href="#runqsteal" class="headerlink" title="runqsteal"></a>runqsteal</h3><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">// runtime/proc.go</span><span class="token keyword">func</span> <span class="token function">runqsteal</span><span class="token punctuation">(</span>_p_<span class="token punctuation">,</span> p2 <span class="token operator">*</span>p<span class="token punctuation">,</span> stealRunNextG <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token operator">*</span>g <span class="token punctuation">{</span>    t <span class="token operator">:=</span> _p_<span class="token punctuation">.</span>runqtail    n <span class="token operator">:=</span> <span class="token function">runqgrab</span><span class="token punctuation">(</span>p2<span class="token punctuation">,</span> <span class="token operator">&amp;</span>_p_<span class="token punctuation">.</span>runq<span class="token punctuation">,</span> t<span class="token punctuation">,</span> stealRunNextG<span class="token punctuation">)</span>    <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">nil</span>    <span class="token punctuation">}</span>    n<span class="token operator">--</span>    gp <span class="token operator">:=</span> _p_<span class="token punctuation">.</span>runq<span class="token punctuation">[</span><span class="token punctuation">(</span>t<span class="token operator">+</span>n<span class="token punctuation">)</span><span class="token operator">%</span><span class="token function">uint32</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>_p_<span class="token punctuation">.</span>runq<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> gp    <span class="token punctuation">}</span>    h <span class="token operator">:=</span> atomic<span class="token punctuation">.</span><span class="token function">LoadAcq</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>_p_<span class="token punctuation">.</span>runqhead<span class="token punctuation">)</span>    atomic<span class="token punctuation">.</span><span class="token function">StoreRel</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>_p_<span class="token punctuation">.</span>runqtail<span class="token punctuation">,</span> t<span class="token operator">+</span>n<span class="token punctuation">)</span>    <span class="token keyword">return</span> gp<span class="token punctuation">}</span></code></pre><p><code>runqsteal</code>函数主要流程：</p><ul><li>获取本地队列队尾坐标</li><li>从<code>p2</code>中获取部分可执行队列</li><li>如果只偷取了一个，直接返回</li><li>否则需要原子修改可执行队列的首尾指针</li></ul><h4 id="runqgrab"><a href="#runqgrab" class="headerlink" title="runqgrab"></a>runqgrab</h4><pre><code>// runtime/proc.gofunc runqgrab(_p_ *p, batch *[256]guintptr, batchHead uint32, stealRunNextG bool) uint32 {    for {        h := atomic.LoadAcq(&amp;_p_.runqhead)        t := atomic.LoadAcq(&amp;_p_.runqtail)         n := t - h        n = n - n/2        if n == 0 {            if stealRunNextG {                // Try to steal from _p_.runnext.                if next := _p_.runnext; next != 0 {                    // 休眠让p不会执行将要偷取的                    if _p_.status == _Prunning {                        if GOOS != "windows" {                            usleep(3)                        } else {                            osyield()                        }                    }                    if !_p_.runnext.cas(next, 0) {                        continue                    }                    batch[batchHead%uint32(len(batch))] = next                    return 1                }            }            return 0        }        if n &gt; uint32(len(_p_.runq)/2) { // 保证队列没有改动            continue        }        // 偷取前半g可执行队列        for i := uint32(0); i &lt; n; i++ {            g := _p_.runq[(h+i)%uint32(len(_p_.runq))]            batch[(batchHead+i)%uint32(len(batch))] = g        }        // 提交本次消费，如果失败则从新再试一次        if atomic.CasRel(&amp;_p_.runqhead, h, h+n) {            return n        }    }}</code></pre><p>runqgrab函数主要流程：</p><ul><li>原子获取待偷取<code>p</code>可执行队列首尾位置</li><li>如果没有，则判断是否需要偷取<code>next</code>指针的<code>gp</code></li><li>复制<code>p</code>的前半部分可执行队列</li><li>原子的修改<code>p</code>的可执行队列的首尾指针位置</li></ul><h2 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h2><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">// runtime/proc.go</span><span class="token keyword">func</span> <span class="token function">execute</span><span class="token punctuation">(</span>gp <span class="token operator">*</span>g<span class="token punctuation">,</span> inheritTime <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    _g_ <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 互相绑定 _g_.m.curg = gp</span>    gp<span class="token punctuation">.</span>m <span class="token operator">=</span> _g_<span class="token punctuation">.</span>m    <span class="token function">casgstatus</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> _Grunnable<span class="token punctuation">,</span> _Grunning<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 转换状态</span>    gp<span class="token punctuation">.</span>waitsince <span class="token operator">=</span> <span class="token number">0</span>    gp<span class="token punctuation">.</span>preempt <span class="token operator">=</span> <span class="token boolean">false</span>    gp<span class="token punctuation">.</span>stackguard0 <span class="token operator">=</span> gp<span class="token punctuation">.</span>stack<span class="token punctuation">.</span>lo <span class="token operator">+</span> _StackGuard    <span class="token keyword">if</span> <span class="token operator">!</span>inheritTime <span class="token punctuation">{</span>        _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>schedtick<span class="token operator">++</span>    <span class="token punctuation">}</span>    <span class="token function">gogo</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>gp<span class="token punctuation">.</span>sched<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p><code>execute</code>函数主要流程：</p><ul><li><code>m</code>和<code>g</code>相互绑定</li><li>设置相关值</li><li>调用<code>gogo</code>函数执行<code>gp</code></li></ul><h3 id="gogo"><a href="#gogo" class="headerlink" title="gogo"></a>gogo</h3><pre class=" language-asm"><code class="language-asm">// runtime/asm_amd64.sTEXT runtime·gogo(SB), NOSPLIT, $16-8    MOVQ    buf+0(FP), BX        // gobuf    MOVQ    gobuf_g(BX), DX    MOVQ    0(DX), CX        // make sure g != nil    get_tls(CX)    MOVQ    DX, g(CX)    MOVQ    gobuf_sp(BX), SP    // restore SP    MOVQ    gobuf_ret(BX), AX    MOVQ    gobuf_ctxt(BX), DX    MOVQ    gobuf_bp(BX), BP    MOVQ    $0, gobuf_sp(BX)    // clear to help garbage collector    MOVQ    $0, gobuf_ret(BX)    MOVQ    $0, gobuf_ctxt(BX)    MOVQ    $0, gobuf_bp(BX)    MOVQ    gobuf_pc(BX), BX    JMP    BX</code></pre><p><code>gogo</code>函数主要流程：</p><ul><li>将<code>gobuf</code>的内容存放到相关寄存器中</li><li>将<code>gobuf</code>的内容清空</li><li>执行<code>gobuf.pc</code></li></ul><h2 id="Gosched"><a href="#Gosched" class="headerlink" title="Gosched"></a>Gosched</h2><p>除了上述的通过运行时启动调度之外，golang还提供了手动的调度函数<code>Gosched</code>函数，该函数在运行时内外都可以触发下一次调度。</p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">Gosched</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">checkTimeouts</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">mcall</span><span class="token punctuation">(</span>gosched_m<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">gosched_m</span><span class="token punctuation">(</span>gp <span class="token operator">*</span>g<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">goschedImpl</span><span class="token punctuation">(</span>gp<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">goschedImpl</span><span class="token punctuation">(</span>gp <span class="token operator">*</span>g<span class="token punctuation">)</span> <span class="token punctuation">{</span>    status <span class="token operator">:=</span> <span class="token function">readgstatus</span><span class="token punctuation">(</span>gp<span class="token punctuation">)</span>    <span class="token keyword">if</span> status<span class="token operator">&amp;^</span>_Gscan <span class="token operator">!=</span> _Grunning <span class="token punctuation">{</span>        <span class="token function">dumpgstatus</span><span class="token punctuation">(</span>gp<span class="token punctuation">)</span>        <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"bad g status"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token function">casgstatus</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> _Grunning<span class="token punctuation">,</span> _Grunnable<span class="token punctuation">)</span>    <span class="token function">dropg</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 解绑g和m</span>    <span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>    <span class="token function">globrunqput</span><span class="token punctuation">(</span>gp<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 放入全局可执行队列</span>    <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>    <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 下一次调度</span><span class="token punctuation">}</span></code></pre><p>Gosched函数主要流程：</p><ul><li>获取gp的状态</li><li>切换gp的状态为_Grunnable</li><li>解绑g和m</li><li>将g存入全局可执行队列中</li><li>启动下一次调度</li></ul><h1 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h1><pre class=" language-asm"><code class="language-asm">TEXT runtime·goexit(SB),NOSPLIT,$0-0    BYTE    $0x90    // NOP    CALL    runtime·goexit1(SB)    // does not return    // traceback from goexit1 must hit code range of goexit    BYTE    $0x90    // NOP</code></pre><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">goexit1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">if</span> raceenabled <span class="token punctuation">{</span>      <span class="token function">racegoend</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span>   <span class="token keyword">if</span> trace<span class="token punctuation">.</span>enabled <span class="token punctuation">{</span>      <span class="token function">traceGoEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span>   <span class="token function">mcall</span><span class="token punctuation">(</span>goexit0<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">goexit0</span><span class="token punctuation">(</span>gp <span class="token operator">*</span>g<span class="token punctuation">)</span> <span class="token punctuation">{</span>    _g_ <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 切换g的状态 </span>    <span class="token function">casgstatus</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> _Grunning<span class="token punctuation">,</span> _Gdead<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 标记系统goroutine </span>    <span class="token keyword">if</span> <span class="token function">isSystemGoroutine</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       atomic<span class="token punctuation">.</span><span class="token function">Xadd</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>ngsys<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 清理gp相关的数据</span>    gp<span class="token punctuation">.</span>m <span class="token operator">=</span> <span class="token boolean">nil</span>    locked <span class="token operator">:=</span> gp<span class="token punctuation">.</span>lockedm <span class="token operator">!=</span> <span class="token number">0</span>    gp<span class="token punctuation">.</span>lockedm <span class="token operator">=</span> <span class="token number">0</span>    _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>lockedg <span class="token operator">=</span> <span class="token number">0</span>    gp<span class="token punctuation">.</span>preemptStop <span class="token operator">=</span> <span class="token boolean">false</span>    gp<span class="token punctuation">.</span>paniconfault <span class="token operator">=</span> <span class="token boolean">false</span>    gp<span class="token punctuation">.</span>_defer <span class="token operator">=</span> <span class="token boolean">nil</span> <span class="token comment" spellcheck="true">// should be true already but just in case.</span>    gp<span class="token punctuation">.</span>_panic <span class="token operator">=</span> <span class="token boolean">nil</span> <span class="token comment" spellcheck="true">// non-nil for Goexit during panic. points at stack-allocated data.</span>    gp<span class="token punctuation">.</span>writebuf <span class="token operator">=</span> <span class="token boolean">nil</span>    gp<span class="token punctuation">.</span>waitreason <span class="token operator">=</span> <span class="token number">0</span>    gp<span class="token punctuation">.</span>param <span class="token operator">=</span> <span class="token boolean">nil</span>    gp<span class="token punctuation">.</span>labels <span class="token operator">=</span> <span class="token boolean">nil</span>    gp<span class="token punctuation">.</span>timer <span class="token operator">=</span> <span class="token boolean">nil</span>    <span class="token function">dropg</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 解绑当前m和gp</span>    <span class="token keyword">if</span> GOARCH <span class="token operator">==</span> <span class="token string">"wasm"</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// no threads yet on wasm</span>        <span class="token function">gfput</span><span class="token punctuation">(</span>_g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> gp<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 将gp存放到p的空闲列表中</span>        <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 下一次调度</span>    <span class="token punctuation">}</span>    <span class="token function">gfput</span><span class="token punctuation">(</span>_g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> gp<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 将gp存放到p的空闲列表中</span>    <span class="token keyword">if</span> locked <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果gp锁定了m，则将这个m杀死</span>        <span class="token keyword">if</span> GOOS <span class="token operator">!=</span> <span class="token string">"plan9"</span> <span class="token punctuation">{</span>             <span class="token function">gogo</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>_g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>g0<span class="token punctuation">.</span>sched<span class="token punctuation">)</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>lockedExt <span class="token operator">=</span> <span class="token number">0</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 下一次调度</span><span class="token punctuation">}</span></code></pre><p><code>goexit0</code>函数主要流程：</p><ul><li>切换<code>g</code>的状态</li><li>解绑<code>g</code>所有绑定的数据</li><li>如果是<code>wasm</code>架构，直接将<code>g</code>存于空闲列表中，并开始下一次调度</li><li>否则，直接将<code>g</code>存于空闲列表中，如果<code>g</code>有锁定的<code>m</code>，则将<code>m</code>杀死，开始下一次调度</li></ul><h1 id="切换"><a href="#切换" class="headerlink" title="切换"></a>切换</h1><h2 id="执行完毕切换"><a href="#执行完毕切换" class="headerlink" title="执行完毕切换"></a>执行完毕切换</h2><p>上面说到，当goroutine执行完毕时，会执行goexit0函数，进而执行下一次调度</p><h2 id="主动切换"><a href="#主动切换" class="headerlink" title="主动切换"></a>主动切换</h2><p>当goroutine中阻塞的操作时，就需要让出CPU，让其他的goroutine执行。所有主动切换都是调用gopark函数来实现的。</p><h3 id="gopark"><a href="#gopark" class="headerlink" title="gopark"></a>gopark</h3><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">gopark</span><span class="token punctuation">(</span>unlockf <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token operator">*</span>g<span class="token punctuation">,</span> unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span> <span class="token builtin">bool</span><span class="token punctuation">,</span> lock unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">,</span> reason waitReason<span class="token punctuation">,</span> traceEv <span class="token builtin">byte</span><span class="token punctuation">,</span> traceskip <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> reason <span class="token operator">!=</span> waitReasonSleep <span class="token punctuation">{</span>        <span class="token function">checkTimeouts</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    mp <span class="token operator">:=</span> <span class="token function">acquirem</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    gp <span class="token operator">:=</span> mp<span class="token punctuation">.</span>curg    status <span class="token operator">:=</span> <span class="token function">readgstatus</span><span class="token punctuation">(</span>gp<span class="token punctuation">)</span>    <span class="token keyword">if</span> status <span class="token operator">!=</span> _Grunning <span class="token operator">&amp;&amp;</span> status <span class="token operator">!=</span> _Gscanrunning <span class="token punctuation">{</span>        <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"gopark: bad g status"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 填充相关参数</span>    mp<span class="token punctuation">.</span>waitlock <span class="token operator">=</span> lock    mp<span class="token punctuation">.</span>waitunlockf <span class="token operator">=</span> unlockf    gp<span class="token punctuation">.</span>waitreason <span class="token operator">=</span> reason    mp<span class="token punctuation">.</span>waittraceev <span class="token operator">=</span> traceEv    mp<span class="token punctuation">.</span>waittraceskip <span class="token operator">=</span> traceskip    <span class="token function">releasem</span><span class="token punctuation">(</span>mp<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// can't do anything that might move the G between Ms here.</span>    <span class="token function">mcall</span><span class="token punctuation">(</span>park_m<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p><code>gopark</code>函数主要流程：</p><ul><li>获取当前<code>m</code>绑定的<code>gp</code></li><li>填充相关参数</li><li>利用<code>g0</code>调用<code>park_m</code>函数</li></ul><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">park_m</span><span class="token punctuation">(</span>gp <span class="token operator">*</span>g<span class="token punctuation">)</span> <span class="token punctuation">{</span>    _g_ <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">casgstatus</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> _Grunning<span class="token punctuation">,</span> _Gwaiting<span class="token punctuation">)</span>    <span class="token function">dropg</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 解绑g和m</span>    <span class="token keyword">if</span> fn <span class="token operator">:=</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>waitunlockf<span class="token punctuation">;</span> fn <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        ok <span class="token operator">:=</span> <span class="token function">fn</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>waitlock<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 尝试调用解锁函数</span>        _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>waitunlockf <span class="token operator">=</span> <span class="token boolean">nil</span>        _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>waitlock <span class="token operator">=</span> <span class="token boolean">nil</span>        <span class="token keyword">if</span> <span class="token operator">!</span>ok <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果解锁成功</span>            <span class="token function">casgstatus</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> _Gwaiting<span class="token punctuation">,</span> _Grunnable<span class="token punctuation">)</span>            <span class="token function">execute</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 直接执行gp</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 下一次调度</span><span class="token punctuation">}</span></code></pre><p><code>park_m</code>函数主要流程：</p><ul><li>切换<code>g</code>的状态为等待</li><li>尝试解锁，如果成功则切换状态为可执行，直接调用<code>execute</code>函数执行</li><li>否则，进入下一个调度</li></ul><h3 id="goready"><a href="#goready" class="headerlink" title="goready"></a>goready</h3><p>当goroutine通过<code>gopark</code>函数由<code>_Grunning</code>到<code>_Gwaiting</code>，反向操作<code>goready</code>函数则是将<code>_Gwaiting</code>到<code>_Grunnable</code>。</p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">goready</span><span class="token punctuation">(</span>gp <span class="token operator">*</span>g<span class="token punctuation">,</span> traceskip <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">systemstack</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">ready</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> traceskip<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">ready</span><span class="token punctuation">(</span>gp <span class="token operator">*</span>g<span class="token punctuation">,</span> traceskip <span class="token builtin">int</span><span class="token punctuation">,</span> next <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    status <span class="token operator">:=</span> <span class="token function">readgstatus</span><span class="token punctuation">(</span>gp<span class="token punctuation">)</span>    _g_ <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    mp <span class="token operator">:=</span> <span class="token function">acquirem</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 如果不是 _Gwaiting 抛异常</span>    <span class="token keyword">if</span> status<span class="token operator">&amp;^</span>_Gscan <span class="token operator">!=</span> _Gwaiting <span class="token punctuation">{</span>        <span class="token function">dumpgstatus</span><span class="token punctuation">(</span>gp<span class="token punctuation">)</span>        <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"bad g->status in ready"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 切换状态</span>    <span class="token function">casgstatus</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> _Gwaiting<span class="token punctuation">,</span> _Grunnable<span class="token punctuation">)</span>    <span class="token function">runqput</span><span class="token punctuation">(</span>_g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> gp<span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 存放到本地可执行队列中</span>    <span class="token function">wakep</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                          <span class="token comment" spellcheck="true">// 尝试去唤起p去执行</span>    <span class="token function">releasem</span><span class="token punctuation">(</span>mp<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p><code>ready</code>函数主要流程：</p><ul><li>获取<code>gp</code>的状态</li><li>获取当前的<code>g</code></li><li>检测<code>gp</code>状态是不是<code>_Gwaiting</code></li><li>由<code>_Gwaiting</code>转换为<code>_Grunnable</code>状态</li><li>放进当前<code>g</code>的<code>m</code>的<code>p</code>中的本地可执行队列中</li></ul><h2 id="抢占切换"><a href="#抢占切换" class="headerlink" title="抢占切换"></a>抢占切换</h2><p>golang调度本质上是非抢占式的，golang利用标志位标志当前的goroutine是否可以被抢占，而触发时机是在栈扩容的时候。<br>golang中有个监控函数，监控着整个进程运行的相关数据，其中就包括检查某个goroutine是否占用CPU时间过长，从而进行标记抢占标记位。</p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">sysmon</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ... 省略 ...</span>    <span class="token keyword">for</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// ... 省略 ...</span>        <span class="token comment" spellcheck="true">// 解绑在陷入系统调用中的p，和抢占长时间运行的g</span>        <span class="token keyword">if</span> <span class="token function">retake</span><span class="token punctuation">(</span>now<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>            idle <span class="token operator">=</span> <span class="token number">0</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            idle<span class="token operator">++</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// ... 省略 ...</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="retake"><a href="#retake" class="headerlink" title="retake"></a>retake</h3><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">retake</span><span class="token punctuation">(</span>now <span class="token builtin">int64</span><span class="token punctuation">)</span> <span class="token builtin">uint32</span> <span class="token punctuation">{</span>    n <span class="token operator">:=</span> <span class="token number">0</span>    <span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>allpLock<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>allp<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        _p_ <span class="token operator">:=</span> allp<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">if</span> _p_ <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>            <span class="token keyword">continue</span>        <span class="token punctuation">}</span>        pd <span class="token operator">:=</span> <span class="token operator">&amp;</span>_p_<span class="token punctuation">.</span>sysmontick <span class="token comment" spellcheck="true">// sysmon 信息记录</span>        s <span class="token operator">:=</span> _p_<span class="token punctuation">.</span>status        sysretake <span class="token operator">:=</span> <span class="token boolean">false</span>        <span class="token keyword">if</span> s <span class="token operator">==</span> _Prunning <span class="token operator">||</span> s <span class="token operator">==</span> _Psyscall <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 处于 _Prunning 或者 _Psyscall 状态时，如果上一次触发调度的时间已经过去了 10ms，</span>            <span class="token comment" spellcheck="true">// 我们就会通过 runtime.preemptone 抢占当前处理器</span>            <span class="token comment" spellcheck="true">// 如果G运行时间太长则抢占G</span>            t <span class="token operator">:=</span> <span class="token function">int64</span><span class="token punctuation">(</span>_p_<span class="token punctuation">.</span>schedtick<span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token function">int64</span><span class="token punctuation">(</span>pd<span class="token punctuation">.</span>schedtick<span class="token punctuation">)</span> <span class="token operator">!=</span> t <span class="token punctuation">{</span>                pd<span class="token punctuation">.</span>schedtick <span class="token operator">=</span> <span class="token function">uint32</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span>                pd<span class="token punctuation">.</span>schedwhen <span class="token operator">=</span> now            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> pd<span class="token punctuation">.</span>schedwhen<span class="token operator">+</span>forcePreemptNS <span class="token operator">&lt;=</span> now <span class="token punctuation">{</span>                <span class="token function">preemptone</span><span class="token punctuation">(</span>_p_<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">// 在_Psyscall时preemptone函数不会工作，因为m没有绑定p</span>                sysretake <span class="token operator">=</span> <span class="token boolean">true</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> s <span class="token operator">==</span> _Psyscall <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 当处理器处于 _Psyscall 状态时</span>            <span class="token comment" spellcheck="true">// 当处理器的运行队列不为空或者不存在空闲处理器时并且当系统调用时间超过了 10ms 时</span>            t <span class="token operator">:=</span> <span class="token function">int64</span><span class="token punctuation">(</span>_p_<span class="token punctuation">.</span>syscalltick<span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token operator">!</span>sysretake <span class="token operator">&amp;&amp;</span> <span class="token function">int64</span><span class="token punctuation">(</span>pd<span class="token punctuation">.</span>syscalltick<span class="token punctuation">)</span> <span class="token operator">!=</span> t <span class="token punctuation">{</span>                pd<span class="token punctuation">.</span>syscalltick <span class="token operator">=</span> <span class="token function">uint32</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span>                pd<span class="token punctuation">.</span>syscallwhen <span class="token operator">=</span> now                <span class="token keyword">continue</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token function">runqempty</span><span class="token punctuation">(</span>_p_<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>nmspinning<span class="token punctuation">)</span><span class="token operator">+</span>atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>npidle<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> pd<span class="token punctuation">.</span>syscallwhen<span class="token operator">+</span><span class="token number">10</span><span class="token operator">*</span><span class="token number">1000</span><span class="token operator">*</span><span class="token number">1000</span> <span class="token operator">></span> now <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 如果_p_没有可执行的g，且有自旋的m或空闲的p，且系统调用时间没有超过10ms</span>                <span class="token keyword">continue</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// Drop allpLock so we can take sched.lock.</span>            <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>allpLock<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 将p的状态设置为_Pidle，计数器n加1，_p_的系统调用次数+1</span>            <span class="token function">incidlelocked</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> atomic<span class="token punctuation">.</span><span class="token function">Cas</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>_p_<span class="token punctuation">.</span>status<span class="token punctuation">,</span> s<span class="token punctuation">,</span> _Pidle<span class="token punctuation">)</span> <span class="token punctuation">{</span>                n<span class="token operator">++</span>                _p_<span class="token punctuation">.</span>syscalltick<span class="token operator">++</span>                <span class="token function">handoffp</span><span class="token punctuation">(</span>_p_<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 让 p 去找其他的事情干</span>            <span class="token punctuation">}</span>            <span class="token function">incidlelocked</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>allpLock<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>allpLock<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token function">uint32</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p><code>retake</code>函数主要流程：</p><ul><li>遍历所有的<code>p</code></li><li>如果<code>p</code>长时间没有调度则标记抢占标志位</li><li>如果<code>p</code>在系统调用中，且超过阈值时间，则解绑<code>p</code></li><li>返回解绑<code>p</code>的个数</li></ul><h3 id="preemptone"><a href="#preemptone" class="headerlink" title="preemptone"></a>preemptone</h3><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">preemptone</span><span class="token punctuation">(</span>_p_ <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>    mp <span class="token operator">:=</span> _p_<span class="token punctuation">.</span>m<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> mp <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token operator">||</span> mp <span class="token operator">==</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>m <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果mp为空，或mp是当前运行的m</span>        <span class="token keyword">return</span> <span class="token boolean">false</span>    <span class="token punctuation">}</span>    gp <span class="token operator">:=</span> mp<span class="token punctuation">.</span>curg    <span class="token keyword">if</span> gp <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token operator">||</span> gp <span class="token operator">==</span> mp<span class="token punctuation">.</span>g0 <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// gp 不能使 g0</span>        <span class="token keyword">return</span> <span class="token boolean">false</span>    <span class="token punctuation">}</span>    gp<span class="token punctuation">.</span>preempt <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token comment" spellcheck="true">// 标志gp可以被抢占</span>    gp<span class="token punctuation">.</span>stackguard0 <span class="token operator">=</span> stackPreempt <span class="token comment" spellcheck="true">// 直接设置为栈顶，方便触发栈扩容</span>    <span class="token comment" spellcheck="true">// Request an async preemption of this P.</span>    <span class="token keyword">if</span> preemptMSupported <span class="token operator">&amp;&amp;</span> debug<span class="token punctuation">.</span>asyncpreemptoff <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>        _p_<span class="token punctuation">.</span>preempt <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token comment" spellcheck="true">// 标记p快速调度</span>        <span class="token function">preemptM</span><span class="token punctuation">(</span>mp<span class="token punctuation">)</span>       <span class="token comment" spellcheck="true">// 向mp发送抢占信号</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">}</span></code></pre><h3 id="handoffp"><a href="#handoffp" class="headerlink" title="handoffp"></a>handoffp</h3><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">handoffp</span><span class="token punctuation">(</span>_p_ <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果本地有可执行的G或全局可执行队列长度不为0，则直接开始执行</span>    <span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">runqempty</span><span class="token punctuation">(</span>_p_<span class="token punctuation">)</span> <span class="token operator">||</span> sched<span class="token punctuation">.</span>runqsize <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token function">startm</span><span class="token punctuation">(</span>_p_<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 如果可以执行GC，则立即执行</span>    <span class="token keyword">if</span> gcBlackenEnabled <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">gcMarkWorkAvailable</span><span class="token punctuation">(</span>_p_<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">startm</span><span class="token punctuation">(</span>_p_<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 如果没有自旋的m和空闲的p，并且增加自旋数成功，则让_p_绑定一个m进入自旋</span>    <span class="token keyword">if</span> atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>nmspinning<span class="token punctuation">)</span><span class="token operator">+</span>atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>npidle<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> atomic<span class="token punctuation">.</span><span class="token function">Cas</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>nmspinning<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">startm</span><span class="token punctuation">(</span>_p_<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>    <span class="token keyword">if</span> sched<span class="token punctuation">.</span>gcwaiting <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 即将GC</span>        _p_<span class="token punctuation">.</span>status <span class="token operator">=</span> _Pgcstop        sched<span class="token punctuation">.</span>stopwait<span class="token operator">--</span>        <span class="token keyword">if</span> sched<span class="token punctuation">.</span>stopwait <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>            <span class="token function">notewakeup</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>stopnote<span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> _p_<span class="token punctuation">.</span>runSafePointFn <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> atomic<span class="token punctuation">.</span><span class="token function">Cas</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>_p_<span class="token punctuation">.</span>runSafePointFn<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        sched<span class="token punctuation">.</span><span class="token function">safePointFn</span><span class="token punctuation">(</span>_p_<span class="token punctuation">)</span>        sched<span class="token punctuation">.</span>safePointWait<span class="token operator">--</span>        <span class="token keyword">if</span> sched<span class="token punctuation">.</span>safePointWait <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>            <span class="token function">notewakeup</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>safePointNote<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 此时如果全局队列有可执行的g，则执行</span>    <span class="token keyword">if</span> sched<span class="token punctuation">.</span>runqsize <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>        <span class="token function">startm</span><span class="token punctuation">(</span>_p_<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 如果这是最后运行的P并且没有人正在轮询网络，则需要唤醒另一个M来轮询网络。</span>    <span class="token keyword">if</span> sched<span class="token punctuation">.</span>npidle <span class="token operator">==</span> <span class="token function">uint32</span><span class="token punctuation">(</span>gomaxprocs<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> atomic<span class="token punctuation">.</span><span class="token function">Load64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lastpoll<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>        <span class="token function">startm</span><span class="token punctuation">(</span>_p_<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> when <span class="token operator">:=</span> <span class="token function">nobarrierWakeTime</span><span class="token punctuation">(</span>_p_<span class="token punctuation">)</span><span class="token punctuation">;</span> when <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token function">wakeNetPoller</span><span class="token punctuation">(</span>when<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 都没有则将_p_存放到空闲P列表中</span>    <span class="token function">pidleput</span><span class="token punctuation">(</span>_p_<span class="token punctuation">)</span>    <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p><code>retake</code>函数主要流程：</p><ul><li>如果<code>p</code>的本地可执行队列不为空，或全局可执行队列不为空，则绑定<code>m</code>去执行</li><li>如果<code>p</code>可以执行GC工作，则绑定m去执行</li><li>如果没有m在自旋且没有空闲的<code>p</code>，且成功设置自旋值，则获取一个<code>m</code>，进入自旋</li><li>如果此时在检测全局可执行队列是否为空，有则绑定<code>m</code>去执行</li><li>如果是最后一个正在运行的<code>p</code>，则绑定<code>m</code>去轮询网络</li><li>都没有则将<code>p</code>存放进空闲<code>p</code>列表</li></ul><h3 id="newstack"><a href="#newstack" class="headerlink" title="newstack"></a>newstack</h3><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">newstack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    thisg <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 当前执行的g</span>    gp <span class="token operator">:=</span> thisg<span class="token punctuation">.</span>m<span class="token punctuation">.</span>curg <span class="token comment" spellcheck="true">// m绑定的g</span>    <span class="token comment" spellcheck="true">// 判断是否抢占触发的栈扩张</span>    preempt <span class="token operator">:=</span> atomic<span class="token punctuation">.</span><span class="token function">Loaduintptr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>gp<span class="token punctuation">.</span>stackguard0<span class="token punctuation">)</span> <span class="token operator">==</span> stackPreempt    <span class="token comment" spellcheck="true">// ... 省略 ...</span>    <span class="token keyword">if</span> preempt <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Act like goroutine called runtime.Gosched.</span>        <span class="token function">gopreempt_m</span><span class="token punctuation">(</span>gp<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// never return</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// ... 省略 ...</span><span class="token punctuation">}</span></code></pre><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">gopreempt_m</span><span class="token punctuation">(</span>gp <span class="token operator">*</span>g<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> trace<span class="token punctuation">.</span>enabled <span class="token punctuation">{</span>        <span class="token function">traceGoPreempt</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token function">goschedImpl</span><span class="token punctuation">(</span>gp<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p><code>goschedImpl</code>函数就是上述Gosched函数的主要执行实体了。</p><p>如果检测到是抢占，则将m绑定的g放入全局可执行队列中。</p><h2 id="系统调用切换"><a href="#系统调用切换" class="headerlink" title="系统调用切换"></a>系统调用切换</h2><p>golang提供了系统调用接口：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">Syscall</span><span class="token punctuation">(</span>trap<span class="token punctuation">,</span> a1<span class="token punctuation">,</span> a2<span class="token punctuation">,</span> a3 <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>r1<span class="token punctuation">,</span> r2 <span class="token builtin">uintptr</span><span class="token punctuation">,</span> err Errno<span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">RawSyscall</span><span class="token punctuation">(</span>trap<span class="token punctuation">,</span> a1<span class="token punctuation">,</span> a2<span class="token punctuation">,</span> a3 <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>r1<span class="token punctuation">,</span> r2 <span class="token builtin">uintptr</span><span class="token punctuation">,</span> err Errno<span class="token punctuation">)</span></code></pre><p>更多参数可以调用Syscall6或Syscall9。</p><h3 id="Syscall"><a href="#Syscall" class="headerlink" title="Syscall"></a>Syscall</h3><pre class=" language-asm"><code class="language-asm">TEXT    ·Syscall(SB),NOSPLIT,$0-56    CALL    runtime·entersyscall(SB)    MOVQ    a1+8(FP), DI    MOVQ    a2+16(FP), SI    MOVQ    a3+24(FP), DX    MOVQ    trap+0(FP), AX    // syscall entry    ADDQ    $0x2000000, AX    SYSCALL    JCC    ok    MOVQ    $-1, r1+32(FP)    MOVQ    $0, r2+40(FP)    MOVQ    AX, err+48(FP)    CALL    runtime·exitsyscall(SB)    RETok:    MOVQ    AX, r1+32(FP)    MOVQ    DX, r2+40(FP)    MOVQ    $0, err+48(FP)    CALL    runtime·exitsyscall(SB)    RET</code></pre><p><code>Syscall</code>函数主要流程：</p><ul><li>调用<code>runtime.entersyscall</code></li><li>将参数存至寄存器</li><li>执行系统调用</li><li>将返回值压栈</li><li>调用<code>runtime.exitsyscall</code></li></ul><h4 id="entersyscall"><a href="#entersyscall" class="headerlink" title="entersyscall"></a>entersyscall</h4><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">entersyscall</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">reentersyscall</span><span class="token punctuation">(</span><span class="token function">getcallerpc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getcallersp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">reentersyscall</span><span class="token punctuation">(</span>pc<span class="token punctuation">,</span> sp <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    _g_ <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>locks<span class="token operator">++</span>    _g_<span class="token punctuation">.</span>stackguard0 <span class="token operator">=</span> stackPreempt <span class="token comment" spellcheck="true">// 等待被抢占</span>    _g_<span class="token punctuation">.</span>throwsplit <span class="token operator">=</span> <span class="token boolean">true</span>    <span class="token comment" spellcheck="true">// Leave SP around for GC and traceback.</span>    <span class="token function">save</span><span class="token punctuation">(</span>pc<span class="token punctuation">,</span> sp<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 保存现场</span>    _g_<span class="token punctuation">.</span>syscallsp <span class="token operator">=</span> sp    _g_<span class="token punctuation">.</span>syscallpc <span class="token operator">=</span> pc    <span class="token function">casgstatus</span><span class="token punctuation">(</span>_g_<span class="token punctuation">,</span> _Grunning<span class="token punctuation">,</span> _Gsyscall<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 切换状态</span>    <span class="token keyword">if</span> _g_<span class="token punctuation">.</span>syscallsp <span class="token operator">&lt;</span> _g_<span class="token punctuation">.</span>stack<span class="token punctuation">.</span>lo <span class="token operator">||</span> _g_<span class="token punctuation">.</span>stack<span class="token punctuation">.</span>hi <span class="token operator">&lt;</span> _g_<span class="token punctuation">.</span>syscallsp <span class="token punctuation">{</span>        <span class="token function">systemstack</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"entersyscall inconsistent "</span><span class="token punctuation">,</span> <span class="token function">hex</span><span class="token punctuation">(</span>_g_<span class="token punctuation">.</span>syscallsp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">" ["</span><span class="token punctuation">,</span> <span class="token function">hex</span><span class="token punctuation">(</span>_g_<span class="token punctuation">.</span>stack<span class="token punctuation">.</span>lo<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">","</span><span class="token punctuation">,</span> <span class="token function">hex</span><span class="token punctuation">(</span>_g_<span class="token punctuation">.</span>stack<span class="token punctuation">.</span>hi<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"]\n"</span><span class="token punctuation">)</span>            <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"entersyscall"</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> trace<span class="token punctuation">.</span>enabled <span class="token punctuation">{</span>        <span class="token function">systemstack</span><span class="token punctuation">(</span>traceGoSysCall<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// systemstack itself clobbers g.sched.{pc,sp} and we might</span>        <span class="token comment" spellcheck="true">// need them later when the G is genuinely blocked in a</span>        <span class="token comment" spellcheck="true">// syscall</span>        <span class="token function">save</span><span class="token punctuation">(</span>pc<span class="token punctuation">,</span> sp<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>sysmonwait<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token function">systemstack</span><span class="token punctuation">(</span>entersyscall_sysmon<span class="token punctuation">)</span>        <span class="token function">save</span><span class="token punctuation">(</span>pc<span class="token punctuation">,</span> sp<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>runSafePointFn <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// runSafePointFn may stack split if run on this stack</span>        <span class="token function">systemstack</span><span class="token punctuation">(</span>runSafePointFn<span class="token punctuation">)</span>        <span class="token function">save</span><span class="token punctuation">(</span>pc<span class="token punctuation">,</span> sp<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>syscalltick <span class="token operator">=</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>syscalltick    _g_<span class="token punctuation">.</span>sysblocktraced <span class="token operator">=</span> <span class="token boolean">true</span>    pp <span class="token operator">:=</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    pp<span class="token punctuation">.</span>m <span class="token operator">=</span> <span class="token number">0</span>    _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>oldp<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>pp<span class="token punctuation">)</span>    _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p <span class="token operator">=</span> <span class="token number">0</span>    atomic<span class="token punctuation">.</span><span class="token function">Store</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pp<span class="token punctuation">.</span>status<span class="token punctuation">,</span> _Psyscall<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 切换p的状态</span>    <span class="token keyword">if</span> sched<span class="token punctuation">.</span>gcwaiting <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token function">systemstack</span><span class="token punctuation">(</span>entersyscall_gcwait<span class="token punctuation">)</span>        <span class="token function">save</span><span class="token punctuation">(</span>pc<span class="token punctuation">,</span> sp<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>locks<span class="token operator">--</span><span class="token punctuation">}</span></code></pre><h4 id="exitsyscall"><a href="#exitsyscall" class="headerlink" title="exitsyscall"></a>exitsyscall</h4><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">exitsyscall</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    _g_ <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>locks<span class="token operator">++</span>     oldp <span class="token operator">:=</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>oldp<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>oldp <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">if</span> <span class="token function">exitsyscallfast</span><span class="token punctuation">(</span>oldp<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 尝试获取系统调用前绑定的p</span>        _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>syscalltick<span class="token operator">++</span>        <span class="token function">casgstatus</span><span class="token punctuation">(</span>_g_<span class="token punctuation">,</span> _Gsyscall<span class="token punctuation">,</span> _Grunning<span class="token punctuation">)</span>        _g_<span class="token punctuation">.</span>syscallsp <span class="token operator">=</span> <span class="token number">0</span>        _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>locks<span class="token operator">--</span>        <span class="token keyword">if</span> _g_<span class="token punctuation">.</span>preempt <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果抢占，就设置stackguard0为stackPreempt</span>            _g_<span class="token punctuation">.</span>stackguard0 <span class="token operator">=</span> stackPreempt        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 否则恢复真实栈帧</span>            _g_<span class="token punctuation">.</span>stackguard0 <span class="token operator">=</span> _g_<span class="token punctuation">.</span>stack<span class="token punctuation">.</span>lo <span class="token operator">+</span> _StackGuard        <span class="token punctuation">}</span>        _g_<span class="token punctuation">.</span>throwsplit <span class="token operator">=</span> <span class="token boolean">false</span>        <span class="token keyword">if</span> sched<span class="token punctuation">.</span>disable<span class="token punctuation">.</span>user <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">schedEnabled</span><span class="token punctuation">(</span>_g_<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// Scheduling of this goroutine is disabled.</span>            <span class="token function">Gosched</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 开始调度</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 没有p被绑定的情况</span>    _g_<span class="token punctuation">.</span>sysexitticks <span class="token operator">=</span> <span class="token number">0</span>    _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>locks<span class="token operator">--</span>    <span class="token comment" spellcheck="true">// Call the scheduler.</span>    <span class="token function">mcall</span><span class="token punctuation">(</span>exitsyscall0<span class="token punctuation">)</span>    _g_<span class="token punctuation">.</span>syscallsp <span class="token operator">=</span> <span class="token number">0</span>    _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>syscalltick<span class="token operator">++</span>    _g_<span class="token punctuation">.</span>throwsplit <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">}</span></code></pre><p><code>exitsyscall</code>函数主要流程：</p><ul><li>获取系统调用前绑定的<code>oldp</code></li><li>尝试获取<code>oldp</code>或从空闲列表获取<code>p</code></li><li>如果成功获取<code>p</code>，改变相关设置，开始下一轮调度</li><li>如果没有获取，则调用<code>exitsyscall0</code></li></ul><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">exitsyscall0</span><span class="token punctuation">(</span>gp <span class="token operator">*</span>g<span class="token punctuation">)</span> <span class="token punctuation">{</span>    _g_ <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">casgstatus</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> _Gsyscall<span class="token punctuation">,</span> _Grunnable<span class="token punctuation">)</span>    <span class="token function">dropg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>    <span class="token keyword">var</span> _p_ <span class="token operator">*</span>p    <span class="token keyword">if</span> <span class="token function">schedEnabled</span><span class="token punctuation">(</span>_g_<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果可以调度_g_</span>        _p_ <span class="token operator">=</span> <span class="token function">pidleget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 从p空闲列表中获取p</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> _p_ <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token function">globrunqput</span><span class="token punctuation">(</span>gp<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 没有可用的p，就将gp存放于全局可执行列表中</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>sysmonwait<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>        atomic<span class="token punctuation">.</span><span class="token function">Store</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>sysmonwait<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">notewakeup</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>sysmonnote<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>    <span class="token keyword">if</span> _p_ <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果有可用的p</span>        <span class="token function">acquirep</span><span class="token punctuation">(</span>_p_<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 直接绑定当前的m</span>        <span class="token function">execute</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 执行gp</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>lockedg <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果m有锁定的g</span>        <span class="token comment" spellcheck="true">// Wait until another thread schedules gp and so m again.</span>        <span class="token function">stoplockedm</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">// 释放p，休眠m，会阻塞</span>        <span class="token function">execute</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 执行gp</span>    <span class="token punctuation">}</span>    <span class="token function">stopm</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 将m休眠，并存于m空闲列表中，会阻塞</span>    <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 下一次调度</span><span class="token punctuation">}</span></code></pre><p><code>exitsyscall0</code>函数主要流程：</p><ul><li>切换<code>gp</code>状态为<code>_Grunnable</code></li><li>解绑<code>g</code>和<code>m</code></li><li>尝试获取一个空闲的<code>_p_</code></li><li>如果没有获取到就把<code>gp</code>放到全局可执行列表中</li><li>如果获取到了，就直接绑定当前的<code>m</code>，执行<code>gp</code></li><li>如果有<code>m</code>有锁定的<code>g</code>，释放p，休眠m，等待被唤醒</li><li>否则<code>m</code>将放置与全局<code>m</code>空闲列表中，等待下一次调度</li></ul><p>exitsyscall0函数如果没有p则会将m休眠</p><h3 id="RawSyscall"><a href="#RawSyscall" class="headerlink" title="RawSyscall"></a>RawSyscall</h3><pre class=" language-asm"><code class="language-asm">TEXT ·RawSyscall(SB),NOSPLIT,$0-56    MOVQ    a1+8(FP), DI    MOVQ    a2+16(FP), SI    MOVQ    a3+24(FP), DX    MOVQ    trap+0(FP), AX    // syscall entry    ADDQ    $0x2000000, AX    SYSCALL    JCC    ok1    MOVQ    $-1, r1+32(FP)    MOVQ    $0, r2+40(FP)    MOVQ    AX, err+48(FP)    RETok1:    MOVQ    AX, r1+32(FP)    MOVQ    DX, r2+40(FP)    MOVQ    $0, err+48(FP)    RET</code></pre><p><code>RawSyscall</code>函数主要流程：</p><ul><li>将参数存至寄存器</li><li>执行系统调用</li><li>将返回值压栈</li></ul><p><code>RawSyscall</code>函数并没有执行<code>runtime.entersyscall</code>和<code>runtime.exitsyscall</code>函数，由于没有执行相关操作导致golang无法准确的调度，可能会导致长时间系统调用，其他的goroutine无法得到执行。</p><h1 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h1><h2 id="getg"><a href="#getg" class="headerlink" title="getg"></a>getg</h2><p>获取当前的<code>g</code>，由于是编译器填充的，所以没有源码。<br>一般都是从TLS寄存器获取的。</p><h2 id="mcall"><a href="#mcall" class="headerlink" title="mcall"></a>mcall</h2><pre class=" language-asm"><code class="language-asm">TEXT runtime·mcall(SB), NOSPLIT, $0-8    MOVQ    fn+0(FP), DI    get_tls(CX)    MOVQ    g(CX), AX    // save state in g->sched    MOVQ    0(SP), BX    // caller's PC    MOVQ    BX, (g_sched+gobuf_pc)(AX)    LEAQ    fn+0(FP), BX    // caller's SP    MOVQ    BX, (g_sched+gobuf_sp)(AX)    MOVQ    AX, (g_sched+gobuf_g)(AX)    MOVQ    BP, (g_sched+gobuf_bp)(AX)    // switch to m->g0 & its stack, call fn    MOVQ    g(CX), BX    MOVQ    g_m(BX), BX    MOVQ    m_g0(BX), SI    CMPQ    SI, AX    // if g == m->g0 call badmcall    JNE    3(PC)    MOVQ    $runtime·badmcall(SB), AX    JMP    AX    MOVQ    SI, g(CX)    // g = m->g0    MOVQ    (g_sched+gobuf_sp)(SI), SP    // sp = m->g0->sched.sp    PUSHQ    AX    MOVQ    DI, DX    MOVQ    0(DI), DI    CALL    DI // 执行fn，不能返回    POPQ    AX    MOVQ    $runtime·badmcall2(SB), AX    JMP    AX    RET</code></pre><p><code>mcall</code>函数切换到<code>m</code>的<code>g0</code>调用<code>fn(g)</code>，<code>fn</code>是不能返回的。</p><h2 id="systemstack"><a href="#systemstack" class="headerlink" title="systemstack"></a>systemstack</h2><pre class=" language-asm"><code class="language-asm">TEXT runtime·systemstack(SB), NOSPLIT, $0-8    MOVQ    fn+0(FP), DI    // DI = fn    get_tls(CX)    MOVQ    g(CX), AX    // AX = g    MOVQ    g_m(AX), BX    // BX = m    CMPQ    AX, m_gsignal(BX) // g == m.gsignal    JEQ    noswitch    MOVQ    m_g0(BX), DX    // DX = g0    CMPQ    AX, DX // g == g0    JEQ    noswitch    CMPQ    AX, m_curg(BX) // g == m.curg    JNE    bad    // 保存当前g的栈信息    MOVQ    $runtime·systemstack_switch(SB), SI    MOVQ    SI, (g_sched+gobuf_pc)(AX)    MOVQ    SP, (g_sched+gobuf_sp)(AX)    MOVQ    AX, (g_sched+gobuf_g)(AX)    MOVQ    BP, (g_sched+gobuf_bp)(AX)    // 切换到g0    MOVQ    DX, g(CX)    MOVQ    (g_sched+gobuf_sp)(DX), BX    // make it look like mstart called systemstack on g0, to stop traceback    SUBQ    $8, BX    MOVQ    $runtime·mstart(SB), DX    MOVQ    DX, 0(BX)    MOVQ    BX, SP    // call target function    MOVQ    DI, DX    MOVQ    0(DI), DI    CALL    DI // 执行目标函数    // 恢复原有g    get_tls(CX)    MOVQ    g(CX), AX    MOVQ    g_m(AX), BX    MOVQ    m_curg(BX), AX    MOVQ    AX, g(CX)    MOVQ    (g_sched+gobuf_sp)(AX), SP    MOVQ    $0, (g_sched+gobuf_sp)(AX)    RET</code></pre><p>systemstack函数主要流程：</p><ul><li>检测相关参数</li><li>保存g现场</li><li>切换到g0，并执行fn(g)</li><li>恢复原有g</li></ul><h2 id="acquirem"><a href="#acquirem" class="headerlink" title="acquirem"></a>acquirem</h2><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">acquirem</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span>m <span class="token punctuation">{</span>    _g_ <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>locks<span class="token operator">++</span>    <span class="token keyword">return</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">}</span></code></pre><p><code>acquirem</code>函数主要是增加<code>locks</code>引用计数，并返回当前的m。主要是防止GC回收m。</p><h2 id="releasem"><a href="#releasem" class="headerlink" title="releasem"></a>releasem</h2><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">releasem</span><span class="token punctuation">(</span>mp <span class="token operator">*</span>m<span class="token punctuation">)</span> <span class="token punctuation">{</span>    _g_ <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    mp<span class="token punctuation">.</span>locks<span class="token operator">--</span>    <span class="token keyword">if</span> mp<span class="token punctuation">.</span>locks <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> _g_<span class="token punctuation">.</span>preempt <span class="token punctuation">{</span>        _g_<span class="token punctuation">.</span>stackguard0 <span class="token operator">=</span> stackPreempt    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>releasem</code>函数主要是减少<code>locks</code>引用计数，并判断是否需要<code>g</code>被抢占</p><h2 id="acquirep"><a href="#acquirep" class="headerlink" title="acquirep"></a>acquirep</h2><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">acquirep</span><span class="token punctuation">(</span>_p_ <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">wirep</span><span class="token punctuation">(</span>_p_<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">wirep</span><span class="token punctuation">(</span>_p_ <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>    _g_ <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>_p_<span class="token punctuation">)</span>    _p_<span class="token punctuation">.</span>m<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>_g_<span class="token punctuation">.</span>m<span class="token punctuation">)</span>    _p_<span class="token punctuation">.</span>status <span class="token operator">=</span> _Prunning<span class="token punctuation">}</span></code></pre><p><code>acquirep</code>函数主要流程：</p><ul><li>绑定<code>p</code>和<code>m</code></li><li>将<code>p</code>的状态置为<code>_Prunning</code></li></ul><h2 id="releasep"><a href="#releasep" class="headerlink" title="releasep"></a>releasep</h2><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">releasep</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span>p <span class="token punctuation">{</span>    _g_ <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    _p_ <span class="token operator">:=</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p <span class="token operator">=</span> <span class="token number">0</span>    _p_<span class="token punctuation">.</span>m <span class="token operator">=</span> <span class="token number">0</span>    _p_<span class="token punctuation">.</span>status <span class="token operator">=</span> _Pidle    <span class="token keyword">return</span> _p_<span class="token punctuation">}</span></code></pre><p><code>releasep</code>函数主要流程：</p><ul><li>解绑<code>m</code>和<code>p</code></li><li>将<code>p</code>的状态置为<code>_Pidle</code></li><li>返回<code>p</code></li></ul><h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><h2 id="p的本地可执行列表无锁，其他p怎么偷取可执行列表"><a href="#p的本地可执行列表无锁，其他p怎么偷取可执行列表" class="headerlink" title="p的本地可执行列表无锁，其他p怎么偷取可执行列表"></a>p的本地可执行列表无锁，其他p怎么偷取可执行列表</h2><p>通过原子cas的方式提交列表头尾位置，如果失败则重新偷取。</p><h2 id="g进入-Gwaiting状态后去哪里了"><a href="#g进入-Gwaiting状态后去哪里了" class="headerlink" title="g进入_Gwaiting状态后去哪里了"></a>g进入_Gwaiting状态后去哪里了</h2><ul><li>如果<code>g</code>是被抢占了，则将g的状态改为<code>_Grunnable</code>，放入全局可执行队列中</li><li>如果是主动切换，调用<code>gopark</code>的调用者需要维护<code>sudog</code>列表（<code>sudog</code>用于保存调用<code>gopark</code>的<code>g</code>），接收已完成的<code>goroutine</code>，然后调用<code>goready</code>，将他们状态置为<code>_Grunnable</code>，存入本地的可执行队列中。</li></ul><h2 id="m进入自旋，在干嘛"><a href="#m进入自旋，在干嘛" class="headerlink" title="m进入自旋，在干嘛"></a>m进入自旋，在干嘛</h2><p><code>m</code>自旋，即<code>m</code>阻塞于<code>schedule()</code>的<code>findrunnable()</code>，<code>m</code>会一直尝试获取可执行的<code>g</code>去工作。</p><h2 id="g0栈复用"><a href="#g0栈复用" class="headerlink" title="g0栈复用"></a>g0栈复用</h2><p><code>g0</code>的栈在golang中不同系统采用不同的初始化方式。</p><pre class=" language-go"><code class="language-go"><span class="token keyword">if</span> iscgo <span class="token operator">||</span> GOOS <span class="token operator">==</span> <span class="token string">"solaris"</span> <span class="token operator">||</span> GOOS <span class="token operator">==</span> <span class="token string">"illumos"</span> <span class="token operator">||</span> GOOS <span class="token operator">==</span> <span class="token string">"windows"</span> <span class="token operator">||</span> GOOS <span class="token operator">==</span> <span class="token string">"plan9"</span> <span class="token operator">||</span> GOOS <span class="token operator">==</span> <span class="token string">"darwin"</span> <span class="token operator">||</span> GOOS <span class="token operator">==</span> <span class="token string">"ios"</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果是上面的情况 g0栈是用的 pthread_create 线程栈</span>        mp<span class="token punctuation">.</span>g0 <span class="token operator">=</span> <span class="token function">malg</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        mp<span class="token punctuation">.</span>g0 <span class="token operator">=</span> <span class="token function">malg</span><span class="token punctuation">(</span><span class="token number">8192</span> <span class="token operator">*</span> sys<span class="token punctuation">.</span>StackGuardMultiplier<span class="token punctuation">)</span>    <span class="token punctuation">}</span></code></pre><p>每次切到<code>g0</code>栈执行指令时，<code>g0-&gt;sched.sp</code>在初始化后没有修改该过，所以每次切换到g0时栈起始值相同，每次调用<code>mcall</code>都会从指定栈位置开始执行相关操作，以此来复用g0栈。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzU1ODEzNjI2NA==&amp;mid=2247487178&amp;idx=2&amp;sn=121f293c1502b10e7569a0e7216de79e&amp;source=41#wechat_redirect" target="_blank" rel="noopener">详尽干货！从源码角度看 Golang 的调度</a></li><li><a href="https://zboya.github.io/post/go_scheduler/" target="_blank" rel="noopener">深入golang runtime的调度</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> runtime </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang MPG 有限状态机</title>
      <link href="/golang/golang-mpg-you-xian-zhuang-tai-ji.html"/>
      <url>/golang/golang-mpg-you-xian-zhuang-tai-ji.html</url>
      
        <content type="html"><![CDATA[<p>去掉了cgo和GC的相关状态转化</p><h1 id="P状态机"><a href="#P状态机" class="headerlink" title="P状态机"></a>P状态机</h1><h1 id="G状态机"><a href="#G状态机" class="headerlink" title="G状态机"></a>G状态机</h1><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mpg </tag>
            
            <tag> infra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang MPG 场景源码剖析</title>
      <link href="/golang/golang-mpg-chang-jing-yuan-ma-pou-xi.html"/>
      <url>/golang/golang-mpg-chang-jing-yuan-ma-pou-xi.html</url>
      
        <content type="html"><![CDATA[<h1 id="场景分析"><a href="#场景分析" class="headerlink" title="场景分析"></a>场景分析</h1><ul><li><p>G创建G<br>p拥有g1，m绑定p后，执行g1，g1创建g2，g2优先加入g1。<br>调用链：</p><pre class=" language-text"><code class="language-text">newproc() --> systemstack(newproc1() --> runqput())</code></pre></li><li><p>G执行完毕<br>当g1执行完毕后，m切换到g0，负责goroutine的切换，从p中获取g2，在从g0切换到g2，并执行g2。<br>调用链：</p><pre class=" language-text"><code class="language-text">goexit() --> goexit1() --> mcall(goexit0) --> schedule()</code></pre></li><li><p>G本地队列满再创建G<br>g1创建g2，但p的本地G空闲队列已满，则会p的空闲队列的前一半随机排序后和g2存放到全局空闲G队列中。<br>调用链：</p><pre class=" language-text"><code class="language-text">newproc() --> systemstack(newproc1() --> runqput() --> runqputslow() --> globrunqputbatch())</code></pre></li><li><p>唤醒M<br>在创建 G 时，运行的 G 会尝试唤醒其他空闲的P和M组合去执行。如果g1唤醒了m2，m2且与p2绑定，但p2没有可执行的G，m2会执行g0，进入自旋状态（一直获取可以执行的G）。<br>调用链：</p><pre class=" language-text"><code class="language-text">newproc() --> systemstack(wakep() --> startm() --> pidleget() --> mget() --> notewakeup())</code></pre></li><li><p>唤醒的M向全局空闲G队列获取<br>自旋的M会向全局空闲G队列获取可执行的G，获取公式：<code>n=min(len(GQ)/GOMAXPROCS+1,len(GQ)/2+1)</code>，其中GQ是全局空闲G队列，最少获取一个。<br>调用链：</p><pre class=" language-text"><code class="language-text">schedule() --> findrunnable() --> globrunqget()</code></pre></li><li><p>M向M偷取G<br>当m1进入自旋状态，且全局空闲G队列也为空，则会向m2队尾偷取一般的G放入与m1绑定的p1的本地空闲G队列中。<br>调用链：</p><pre class=" language-text"><code class="language-text">schedule() --> findrunnable() --> runqsteal()</code></pre></li><li><p>自旋最大限制<br>M必须绑定了P才会自旋，所以最多有<code>GOMAXPROCS</code>个M自旋，其他的M会存入全局休眠M队列。<br>调用链：</p><pre class=" language-text"><code class="language-text">stopm() --> mput()</code></pre></li><li><p>G调用系统调用<br><code>m1</code>执行的<code>g1</code>调用了系统调用，那么会保存<code>g1</code>的状态，并将<code>g1</code>标记为可抢占，解绑<code>p</code>，将<code>p</code>的状态设置为<code>_Psyscall</code>，但不会做其他事，方便很快的系统调用返回时可以立即拥有<code>p</code>执行。当<code>sysmon</code>检测当前p处于系统调用时间超时后再去绑定m，做其他事情。退出系统调用时，<code>g1</code>会被标记可执行状态存放到全局空闲G队列，<code>m1</code>则会存放到全局休眠M队列。<br>调用链：</p><pre class=" language-text"><code class="language-text">进入系统调用entersyscall() --> reentersyscall()sysmon() --> retake() --> handoffp() --> startm() --> pidleput()</code></pre></li></ul><p>退出系统调用<br>exitsyscall() –&gt; exitsyscallfast() –&gt; mcall(exitsyscall0() –&gt; pidleget() –&gt; globrunqput() –&gt; stopm())</p><pre><code># 参考文献* [[典藏版] Golang 调度器 GMP 原理与调度全分析](https://learnku.com/articles/41728)</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mpg </tag>
            
            <tag> infra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang内存管理</title>
      <link href="/golang/golang-nei-cun-guan-li.html"/>
      <url>/golang/golang-nei-cun-guan-li.html</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> infra </tag>
            
            <tag> memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-sed命令</title>
      <link href="/linux/linux-sed-ming-ling.html"/>
      <url>/linux/linux-sed-ming-ling.html</url>
      
        <content type="html"><![CDATA[<p>sed是linux行文本处理命令，默认选项是<code>-e</code></p><pre class=" language-sh"><code class="language-sh">➜ sed --help用法: sed [选项]... {脚本(如果没有其他脚本)} [输入文件]...  -n, --quiet, --silent                 取消自动打印模式空间  -e 脚本, --expression=脚本                 添加“脚本”到程序的运行列表  -f 脚本文件, --file=脚本文件                 添加“脚本文件”到程序的运行列表  --follow-symlinks                 直接修改文件时跟随软链接  -i[SUFFIX], --in-place[=SUFFIX]                 edit files in place (makes backup if SUFFIX supplied)  -c, --copy                 use copy instead of rename when shuffling files in -i mode  -b, --binary                 does nothing; for compatibility with WIN32/CYGWIN/MSDOS/EMX (                 open files in binary mode (CR+LFs are not treated specially))  -l N, --line-length=N                 指定“l”命令的换行期望长度  --posix                 关闭所有 GNU 扩展  -r, --regexp-extended                 在脚本中使用扩展正则表达式  -s, --separate                 将输入文件视为各个独立的文件而不是一个长的连续输入  -u, --unbuffered                 从输入文件读取最少的数据，更频繁的刷新输出  -z, --null-data                 separate lines by NUL characters  --help                 display this help and exit  --version                 output version information and exit如果没有 -e, --expression, -f 或 --file 选项，那么第一个非选项参数被视为sed脚本。其他非选项参数被视为输入文件，如果没有输入文件，那么程序将从标准输入读取数据。</code></pre><h1 id="sed-命令"><a href="#sed-命令" class="headerlink" title="sed 命令"></a>sed 命令</h1><h2 id="行为命令"><a href="#行为命令" class="headerlink" title="行为命令"></a>行为命令</h2><p>行为命令为sed匹配到指定的行后的操作，多个操作用<code>;</code>进行间隔：</p><ul><li><code>!</code>，反向选取</li><li><code>:</code>，声明标签</li><li><code>a</code>，向下新增一行数据</li><li><code>b</code>，跳转标签，需要在标签前</li><li><code>c</code>，替换匹配行</li><li><code>d</code>，删除匹配行</li><li><code>g</code>，将保持空间复制到模式空间</li><li><code>G</code>，将保持空间追加到模式空间</li><li><code>h</code>，将模式空间的值复制到保持空间</li><li><code>H</code>，将模式空间的值追加到保持空间</li><li><code>i</code>，向上新增一行数据</li><li><code>n</code>，读取下一行到追加到模式空间，相当于模式空间有两行数据，但后续操作只会影响新读取的行</li><li><code>N</code>，读取下一行到追加到模式空间，与原有数据合并成一行，后续操作会影响新的一行</li><li><code>p</code>，打印匹配行</li><li><code>q</code>，退出</li><li><code>r</code>，从文件读取输入行</li><li><code>s</code>，替换，按照规则替换匹配行中的字符串，附加命令<code>g</code>表示行内全部替换</li><li><code>w</code>，将所选的行写入文件</li><li><code>x</code>，将模式空间和保持空间互换</li><li><code>y</code>，将字符替换为另一个字符</li></ul><h2 id="操作对象"><a href="#操作对象" class="headerlink" title="操作对象"></a>操作对象</h2><p>操作对象表示sed匹配的行</p><ul><li>数字，表示指定行，用<code>,</code>隔开表示连续的行</li><li><code>$</code>，表示最后一行</li><li><code>//{}</code>，之间的内容进行正则匹配，对匹配的行进行<code>{}</code>的操作，也可以不用<code>{}</code>，直接使用简化的行为命令也可以，还可以和数字一起使用，例如<code>/^s/,10p</code>，打印第一个以<code>s</code>开头的行到第10行</li></ul><h2 id="sed正则表达式"><a href="#sed正则表达式" class="headerlink" title="sed正则表达式"></a>sed正则表达式</h2><p>正则操作符，用于匹配复杂的行</p><ul><li><code>^</code>，行首匹配</li><li><code>$</code>，行尾匹配</li><li><code>.</code>，匹配除换行符外的任意字符</li><li><code>*</code>，贪心匹配，即匹配前一字符零次或多次，匹配直到最后出现的一次</li><li><code>?</code>，非贪心匹配，即匹配零次或一次</li><li><code>[]</code>，匹配任一字符</li><li><code>[^]</code>，不能匹配到任一字符</li><li><code>\(\)</code>，保存已匹配的字符，最多可匹配9次，编号为1到9，通过\1来引用</li><li><code>&amp;</code>，表示已匹配的行</li><li><code>\&lt;</code>，词首定位符</li><li><code>\&gt;</code>，词尾定位符</li><li><code>\{n\}</code>，匹配前一字符出现n次</li><li><code>\{n,\}</code>，匹配前一字符至少出现n次</li><li><code>\{n,m\}</code>，匹配前一字符至少出现n次，但不超过m次</li></ul><h1 id="模式空间与保持空间"><a href="#模式空间与保持空间" class="headerlink" title="模式空间与保持空间"></a>模式空间与保持空间</h1><p>上面的操作都是在默认的模式空间中进行的，sed为了能够同时处理多行数据，提供了保持空间。<br>模式空间是指，匹配到一行后执行相应的操作，然后模式空间清空，直到文件处理完毕。<br>保持空间是指，存储指定数据，可以通过行为命令将模式空间的数据覆盖、追加、互换操作。</p><h2 id="实现tac"><a href="#实现tac" class="headerlink" title="实现tac"></a>实现tac</h2><pre class=" language-sh"><code class="language-sh">➜ seq 3 | sed -n '1!G;h;$p'321</code></pre><p>模式空间读入第一行，将模式空间复制到保持空间，删除模式空间<br>模式空间读入第二行，将保持空间追加到模式空间，将模式空间复制到保持空间，删除模式空间<br>其他行重复第二行的操作<br>模式空间读入最后一行，将保持空间追加到模式空间，将模式空间复制到保持空间，打印模式空间</p><h2 id="实现xargs"><a href="#实现xargs" class="headerlink" title="实现xargs"></a>实现xargs</h2><pre class=" language-sh"><code class="language-sh">➜ seq 3 | sed -n 'H;${x;s/\n/ /g;p}'</code></pre><p>每一行都将模式空间追加到保持空间，最后一行将模式空间和保持空间数据对换，替换所有换行符为空格，打印模式空间。<br>正常情况下sed按行处理文本，是不会读到换行符，可以通过这种方式获取带换行符的多行数据。</p><h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><p>在sed脚本中<code>:</code>表示声明一个标签，b表示跳转标签。利用标签可以实现类似循环的操作。</p><h2 id="实现xargs-1"><a href="#实现xargs-1" class="headerlink" title="实现xargs"></a>实现xargs</h2><pre class=" language-sh"><code class="language-sh">➜ seq 3 | sed ':a;N;$!ba;${s/\n/ /g}'</code></pre><p>设置标签a，读取下一行，与原有数据当做一行，不是最后一行跳转到标签a，直到最后一行，不跳转到标签a，替换所有的换行符为空格，sed自动打印模式空间内容</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://www.runoob.com/linux/linux-comm-sed.html" target="_blank" rel="noopener">菜鸟教程-Linux sed 命令</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cmd </tag>
            
            <tag> command </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-find命令</title>
      <link href="/linux/linux-find-ming-ling.html"/>
      <url>/linux/linux-find-ming-ling.html</url>
      
        <content type="html"><![CDATA[<p>在linux中find是一个非常有用的命令，它可以快速查找指定目录下符合条件的文件。</p><pre class=" language-sh"><code class="language-sh">➜ find --helpUsage: find [-H] [-L] [-P] [-Olevel] [-D help|tree|search|stat|rates|opt|exec] [path...] [expression]default path is the current directory; default expression is -printexpression may consist of: operators, options, tests, and actions:operators (decreasing precedence; -and is implicit where no others are given):      ( EXPR )   ! EXPR   -not EXPR   EXPR1 -a EXPR2   EXPR1 -and EXPR2      EXPR1 -o EXPR2   EXPR1 -or EXPR2   EXPR1 , EXPR2positional options (always true): -daystart -follow -regextypenormal options (always true, specified before other expressions):      -depth --help -maxdepth LEVELS -mindepth LEVELS -mount -noleaf      --version -xautofs -xdev -ignore_readdir_race -noignore_readdir_racetests (N can be +N or -N or N): -amin N -anewer FILE -atime N -cmin N      -cnewer FILE -ctime N -empty -false -fstype TYPE -gid N -group NAME      -ilname PATTERN -iname PATTERN -inum N -iwholename PATTERN -iregex PATTERN      -links N -lname PATTERN -mmin N -mtime N -name PATTERN -newer FILE      -nouser -nogroup -path PATTERN -perm [-/]MODE -regex PATTERN      -readable -writable -executable      -wholename PATTERN -size N[bcwkMG] -true -type [bcdpflsD] -uid N      -used N -user NAME -xtype [bcdpfls]      -context CONTEXTactions: -delete -print0 -printf FORMAT -fprintf FILE FORMAT -print      -fprint0 FILE -fprint FILE -ls -fls FILE -prune -quit      -exec COMMAND ; -exec COMMAND {} + -ok COMMAND ;      -execdir COMMAND ; -execdir COMMAND {} + -okdir COMMAND ;</code></pre><p>find的语法：<code>find [option] [path ... ] [expression]</code><br>默认<code>path</code>是当前路径，默认<code>expression</code>是<code>-print</code>。<code>expression</code>还可以是<code>operators</code>，<code>options</code>，<code>tests</code>，<code>actions</code>。</p><p>operators：优先级递减，默认是<code>-and</code></p><ul><li><code>()</code>，集合</li><li><code>!</code>，<code>-not</code>，非</li><li><code>-a</code>，<code>-and</code>，且</li><li><code>-o</code>，<code>-or</code>，或</li><li><code>,</code>，合并</li></ul><p>positional options：总是true</p><ul><li><code>-daystart</code>，从本日开始计算时间</li><li><code>-follow</code>，排除符号连接</li><li><code>-regextype</code></li></ul><p>normal options：总是true，在其他表达式之前指定</p><ul><li><code>-depth</code>，限制递归深度</li><li><code>--help</code>，打印usage</li><li><code>-maxdepth LEVELS</code>，</li><li><code>-mindepth LEVELS</code>，</li><li><code>-mount</code>，同<code>-xdev</code></li><li><code>-noleaf</code>，不去考虑目录至少需拥有两个硬连接存在</li><li><code>--version</code>，打印版本</li><li><code>-xautofs</code>，</li><li><code>-xdev</code>，将范围局限在先行的文件系统中<br><code>-ignore_readdir_race</code>，<code>-noignore_readdir_race</code></li></ul><p>tests：（N可以是+N -N N，+表示大于N，-表示小于N，不带符号表示等于N）</p><ul><li><code>-amin N</code>，查找在指定时间曾被存取过的文件或目录，单位以分钟计算</li><li><code>-anewer FILE</code>，查找其存取时间较指定文件或目录的存取时间更接近现在的文件或目录</li><li><code>-atime N</code>，查找在指定时间曾被存取过的文件或目录，单位以 24 小时计算</li><li><code>-cmin N</code>，查找在指定时间之时被更改过的文件或目录</li><li><code>-cnewer FILE</code>，查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录</li><li><code>-ctime N</code>，查找在指定时间之时被更改的文件或目录，单位以 24 小时计算</li><li><code>-empty</code>，寻找文件大小为 0 Byte 的文件，或目录下没有任何子目录或文件的空目录</li><li><code>-false</code>，回传值都为false</li><li><code>-fstype TYPE</code>，只寻找该文件系统类型下的文件或目录</li><li><code>-gid N</code>，所属组id的文件</li><li><code>-group NAME</code>，所属组名称的文件</li><li><code>-ilname PATTERN</code>，类似<code>-lname</code>，忽略大小写</li><li><code>-iname PATTERN</code>，类似<code>-name</code>，忽略大小写</li><li><code>-inum N</code>，查找符合指定的<code>inode</code>编号的文件或目录</li><li><code>-iwholename PATTERN</code> </li><li><code>-iregex PATTERN</code>，类似<code>-regex</code>，忽略大小写</li><li><code>-links N</code>，查找符合指定的硬连接数目的文件或目录</li><li><code>-lname PATTERN</code>，类似<code>-name</code>，只获取连接文件</li><li><code>-mmin N</code>，查找在指定时间曾被更改过的文件或目录，单位以分钟计算</li><li><code>-mtime N</code>，查找在指定时间曾被更改过的文件或目录，单位以 24 小时计算</li><li><code>-name PATTERN</code>，按照<strong>文件名</strong>查找，支持<code>*</code>通配符</li><li><code>-newer FILE</code>，查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录</li><li><code>-nouser</code>，找出不属于本地主机用户识别码的文件或目录</li><li><code>-nogroup</code>，找出不属于本地主机群组识别码的文件或目录</li><li><code>-path PATTERN</code>，类似<code>-name</code>，匹配的是整个相对路径</li><li><code>-perm [-/]MODE</code>，按照文件权限查找</li><li><code>-regex PATTERN</code>，正则</li><li><code>-readable</code>，可读文件</li><li><code>-writable</code>，可写文件</li><li><code>-executable</code>，可执行文件</li><li><code>-wholename PATTERN</code>，完全名字匹配</li><li><code>-size N[bcwkMG]</code>，按照文件大小查找</li><li><code>-true</code>，回传值都为true</li><li><code>-type [bcdpflsD]</code>，按照文件类型查找</li><li><code>-uid N</code>，按照文件拥有者ID查找</li><li><code>-used N</code>，查找文件或目录被更改之后在指定时间曾被存取过的文件或目录，单位以日计算</li><li><code>-user NAME</code>，按照文件拥有者查找</li><li><code>-xtype [bcdpfls]</code>，类似<code>-type</code>，针对符号连接检查</li><li><code>-context CONTEXT</code></li></ul><p>actions：</p><ul><li><code>-delete</code></li><li><code>-print0</code>，假设<code>find</code>指令的回传值为<code>ture</code>，就将文件或目录名称列出到标准输出，格式为全部的名称皆在同一行</li><li><code>-printf FORMAT</code>，假设<code>find</code>指令的回传值为<code>ture</code>，就将文件或目录名称列出到标准输出，格式由<code>FORMAT</code>指定</li><li><code>-fprintf FILE FORMAT</code>，类似<code>-printf</code>，格式化输出到文件</li><li><code>-print</code>，假设<code>find</code>指令的回传值为<code>ture</code>，就将文件或目录名称列出到标准输出，格式为每列一个名称</li><li><code>-fprint0 FILE</code>，类似<code>-print0</code>，将输出写入文件</li><li><code>-fprint FILE</code>，类似<code>-print</code>，将输出写入文件</li><li><code>-ls</code>，打印查找结果详细信息</li><li><code>-fls FILE</code>，类似<code>-ls</code>，将输出写入文件</li><li><code>-prune</code>，不寻找字符串作为寻找文件或目录的范本样式</li><li><code>-quit</code>，什么也不打印</li><li><code>-exec COMMAND</code>、<code>-exec COMMAND {} + -ok COMMAND</code>、<code>-execdir COMMAND</code>、<code>-execdir COMMAND {} + -okdir COMMAND</code>，将<code>find</code>出的结果执行其他命令，<code>{}</code>表示find后的集合，在<code>COMMAND</code>后面需要加上<code>\;</code>来标记<code>COMMAND</code>结束。<code>ok</code>类似<code>exec</code>，在执行<code>COMMAND</code>之前会询问是否执行。</li></ul><p>文件类型：</p><ul><li>b，块设备</li><li>c，字符设备</li><li>d，目录</li><li>p，管道</li><li>f，普通文件</li><li>l，链接文件</li><li>s，套接字</li><li>D，未知</li></ul><p>大小单位：</p><ul><li>b，块（512 字节）</li><li>c，字节</li><li>w，字（2 字节）</li><li>k，千字节</li><li>M，兆字节</li><li>G，吉字节</li></ul><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://blog.csdn.net/qq_35246620/article/details/79104520" target="_blank" rel="noopener">Linux 命令之 find：查找文件</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cmd </tag>
            
            <tag> command </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang MPG调度</title>
      <link href="/golang/golang-mpg-diao-du.html"/>
      <url>/golang/golang-mpg-diao-du.html</url>
      
        <content type="html"><![CDATA[<h1 id="MPG"><a href="#MPG" class="headerlink" title="MPG"></a>MPG</h1><p>MPG是golang的并发模型，结构源码在<code>runtime/runtime2.go</code>里面，主体逻辑结构在<code>runtime/proc.go</code>里，是golang可以高并发的根本。</p><ul><li>M，连接一个内核态的线程，goroutine跑在M上，每个M都会有一个g0的G，用于协调P队列里的G，在调度或系统调用时会用到g0的栈</li><li>P，维护执行G队列，管理G上下文</li><li>G，代表goroutine的元数据，包括栈信息，M信息，计数器等</li></ul><p>除了MPG之外，还有Sched来负责全局队列的处理。<br>四者协同完成整个golang的高并发处理的主要逻辑，还有其他小的结构进行辅助，例如：sudog（G队列）、stack（栈信息）等。</p><p>M、P数量：</p><ul><li>P的数量可以在启动时通过环境变量<code>$GOMAXPROCS</code>，或在代码中通过<code>runtime</code>包的<code>GOMAXPROCS()</code>设置。P的数量限制了最大goroutine并发执行数。</li><li>M的数量在启动时会被<code>schedinit()</code>设置成<code>sched.maxmcount = 10000</code>，可在代码中调用<code>runtime/debug</code>包的<code>SetMaxThreads()</code>。M的数量限制了最大可用的系统线程数。</li></ul><p>M、P创建：</p><ul><li>P，在系统确定了P的数量后就会创建指定个数的P</li><li>M，如果P没有M，则会去全局休眠M队列中找，如果还没有则会创建M</li></ul><p>M调度策略：</p><ul><li>work stealing，当M执行G结束后，会从绑定P中获取G，而不是销毁当前M</li><li>hand off，当G调用阻塞系统调用时，M释放绑定的P，将P交给空闲的M</li></ul><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>程序启动第一时间都会调用<code>runtime.main()</code>，进行相关值的初始化。</p><pre><code>// The main goroutine.func main() {    g := getg()    // Racectx of m0-&gt;g0 is used only as the parent of the main goroutine.    // It must not be used for anything else.    g.m.g0.racectx = 0    // Max stack size is 1 GB on 64-bit, 250 MB on 32-bit.    // Using decimal instead of binary GB and MB because    // they look nicer in the stack overflow failure message.    // 设置栈的最大值    if sys.PtrSize == 8 {        maxstacksize = 1000000000    } else {        maxstacksize = 250000000    }    // Allow newproc to start new Ms.    // 允许新P创建M    mainStarted = true    if GOARCH != "wasm" { // no threads on wasm yet, so no sysmon        systemstack(func() {            newm(sysmon, nil, -1)        })    }    // Lock the main goroutine onto this, the main OS thread,    // during initialization. Most programs won't care, but a few    // do require certain calls to be made by the main thread.    // Those can arrange for main.main to run in the main thread    // by calling runtime.LockOSThread during initialization    // to preserve the lock.    lockOSThread()    if g.m != &amp;m0 {        throw("runtime.main not on m0")    }    doInit(&amp;runtime_inittask) // must be before defer    if nanotime() == 0 {        throw("nanotime returning zero")    }    // Defer unlock so that runtime.Goexit during init does the unlock too.    needUnlock := true    defer func() {        if needUnlock {            unlockOSThread()        }    }()    // Record when the world started.    // 记录启动时间    runtimeInitTime = nanotime()    gcenable() // 开启GC    ...    needUnlock = false    unlockOSThread()    if isarchive || islibrary {        // A program compiled with -buildmode=c-archive or c-shared        // has a main, but it is not executed.        return    }    // 执行main包的main函数    fn := main_main // make an indirect call, as the linker doesn't know the address of the main package when laying down the runtime    fn()    if raceenabled {        racefini() // 竞态检测    }    // Make racy client program work: if panicking on    // another goroutine at the same time as main returns,    // let the other goroutine finish printing the panic trace.    // Once it does, it will exit. See issues 3934 and 20018.    // 如果goroutine panic了则创建另一个goroutine打印相关信息，完成之后新建goroutine将退出    if atomic.Load(&amp;runningPanicDefers) != 0 {        // Running deferred functions should not take long.        for c := 0; c &lt; 1000; c++ {            if atomic.Load(&amp;runningPanicDefers) == 0 {                break            }            Gosched()        }    }    if atomic.Load(&amp;panicking) != 0 {        gopark(nil, nil, waitReasonPanicWait, traceEvGoStop, 1)    }    exit(0) // 退出进程    for {        var x *int32        *x = 0    }}</code></pre><p>在程序启动时会创建m0，同时创建g0，在<code>runtime/proc.go</code>声明：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> <span class="token punctuation">(</span>    m0 m    g0 g<span class="token punctuation">)</span></code></pre><blockquote><p>特殊的m0，是启动程序后的编号为0的主线程，这个M对应的实例会在全局变量<code>runtime.m0</code>中，不需要在heap上分配，m0负责执行初始化操作和启动第一个G，在之后M0就和其他的一样了。</p></blockquote><p>初始化P，创建<code>main()</code>的g1，将g1存放于p的本地G队列中，启动m0，m0绑定p，如果绑定不成功就会进入全局休眠M队列等待被唤醒，从p中获取可执行的G，如果没有课执行的G则会进入自旋状态，如果获取到g1，设置g1的运行环境，运行g1，g1退出，m0继续通过p获取G。</p><blockquote><p>自旋状态，是指M绑定的P没有可以执行的G，此时M执行的g0，轮询P的本地空闲G队列有没有可执行的G</p></blockquote><h2 id="三者关系"><a href="#三者关系" class="headerlink" title="三者关系"></a>三者关系</h2><ul><li><p><code>G</code>需要绑定在<code>M</code>上才能运行；</p></li><li><p><code>M</code>需要绑定<code>P</code>才能运行；</p></li><li><p>程序中的多个<code>M</code>并不会同时都处于执行状态，最多只有<code>GOMAXPROCS</code>个<code>M</code>在执行。</p><p>早期版本的Golang是没有<code>P</code>的，调度是由<code>G</code>与<code>M</code>完成。 这样的问题在于每当创建、终止Goroutine或者需要调度时，需要一个全局的锁来保护调度的相关对象(sched)。 全局锁严重影响Goroutine的并发性能。<br>通过引入<code>P</code>，实现了一种叫做<code>work-stealing</code>的调度算法：</p></li><li><p>每个<code>P</code>维护一个<code>G</code>队列；</p></li><li><p>当一个<code>G</code>被创建出来，或者变为可执行状态时，就把他放到<code>P</code>的可执行队列中；</p></li><li><p>当一个<code>G</code>执行结束时，<code>P</code>会从队列中把该<code>G</code>取出；如果此时<code>P</code>的队列为空，即没有其他<code>G</code>可以执行， 就随机选择另外一个<code>P</code>，从其可执行的<code>G</code>队列中偷取一半。</p></li></ul><p>该算法避免了在Goroutine调度时使用全局锁。</p><h1 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h1><h2 id="trace"><a href="#trace" class="headerlink" title="trace"></a>trace</h2><p>代码：</p><pre><code>package mainimport (    "fmt"    "os"    "runtime/trace")func main() {    f, err := os.Create("trace.out")    if err != nil {        panic(err)    }    defer f.Close()    err = trace.Start(f)    if err != nil {        panic(err)    }    defer trace.Stop()    fmt.Println("Hello world!")}</code></pre><p>运行程序会生成一个trace.out的文件，可以通过tool工具将其可视化</p><pre><code>➜ go tool trace trace.out</code></pre><p>这样写会对代码侵入太强，可以写成测试文件，在test的时候生成trace.out文件，在<code>Test()</code>不需要显式的调用上面的代码，代码如下：</p><pre><code>package mainimport (    "fmt"    "testing")func Test(t *testing.T) {    fmt.Println("Hello world!")}</code></pre><p>执行代码</p><pre><code>go test -trace trace.out -run Test</code></pre><p>也可以生成trace.out文件。<br>在有了trace.out文件后，执行<code>go tool trace trace.out</code>，启动http服务可视化查看MPG的相关信息。</p><h2 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h2><p>代码：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Hello world!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>在执行之前设置<code>GODEBUG=schedtrace=10</code>，单位毫秒<br>执行结果</p><pre class=" language-sh"><code class="language-sh">GODEBUG=schedtrace=10 go run main.go SCHED 0ms: gomaxprocs=4 idleprocs=1 threads=6 spinningthreads=1 idlethreads=0 runqueue=0 [1 0 0 0]SCHED 18ms: gomaxprocs=4 idleprocs=0 threads=9 spinningthreads=1 idlethreads=2 runqueue=1 [0 4 0 0]SCHED 30ms: gomaxprocs=4 idleprocs=1 threads=9 spinningthreads=1 idlethreads=2 runqueue=0 [0 0 0 0]SCHED 42ms: gomaxprocs=4 idleprocs=2 threads=9 spinningthreads=0 idlethreads=3 runqueue=1 [0 0 0 0]SCHED 53ms: gomaxprocs=4 idleprocs=4 threads=9 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]SCHED 66ms: gomaxprocs=4 idleprocs=0 threads=9 spinningthreads=1 idlethreads=2 runqueue=1 [0 0 0 0]SCHED 79ms: gomaxprocs=4 idleprocs=3 threads=9 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]</code></pre><ul><li><code>SCHED 0ms</code>：调试信息输出标志字符串，后面是执行的时间戳</li><li><code>gomaxprocs</code>：P的数量，本例有4个P，默认与cpu核心数量一致，可以通过GOMAXPROCS来设置</li><li><code>idleprocs</code>：处于idle状态P的数量</li><li><code>threads</code>：M的数量，包含scheduler使用的M数量，加上runtime自用的类似sysmon这样的thread的数量</li><li><code>spinningthreads</code>: 处于自旋状态M数量</li><li><code>idlethread</code>: 处于idle状态的M的数量</li><li><code>runqueue=0</code>：Scheduler全局队列中G的数量</li><li><code>[0 0 0 0]</code>: 分别为4个的<code>local queue</code>中的G的数量</li></ul><h1 id="关键字段说明"><a href="#关键字段说明" class="headerlink" title="关键字段说明"></a>关键字段说明</h1><h2 id="M"><a href="#M" class="headerlink" title="M"></a>M</h2><pre class=" language-go"><code class="language-go"><span class="token keyword">type</span> m <span class="token keyword">struct</span> <span class="token punctuation">{</span>    g0      <span class="token operator">*</span>g     <span class="token comment" spellcheck="true">// goroutine with scheduling stack</span>    morebuf gobuf  <span class="token comment" spellcheck="true">// gobuf arg to morestack</span>    divmod  <span class="token builtin">uint32</span> <span class="token comment" spellcheck="true">// div/mod denominator for arm - known to liblink</span>    <span class="token comment" spellcheck="true">// Fields not known to debuggers.</span>    procid        <span class="token builtin">uint64</span>       <span class="token comment" spellcheck="true">// for debuggers, but offset not hard-coded</span>    gsignal       <span class="token operator">*</span>g           <span class="token comment" spellcheck="true">// signal-handling g</span>    goSigStack    gsignalStack <span class="token comment" spellcheck="true">// Go-allocated signal handling stack</span>    sigmask       sigset       <span class="token comment" spellcheck="true">// storage for saved signal mask</span>    tls           <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token builtin">uintptr</span>   <span class="token comment" spellcheck="true">// thread-local storage (for x86 extern register)</span>    mstartfn      <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    curg          <span class="token operator">*</span>g       <span class="token comment" spellcheck="true">// 当前执行的G，检测gp</span>    caughtsig     guintptr <span class="token comment" spellcheck="true">// goroutine running during fatal signal</span>    p             puintptr <span class="token comment" spellcheck="true">// 绑定的P执行go代码 (如果没有执行go代码则为nil)</span>    nextp         puintptr    oldp          puintptr <span class="token comment" spellcheck="true">// 执行系统调用之前的P</span>    id            <span class="token builtin">int64</span>    mallocing     <span class="token builtin">int32</span>    throwing      <span class="token builtin">int32</span>    preemptoff    <span class="token builtin">string</span> <span class="token comment" spellcheck="true">// if != "", keep curg running on this m</span>    locks         <span class="token builtin">int32</span>  <span class="token comment" spellcheck="true">// m的引用计数 </span>    dying         <span class="token builtin">int32</span>    profilehz     <span class="token builtin">int32</span>    spinning      <span class="token builtin">bool</span> <span class="token comment" spellcheck="true">// m is out of work and is actively looking for work</span>    blocked       <span class="token builtin">bool</span> <span class="token comment" spellcheck="true">// m is blocked on a note</span>    newSigstack   <span class="token builtin">bool</span> <span class="token comment" spellcheck="true">// minit on C thread called sigaltstack</span>    printlock     <span class="token builtin">int8</span>    incgo         <span class="token builtin">bool</span>   <span class="token comment" spellcheck="true">// m is executing a cgo call</span>    freeWait      <span class="token builtin">uint32</span> <span class="token comment" spellcheck="true">// if == 0, safe to free g0 and delete m (atomic)</span>    fastrand      <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token builtin">uint32</span> <span class="token comment" spellcheck="true">// 两个随机值，不能同时为0</span>    needextram    <span class="token builtin">bool</span>    traceback     <span class="token builtin">uint8</span>    ncgocall      <span class="token builtin">uint64</span>      <span class="token comment" spellcheck="true">// number of cgo calls in total</span>    ncgo          <span class="token builtin">int32</span>       <span class="token comment" spellcheck="true">// number of cgo calls currently in progress</span>    cgoCallersUse <span class="token builtin">uint32</span>      <span class="token comment" spellcheck="true">// if non-zero, cgoCallers in use temporarily</span>    cgoCallers    <span class="token operator">*</span>cgoCallers <span class="token comment" spellcheck="true">// cgo traceback if crashing in cgo call</span>    park          note    alllink       <span class="token operator">*</span>m <span class="token comment" spellcheck="true">// on allm</span>    schedlink     muintptr    <span class="token comment" spellcheck="true">// M的单链表</span>    lockedg       guintptr    <span class="token comment" spellcheck="true">// M锁定的G</span>    createstack   <span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token builtin">uintptr</span> <span class="token comment" spellcheck="true">// stack that created this thread.</span>    lockedExt     <span class="token builtin">uint32</span>      <span class="token comment" spellcheck="true">// tracking for external LockOSThread</span>    lockedInt     <span class="token builtin">uint32</span>      <span class="token comment" spellcheck="true">// tracking for internal lockOSThread</span>    nextwaitm     muintptr    <span class="token comment" spellcheck="true">// next m waiting for lock</span>    waitunlockf   <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token operator">*</span>g<span class="token punctuation">,</span> unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span> <span class="token builtin">bool</span>    waitlock      unsafe<span class="token punctuation">.</span>Pointer    waittraceev   <span class="token builtin">byte</span>    waittraceskip <span class="token builtin">int</span>    startingtrace <span class="token builtin">bool</span>    syscalltick   <span class="token builtin">uint32</span>    freelink      <span class="token operator">*</span>m <span class="token comment" spellcheck="true">// 对应全局休眠M队列</span>    <span class="token comment" spellcheck="true">// these are here because they are too large to be on the stack</span>    <span class="token comment" spellcheck="true">// of low-level NOSPLIT functions.</span>    libcall   libcall    libcallpc <span class="token builtin">uintptr</span> <span class="token comment" spellcheck="true">// for cpu profiler</span>    libcallsp <span class="token builtin">uintptr</span>    libcallg  guintptr    syscall   libcall <span class="token comment" spellcheck="true">// stores syscall parameters on windows</span>    vdsoSP <span class="token builtin">uintptr</span> <span class="token comment" spellcheck="true">// SP for traceback while in VDSO call (0 if not in call)</span>    vdsoPC <span class="token builtin">uintptr</span> <span class="token comment" spellcheck="true">// PC for traceback while in VDSO call</span>    <span class="token comment" spellcheck="true">// preemptGen counts the number of completed preemption</span>    <span class="token comment" spellcheck="true">// signals. This is used to detect when a preemption is</span>    <span class="token comment" spellcheck="true">// requested, but fails. Accessed atomically.</span>    preemptGen <span class="token builtin">uint32</span>    <span class="token comment" spellcheck="true">// Whether this is a pending preemption signal on this M.</span>    <span class="token comment" spellcheck="true">// Accessed atomically.</span>    signalPending <span class="token builtin">uint32</span>    dlogPerM    mOS    <span class="token comment" spellcheck="true">// Up to 10 locks held by this m, maintained by the lock ranking code.</span>    locksHeldLen <span class="token builtin">int</span>    locksHeld    <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span>heldLockInfo<span class="token punctuation">}</span></code></pre><h2 id="P"><a href="#P" class="headerlink" title="P"></a>P</h2><pre class=" language-go"><code class="language-go"><span class="token keyword">type</span> p <span class="token keyword">struct</span> <span class="token punctuation">{</span>    id          <span class="token builtin">int32</span>    status      <span class="token builtin">uint32</span> <span class="token comment" spellcheck="true">// one of pidle/prunning/...</span>    link        puintptr   <span class="token comment" spellcheck="true">// P的单链表</span>    schedtick   <span class="token builtin">uint32</span>     <span class="token comment" spellcheck="true">// incremented on every scheduler call</span>    syscalltick <span class="token builtin">uint32</span>     <span class="token comment" spellcheck="true">// incremented on every system call</span>    sysmontick  sysmontick <span class="token comment" spellcheck="true">// last tick observed by sysmon</span>    m           muintptr   <span class="token comment" spellcheck="true">// 当前的M，如果空闲则为nil</span>    mcache      <span class="token operator">*</span>mcache    pcache      pageCache    raceprocctx <span class="token builtin">uintptr</span>    deferpool    <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>_defer <span class="token comment" spellcheck="true">// pool of available defer structs of different sizes (see panic.go)</span>    deferpoolbuf <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token operator">*</span>_defer    <span class="token comment" spellcheck="true">// Cache of goroutine ids, amortizes accesses to runtime·sched.goidgen.</span>    goidcache    <span class="token builtin">uint64</span>    goidcacheend <span class="token builtin">uint64</span>    <span class="token comment" spellcheck="true">// Queue of runnable goroutines. Accessed without lock.</span>    runqhead <span class="token builtin">uint32</span>         <span class="token comment" spellcheck="true">// 队首下标</span>    runqtail <span class="token builtin">uint32</span>         <span class="token comment" spellcheck="true">// 队尾下标</span>    runq     <span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span>guintptr  <span class="token comment" spellcheck="true">// 可执行队列，最多256个</span>    <span class="token comment" spellcheck="true">// runnext, if non-nil, is a runnable G that was ready'd by</span>    <span class="token comment" spellcheck="true">// the current G and should be run next instead of what's in</span>    <span class="token comment" spellcheck="true">// runq if there's time remaining in the running G's time</span>    <span class="token comment" spellcheck="true">// slice. It will inherit the time left in the current time</span>    <span class="token comment" spellcheck="true">// slice. If a set of goroutines is locked in a</span>    <span class="token comment" spellcheck="true">// communicate-and-wait pattern, this schedules that set as a</span>    <span class="token comment" spellcheck="true">// unit and eliminates the (potentially large) scheduling</span>    <span class="token comment" spellcheck="true">// latency that otherwise arises from adding the ready'd</span>    <span class="token comment" spellcheck="true">// goroutines to the end of the run queue.</span>    runnext guintptr    <span class="token comment" spellcheck="true">// Available G's (status == Gdead)</span>    gFree <span class="token keyword">struct</span> <span class="token punctuation">{</span>        gList        n <span class="token builtin">int32</span>    <span class="token punctuation">}</span>    sudogcache <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>sudog     <span class="token comment" spellcheck="true">// 本地G的队列</span>    sudogbuf   <span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">]</span><span class="token operator">*</span>sudog    <span class="token comment" spellcheck="true">// Cache of mspan objects from the heap.</span>    mspancache <span class="token keyword">struct</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// We need an explicit length here because this field is used</span>        <span class="token comment" spellcheck="true">// in allocation codepaths where write barriers are not allowed,</span>        <span class="token comment" spellcheck="true">// and eliminating the write barrier/keeping it eliminated from</span>        <span class="token comment" spellcheck="true">// slice updates is tricky, moreso than just managing the length</span>        <span class="token comment" spellcheck="true">// ourselves.</span>        <span class="token builtin">len</span> <span class="token builtin">int</span>        buf <span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">]</span><span class="token operator">*</span>mspan    <span class="token punctuation">}</span>    tracebuf traceBufPtr    <span class="token comment" spellcheck="true">// traceSweep indicates the sweep events should be traced.</span>    <span class="token comment" spellcheck="true">// This is used to defer the sweep start event until a span</span>    <span class="token comment" spellcheck="true">// has actually been swept.</span>    traceSweep <span class="token builtin">bool</span>    <span class="token comment" spellcheck="true">// traceSwept and traceReclaimed track the number of bytes</span>    <span class="token comment" spellcheck="true">// swept and reclaimed by sweeping in the current sweep loop.</span>    traceSwept<span class="token punctuation">,</span> traceReclaimed <span class="token builtin">uintptr</span>    palloc persistentAlloc <span class="token comment" spellcheck="true">// per-P to avoid mutex</span>    <span class="token boolean">_</span> <span class="token builtin">uint32</span> <span class="token comment" spellcheck="true">// Alignment for atomic fields below</span>    <span class="token comment" spellcheck="true">// The when field of the first entry on the timer heap.</span>    <span class="token comment" spellcheck="true">// This is updated using atomic functions.</span>    <span class="token comment" spellcheck="true">// This is 0 if the timer heap is empty.</span>    timer0When <span class="token builtin">uint64</span>    <span class="token comment" spellcheck="true">// Per-P GC state</span>    gcAssistTime         <span class="token builtin">int64</span>    <span class="token comment" spellcheck="true">// Nanoseconds in assistAlloc</span>    gcFractionalMarkTime <span class="token builtin">int64</span>    <span class="token comment" spellcheck="true">// Nanoseconds in fractional mark worker (atomic)</span>    gcBgMarkWorker       guintptr <span class="token comment" spellcheck="true">// (atomic)</span>    gcMarkWorkerMode     gcMarkWorkerMode    <span class="token comment" spellcheck="true">// gcMarkWorkerStartTime is the nanotime() at which this mark</span>    <span class="token comment" spellcheck="true">// worker started.</span>    gcMarkWorkerStartTime <span class="token builtin">int64</span>    <span class="token comment" spellcheck="true">// gcw is this P's GC work buffer cache. The work buffer is</span>    <span class="token comment" spellcheck="true">// filled by write barriers, drained by mutator assists, and</span>    <span class="token comment" spellcheck="true">// disposed on certain GC state transitions.</span>    gcw gcWork    <span class="token comment" spellcheck="true">// wbBuf is this P's GC write barrier buffer.</span>    <span class="token comment" spellcheck="true">//</span>    <span class="token comment" spellcheck="true">// TODO: Consider caching this in the running G.</span>    wbBuf wbBuf    runSafePointFn <span class="token builtin">uint32</span> <span class="token comment" spellcheck="true">// if 1, run sched.safePointFn at next safe point</span>    <span class="token comment" spellcheck="true">// Lock for timers. We normally access the timers while running</span>    <span class="token comment" spellcheck="true">// on this P, but the scheduler can also do it from a different P.</span>    timersLock mutex    <span class="token comment" spellcheck="true">// Actions to take at some time. This is used to implement the</span>    <span class="token comment" spellcheck="true">// standard library's time package.</span>    <span class="token comment" spellcheck="true">// Must hold timersLock to access.</span>    timers <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>timer    <span class="token comment" spellcheck="true">// Number of timers in P's heap.</span>    <span class="token comment" spellcheck="true">// Modified using atomic instructions.</span>    numTimers <span class="token builtin">uint32</span>    <span class="token comment" spellcheck="true">// Number of timerModifiedEarlier timers on P's heap.</span>    <span class="token comment" spellcheck="true">// This should only be modified while holding timersLock,</span>    <span class="token comment" spellcheck="true">// or while the timer status is in a transient state</span>    <span class="token comment" spellcheck="true">// such as timerModifying.</span>    adjustTimers <span class="token builtin">uint32</span>    <span class="token comment" spellcheck="true">// Number of timerDeleted timers in P's heap.</span>    <span class="token comment" spellcheck="true">// Modified using atomic instructions.</span>    deletedTimers <span class="token builtin">uint32</span>    <span class="token comment" spellcheck="true">// Race context used while executing timer functions.</span>    timerRaceCtx <span class="token builtin">uintptr</span>    <span class="token comment" spellcheck="true">// preempt is set to indicate that this P should be enter the</span>    <span class="token comment" spellcheck="true">// scheduler ASAP (regardless of what G is running on it).</span>    preempt <span class="token builtin">bool</span>    pad cpu<span class="token punctuation">.</span>CacheLinePad<span class="token punctuation">}</span></code></pre><h2 id="G"><a href="#G" class="headerlink" title="G"></a>G</h2><pre class=" language-go"><code class="language-go"><span class="token keyword">type</span> g <span class="token keyword">struct</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Stack parameters.</span>    <span class="token comment" spellcheck="true">// stack describes the actual stack memory: [stack.lo, stack.hi).</span>    <span class="token comment" spellcheck="true">// stackguard0 is the stack pointer compared in the Go stack growth prologue.</span>    <span class="token comment" spellcheck="true">// It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption.</span>    <span class="token comment" spellcheck="true">// stackguard1 is the stack pointer compared in the C stack growth prologue.</span>    <span class="token comment" spellcheck="true">// It is stack.lo+StackGuard on g0 and gsignal stacks.</span>    <span class="token comment" spellcheck="true">// It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash).</span>    stack       stack   <span class="token comment" spellcheck="true">// offset known to runtime/cgo</span>    stackguard0 <span class="token builtin">uintptr</span> <span class="token comment" spellcheck="true">// offset known to liblink</span>    stackguard1 <span class="token builtin">uintptr</span> <span class="token comment" spellcheck="true">// offset known to liblink</span>    _panic       <span class="token operator">*</span>_panic <span class="token comment" spellcheck="true">// innermost panic - offset known to liblink</span>    _defer       <span class="token operator">*</span>_defer <span class="token comment" spellcheck="true">// innermost defer</span>    m            <span class="token operator">*</span>m      <span class="token comment" spellcheck="true">// 当前M；offset known to arm liblink</span>    sched        gobuf    syscallsp    <span class="token builtin">uintptr</span>        <span class="token comment" spellcheck="true">// if status==Gsyscall, syscallsp = sched.sp to use during gc</span>    syscallpc    <span class="token builtin">uintptr</span>        <span class="token comment" spellcheck="true">// if status==Gsyscall, syscallpc = sched.pc to use during gc</span>    stktopsp     <span class="token builtin">uintptr</span>        <span class="token comment" spellcheck="true">// expected sp at top of stack, to check in traceback</span>    param        unsafe<span class="token punctuation">.</span>Pointer <span class="token comment" spellcheck="true">// passed parameter on wakeup</span>    atomicstatus <span class="token builtin">uint32</span>     <span class="token comment" spellcheck="true">// G的状态</span>    stackLock    <span class="token builtin">uint32</span>     <span class="token comment" spellcheck="true">// sigprof/scang lock; TODO: fold in to atomicstatus</span>    goid         <span class="token builtin">int64</span>      <span class="token comment" spellcheck="true">// goroutine id</span>    schedlink    guintptr   <span class="token comment" spellcheck="true">// 下一个G的地址</span>    waitsince    <span class="token builtin">int64</span>      <span class="token comment" spellcheck="true">// approx time when the g become blocked</span>    waitreason   waitReason <span class="token comment" spellcheck="true">// if status==Gwaiting</span>    preempt       <span class="token builtin">bool</span> <span class="token comment" spellcheck="true">// preemption signal, duplicates stackguard0 = stackpreempt</span>    preemptStop   <span class="token builtin">bool</span> <span class="token comment" spellcheck="true">// transition to _Gpreempted on preemption; otherwise, just deschedule</span>    preemptShrink <span class="token builtin">bool</span> <span class="token comment" spellcheck="true">// shrink stack at synchronous safe point</span>    <span class="token comment" spellcheck="true">// asyncSafePoint is set if g is stopped at an asynchronous</span>    <span class="token comment" spellcheck="true">// safe point. This means there are frames on the stack</span>    <span class="token comment" spellcheck="true">// without precise pointer information.</span>    asyncSafePoint <span class="token builtin">bool</span>    paniconfault <span class="token builtin">bool</span> <span class="token comment" spellcheck="true">// panic (instead of crash) on unexpected fault address</span>    gcscandone   <span class="token builtin">bool</span> <span class="token comment" spellcheck="true">// g has scanned stack; protected by _Gscan bit in status</span>    throwsplit   <span class="token builtin">bool</span> <span class="token comment" spellcheck="true">// must not split stack</span>    <span class="token comment" spellcheck="true">// activeStackChans indicates that there are unlocked channels</span>    <span class="token comment" spellcheck="true">// pointing into this goroutine's stack. If true, stack</span>    <span class="token comment" spellcheck="true">// copying needs to acquire channel locks to protect these</span>    <span class="token comment" spellcheck="true">// areas of the stack.</span>    activeStackChans <span class="token builtin">bool</span>    raceignore     <span class="token builtin">int8</span>     <span class="token comment" spellcheck="true">// ignore race detection events</span>    sysblocktraced <span class="token builtin">bool</span>     <span class="token comment" spellcheck="true">// StartTrace has emitted EvGoInSyscall about this goroutine</span>    sysexitticks   <span class="token builtin">int64</span>    <span class="token comment" spellcheck="true">// cputicks when syscall has returned (for tracing)</span>    traceseq       <span class="token builtin">uint64</span>   <span class="token comment" spellcheck="true">// trace event sequencer</span>    tracelastp     puintptr <span class="token comment" spellcheck="true">// last P emitted an event for this goroutine</span>    lockedm        muintptr    sig            <span class="token builtin">uint32</span>    writebuf       <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span>    sigcode0       <span class="token builtin">uintptr</span>    sigcode1       <span class="token builtin">uintptr</span>    sigpc          <span class="token builtin">uintptr</span>    gopc           <span class="token builtin">uintptr</span>         <span class="token comment" spellcheck="true">// pc of go statement that created this goroutine</span>    ancestors      <span class="token operator">*</span><span class="token punctuation">[</span><span class="token punctuation">]</span>ancestorInfo <span class="token comment" spellcheck="true">// ancestor information goroutine(s) that created this goroutine (only used if debug.tracebackancestors)</span>    startpc        <span class="token builtin">uintptr</span>         <span class="token comment" spellcheck="true">// pc of goroutine function</span>    racectx        <span class="token builtin">uintptr</span>    waiting        <span class="token operator">*</span>sudog         <span class="token comment" spellcheck="true">// sudog structures this g is waiting on (that have a valid elem ptr); in lock order</span>    cgoCtxt        <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">uintptr</span>      <span class="token comment" spellcheck="true">// cgo traceback context</span>    labels         unsafe<span class="token punctuation">.</span>Pointer <span class="token comment" spellcheck="true">// profiler labels</span>    timer          <span class="token operator">*</span>timer         <span class="token comment" spellcheck="true">// cached timer for time.Sleep</span>    selectDone     <span class="token builtin">uint32</span>         <span class="token comment" spellcheck="true">// are we participating in a select and did someone win the race?</span>    <span class="token comment" spellcheck="true">// Per-G GC state</span>    <span class="token comment" spellcheck="true">// gcAssistBytes is this G's GC assist credit in terms of</span>    <span class="token comment" spellcheck="true">// bytes allocated. If this is positive, then the G has credit</span>    <span class="token comment" spellcheck="true">// to allocate gcAssistBytes bytes without assisting. If this</span>    <span class="token comment" spellcheck="true">// is negative, then the G must correct this by performing</span>    <span class="token comment" spellcheck="true">// scan work. We track this in bytes to make it fast to update</span>    <span class="token comment" spellcheck="true">// and check for debt in the malloc hot path. The assist ratio</span>    <span class="token comment" spellcheck="true">// determines how this corresponds to scan work debt.</span>    gcAssistBytes <span class="token builtin">int64</span><span class="token punctuation">}</span></code></pre><h2 id="Sched"><a href="#Sched" class="headerlink" title="Sched"></a>Sched</h2><pre class=" language-go"><code class="language-go"><span class="token keyword">type</span> schedt <span class="token keyword">struct</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// accessed atomically. keep at top to ensure alignment on 32-bit systems.</span>    goidgen   <span class="token builtin">uint64</span>    lastpoll  <span class="token builtin">uint64</span> <span class="token comment" spellcheck="true">// time of last network poll, 0 if currently polling</span>    pollUntil <span class="token builtin">uint64</span> <span class="token comment" spellcheck="true">// time to which current poll is sleeping</span>    lock mutex <span class="token comment" spellcheck="true">// 操作锁，锁定schedt</span>    <span class="token comment" spellcheck="true">// When increasing nmidle, nmidlelocked, nmsys, or nmfreed, be</span>    <span class="token comment" spellcheck="true">// sure to call checkdead().</span>    midle        muintptr <span class="token comment" spellcheck="true">// 空闲M单链表</span>    nmidle       <span class="token builtin">int32</span>    <span class="token comment" spellcheck="true">// 空闲M的个数</span>    nmidlelocked <span class="token builtin">int32</span>    <span class="token comment" spellcheck="true">// number of locked m's waiting for work</span>    mnext        <span class="token builtin">int64</span>    <span class="token comment" spellcheck="true">// number of m's that have been created and next M ID</span>    maxmcount    <span class="token builtin">int32</span>    <span class="token comment" spellcheck="true">// maximum number of m's allowed (or die)</span>    nmsys        <span class="token builtin">int32</span>    <span class="token comment" spellcheck="true">// number of system m's not counted for deadlock</span>    nmfreed      <span class="token builtin">int64</span>    <span class="token comment" spellcheck="true">// cumulative number of freed m's</span>    ngsys <span class="token builtin">uint32</span> <span class="token comment" spellcheck="true">// number of system goroutines; updated atomically</span>    pidle      puintptr <span class="token comment" spellcheck="true">// 空闲的P</span>    npidle     <span class="token builtin">uint32</span>    nmspinning <span class="token builtin">uint32</span> <span class="token comment" spellcheck="true">// See "Worker thread parking/unparking" comment in proc.go.</span>    <span class="token comment" spellcheck="true">// Global runnable queue.</span>    runq     gQueue  <span class="token comment" spellcheck="true">// 全局可执行队列</span>    runqsize <span class="token builtin">int32</span>   <span class="token comment" spellcheck="true">// 全局队列大小</span>    <span class="token comment" spellcheck="true">// disable控制有选择的禁用调度</span>    <span class="token comment" spellcheck="true">//</span>    <span class="token comment" spellcheck="true">// 使用schedEnableUser(enable bool)进行控制</span>    <span class="token comment" spellcheck="true">//</span>    <span class="token comment" spellcheck="true">// disable需要被sched.lock保护</span>    disable <span class="token keyword">struct</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// user是否禁止调度goroutines.</span>        user     <span class="token builtin">bool</span>        runnable gQueue <span class="token comment" spellcheck="true">// pending runnable Gs</span>        n        <span class="token builtin">int32</span>  <span class="token comment" spellcheck="true">// length of runnable</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Global cache of dead G's.</span>    gFree <span class="token keyword">struct</span> <span class="token punctuation">{</span>        lock    mutex        stack   gList <span class="token comment" spellcheck="true">// Gs with stacks</span>        noStack gList <span class="token comment" spellcheck="true">// Gs without stacks</span>        n       <span class="token builtin">int32</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Central cache of sudog structs.</span>    sudoglock  mutex  <span class="token comment" spellcheck="true">// 全局空闲G队列锁</span>    sudogcache <span class="token operator">*</span>sudog <span class="token comment" spellcheck="true">// 全局空闲G队列</span>    <span class="token comment" spellcheck="true">// Central pool of available defer structs of different sizes.</span>    deferlock mutex    deferpool <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">*</span>_defer    <span class="token comment" spellcheck="true">// freem is the list of m's waiting to be freed when their</span>    <span class="token comment" spellcheck="true">// m.exited is set. Linked through m.freelink.</span>    freem <span class="token operator">*</span>m <span class="token comment" spellcheck="true">// 全局休眠M队列</span>    gcwaiting  <span class="token builtin">uint32</span> <span class="token comment" spellcheck="true">// gc is waiting to run</span>    stopwait   <span class="token builtin">int32</span>    stopnote   note    sysmonwait <span class="token builtin">uint32</span>    sysmonnote note    <span class="token comment" spellcheck="true">// safepointFn should be called on each P at the next GC</span>    <span class="token comment" spellcheck="true">// safepoint if p.runSafePointFn is set.</span>    safePointFn   <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span>    safePointWait <span class="token builtin">int32</span>    safePointNote note    profilehz <span class="token builtin">int32</span> <span class="token comment" spellcheck="true">// cpu profiling rate</span>    procresizetime <span class="token builtin">int64</span> <span class="token comment" spellcheck="true">// nanotime() of last change to gomaxprocs</span>    totaltime      <span class="token builtin">int64</span> <span class="token comment" spellcheck="true">// ∫gomaxprocs dt up to procresizetime</span>    <span class="token comment" spellcheck="true">// sysmonlock protects sysmon's actions on the runtime.</span>    <span class="token comment" spellcheck="true">//</span>    <span class="token comment" spellcheck="true">// Acquire and hold this mutex to block sysmon from interacting</span>    <span class="token comment" spellcheck="true">// with the rest of the runtime.</span>    sysmonlock mutex<span class="token punctuation">}</span></code></pre><h1 id="字段和结构体"><a href="#字段和结构体" class="headerlink" title="字段和结构体"></a>字段和结构体</h1><h2 id="G状态"><a href="#G状态" class="headerlink" title="G状态"></a>G状态</h2><pre class=" language-go"><code class="language-go"><span class="token keyword">const</span> <span class="token punctuation">(</span>    <span class="token comment" spellcheck="true">// G status</span>    <span class="token comment" spellcheck="true">//</span>    <span class="token comment" spellcheck="true">// 除了指示G的一般状态外，G状态还像goroutine堆栈上的锁一样（因此具有执行用户代码的能力）。</span>    <span class="token comment" spellcheck="true">// _Gidle表示此goroutine已分配，尚未初始化。</span>    _Gidle <span class="token operator">=</span> <span class="token boolean">iota</span> <span class="token comment" spellcheck="true">// 0</span>    <span class="token comment" spellcheck="true">// _Grunnable表示此goroutine在运行队列中，当前未执行用户代码，没有堆栈。</span>    _Grunnable <span class="token comment" spellcheck="true">// 1</span>    <span class="token comment" spellcheck="true">// _Grunning表示此goroutine可以执行用户代码。</span>    <span class="token comment" spellcheck="true">// 该goroutine拥有堆栈，且不在运行队列中。</span>    <span class="token comment" spellcheck="true">// 它已分配一个M和一个P。</span>    _Grunning <span class="token comment" spellcheck="true">// 2</span>    <span class="token comment" spellcheck="true">// _Gsyscall表示此goroutine正在执行系统调用。</span>    <span class="token comment" spellcheck="true">// 它不执行用户代码，堆栈由该goroutine拥有，它不在运行队列中。</span>    <span class="token comment" spellcheck="true">// 它被分配了一个M。</span>    _Gsyscall <span class="token comment" spellcheck="true">// 3</span>    <span class="token comment" spellcheck="true">// _Gwaiting 意味着goroutine被runtime阻止。</span>    <span class="token comment" spellcheck="true">// 它不执行用户代码，它也不再运行队列，但应该被记录下来（例如：等待chan中的数据），必要时可以调用ready()恢复。</span>    <span class="token comment" spellcheck="true">// 除chan操作可以在适当的锁下读取或写入堆栈的某些部分外，不应该拥有该堆栈。</span>    _Gwaiting <span class="token comment" spellcheck="true">// 4</span>    <span class="token comment" spellcheck="true">// _Gmoribund_unused当前未使用，但已在gdb脚本中进行了硬编码。</span>    _Gmoribund_unused <span class="token comment" spellcheck="true">// 5</span>    <span class="token comment" spellcheck="true">// _Gdead表示此goroutine当前未使用。</span>    <span class="token comment" spellcheck="true">// 它有可能已退出，在空闲列表或刚被初始化。它不能执行用户代码。它可能拥有堆栈也可能不拥有堆栈。</span>    <span class="token comment" spellcheck="true">// G及其堆栈（如果有）由退出G或从空闲列表中获得G的M拥有。</span>    _Gdead <span class="token comment" spellcheck="true">// 6</span>    <span class="token comment" spellcheck="true">// _Genqueue_unused当前未使用。</span>    _Genqueue_unused <span class="token comment" spellcheck="true">// 7</span>    <span class="token comment" spellcheck="true">// _Gcopystack表示此goroutine的堆栈正在迁移。</span>    <span class="token comment" spellcheck="true">// 它不能执行用户代码，并且不再运行队列中。</span>    <span class="token comment" spellcheck="true">// 堆栈由将其放入_Gcopystack的goroutine拥有。</span>    _Gcopystack <span class="token comment" spellcheck="true">// 8</span>    <span class="token comment" spellcheck="true">// _Gscan与上述状态之一组合表示GC正在扫描堆栈（除_Grunning）。</span>    <span class="token comment" spellcheck="true">// goroutine未执行用户代码，并且堆栈由设置_Gscan位的goroutine拥有。</span>    <span class="token comment" spellcheck="true">// _Gscanrunning不同: 它用于短暂阻止状态转换，而GC则通知G扫描其自身的堆栈。否则就像_Grunning。</span>    <span class="token comment" spellcheck="true">// atomicstatus&amp;~Gscan 给出goroutine将在扫描完成时返回的状态。</span>    _Gscan         <span class="token operator">=</span> <span class="token number">0x1000</span>    _Gscanrunnable <span class="token operator">=</span> _Gscan <span class="token operator">+</span> _Grunnable <span class="token comment" spellcheck="true">// 0x1001</span>    _Gscanrunning  <span class="token operator">=</span> _Gscan <span class="token operator">+</span> _Grunning  <span class="token comment" spellcheck="true">// 0x1002</span>    _Gscansyscall  <span class="token operator">=</span> _Gscan <span class="token operator">+</span> _Gsyscall  <span class="token comment" spellcheck="true">// 0x1003</span>    _Gscanwaiting  <span class="token operator">=</span> _Gscan <span class="token operator">+</span> _Gwaiting  <span class="token comment" spellcheck="true">// 0x1004</span><span class="token punctuation">)</span></code></pre><h2 id="P状态"><a href="#P状态" class="headerlink" title="P状态"></a>P状态</h2><pre class=" language-go"><code class="language-go"><span class="token keyword">const</span> <span class="token punctuation">(</span>    <span class="token comment" spellcheck="true">// P status</span>    <span class="token comment" spellcheck="true">// _Pidle表示不使用P来运行用户代码或调度程序。</span>    <span class="token comment" spellcheck="true">// 它在空闲的P列表中，可供调度程序使用，但可能只是在其他状态之间转换。</span>    <span class="token comment" spellcheck="true">//</span>    <span class="token comment" spellcheck="true">// P由空闲列表或转换其状态的任何内容所拥有。它的运行队列为空。</span>    _Pidle <span class="token operator">=</span> <span class="token boolean">iota</span>    <span class="token comment" spellcheck="true">// _Prunning表示P由M拥有，并用于运行用户代码或调度程序。</span>    <span class="token comment" spellcheck="true">// 仅拥有此P的M允许从_Prunning更改P的状态。</span>    <span class="token comment" spellcheck="true">// M可以将P转换为_Pidle（如果没有更多工作要做），_Psyscall（进入系统调用时）或_Pgcstop（以停止GC）。</span>    <span class="token comment" spellcheck="true">// M也可以将P的所有权直接移交给另一个M（例如，调度锁定的G）。</span>    _Prunning    <span class="token comment" spellcheck="true">// _Psyscall表示P没有运行用户代码。</span>    <span class="token comment" spellcheck="true">// 它与系统调用中的M有亲缘关系，但不归其所有，并且可能被另一个M窃取。</span>    <span class="token comment" spellcheck="true">// 这类似于_Pidle，但使用轻量级转换并保持M相似性。</span>    <span class="token comment" spellcheck="true">//</span>    <span class="token comment" spellcheck="true">// 必须通过CAS离开_Psyscall才能窃取或重新获得P。</span>    <span class="token comment" spellcheck="true">// 注意ABA危害：</span>    <span class="token comment" spellcheck="true">// 即使M在系统调用后成功将其原始P恢复为_Prunning，它也必须了解该P在此期间可能已被另一个M使用。</span>    _Psyscall    <span class="token comment" spellcheck="true">// _Pgcstop表示对STW(stop the world)暂停P并由STW的M拥有。</span>    <span class="token comment" spellcheck="true">// STW的M甚至在_Pgcstop中也继续使用其P。</span>    <span class="token comment" spellcheck="true">// 从_Prunning过渡到_Pgcstop会导致M释放其P并停放。</span>    <span class="token comment" spellcheck="true">//</span>    <span class="token comment" spellcheck="true">// P保留其运行队列，STW将使用非空运行队列在P上重新启动调度程序。</span>    _Pgcstop    <span class="token comment" spellcheck="true">// _Pdead表示不再使用P（GOMAXPROCS缩小），如果P的数量增加将会复用P。</span>    <span class="token comment" spellcheck="true">// 一个死掉的P大部分被剥夺了其资源，尽管还剩下一些东西（例如跟踪缓冲区）。</span>    _Pdead<span class="token punctuation">)</span></code></pre><h2 id="runtime2-go-全局变量"><a href="#runtime2-go-全局变量" class="headerlink" title="runtime2.go 全局变量"></a>runtime2.go 全局变量</h2><pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> <span class="token punctuation">(</span>    allglen    <span class="token builtin">uintptr</span> <span class="token comment" spellcheck="true">// allgs的长度</span>    allm       <span class="token operator">*</span>m      <span class="token comment" spellcheck="true">// 所有m的单链表</span>    allp       <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>p    <span class="token comment" spellcheck="true">// 所有的P列表，len(allp) == gomaxprocs，只能通过GOMAXPROCS()修改</span>    allpLock   mutex   <span class="token comment" spellcheck="true">// Protects P-less reads of allp and all writes</span>    gomaxprocs <span class="token builtin">int32</span>         <span class="token comment" spellcheck="true">// 最大P的数量</span>    ncpu       <span class="token builtin">int32</span>         <span class="token comment" spellcheck="true">// CPU数</span>    forcegc    forcegcstate    sched      schedt        <span class="token comment" spellcheck="true">// 调度者</span>    newprocs   <span class="token builtin">int32</span>    <span class="token comment" spellcheck="true">// Information about what cpu features are available.</span>    <span class="token comment" spellcheck="true">// Packages outside the runtime should not use these</span>    <span class="token comment" spellcheck="true">// as they are not an external api.</span>    <span class="token comment" spellcheck="true">// Set on startup in asm_{386,amd64}.s</span>    processorVersionInfo <span class="token builtin">uint32</span>    isIntel              <span class="token builtin">bool</span>    lfenceBeforeRdtsc    <span class="token builtin">bool</span>    goarm                <span class="token builtin">uint8</span> <span class="token comment" spellcheck="true">// set by cmd/link on arm systems</span>    framepointer_enabled <span class="token builtin">bool</span>  <span class="token comment" spellcheck="true">// set by cmd/link</span><span class="token punctuation">)</span><span class="token keyword">var</span> <span class="token punctuation">(</span>    allgs    <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>g  <span class="token comment" spellcheck="true">// 所有g的单链表</span>    allglock mutex <span class="token comment" spellcheck="true">// 修改单链表锁</span><span class="token punctuation">)</span></code></pre><h2 id="sodug"><a href="#sodug" class="headerlink" title="sodug"></a>sodug</h2><pre><code>type hchan struct {    qcount   uint           // 队列元素总数    dataqsiz uint           // 循环队列的大小    buf      unsafe.Pointer // 指向dataqsiz元素数组    elemsize uint16    closed   uint32    elemtype *_type // element type    sendx    uint   // send index    recvx    uint   // receive index    recvq    waitq  // list of recv waiters    sendq    waitq  // list of send waiters    // lock保护hchan的所有字段，也保护sudog的所有字段在这个channel。    //    // 锁住此锁时，请勿更改另一个G的状态（特别是不要对G调用ready），因为这会因堆栈收缩而死锁。    lock mutex}type waitq struct {    first *sudog    last  *sudog}// sudog 表示可执行G的列表，一个G可能在多个sudog中，// 并且许多G可能正在等待同一个同步对象，因此一个对象可能有许多sudog。// // sudog 由特殊的池分配，所以只能通过acquireSudog和releaseSudog来分配和释放sudog。type sudog struct {    // 由hchan.lock来保护以下字段，收缩栈依赖sudog的操作    g *g    next *sudog    prev *sudog    elem unsafe.Pointer // data element (may point to stack)    // 以下字段永远不能同时访问    // 对于channel，waitlink仅由g访问。    // 对于信号量，仅在持有semaRoot锁时才能访问所有字段（包括上述字段）。    acquiretime int64    releasetime int64    ticket      uint32    // isSelect表示g正在参与选择，因此必须对g.selectDone进行CAS操作才能wake-up竞争。    isSelect bool    parent   *sudog // semaRoot binary tree    waitlink *sudog // g.waiting list or semaRoot    waittail *sudog // semaRoot    c        *hchan // channel，引用chan的底层实现}</code></pre><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://learnku.com/articles/41728" target="_blank" rel="noopener">[典藏版] Golang 调度器 GMP 原理与调度全分析</a></li><li><a href="http://ga0.github.io/golang/2015/09/20/golang-runtime-scheduler.html" target="_blank" rel="noopener">Golang调度器源码分析</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mpg </tag>
            
            <tag> infra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wireshark解析自定义协议</title>
      <link href="/wireshark/wireshark-jie-xi-zi-ding-yi-xie-yi.html"/>
      <url>/wireshark/wireshark-jie-xi-zi-ding-yi-xie-yi.html</url>
      
        <content type="html"><![CDATA[<h1 id="lua脚本"><a href="#lua脚本" class="headerlink" title="lua脚本"></a>lua脚本</h1><p>wireshark插件有代码固定的格式</p><pre class=" language-lua"><code class="language-lua"><span class="token keyword">do</span>    <span class="token comment" spellcheck="true">-- 定义协议</span>    <span class="token keyword">local</span> PROTO <span class="token operator">=</span> <span class="token function">Proto</span><span class="token punctuation">(</span><span class="token string">'proto'</span><span class="token punctuation">,</span> <span class="token string">'Proto'</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">-- 定义协议字段</span>    <span class="token keyword">local</span> field <span class="token operator">=</span> ProtoField<span class="token punctuation">.</span><span class="token function">char</span><span class="token punctuation">(</span><span class="token string">"field"</span><span class="token punctuation">,</span> <span class="token string">"proto field"</span><span class="token punctuation">,</span> base<span class="token punctuation">.</span>NONE<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">-- 协议绑定字段</span>    PROTO<span class="token punctuation">.</span>fields <span class="token operator">=</span> <span class="token punctuation">{</span>        field<span class="token punctuation">,</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">-- 获取源数据</span>    <span class="token keyword">local</span> data_dis <span class="token operator">=</span> Dissector<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"data"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">-- 协议解剖函数</span>    <span class="token keyword">local</span> <span class="token keyword">function</span> <span class="token function">proto_dissector</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> pinfo<span class="token punctuation">,</span> root<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">-- 自定义协议dissector</span>    <span class="token keyword">end</span>    <span class="token comment" spellcheck="true">-- 让wireshark调用的解剖函数</span>    <span class="token keyword">function</span> PROTO<span class="token punctuation">.</span><span class="token function">dissector</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> pinfo<span class="token punctuation">,</span> root<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token function">proto_dissector</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> pinfo<span class="token punctuation">,</span> root<span class="token punctuation">)</span> <span class="token keyword">then</span>            <span class="token comment" spellcheck="true">-- 自定义解剖函数执行成功</span>        <span class="token keyword">else</span>            <span class="token comment" spellcheck="true">-- 自定义解剖函数执行失败，让其他底层协议解剖</span>            data_dis<span class="token punctuation">:</span><span class="token function">call</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> pinfo<span class="token punctuation">,</span> root<span class="token punctuation">)</span>        <span class="token keyword">end</span>    <span class="token keyword">end</span>    <span class="token comment" spellcheck="true">-- 监听端口</span>    <span class="token keyword">local</span> listen_port <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token number">8000</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">-- 获取tcp.port的解剖器</span>    <span class="token keyword">local</span> dissectors <span class="token operator">=</span> DissectorTable<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'tcp.port'</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> _<span class="token punctuation">,</span> port <span class="token keyword">in</span> <span class="token function">ipairs</span><span class="token punctuation">(</span>listen_port<span class="token punctuation">)</span> <span class="token keyword">do</span>        <span class="token comment" spellcheck="true">-- 将自定义协议绑定到指定端口的解剖器</span>        dissectors<span class="token punctuation">:</span><span class="token function">add</span><span class="token punctuation">(</span>port<span class="token punctuation">,</span> PROTO<span class="token punctuation">)</span>    <span class="token keyword">end</span><span class="token keyword">end</span></code></pre><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>参考<a href="https://github.com/jzwinck/redis-wireshark" target="_blank" rel="noopener">https://github.com/jzwinck/redis-wireshark</a><br>自己实现了一个<a href="https://github.com/djaigoo/wireshark-redis" target="_blank" rel="noopener">wireshark-redis</a></p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://www.wireshark.org/docs/wsdg_html_chunked/wsluarm_modules.html" target="_blank" rel="noopener">Chapter 11. Wireshark’s Lua API Reference Manual</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> wireshark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务注册与发现</title>
      <link href="/service-discovery/fu-wu-zhu-ce-yu-fa-xian.html"/>
      <url>/service-discovery/fu-wu-zhu-ce-yu-fa-xian.html</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>聊起微服务的服务注册与发现，很多人立马就会脱口而出 zk、etcd、consul、eureka 这些组件，进而聊到 CAP 如何取舍，性能如何，高可用和容灾是怎么实现的。</p><p>在这之前，站在组件使用者的角度，我想先问这么几个问题：</p><ul><li><p>注册的 IP 和端口怎么确定 ？</p></li><li><p>实现服务治理还需要注册哪些信息 ？</p></li><li><p>如何进行优雅的服务注册与服务下线 ？</p></li><li><p>注册服务的健康检查是如何做的 ？</p></li><li><p>当服务有节点退出或新的节点加入时，订阅者能不能及时收到通知 ?</p></li><li><p>我能方便地查看某个应用发布和订阅了哪些服务，以及所订阅的服务有哪些节点吗 ？</p></li></ul><p>看完这些问题后，您也许会发现，对于服务注册与发现，首先应该关注的是服务注册发现本身的功能，然后才是性能和高可用。</p><p>一个好的服务注册发现中间件，应该是能完整地满足服务开发和治理的基础功能，然后才是性能和高可用。如果没有想清楚前面的功能，再高的可用性和性能都是浮云。最后，安全也同样重要。</p><ul><li><p>服务端的性能如何 ？</p></li><li><p>服务发现的容灾策略是怎样的 ？</p></li><li><p>当我的应用和服务发现中心的网络连接出现问题时，会对我的调用产生什么影响 ？</p></li><li><p>服务注册中心某台机器宕机或者全部宕机时，会对我的调用产生什么影响 ？</p></li><li><p>服务注册和发现的链路安全吗，有没有做好权限控制 ？</p></li></ul><p>下面将从 服务注册、服务发现、容灾和高可用三个大方面来回答这些问题的主流做法。</p><p>最后会介绍一下 ANS(Alibaba Naming Service) ， ANS 综合了这些解决方案中的优点，并在 EDAS(阿里巴巴企业级分布式应用服务) 中输出，目前完全免费！</p><h1 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h1><h2 id="注册的-IP-和端口怎么确定-？"><a href="#注册的-IP-和端口怎么确定-？" class="headerlink" title="注册的 IP 和端口怎么确定 ？"></a>注册的 IP 和端口怎么确定 ？</h2><h3 id="IP-如何确定"><a href="#IP-如何确定" class="headerlink" title="IP 如何确定"></a>IP 如何确定</h3><p>主流的 IP 获取有这几种方法。</p><ul><li><p>最简单粗暴的方式，手动配置需要注册的IP。当然这种方式基本无法在生产环境使用，因为微服务基本都是支持水平扩容多机部署的，在配置中写死 IP 地址的方式无法支持一份代码水平扩容，会给运维带来极大的成本。</p></li><li><p>通过遍历网卡的方式去获取，找到第一个不为本地环回地址的 IP 地址。绝大多数情况下，这个方式比较好用，dubbo 等框架采用的就是这种方法。</p></li><li><p>在一些网络规划比较好的标准化机房中，我们还可以通过手动指定网卡名，即 interfaceName 的方式来指定使用哪一块网卡所对应的 IP 地址进行注册。</p></li><li><p>当上述三种方式都不能有效解决问题的时候，有一个方法就是直接与服务注册中心建立 socket 连接，然后通过<code>socket.getLocalAddress()</code> 这种方式来获取本机的 IP。</p></li></ul><h3 id="端口如何确定"><a href="#端口如何确定" class="headerlink" title="端口如何确定"></a>端口如何确定</h3><p>端口的获取，没有标准化的方案。</p><ul><li><p>如果是 RPC 应用，启动的时候都有一个配置来指定服务监听的端口， 注册的时候直接使用配置项的端口值。</p></li><li><p>传统的 WEB 容器所提供的 HTTP 的应用，同样也存在一个配置文件来配置容器的监听端口，注册时候直接使用配置项的端口值。</p></li><li><p>特别的，在 Java 应用的 Spring Boot 框架中，可以通过 <code>EmbeddedServletContainerInitializedEvent. getEmbeddedServletContainer().getPort()</code>来获取。(Spring Boot 版本为 1.x)。</p></li></ul><h2 id="实现服务治理还需要注册哪些信息-？"><a href="#实现服务治理还需要注册哪些信息-？" class="headerlink" title="实现服务治理还需要注册哪些信息 ？"></a>实现服务治理还需要注册哪些信息 ？</h2><p>简单地将 IP 和 port 信息注册上去，可以满足基本的服务调用的需求，但是在业务发展到一定程度的时候，我们还会有这些需求：</p><ul><li><p>想知道某个 HTTP 服务是否开启了 TLS。</p></li><li><p>对相同服务下的不同节点设置不同的权重，进行流量调度。</p></li><li><p>将服务分成预发环境和生产环境，方便进行AB Test功能。</p></li><li><p>不同机房的服务注册时加上机房的标签，以实现同机房优先的路由规则。</p></li></ul><p>这些高级功能的实现，本质上是依赖于客户端调用时候的负载均衡策略和调用策略，但是如果服务元数据没有注册上来，也只能是巧妇难为无米之炊。一个良好的服务注册中心在设计最初就应该支持这些扩展字段。</p><h2 id="如何进行优雅的服务注册与服务下线-？"><a href="#如何进行优雅的服务注册与服务下线-？" class="headerlink" title="如何进行优雅的服务注册与服务下线 ？"></a>如何进行优雅的服务注册与服务下线 ？</h2><h3 id="优雅发布"><a href="#优雅发布" class="headerlink" title="优雅发布"></a>优雅发布</h3><p>虽然服务注册一般发生在服务的启动阶段，但是细分的话，服务注册应该在服务已经完全启动成功，并准备对外提供服务之后才能进行注册。</p><ul><li><p>有些 RPC 框架自身提供了方法来判断服务是否已经启动完成，如 Thrift ，我们可以通过 Server.isServing() 来判断。</p></li><li><p>有一些 RPC 框架本身没有提供服务是否启动完成的方式，这时我们可以通过检测端口是否已经处于监听状态来判断。</p></li><li><p>而对于 HTTP 服务，服务是否启动完毕也可以通过端口是否处于监听状态来判断。</p></li><li><p>特别的，在 Java 应用的 Spring Boot 框架中，可以通过事件通知的形式来通知容器已经启动完毕， EmbeddedServletContainerInitializedEvent 事件来通知容器已经启动完成 (Spring Boot 版本为 1.x)。</p></li></ul><h3 id="优雅下线"><a href="#优雅下线" class="headerlink" title="优雅下线"></a>优雅下线</h3><p>绝大多数的服务注册中心都提供了健康检查功能，在应用停止后会自动摘除服务所对应的节点。但是我们也不能完全依赖此功能，应用应该在停止时主动调用服务注册中心的服务下线接口。</p><ul><li><p>在 Java 应用中，通用的服务下线接口调用一般使用 JVM Shutdown Hook 的方式来实现。</p></li><li><p>特别的，在 Java 应用中的 Spring 框架中，可以通过 Spring Bean LifeCycle 来实现应用停止时主动调用服务下线接口。</p></li><li><p>当然上述两种方式还不够优雅，因为不能确保不出现 kill -9 这种粗暴的停止方式，而且应用调用服务下线接口也是尝试去调用，对于网络不通等异常场景并没有做异常处理。因此，调用客户端仍应该做好负载均衡与 failover 的处理。</p></li><li><p>更优雅的方式，先将即将停止的应用所对应的权重调成 0，此时上游将不再调用此应用。这时候的停止应用的操作对服务订阅者完全没有影响，当然这种场景需要订阅者实现按权重的负载均衡和运维部署工具深度结合。</p></li></ul><h2 id="服务的健康检查是如何做的-？"><a href="#服务的健康检查是如何做的-？" class="headerlink" title="服务的健康检查是如何做的 ？"></a>服务的健康检查是如何做的 ？</h2><p>健康检查分为客户端心跳和服务端主动探测两种方式。</p><ul><li><p>客户端心跳</p></li><li><p>客户端每隔一定时间主动发送“心跳”的方式来向服务端表明自己的服务状态正常，心跳可以是 TCP 的形式，也可以是 HTTP 的形式。</p></li><li><p>也可以通过维持客户端和服务端的一个 socket 长连接自己实现一个客户端心跳的方式。</p></li><li><p>ZooKeeper 并没有主动的发送心跳，而是依赖了组件本身提供的临时节点的特性，通过 ZooKeeper 连接的 session 来维持临时节点。</p></li></ul><p>但是客户端心跳中，长连接的维持和客户端的主动心跳都只是表明链路上的正常，不一定是服务状态正常。</p><p>服务端主动调用服务进行健康检查是一个较为准确的方式，返回结果成功表明服务状态确实正常。</p><ul><li>服务端主动探测</li><li>服务端调用服务发布者某个 HTTP 接口来完成健康检查。</li><li>对于没有提供 HTTP 服务的 RPC 应用，服务端调用服务发布者的接口来完成健康检查。</li><li>可以通过执行某个脚本的形式来进行综合检查。</li></ul><p>服务端主动探测也存在问题。服务注册中心主动调用 RPC 服务的某个接口无法做到通用性；在很多场景下服务注册中心到服务发布者的网络是不通的，服务端无法主动发起健康检查。</p><p>所以如何取舍，还是需要根据实际情况来决定，根据不同的场景，选择不同的策略。</p><h1 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h1><h2 id="怎么找到服务发现服务端的地址？"><a href="#怎么找到服务发现服务端的地址？" class="headerlink" title="怎么找到服务发现服务端的地址？"></a>怎么找到服务发现服务端的地址？</h2><ul><li>在应用的配置文件中指定服务注册中心的地址，类似于 zookeeper 和 eureka。</li><li>指定一个地址服务器的地址，然后通过这个地址服务器来获取服务注册中心的地址，地址服务器返回的结果会随着服务注册中心的扩缩容及时更新。</li></ul><h2 id="当服务有节点退出或新的节点加入时，订阅者如何及时收到通知-？"><a href="#当服务有节点退出或新的节点加入时，订阅者如何及时收到通知-？" class="headerlink" title="当服务有节点退出或新的节点加入时，订阅者如何及时收到通知 ？"></a>当服务有节点退出或新的节点加入时，订阅者如何及时收到通知 ？</h2><p>很经典的 Push 和 Pull 问题。</p><p>Push 的经典实现有两种，基于 socket 长连接的 notify，典型的实现如 zookeeper；另一种为 HTTP 连接所使用 Long Polling。</p><p>但是基于 socket 长连接的 notify 和基于 HTTP 协议的 Long Polling 都会存在notify消息丢失的问题。</p><p>所以通过 Pull 的方式定时轮询也必不可少，时间间隔的选择也很关键，频率越高服务注册中心所承受的压力也越大。需要结合服务端的性能和业务的规模进行权衡。</p><p>还有一种方式，真实的 Push，客户端开启一个 UDP server，服务注册中心通过 UDP 的方式进行数据推送，当然这个也受限于网络的连通性。</p><h2 id="我能方便地查看我发布和订阅了哪些服务，订阅的服务有哪些节点吗-？"><a href="#我能方便地查看我发布和订阅了哪些服务，订阅的服务有哪些节点吗-？" class="headerlink" title="我能方便地查看我发布和订阅了哪些服务，订阅的服务有哪些节点吗 ？"></a>我能方便地查看我发布和订阅了哪些服务，订阅的服务有哪些节点吗 ？</h2><ul><li><p>一个好的产品，用户使用体验和运维体验必须是优雅的，如果查看本机发布和订阅的服务，只能通过查看日志，甚至是 jmap 的方式来获取，显然体验非常糟糕。</p></li><li><p>服务注册中心应该提供了丰富的接口，支持根据应用名、IP、订阅服务名、发布服务名，来进行多层次的组合查询。</p></li><li><p>同时，客户端的内存里，同样也应该保留服务发布与订阅的各种信息，并提供方式供人方便地查询。</p></li><li><p>比如在 Java 中的 Spring Boot 的应用，可以结合 actuator endpoint，通过 HTTP 的方式来提供本机服务查询功能，查询此应用发布的服务，以及订阅的服务及各服务的对应节点。</p></li></ul><h1 id="容灾和高可用"><a href="#容灾和高可用" class="headerlink" title="容灾和高可用"></a>容灾和高可用</h1><h2 id="性能如何"><a href="#性能如何" class="headerlink" title="性能如何"></a>性能如何</h2><p>当服务节点数越来越多时，服务注册中心的性能会成为瓶颈，这时候就需要通过水平扩容来提升服务注册中心集群的性能。</p><ul><li>对于那些采用了类 Paxos 协议的强一致性的组件，如ZooKeeper，由于每次写操作需要过半的节点确认。水平扩容不能提升整个集群的写性能，只能提升整个集群的读性能。</li><li>而对于采用最终一致性的组件来说，水平扩容可以同时提升整个集群的写性能和读性能。</li></ul><h2 id="客户端容灾策略"><a href="#客户端容灾策略" class="headerlink" title="客户端容灾策略"></a>客户端容灾策略</h2><ol><li><p>首先，本地内存缓存，当运行时与服务注册中心的连接丢失或服务注册中心完全宕机，仍能正常地调用服务。</p></li><li><p>然后，本地缓存文件，当应用与服务注册中心发生网络分区或服务注册中心完全宕机后，应用进行了重启操作，内存里没有数据，此时应用可以通过读取本地缓存文件的数据来获取到最后一次订阅到的内容。</p></li><li><p>最后，本地容灾文件夹。正常的情况下，容灾文件夹内是没有内容的。当服务端完全宕机且长时间不能恢复，同时服务提供者又发生了很大的变更时，可以通过在容灾文件夹内添加文件的方式来开启本地容灾。此时客户端会忽略原有的本地缓存文件，只从本地容灾文件中读取配置。</p></li></ol><h2 id="服务端容灾与高可用"><a href="#服务端容灾与高可用" class="headerlink" title="服务端容灾与高可用"></a>服务端容灾与高可用</h2><ul><li>当有新节点加入集群时，节点启动后能自动添加到地址服务器中，并通过地址服务器找到其他节点，自动从其他节点同步数据，以达到数据的最终一致性。</li><li>当某个节点宕机时，此服务注册中心节点的信息会自动地址服务器中摘除，客户端能及时感知到此节点已下线。</li></ul><p>服务端的无状态性保证了服务的容灾和高可用可以做的很薄。</p><h2 id="服务端安全是如何做的-？"><a href="#服务端安全是如何做的-？" class="headerlink" title="服务端安全是如何做的 ？"></a>服务端安全是如何做的 ？</h2><p>链路安全，对于使用 HTTP 连接的服务注册中心，保护链路安全的最好方式是使用 HTTPS。而使用 TCP 连接的服务注册中心来说，由于应用层协议一般使用的是私有协议，不一定存在现成的 TLS 支持方案。</p><p>在业务安全方面，应该在每一次的发布、订阅、心跳，都带上鉴权的信息就行验签和鉴权，确保业务信息的安全性。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol><li><a href="http://jm.taobao.org/2018/06/26/%E8%81%8A%E8%81%8A%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/" target="_blank" rel="noopener">聊聊微服务的服务注册与发现</a></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> service discovery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> etcd </tag>
            
            <tag> zk </tag>
            
            <tag> zookeeper </tag>
            
            <tag> consul </tag>
            
            <tag> confd </tag>
            
            <tag> eureka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>protocol buffer</title>
      <link href="/protobuf/protocol-buffer.html"/>
      <url>/protobuf/protocol-buffer.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>protocol buffer</code>是一种与语言无关，与平台无关的可扩展机制，用于序列化结构化数据。它通过定义<code>.proto</code>文件，使用<code>protoc</code>工具生成指定代码的文件，让程序猿没有了心智负担。与json相比，它编码和解码快，生成数据体积小。</p><h1 id="protobuf类型"><a href="#protobuf类型" class="headerlink" title="protobuf类型"></a>protobuf类型</h1><table><thead><tr><th>.proto Type</th><th>Notes</th><th>Go Type</th></tr></thead><tbody><tr><td>double</td><td></td><td>float64</td></tr><tr><td>float</td><td></td><td>float32</td></tr><tr><td>int32</td><td>使用可变长度编码。负数编码效率低下–如果您的字段可能具有负值，请改用sint32。</td><td>int32</td></tr><tr><td>int64</td><td>使用可变长度编码。负数编码效率低下，如果您的字段可能具有负值，请改用sint64。</td><td>int64</td></tr><tr><td>uint32</td><td>使用可变长度编码。</td><td>uint32</td></tr><tr><td>uint64</td><td>使用可变长度编码。</td><td>uint64</td></tr><tr><td>sint32</td><td>使用可变长度编码。有符号的int值。与常规int32相比，它们更有效地编码负数。</td><td>int32</td></tr><tr><td>sint64</td><td>使用可变长度编码。有符号的int值。与常规int64相比，它们更有效地编码负数。</td><td>int64</td></tr><tr><td>fixed32</td><td>始终为八个字节。如果值通常大于$2^{28}$，则比uint32更有效。</td><td>uint32</td></tr><tr><td>fixed64</td><td>始终为八个字节。如果值通常大于$2^{56}$，则比uint64更有效。</td><td>uint64</td></tr><tr><td>sfixed32</td><td>始终为4字节。</td><td>int32</td></tr><tr><td>sfixed64</td><td>始终为8字节。</td><td>int64</td></tr><tr><td>bool</td><td></td><td>bool</td></tr><tr><td>string</td><td>字符串必须始终包含UTF-8编码或7位ASCII文本，并且不能超过$2^{32}$。</td><td>string</td></tr><tr><td>bytes</td><td>可以包含不超过$2^{32}$的字节序列。</td><td>[]byte</td></tr></tbody></table><ul><li>sint，对负数的编码结果更优秀，如果用int存小负数会占用4字节，用sint能像正数一样占少量空间</li><li>fixed，对应位数占固定字节数</li><li>sfixed，对应位数占固定字节数，使用sint的编码格式</li></ul><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://developers.google.com/protocol-buffers/docs/proto3" target="_blank" rel="noopener">proto3 guide</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> protobuf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> protobuf </tag>
            
            <tag> proto3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang调用syscall</title>
      <link href="/golang/golang-diao-yong-syscall.html"/>
      <url>/golang/golang-diao-yong-syscall.html</url>
      
        <content type="html"><![CDATA[<h1 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h1><p>OS：linux<br>ARCH：amd64<br>GOVERSION：1.14.1</p><h1 id="syscall实现"><a href="#syscall实现" class="headerlink" title="syscall实现"></a>syscall实现</h1><p>在linux下golang调用syscall的接口，文件路径<code>syscall/syscall_unix.go</code></p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">Syscall</span><span class="token punctuation">(</span>trap<span class="token punctuation">,</span> a1<span class="token punctuation">,</span> a2<span class="token punctuation">,</span> a3 <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>r1<span class="token punctuation">,</span> r2 <span class="token builtin">uintptr</span><span class="token punctuation">,</span> err Errno<span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">Syscall6</span><span class="token punctuation">(</span>trap<span class="token punctuation">,</span> a1<span class="token punctuation">,</span> a2<span class="token punctuation">,</span> a3<span class="token punctuation">,</span> a4<span class="token punctuation">,</span> a5<span class="token punctuation">,</span> a6 <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>r1<span class="token punctuation">,</span> r2 <span class="token builtin">uintptr</span><span class="token punctuation">,</span> err Errno<span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">RawSyscall</span><span class="token punctuation">(</span>trap<span class="token punctuation">,</span> a1<span class="token punctuation">,</span> a2<span class="token punctuation">,</span> a3 <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>r1<span class="token punctuation">,</span> r2 <span class="token builtin">uintptr</span><span class="token punctuation">,</span> err Errno<span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">RawSyscall6</span><span class="token punctuation">(</span>trap<span class="token punctuation">,</span> a1<span class="token punctuation">,</span> a2<span class="token punctuation">,</span> a3<span class="token punctuation">,</span> a4<span class="token punctuation">,</span> a5<span class="token punctuation">,</span> a6 <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>r1<span class="token punctuation">,</span> r2 <span class="token builtin">uintptr</span><span class="token punctuation">,</span> err Errno<span class="token punctuation">)</span></code></pre><p>这些函数的实现都是汇编，按照 linux 的 syscall 调用规范，我们只要在汇编中把参数依次传入寄存器，并调用 SYSCALL 指令即可进入内核处理逻辑，系统调用执行完毕之后，返回值放在 RAX 中：</p><table><thead><tr><th>RDI</th><th>RSI</th><th>RDX</th><th>R10</th><th>R8</th><th>R9</th><th>RAX</th></tr></thead><tbody><tr><td>参数一</td><td>参数二</td><td>参数三</td><td>参数四</td><td>参数五</td><td>参数六</td><td>系统调用编号/返回值</td></tr></tbody></table><p>这些函数的底层实现都是汇编代码，文件路径<code>syscall/asm_linux_amd64.s</code></p><pre class=" language-s"><code class="language-s">TEXT ·Syscall(SB),NOSPLIT,$0-56    CALL    runtime·entersyscall(SB)    MOVQ    a1+8(FP), DI    MOVQ    a2+16(FP), SI    MOVQ    a3+24(FP), DX    MOVQ    trap+0(FP), AX    // syscall entry    SYSCALL    // 0xfffffffffffff001 是 linux MAX_ERRNO 取反 转无符号，http://lxr.free-electrons.com/source/include/linux/err.h#L17    CMPQ    AX, $0xfffffffffffff001    JLS    ok    MOVQ    $-1, r1+32(FP)    MOVQ    $0, r2+40(FP)    NEGQ    AX    MOVQ    AX, err+48(FP)    CALL    runtime·exitsyscall(SB)    RETok:    MOVQ    AX, r1+32(FP)    MOVQ    DX, r2+40(FP)    MOVQ    $0, err+48(FP)    CALL    runtime·exitsyscall(SB)    RET// func Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr)TEXT ·Syscall6(SB),NOSPLIT,$0-80    CALL    runtime·entersyscall(SB)    MOVQ    a1+8(FP), DI    MOVQ    a2+16(FP), SI    MOVQ    a3+24(FP), DX    MOVQ    a4+32(FP), R10    MOVQ    a5+40(FP), R8    MOVQ    a6+48(FP), R9    MOVQ    trap+0(FP), AX    // syscall entry    SYSCALL    CMPQ    AX, $0xfffffffffffff001    JLS    ok6    MOVQ    $-1, r1+56(FP)    MOVQ    $0, r2+64(FP)    NEGQ    AX    MOVQ    AX, err+72(FP)    CALL    runtime·exitsyscall(SB)    RETok6:    MOVQ    AX, r1+56(FP)    MOVQ    DX, r2+64(FP)    MOVQ    $0, err+72(FP)    CALL    runtime·exitsyscall(SB)    RET</code></pre><p>可以看到Syscall和Syscall6函数没有区别，只是在传参的个数上有区别，且在开始系统和结束系统调用时会调用<code>runtime·entersyscall(SB)</code>和<code>runtime·exitsyscall(SB)</code>，这样可以让系统调用和runtime进行沟通，让runtime进行调度当前正在调用syscall的g。</p><pre class=" language-s"><code class="language-s">// func RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2, err uintptr)TEXT ·RawSyscall(SB),NOSPLIT,$0-56    MOVQ    a1+8(FP), DI    MOVQ    a2+16(FP), SI    MOVQ    a3+24(FP), DX    MOVQ    trap+0(FP), AX    // syscall entry    SYSCALL    CMPQ    AX, $0xfffffffffffff001    JLS    ok1    MOVQ    $-1, r1+32(FP)    MOVQ    $0, r2+40(FP)    NEGQ    AX    MOVQ    AX, err+48(FP)    RETok1:    MOVQ    AX, r1+32(FP)    MOVQ    DX, r2+40(FP)    MOVQ    $0, err+48(FP)    RET// func RawSyscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr)TEXT ·RawSyscall6(SB),NOSPLIT,$0-80    MOVQ    a1+8(FP), DI    MOVQ    a2+16(FP), SI    MOVQ    a3+24(FP), DX    MOVQ    a4+32(FP), R10    MOVQ    a5+40(FP), R8    MOVQ    a6+48(FP), R9    MOVQ    trap+0(FP), AX    // syscall entry    SYSCALL    CMPQ    AX, $0xfffffffffffff001    JLS    ok2    MOVQ    $-1, r1+56(FP)    MOVQ    $0, r2+64(FP)    NEGQ    AX    MOVQ    AX, err+72(FP)    RETok2:    MOVQ    AX, r1+56(FP)    MOVQ    DX, r2+64(FP)    MOVQ    $0, err+72(FP)    RET</code></pre><p>RawSyscall和RawSyscall6函数也只是只有传参数目的不同，但是Syscall和RawSyscall的区别在于没有调用<code>runtime·entersyscall(SB)</code>和<code>runtime·exitsyscall(SB)</code>，这样 runtime 理论上是没有办法通过调度把这个 g 的 m 的 p 调度走的，所以如果用户代码使用了 RawSyscall 来做一些阻塞的系统调用，是有可能阻塞其它的 g 的，下面是官方开发的原话:</p><blockquote><p>Yes, if you call RawSyscall you may block other goroutines from running. The system monitor may start them up after a while, but I think there are cases where it won’t. I would say that Go programs should always call Syscall. RawSyscall exists to make it slightly more efficient to call system calls that never block, such as getpid. But it’s really an internal mechanism.</p></blockquote><h1 id="syscall管理"><a href="#syscall管理" class="headerlink" title="syscall管理"></a>syscall管理</h1><p>golang实现了部分系统调用，定义在<code>syscall/syscall_linux.go</code>中。<br>可以把系统调用分为三类:</p><ul><li>阻塞系统调用</li><li>非阻塞系统调用</li><li>wrapped 系统调用</li></ul><p>这里截取部分代码注释</p><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">//sys    Setpriority(which int, who int, prio int) (err error)</span><span class="token comment" spellcheck="true">//sys    Setxattr(path string, attr string, data []byte, flags int) (err error)</span><span class="token comment" spellcheck="true">//sys    Sync()</span><span class="token comment" spellcheck="true">//sysnb    Sysinfo(info *Sysinfo_t) (err error)</span><span class="token comment" spellcheck="true">//sys    Tee(rfd int, wfd int, len int, flags int) (n int64, err error)</span><span class="token comment" spellcheck="true">//sysnb    Tgkill(tgid int, tid int, sig Signal) (err error)</span><span class="token comment" spellcheck="true">//sysnb    Times(tms *Tms) (ticks uintptr, err error)</span><span class="token comment" spellcheck="true">//sysnb    Umask(mask int) (oldmask int)</span><span class="token comment" spellcheck="true">//sysnb    Uname(buf *Utsname) (err error)</span><span class="token comment" spellcheck="true">//sys    Unmount(target string, flags int) (err error) = SYS_UMOUNT2</span><span class="token comment" spellcheck="true">//sys    Unshare(flags int) (err error)</span><span class="token comment" spellcheck="true">//sys    write(fd int, p []byte) (n int, err error)</span><span class="token comment" spellcheck="true">//sys    exitThread(code int) (err error) = SYS_EXIT</span><span class="token comment" spellcheck="true">//sys    readlen(fd int, p *byte, np int) (n int, err error) = SYS_READ</span><span class="token comment" spellcheck="true">//sys    writelen(fd int, p *byte, np int) (n int, err error) = SYS_WRITE</span></code></pre><p>其中有<code>//sys</code>表示阻塞的系统调用，<code>//sysnb</code>表示非阻塞系统调用。然后，根据这些注释，mksyscall.pl 脚本会生成对应的平台的具体实现。mksyscall.pl 是一段 perl 脚本，感兴趣的同学可以自行查看，这里就不再赘述了。生成的代码前面会有一段<code>// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT</code>的注释。<br>如果是标记为阻塞的系统调用生成的代码是调用<code>Syscall</code>和<code>Syscall6</code>，标记为非阻塞的系统调用会<code>RawSyscall</code>和<code>RawSyscall6</code>。<br>wrapped系统调用是封装了一层系统调用，可能是觉得命名风格不是很golang。</p><h1 id="runtime中的syscall"><a href="#runtime中的syscall" class="headerlink" title="runtime中的syscall"></a>runtime中的syscall</h1><p>除了上面提到的阻塞非阻塞和 wrapped syscall，runtime 中还定义了一些 low-level 的 syscall，这些是不暴露给用户的。<br>提供给用户的 syscall 库，在使用时，会使 goroutine 和 p 分别进入 Gsyscall 和 Psyscall 状态。但 runtime 自己封装的这些 syscall 无论是否阻塞，都不会调用 entersyscall 和 exitsyscall。虽说是 “low-level” 的 syscall，不过和暴露给用户的 syscall 本质是一样的。<br>runtime定义的系统调用列表，定义在<code>runtime/sys_linux_arm64.s</code>中。</p><pre class=" language-golang"><code class="language-golang">#define SYS_exit        93#define SYS_read        63#define SYS_write        64#define SYS_openat        56#define SYS_close        57#define SYS_pipe2        59#define SYS_fcntl        25#define SYS_nanosleep        101#define SYS_mmap        222#define SYS_munmap        215#define SYS_setitimer        103#define SYS_clone        220#define SYS_sched_yield        124#define SYS_rt_sigreturn    139#define SYS_rt_sigaction    134#define SYS_rt_sigprocmask    135#define SYS_sigaltstack        132#define SYS_madvise        233#define SYS_mincore        232#define SYS_getpid        172#define SYS_gettid        178#define SYS_kill        129#define SYS_tgkill        131#define SYS_futex        98#define SYS_sched_getaffinity    123#define SYS_exit_group        94#define SYS_epoll_create1    20#define SYS_epoll_ctl        21#define SYS_epoll_pwait        22#define SYS_clock_gettime    113#define SYS_faccessat        48#define SYS_socket        198#define SYS_connect        203#define SYS_brk            214</code></pre><p>这些 syscall 理论上都是不会在执行期间被调度器剥离掉 p 的，所以执行成功之后 goroutine 会继续执行，而不像用户的 goroutine 一样，若被剥离 p 会进入等待队列。</p><h1 id="调度交互"><a href="#调度交互" class="headerlink" title="调度交互"></a>调度交互</h1><p>既然要和调度交互，那友好地通知我要 syscall 了: entersyscall，我完事了: exitsyscall。<br>所以这里的交互指的是用户代码使用 syscall 库时和调度器的交互。<strong>runtime 里的 syscall 不走这套流程。</strong></p><p>文件路径<code>runtime/proc.go:2974</code></p><pre class=" language-golang"><code class="language-golang">// Standard syscall entry used by the go syscall library and normal cgo calls.//// This is exported via linkname to assembly in the syscall package.////go:nosplit//go:linkname entersyscallfunc entersyscall() {    reentersyscall(getcallerpc(), getcallersp())}</code></pre><pre class=" language-golang"><code class="language-golang">//go:nosplitfunc reentersyscall(pc, sp uintptr) {    _g_ := getg()    // Disable preemption because during this function g is in Gsyscall status,    // but can have inconsistent g->sched, do not let GC observe it.    _g_.m.locks++    // Entersyscall must not call any function that might split/grow the stack.    // (See details in comment above.)    // Catch calls that might, by replacing the stack guard with something that    // will trip any stack check and leaving a flag to tell newstack to die.    _g_.stackguard0 = stackPreempt    _g_.throwsplit = true    // Leave SP around for GC and traceback.    save(pc, sp)    _g_.syscallsp = sp    _g_.syscallpc = pc    casgstatus(_g_, _Grunning, _Gsyscall)    if _g_.syscallsp < _g_.stack.lo || _g_.stack.hi < _g_.syscallsp {        systemstack(func() {            print("entersyscall inconsistent ", hex(_g_.syscallsp), " [", hex(_g_.stack.lo), ",", hex(_g_.stack.hi), "]\n")            throw("entersyscall")        })    }    if trace.enabled {        systemstack(traceGoSysCall)        // systemstack itself clobbers g.sched.{pc,sp} and we might        // need them later when the G is genuinely blocked in a        // syscall        save(pc, sp)    }    if atomic.Load(&sched.sysmonwait) != 0 {        systemstack(entersyscall_sysmon)        save(pc, sp)    }    if _g_.m.p.ptr().runSafePointFn != 0 {        // runSafePointFn may stack split if run on this stack        systemstack(runSafePointFn)        save(pc, sp)    }    _g_.m.syscalltick = _g_.m.p.ptr().syscalltick    _g_.sysblocktraced = true    _g_.m.mcache = nil    pp := _g_.m.p.ptr()    pp.m = 0    _g_.m.oldp.set(pp)    _g_.m.p = 0    atomic.Store(&pp.status, _Psyscall)    if sched.gcwaiting != 0 {        systemstack(entersyscall_gcwait)        save(pc, sp)    }    _g_.m.locks--}</code></pre><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="[https://juejin.im/post/5cdd56f6e51d456e8b07de5e](https://juejin.im/post/5cdd56f6e51d456e8b07de5e)">曹春晖：谈一谈 Go 和 Syscall</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> syscall </tag>
            
            <tag> linux </tag>
            
            <tag> syscall6 </tag>
            
            <tag> rawsyscall </tag>
            
            <tag> rawsyscall6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang调用IPC</title>
      <link href="/golang/golang-diao-yong-ipc.html"/>
      <url>/golang/golang-diao-yong-ipc.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>进程间通信（IPC，Inter-Process Communication）指至少两个进程或线程间传送数据或信号的一些技术或方法。最初Unix IPC包括：管道、FIFO、信号；System V IPC包括：System V消息队列、System V信号灯、System V共享内存区；Posix IPC包括： Posix消息队列、Posix信号灯、Posix共享内存区。<br>IPC的生命周期都与内核相同</p><h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1><p>管道（Pipe）及有名管道（named pipe）：管道可用于具有亲缘关系进程间的通信，有名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。</p><h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><p>消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p><h1 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h1><p>信号量的本质是一种数据操作锁、用来负责数据操作过程中的互斥、同步等功能。<br>信号量用来管理临界资源的。它本身只是一种外部资源的标识、不具有数据交换功能，而是通过控制其他的通信资源实现进程间通信。<br>信号量通过PV操作（P减少信号，V增加信号）来控制信号量，其本质上信号量允许多个进程同时执行，当超过预定的数量后再次执行P操作或阻塞等待。P操作也叫做wait操作，sleep操作或者down操作，而V操作也被叫做signal操作，wake-up以及up操作。</p><h1 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h1><h1 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h1><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://www.ibm.com/developerworks/cn/linux/l-ipc/" target="_blank" rel="noopener">深刻理解Linux进程间通信（IPC）</a><br><a href="https://www.zhihu.com/question/47411729" target="_blank" rel="noopener">linux 信号量是什么怎么用？</a><br><a href="https://studygolang.com/articles/10203" target="_blank" rel="noopener">Golang直接操作共享内存</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ipc </tag>
            
            <tag> shmems </tag>
            
            <tag> queues </tag>
            
            <tag> semaphores </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux软链接和硬链接</title>
      <link href="/linux/linux-ruan-lian-jie-he-ying-lian-jie.html"/>
      <url>/linux/linux-ruan-lian-jie-he-ying-lian-jie.html</url>
      
        <content type="html"><![CDATA[<p>我们知道文件都有文件名与数据，这在 Linux 上被分成两个部分：用户数据 (user data) 与元数据 (metadata)。用户数据，即文件数据块 (data block)，数据块是记录文件真实内容的地方；而元数据则是文件的附加属性，如文件大小、创建时间、所有者等信息。在 Linux 中，元数据中的 inode 号（inode 是文件元数据的一部分但其并不包含文件名，inode 号即索引节点号）才是文件的唯一标识而非文件名。文件名仅是为了方便人们的记忆和使用，系统或程序通过 inode 号寻找正确的文件数据块。<br>为解决文件的共享使用，Linux 系统引入了两种链接：硬链接 (hard link) 与软链接（又称符号链接，即 soft link 或 symbolic link）。链接为 Linux 系统解决了文件的共享使用，还带来了隐藏文件路径、增加权限安全及节省存储等好处。若一个 inode 号对应多个文件名，则称这些文件为硬链接。换言之，硬链接就是同一个文件使用了多个别名他们有共同的 inode。硬链接可由命令 link 或 ln 创建。</p><h1 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h1><p>由于硬链接是有着相同 inode 号仅文件名不同的文件，因此硬链接存在以下几点特性：</p><ul><li>文件有相同的 inode 及 data block；</li><li>只能对已存在的文件进行创建；</li><li>不能交叉文件系统进行硬链接的创建；</li><li>不能对目录进行创建，只可对文件创建；</li><li>删除一个硬链接文件并不影响其他有相同 inode 号的文件。</li></ul><h1 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h1><p>软链接与硬链接不同，若文件用户数据块中存放的内容是另一文件的路径名的指向，则该文件就是软连接。软链接就是一个普通文件，只是数据块内容有点特殊。软链接有着自己的 inode 号以及用户数据块。因此软链接的创建与使用没有类似硬链接的诸多限制：</p><ul><li>软链接有自己的文件属性及权限等；</li><li>可对不存在的文件或目录创建软链接；</li><li>软链接可交叉文件系统；</li><li>软链接可对文件或目录创建；</li><li>创建软链接时，链接计数 i_nlink 不会增加；</li><li>删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）。</li></ul><h1 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h1><p>在 Linux 中，索引节点结构存在于系统内存及磁盘，其可区分成 VFS inode 与实际文件系统的 inode。VFS inode 作为实际文件系统中 inode 的抽象，定义了结构体 inode 与其相关的操作 inode_operations（见内核源码 include/linux/fs.h）。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> inode <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">const</span> <span class="token keyword">struct</span> inode_operations   <span class="token operator">*</span>i_op<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 索引节点操作</span>   <span class="token keyword">unsigned</span> <span class="token keyword">long</span>           i_ino<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 索引节点号</span>   atomic_t                i_count<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 引用计数器</span>   <span class="token keyword">unsigned</span> <span class="token keyword">int</span>            i_nlink<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 硬链接数目</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span> <span class="token keyword">struct</span> inode_operations <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>create<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> inode <span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">struct</span> dentry <span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> nameidata <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>link<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> dentry <span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">struct</span> inode <span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">struct</span> dentry <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>unlink<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> inode <span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">struct</span> dentry <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>symlink<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> inode <span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">struct</span> dentry <span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>mkdir<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> inode <span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">struct</span> dentry <span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>rmdir<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> inode <span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">struct</span> dentry <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span></code></pre><p>如清单 10. 所见，每个文件存在两个计数器：<code>i_count</code> 与 <code>i_nlink</code>，即引用计数与硬链接计数。结构体 inode 中的 <code>i_count</code> 用于跟踪文件被访问的数量，而 <code>i_nlink</code> 则是上述使用 ls -l 等命令查看到的文件硬链接数。或者说 <code>i_count</code> 跟踪文件在内存中的情况，而 <code>i_nlink</code> 则是磁盘计数器。当文件被删除时，则 <code>i_nlink</code> 先被设置成 0。文件的这两个计数器使得 Linux 系统升级或程序更新变的容易。系统或程序可在不关闭的情况下（即文件 <code>i_count</code> 不为 0），将新文件以同样的文件名进行替换，新文件有自己的 inode 及 data block，旧文件会在相关进程关闭后被完整的删除。</p><p>文件系统 ext4 中的 inode</p><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> ext4_inode <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    __le32  i_atime<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 文件内容最后一次访问时间</span>   __le32  i_ctime<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// inode 修改时间</span>   __le32  i_mtime<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 文件内容最后一次修改时间</span>   __le16  i_links_count<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 硬链接计数</span>   __le32  i_blocks_lo<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Block 计数</span>   __le32  i_block<span class="token punctuation">[</span>EXT4_N_BLOCKS<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 指向具体的 block </span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>其中三个时间的定义可对应与命令 stat 中查看到三个时间。<code>i_links_count</code> 不仅用于文件的硬链接计数，也用于目录的子目录数跟踪（目录并不显示硬链接数，命令 ls -ld 查看到的是子目录数）。由于文件系统 ext3 对 <code>i_links_count</code> 有限制，其最大数为：32000（该限制在 ext4 中被取消）。尝试在 ext3 文件系统上验证目录子目录及普通文件硬链接最大数可见的错误信息。因此实际文件系统的 inode 之间及与 VFS inode 相较是有差异的。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/index.html" target="_blank" rel="noopener">理解 Linux 的硬链接与软链接</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> link </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang TCP Socket编程</title>
      <link href="/golang/golang-de-tcpsocket-bian-cheng.html"/>
      <url>/golang/golang-de-tcpsocket-bian-cheng.html</url>
      
        <content type="html"><![CDATA[<p>golang版本：1.14.1<br>主要是对golang net包的Conn接口函数进行测试，这里只是分析常见的几个错误，如果要了解详细的错误可以查看man手册。</p><h1 id="Dial"><a href="#Dial" class="headerlink" title="Dial"></a>Dial</h1><p>Dial主要实现了TCP三次握手的环节。握手环节中有很多种情况：网络不可达，服务器backlog满了，网络超时等。</p><h2 id="network-is-unreachable"><a href="#network-is-unreachable" class="headerlink" title="network is unreachable"></a>network is unreachable</h2><p>会返回<code>connect: network is unreachable</code></p><h2 id="connection-refused"><a href="#connection-refused" class="headerlink" title="connection refused"></a>connection refused</h2><p>目标服务器的指定端口未被监听。<br>TCP层发送完第一次握手后就会收到目标主机返回的RST包，golang会返回<code>connect: connection refused</code>。<br>示例：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">Dial</span><span class="token punctuation">(</span><span class="token string">"tcp"</span><span class="token punctuation">,</span> <span class="token string">":8080"</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token keyword">defer</span> conn<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>对应控制台输出</p><pre class=" language-sh"><code class="language-sh">dial tcp :8080: connect: connection refused</code></pre><h2 id="connection-timed-out"><a href="#connection-timed-out" class="headerlink" title="connection timed out"></a>connection timed out</h2><p>Dial是阻塞的，如果不设置超时，协程会长时间阻塞（golang tcp超时是3分钟），这样很影响程序运行。<br>如果网络环境不好情况下经常有丢包发生，我们也可以手动设置超时时间来控制超时时间。<br>TCP会一直重传第一次握手的包，直到设置的超时时间后还没有收到第二次握手，网络状态一直是<code>SYN_SENT</code>，golang返回<code>i/o timeout</code>。还有连接时超时返回<code>connect: connection timed out</code>错误<br>示例：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">DialTimeout</span><span class="token punctuation">(</span><span class="token string">"tcp"</span><span class="token punctuation">,</span> <span class="token string">"google.com:443"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">*</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token keyword">defer</span> conn<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>对应控制台输出</p><pre class=" language-sh"><code class="language-sh">dial tcp 172.217.160.78:443: i/o timeout</code></pre><h1 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h1><h2 id="EOF"><a href="#EOF" class="headerlink" title="EOF"></a>EOF</h2><p>当前连接处于<code>CLOSE_WAIT</code>是调用<code>Read</code>会返回<code>EOF</code></p><h2 id="i-o-timeout"><a href="#i-o-timeout" class="headerlink" title="i/o timeout"></a>i/o timeout</h2><p>调用<code>Read</code>函数时间超过设置<code>SetReadDeadline</code>时会返回<code>i/o timeout</code></p><h2 id="connection-reset-by-peer"><a href="#connection-reset-by-peer" class="headerlink" title="connection reset by peer"></a>connection reset by peer</h2><p>在<code>Read</code>函数阻塞期间收到对端发送的<code>RST</code>包时会返回<code>read: connection reset by peer</code><br>向一个对端已关闭本端未关闭的连接（即本端处于<code>CLOSE_WAIT</code>）调用<code>Write</code>函数后再调用<code>Read</code>函数可以模拟这一个场景。</p><h2 id="use-of-closed-network-connection"><a href="#use-of-closed-network-connection" class="headerlink" title="use of closed network connection"></a>use of closed network connection</h2><p>对已关闭的连接进行<code>Read</code>时会返回<code>use of closed network connection</code></p><h2 id="connection-timed-out-1"><a href="#connection-timed-out-1" class="headerlink" title="connection timed out"></a>connection timed out</h2><p>试图读取连接时超时</p><h2 id="network-is-down"><a href="#network-is-down" class="headerlink" title="network is down"></a>network is down</h2><p>读取一个未连接socket</p><h1 id="Write"><a href="#Write" class="headerlink" title="Write"></a>Write</h1><h2 id="无错误"><a href="#无错误" class="headerlink" title="无错误"></a>无错误</h2><p>当前连接处于对端已关闭本端未关闭（即本端处于<code>CLOSE_WAIT</code>）状态时调用<code>Write</code>函数，golang不会返回error，在TCP层面会收到<code>RST</code>包。当调用<code>Close</code>函数时，系统会标记连接为全关闭，禁止在该连接上读写，所以会返回<code>RST</code>包，如果要进入半关闭需要调用<code>Shutdown</code>函数。</p><h2 id="use-of-closed-network-connection-1"><a href="#use-of-closed-network-connection-1" class="headerlink" title="use of closed network connection"></a>use of closed network connection</h2><p>当前连接处于<code>FIN_WAIT_2</code>状态和已经完全关闭的连接调用<code>Write</code>会返回<code>use of closed network connection</code></p><h2 id="broken-pipe"><a href="#broken-pipe" class="headerlink" title="broken pipe"></a>broken pipe</h2><p>当连接收到<code>RST</code>包后，连接已断开，此时调用<code>Write</code>会返回<code>write: broken pipe</code></p><h2 id="connection-timed-out-2"><a href="#connection-timed-out-2" class="headerlink" title="connection timed out"></a>connection timed out</h2><h1 id="Close"><a href="#Close" class="headerlink" title="Close"></a>Close</h1><h2 id="use-of-closed-network-connection-2"><a href="#use-of-closed-network-connection-2" class="headerlink" title="use of closed network connection"></a>use of closed network connection</h2><p>当前连接关闭多次</p><h2 id="socket-is-not-connected"><a href="#socket-is-not-connected" class="headerlink" title="socket is not connected"></a>socket is not connected</h2><p>多次关闭socket</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>对<strong>本端关闭的连接</strong>进行<code>Read</code>、<code>Write</code>和<code>Close</code>都会返回<code>use of closed network connection</code></li><li>对<strong>对端关闭本端未关闭的连接</strong>进行<code>Write</code>时对端会返回<code>RST</code>包（重置连接但golang不会返回错误），进行<code>Read</code>时会返回<code>EOF</code>错误</li><li>对<strong>重置连接（收到RST包的连接）</strong>进行<code>Write</code>会返回<code>write: broken pipe</code>错误，进行<code>Read</code>会返回<code>read: connection reset by peer</code></li><li>未在规定的时间完成<code>Read</code>和<code>Write</code>会返回<code>i/o timeout</code>错误</li></ol><h1 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h1><h2 id="syscall-server"><a href="#syscall-server" class="headerlink" title="syscall server"></a>syscall server</h2><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">socketServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fd<span class="token punctuation">,</span> err <span class="token operator">:=</span> syscall<span class="token punctuation">.</span><span class="token function">Socket</span><span class="token punctuation">(</span>syscall<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> syscall<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">,</span> syscall<span class="token punctuation">.</span>IPPROTO_TCP<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        err <span class="token operator">=</span> syscall<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span>        <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    sa <span class="token operator">:=</span> <span class="token operator">&amp;</span>syscall<span class="token punctuation">.</span>SockaddrInet4<span class="token punctuation">{</span>        Port<span class="token punctuation">:</span> <span class="token number">8080</span><span class="token punctuation">,</span>        Addr<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">{</span><span class="token number">127</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span>    err <span class="token operator">=</span> syscall<span class="token punctuation">.</span><span class="token function">Bind</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> sa<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    err <span class="token operator">=</span> syscall<span class="token punctuation">.</span><span class="token function">Listen</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">{</span>        nfd<span class="token punctuation">,</span> csa<span class="token punctuation">,</span> err <span class="token operator">:=</span> syscall<span class="token punctuation">.</span><span class="token function">Accept</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span>        <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span>        <span class="token punctuation">}</span>        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"fd %d sa %#v\n"</span><span class="token punctuation">,</span> nfd<span class="token punctuation">,</span> csa<span class="token punctuation">)</span>        buf <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span>        n<span class="token punctuation">,</span> err <span class="token operator">:=</span> syscall<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>nfd<span class="token punctuation">,</span> buf<span class="token punctuation">)</span>        <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span>        <span class="token punctuation">}</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"read data:"</span><span class="token punctuation">,</span> <span class="token function">string</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token punctuation">:</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        n<span class="token punctuation">,</span> err <span class="token operator">=</span> syscall<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">)</span>        <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span>        <span class="token punctuation">}</span>        err <span class="token operator">=</span> syscall<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span>nfd<span class="token punctuation">)</span>        <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span>        <span class="token punctuation">}</span>        <span class="token keyword">break</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="syscall-client"><a href="#syscall-client" class="headerlink" title="syscall client"></a>syscall client</h2><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">socketClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fd<span class="token punctuation">,</span> err <span class="token operator">:=</span> syscall<span class="token punctuation">.</span><span class="token function">Socket</span><span class="token punctuation">(</span>syscall<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> syscall<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">,</span> syscall<span class="token punctuation">.</span>IPPROTO_TCP<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        err <span class="token operator">=</span> syscall<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span>        <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    sa <span class="token operator">:=</span> <span class="token operator">&amp;</span>syscall<span class="token punctuation">.</span>SockaddrInet4<span class="token punctuation">{</span>        Port<span class="token punctuation">:</span> <span class="token number">8080</span><span class="token punctuation">,</span>        Addr<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">{</span><span class="token number">127</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span>    err <span class="token operator">=</span> syscall<span class="token punctuation">.</span><span class="token function">Connect</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> sa<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    buf <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"1234567890"</span><span class="token punctuation">)</span>    n<span class="token punctuation">,</span> err <span class="token operator">:=</span> syscall<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"send data"</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token function">string</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h2 id="net-server"><a href="#net-server" class="headerlink" title="net server"></a>net server</h2><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">netServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    l<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">Listen</span><span class="token punctuation">(</span><span class="token string">"tcp"</span><span class="token punctuation">,</span> <span class="token string">":8080"</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> l<span class="token punctuation">.</span><span class="token function">Accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    buf <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span>    n<span class="token punctuation">,</span> err <span class="token operator">:=</span> conn<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    n<span class="token punctuation">,</span> err <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>    err <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="net-client"><a href="#net-client" class="headerlink" title="net client"></a>net client</h2><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">netClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">Dial</span><span class="token punctuation">(</span><span class="token string">"tcp"</span><span class="token punctuation">,</span> <span class="token string">"127.0.0.1:8080"</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        err <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    buf <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span>    conn<span class="token punctuation">.</span><span class="token function">SetWriteDeadline</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">5</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token punctuation">)</span>    n<span class="token punctuation">,</span> err <span class="token operator">:=</span> conn<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    conn<span class="token punctuation">.</span><span class="token function">SetReadDeadline</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">5</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token punctuation">)</span>    n<span class="token punctuation">,</span> err <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token punctuation">:</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://tonybai.com/2015/11/17/tcp-programming-in-golang/" target="_blank" rel="noopener">Go语言TCP Socket编程</a><br><a href="https://blog.csdn.net/lanyang123456/article/details/89288824" target="_blank" rel="noopener">TCP连接异常：broken pipe 和EOF</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tcp </tag>
            
            <tag> net </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis大key处理</title>
      <link href="/redis/redis-da-key-chu-li.html"/>
      <url>/redis/redis-da-key-chu-li.html</url>
      
        <content type="html"><![CDATA[<p>Redis是一个高性能的key-value数据库。性能的关键点在于使用内存存储和单进程操作，如果Redis中存储了一个大key在内存使用和操作上都会有很大的风险。</p><h1 id="大key的风险："><a href="#大key的风险：" class="headerlink" title="大key的风险："></a>大key的风险：</h1><ol><li>读写大key会导致超时严重，甚至阻塞服务。</li><li>如果删除大key，<code>DEL</code>命令可能阻塞Redis进程数十秒，使得其他请求阻塞，对应用程序和Redis集群可用性造成严重的影响。</li><li>建议每个key不要超过M级别。</li></ol><h1 id="处理方式"><a href="#处理方式" class="headerlink" title="处理方式"></a>处理方式</h1><h2 id="valve数据多但单条数据不大"><a href="#valve数据多但单条数据不大" class="headerlink" title="valve数据多但单条数据不大"></a>valve数据多但单条数据不大</h2><p>可以按照一定的方法，聚合一些key</p><h2 id="valve数据少但单条数据量大"><a href="#valve数据少但单条数据量大" class="headerlink" title="valve数据少但单条数据量大"></a>valve数据少但单条数据量大</h2><h2 id="valve数据多且单条数据量大"><a href="#valve数据多且单条数据量大" class="headerlink" title="valve数据多且单条数据量大"></a>valve数据多且单条数据量大</h2><p>处理方式的核心思想就是将一个大key进行某种程度的拆分，常见的有：</p><ul><li>分段，将数据按照规则递增的插入，超过阈值则插入新键，以此类推，key的数量不可控，但从根本上解决了大key的问题</li><li>哈希，将数据计算出对应的哈希值，分别存储到对应的key上，key的数量可控，但依旧会产生大key问题</li></ul><h1 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h1><p>当内存到达maxmemory的限制时，可以采用以下选项清理内存：</p><ul><li>volatile-lru，在具有过期集的密钥中使用近似的LRU逐出。</li><li>allkeys-lru，使用近似的LRU逐出任何密钥。</li><li>volatile-lfu，在具有过期集的键中使用近似的逐出。</li><li>allkeys-lfu，使用近似的LFU逐出任何键。</li><li>volatile-random，在有过期集的密钥中删除一个随机密钥。</li><li>allkeys-random，随机删除任意键。</li><li>volatile-ttl，删除最接近过期时间的密钥（次要TTL）。</li><li>noeviction，不要逐出任何内容，只返回写操作错误。</li></ul><p>在不同的场景使用不同的淘汰策略，也可以充分利用redis的缓存作用。</p><h1 id="优雅的删除大key"><a href="#优雅的删除大key" class="headerlink" title="优雅的删除大key"></a>优雅的删除大key</h1><p>Redis数据类型除了字符串，都支持key的部分删除，运用多次少量的删除可以减少redis单次执行操作时间。</p><ul><li>hash，提供了<code>HDEL</code>方法进行批量删除，如果不清楚该<code>hash key</code>有哪些<code>field</code>，可以使用<code>HSCAN</code>先迭代部分<code>field</code>然后<code>HDEL</code>批量删除</li><li>list，提供了<code>LTRIM</code>方法进行删除非指定list区间的value，可以先通过<code>LLEN</code>获取当前list的长度，再根据实际情况进行<code>LTRIM</code></li><li>set，提供了<code>SREM</code>方法进行批量删除，可以先通过<code>SSCAN</code>进行迭代出部分member，再通过<code>SREM</code>进行删除</li><li>zset，提供<code>ZREM</code>方法进行批量删除，可以先通过<code>ZSCAN</code>进行迭代出部分member，再通过<code>ZREM</code>进行删除。除此之外zset还支持<code>ZREMRANGEBYLEX</code>、<code>ZREMRANGEBYRANK</code>和<code>ZREMRANGEBYSCORE</code>，分别通过member区间，score排名和score区间进行批量删除</li></ul><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://blog.csdn.net/u013474436/article/details/88808914" target="_blank" rel="noopener">Redis大Key优化</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> key </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>etcdctl命令行交互</title>
      <link href="/etcd/etcdctl-ming-ling-xing-jiao-hu.html"/>
      <url>/etcd/etcdctl-ming-ling-xing-jiao-hu.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>etcd 是一个分布式一致性键值存储，用于共享配置和服务发现，专注于：</p><ul><li>简单：良好定义的，面向用户的API (gRPC)</li><li>安全：带有可选客户端证书认证的自动 TLS</li><li>快速：测试验证，每秒 10000 写入</li><li>可靠：使用Raft适当分布</li></ul><p>etcd是Go编写，并使用 Raft 一致性算法来管理高可用复制日志。</p><p>用户通常通过设置或者获取 key 的值来和 etcd 交互。本文描述如何使用 etcdctl 来操作， etcdctl 是一个和 etcd 服务器交互的命令行工具。这里描述的概念也适用于 gRPC API 或者客户端类库 API。</p><p>默认，为了向后兼容 etcdctl 使用 v2 API 来和 etcd 服务器通讯。为了让 etcdctl 使用 v3 API 来和etcd通讯，API 版本必须通过环境变量 <code>ETCDCTL_API</code> 设置为版本3。</p><pre class=" language-bash"><code class="language-bash"><span class="token function">export</span> ETCDCTL_API<span class="token operator">=</span>3</code></pre><h1 id="写入key"><a href="#写入key" class="headerlink" title="写入key"></a>写入key</h1><p>应用通过写入 key 来储存 key 到 etcd 中。每个存储的 key 被通过 Raft 协议复制到所有 etcd 集群成员来达到一致性和可靠性。</p><p>这是设置 key <code>foo</code> 的值为 <code>bar</code> 的命令:</p><pre><code>$ etcdctl put foo barOK</code></pre><p>etcdctl默认操作的etcd是<code>--endpoints=[127.0.0.1:2379]        gRPC endpoints</code>，下同。</p><h1 id="读取-key"><a href="#读取-key" class="headerlink" title="读取 key"></a>读取 key</h1><p>应用可以从 etcd 集群中读取 key 的值。查询可以读取单个 key，或者某个范围的 key。</p><p>假设 etcd 集群存储有下面的 key：</p><pre><code>foo = barfoo1 = bar1foo2 = bar2foo4 = bar4foo5 = bar5</code></pre><p>这是读取 key <code>foo</code> 的值的命令：</p><pre><code>$ etcdctl get foofoobar</code></pre><p>这是覆盖从 <code>foo</code> to <code>foo5</code> 的 key 的命令：</p><pre><code>$ etcdctl get foo foo5foobarfoo1bar1foo2bar2foo4bar4</code></pre><blockquote><p>注： 这里是按照左闭右开的区间进行获取。</p></blockquote><h2 id="读取-key-过往版本的值"><a href="#读取-key-过往版本的值" class="headerlink" title="读取 key 过往版本的值"></a>读取 key 过往版本的值</h2><p>应用可能想读取 key 的被替代的值。例如，应用可能想通过访问 key 的过往版本来回滚到旧的配置。或者，应用可能想通过访问 key 历史记录的多个请求来得到一个覆盖多个 key 上的统一视图。</p><p>因为 etcd 集群上键值存储的每个修改都会增加 etcd 集群的全局修订版本（所有的key共有一个版本），应用可以通过提供旧有的 etcd 版本来读取被替代的 key。</p><p>假设 etcd 集群已经有下列 key：</p><pre><code>$ etcdctl put foo bar         # revision = 2$ etcdctl put foo1 bar1       # revision = 3$ etcdctl put foo bar_new     # revision = 4$ etcdctl put foo1 bar1_new   # revision = 5</code></pre><p>这里是访问 key 的过往版本的例子：</p><pre><code>$ etcdctl get foo foo9 # 访问 key 的最新版本foobar_newfoo1bar1_new$ etcdctl get --rev=4 foo foo9 # 访问 key 的修订版本4foobar_newfoo1bar1$ etcdctl get --rev=3 foo foo9 # 访问 key 的修订版本3foobarfoo1bar1$ etcdctl get --rev=2 foo foo9 # 访问 key 的修订版本2foobar$ etcdctl get --rev=1 foo foo9 # 访问 key 的修订版本1</code></pre><h1 id="删除-key"><a href="#删除-key" class="headerlink" title="删除 key"></a>删除 key</h1><p>应用可以从 etcd 集群中删除一个 key 或者特定范围的 key。</p><p>下面是删除 key <code>foo</code> 的命令：</p><pre><code>$ etcdctl del foo1 # 删除了一个key</code></pre><p>这是删除从 <code>foo</code> to <code>foo9</code> 范围的 key 的命令：</p><pre><code>$ etcdctl del foo foo95 # 删除了5个key</code></pre><h1 id="前缀匹配"><a href="#前缀匹配" class="headerlink" title="前缀匹配"></a>前缀匹配</h1><h2 id="获取指定前缀所有key"><a href="#获取指定前缀所有key" class="headerlink" title="获取指定前缀所有key"></a>获取指定前缀所有key</h2><p>通过设置<code>--prefix</code>调用对象是拥有指定前缀的key，设置<code>--keys-only</code>只显示key的名字，设置<code>--from-key</code>获取所有的键值。</p><pre class=" language-bash"><code class="language-bash">$ etcdctl --prefix --keys-only<span class="token operator">=</span>true get foofoofoo1foo2foo4foo5</code></pre><p>如果把前缀变成空字符就是获取当前etcd中所有的key。</p><pre class=" language-bash"><code class="language-bash">$ etcdctl --prefix --keys-only<span class="token operator">=</span>true get <span class="token string">""</span>foofoo1foo2foo4foo5</code></pre><p><code>--from-key</code>和<code>--prefix</code>不能同时使用。</p><pre class=" language-bash"><code class="language-bash">$ etcdctl get <span class="token string">""</span> --from-key --prefixError: <span class="token variable"><span class="token variable">`</span>--prefix<span class="token variable">`</span></span> and <span class="token variable"><span class="token variable">`</span>--from-key<span class="token variable">`</span></span> cannot be <span class="token keyword">set</span> at the same time, choose one</code></pre><p>且<code>--from-key</code>必须写在get之后，不然会报错找不到flag。</p><pre><code>$ etcdctl --from-key get ""Error: unknown flag: --from-key</code></pre><h1 id="观察-key-的变化"><a href="#观察-key-的变化" class="headerlink" title="观察 key 的变化"></a>观察 key 的变化</h1><p>应用可以观察一个 key 或者特定范围内的 key 来监控任何更新。</p><p>这是在 key <code>foo</code> 上进行观察的命令：</p><pre><code>$ etcdctl watch foofoobar</code></pre><pre class=" language-sh"><code class="language-sh">$ etcdctl put foo barOK</code></pre><p>这是观察从 <code>foo</code> to <code>foo9</code> 范围key的命令：</p><pre class=" language-bash"><code class="language-bash">$ etcdctl <span class="token function">watch</span> foo foo9<span class="token comment" spellcheck="true"># 在另外一个终端: etcdctl put foo bar</span>foobar<span class="token comment" spellcheck="true"># 在另外一个终端: etcdctl put foo1 bar1</span>foo1bar1</code></pre><h2 id="观察-key-的历史改动"><a href="#观察-key-的历史改动" class="headerlink" title="观察 key 的历史改动"></a>观察 key 的历史改动</h2><p>应用可能想观察 etcd 中 key 的历史改动。例如，应用想接收到某个 key 的所有修改。如果应用一直连接到etcd，那么 <code>watch</code> 就足够好了。但是，如果应用或者 etcd 出错，改动可能发生在出错期间，这样应用就没能实时接收到这个更新。为了保证更新被接收，应用必须能够观察到 key 的历史变动。为了做到这点，应用可以在观察时指定一个历史修订版本，就像读取 key 的过往版本一样。</p><p>假设我们完成了下列操作序列：</p><pre><code>etcdctl put foo bar         # revision = 2etcdctl put foo1 bar1       # revision = 3etcdctl put foo bar_new     # revision = 4etcdctl put foo1 bar1_new   # revision = 5</code></pre><p>这是观察历史改动的例子：</p><pre><code># 从修订版本 2 开始观察key `foo` 的改动$ etcdctl watch --rev=2 fooPUTfoobarPUTfoobar_new# 从修订版本 3 开始观察key `foo` 的改动$ etcdctl watch --rev=3 fooPUTfoobar_new</code></pre><h1 id="压缩修订版本"><a href="#压缩修订版本" class="headerlink" title="压缩修订版本"></a>压缩修订版本</h1><p>如我们提到的，etcd 保存修订版本以便应用可以读取 key 的过往版本。但是，为了避免积累无限数量的历史数据，压缩过往的修订版本就变得很重要。压缩之后，etcd 删除历史修订版本，释放资源来提供未来使用。所有修订版本在压缩修订版本之前的被替代的数据将不可访问。</p><p>这是压缩修订版本的命令：</p><pre><code>$ etcdctl compact 5compacted revision 5# 在压缩修订版本之前的任何修订版本都不可访问$ etcdctl get --rev=4 foo{"level":"warn","ts":"2020-03-24T10:25:00.189+0800","caller":"clientv3/retry_interceptor.go:62","msg":"retrying of unary invoker failed","target":"endpoint://client-d0dbfe68-878e-4b3f-8bc9-8c1c8fad1a10/127.0.0.1:2379","attempt":0,"error":"rpc error: code = OutOfRange desc = etcdserver: mvcc: required revision has been compacted"}</code></pre><h1 id="租约"><a href="#租约" class="headerlink" title="租约"></a>租约</h1><h2 id="授予租约"><a href="#授予租约" class="headerlink" title="授予租约"></a>授予租约</h2><p>应用可以为 etcd 集群里面的 key 授予租约。当 key 被附加到租约时，它的生存时间被绑定到租约的生存时间，而租约的生存时间相应的被 <code>time-to-live</code> (TTL)管理。租约的实际 TTL 值是不低于最小 TTL，由 etcd 集群选择。一旦租约的 TTL 到期，租约就过期并且所有附带的 key 都将被删除。</p><p>这是授予租约的命令：</p><pre><code># 授予租约，TTL为100秒$ etcdctl lease grant 100lease 00d4710a3e7c7539 granted with TTL(100s)# 附加key foo到租约32695410dcc0ca06$ etcdctl put --lease=00d4710a3e7c7539 foo barOK</code></pre><h2 id="撤销租约"><a href="#撤销租约" class="headerlink" title="撤销租约"></a>撤销租约</h2><p>应用通过租约 id 可以撤销租约。撤销租约将删除所有它附带的 key。</p><p>假设我们完成了下列的操作：</p><pre><code>$ etcdctl lease grant 10lease 32695410dcc0ca06 granted with TTL(10s)$ etcdctl put --lease=32695410dcc0ca06 foo barOK</code></pre><p>这是撤销同一个租约的命令：</p><pre><code>$ etcdctl lease revoke 32695410dcc0ca06lease 32695410dcc0ca06 revoked$ etcdctl get foo# 空应答，因为租约撤销导致foo被删除</code></pre><h2 id="维持租约"><a href="#维持租约" class="headerlink" title="维持租约"></a>维持租约</h2><p>应用可以通过刷新 key 的 TTL 来维持租约，以便租约不过期。</p><p>假设我们完成了下列操作：</p><pre><code>$ etcdctl lease grant 10lease 32695410dcc0ca06 granted with TTL(10s)</code></pre><p>这是维持同一个租约的命令：</p><pre><code>$ etcdctl lease keep-alive 32695410dcc0ca0lease 32695410dcc0ca0 keepalived with TTL(100)lease 32695410dcc0ca0 keepalived with TTL(100)lease 32695410dcc0ca0 keepalived with TTL(100)...</code></pre><blockquote><p>注： 上面的这个命令中，etcdctl 不是单次续约，而是 etcdctl 会一直不断的发送请求来维持这个租约。</p></blockquote><p> <a href="https://skyao.gitbooks.io/learning-etcd3/content/documentation/dev-guide/local_cluster.html" target="_blank" rel="noopener"></a></p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol><li><a href="https://skyao.gitbooks.io/learning-etcd3/content/introduction/" target="_blank" rel="noopener">etcd3介绍</a></li><li><a href="https://skyao.gitbooks.io/learning-etcd3/content/documentation/dev-guide/interacting_v3.html" target="_blank" rel="noopener">和etcd交互</a></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> etcd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cmd </tag>
            
            <tag> etcd </tag>
            
            <tag> etcdctl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang 编译指示</title>
      <link href="/golang/golang-bian-yi-zhi-shi.html"/>
      <url>/golang/golang-bian-yi-zhi-shi.html</url>
      
        <content type="html"><![CDATA[<h1 id="编译指示"><a href="#编译指示" class="headerlink" title="编译指示"></a>编译指示</h1><p>函数声明前一行写上<code>//go:</code>后面跟上编译指示，在编译的时候，go编译器会进行指定的操作</p><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">// cmd/compile/internal/gc/lex.go</span><span class="token keyword">const</span> <span class="token punctuation">(</span>    <span class="token comment" spellcheck="true">// Func pragmas.</span>    Nointerface    PragmaFlag <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token boolean">iota</span>    Noescape                  <span class="token comment" spellcheck="true">// func parameters don't escape</span>    Norace                    <span class="token comment" spellcheck="true">// func must not have race detector annotations</span>    Nosplit                   <span class="token comment" spellcheck="true">// func should not execute on separate stack</span>    Noinline                  <span class="token comment" spellcheck="true">// func should not be inlined</span>    NoCheckPtr                <span class="token comment" spellcheck="true">// func should not be instrumented by checkptr</span>    CgoUnsafeArgs             <span class="token comment" spellcheck="true">// treat a pointer to one arg as a pointer to them all</span>    UintptrEscapes            <span class="token comment" spellcheck="true">// pointers converted to uintptr escape</span>    <span class="token comment" spellcheck="true">// Runtime-only func pragmas.</span>    <span class="token comment" spellcheck="true">// See ../../../../runtime/README.md for detailed descriptions.</span>    Systemstack        <span class="token comment" spellcheck="true">// func must run on system stack</span>    Nowritebarrier     <span class="token comment" spellcheck="true">// emit compiler error instead of write barrier</span>    Nowritebarrierrec  <span class="token comment" spellcheck="true">// error on write barrier in this or recursive callees</span>    Yeswritebarrierrec <span class="token comment" spellcheck="true">// cancels Nowritebarrierrec in this function and callees</span>    <span class="token comment" spellcheck="true">// Runtime and cgo type pragmas</span>    NotInHeap <span class="token comment" spellcheck="true">// values of this type must not be heap allocated</span>    <span class="token comment" spellcheck="true">// Go command pragmas</span>    GoBuildPragma<span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">pragmaFlag</span><span class="token punctuation">(</span>verb <span class="token builtin">string</span><span class="token punctuation">)</span> PragmaFlag <span class="token punctuation">{</span>    <span class="token keyword">switch</span> verb <span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token string">"go:build"</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> GoBuildPragma    <span class="token keyword">case</span> <span class="token string">"go:nointerface"</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> objabi<span class="token punctuation">.</span>Fieldtrack_enabled <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> Nointerface        <span class="token punctuation">}</span>    <span class="token keyword">case</span> <span class="token string">"go:noescape"</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> Noescape    <span class="token keyword">case</span> <span class="token string">"go:norace"</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> Norace    <span class="token keyword">case</span> <span class="token string">"go:nosplit"</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> Nosplit <span class="token operator">|</span> NoCheckPtr <span class="token comment" spellcheck="true">// implies NoCheckPtr (see #34972)</span>    <span class="token keyword">case</span> <span class="token string">"go:noinline"</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> Noinline    <span class="token keyword">case</span> <span class="token string">"go:nocheckptr"</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> NoCheckPtr    <span class="token keyword">case</span> <span class="token string">"go:systemstack"</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> Systemstack    <span class="token keyword">case</span> <span class="token string">"go:nowritebarrier"</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> Nowritebarrier    <span class="token keyword">case</span> <span class="token string">"go:nowritebarrierrec"</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> Nowritebarrierrec <span class="token operator">|</span> Nowritebarrier <span class="token comment" spellcheck="true">// implies Nowritebarrier</span>    <span class="token keyword">case</span> <span class="token string">"go:yeswritebarrierrec"</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> Yeswritebarrierrec    <span class="token keyword">case</span> <span class="token string">"go:cgo_unsafe_args"</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> CgoUnsafeArgs <span class="token operator">|</span> NoCheckPtr <span class="token comment" spellcheck="true">// implies NoCheckPtr (see #34968)</span>    <span class="token keyword">case</span> <span class="token string">"go:uintptrescapes"</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">// For the next function declared in the file</span>        <span class="token comment" spellcheck="true">// any uintptr arguments may be pointer values</span>        <span class="token comment" spellcheck="true">// converted to uintptr. This directive</span>        <span class="token comment" spellcheck="true">// ensures that the referenced allocated</span>        <span class="token comment" spellcheck="true">// object, if any, is retained and not moved</span>        <span class="token comment" spellcheck="true">// until the call completes, even though from</span>        <span class="token comment" spellcheck="true">// the types alone it would appear that the</span>        <span class="token comment" spellcheck="true">// object is no longer needed during the</span>        <span class="token comment" spellcheck="true">// call. The conversion to uintptr must appear</span>        <span class="token comment" spellcheck="true">// in the argument list.</span>        <span class="token comment" spellcheck="true">// Used in syscall/dll_windows.go.</span>        <span class="token keyword">return</span> UintptrEscapes    <span class="token keyword">case</span> <span class="token string">"go:notinheap"</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> NotInHeap    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">}</span></code></pre><h1 id="通用标签"><a href="#通用标签" class="headerlink" title="通用标签"></a>通用标签</h1><h2 id="noescape"><a href="#noescape" class="headerlink" title="noescape"></a>noescape</h2><p><code>//go:noescape</code>表示当前函数的局部变量不能逃逸，它只能指示一个只有声明没有主体的函数。<br>例如：在原子操作，函数内创建的变量是不能向外传递指针，只能传递值</p><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">//go:noescape</span><span class="token keyword">func</span> <span class="token function">Xadd</span><span class="token punctuation">(</span>ptr <span class="token operator">*</span><span class="token builtin">uint32</span><span class="token punctuation">,</span> delta <span class="token builtin">int32</span><span class="token punctuation">)</span> <span class="token builtin">uint32</span></code></pre><h2 id="norace"><a href="#norace" class="headerlink" title="norace"></a>norace</h2><p><code>//go:norace</code>表示当前函数不需要竞态检测。<br>例如：处理错误信号时，在没有m或g的外部堆栈上运行，所以没有竞争</p><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">//go:norace</span><span class="token keyword">func</span> <span class="token function">badsignal</span><span class="token punctuation">(</span>sig <span class="token builtin">uintptr</span><span class="token punctuation">,</span> c <span class="token operator">*</span>sigctxt<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token operator">...</span><span class="token operator">...</span><span class="token punctuation">}</span></code></pre><h2 id="nosplit"><a href="#nosplit" class="headerlink" title="nosplit"></a>nosplit</h2><p><code>//go:nosplit</code>表示当前函数不需要栈溢出检测。<br>例如：当创建新的协程的函数是在<code>g0</code>栈上执行的，<code>g0</code>栈是不需要栈溢出检测的，所以就使用<code>nosplit</code>进行标记。</p><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">//go:nosplit</span><span class="token keyword">func</span> <span class="token function">newproc</span><span class="token punctuation">(</span>siz <span class="token builtin">int32</span><span class="token punctuation">,</span> fn <span class="token operator">*</span>funcval<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token operator">...</span><span class="token operator">...</span><span class="token punctuation">}</span></code></pre><h2 id="noinline"><a href="#noinline" class="headerlink" title="noinline"></a>noinline</h2><p><code>//go:noinline</code>表示当前函数不需要内联。<br>例如：原子获取<code>uint32</code>指针指向的值</p><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">//go:noinline</span><span class="token keyword">func</span> <span class="token function">Load</span><span class="token punctuation">(</span>ptr <span class="token operator">*</span><span class="token builtin">uint32</span><span class="token punctuation">)</span> <span class="token builtin">uint32</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token operator">*</span>ptr<span class="token punctuation">}</span></code></pre><h2 id="linkname"><a href="#linkname" class="headerlink" title="linkname"></a>linkname</h2><p><code>//go:linkname</code>表示函数之间的链接，可以将不可导出函数通过链接方式指向另一个包外的函数。<br>例如：将<code>runtime/timestub.go</code>的<code>time_now()</code>链接到<code>time/time.go</code>的<code>time.now()</code></p><pre class=" language-go"><code class="language-go"><span class="token keyword">import</span> <span class="token boolean">_</span> <span class="token string">"unsafe"</span> <span class="token comment" spellcheck="true">// for go:linkname</span><span class="token comment" spellcheck="true">//go:linkname time_now time.now</span><span class="token keyword">func</span> <span class="token function">time_now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>sec <span class="token builtin">int64</span><span class="token punctuation">,</span> nsec <span class="token builtin">int32</span><span class="token punctuation">,</span> mono <span class="token builtin">int64</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    sec<span class="token punctuation">,</span> nsec <span class="token operator">=</span> <span class="token function">walltime</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> sec<span class="token punctuation">,</span> nsec<span class="token punctuation">,</span> <span class="token function">nanotime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h1 id="仅运行时可用标签"><a href="#仅运行时可用标签" class="headerlink" title="仅运行时可用标签"></a>仅运行时可用标签</h1><h2 id="systemstack"><a href="#systemstack" class="headerlink" title="systemstack"></a>systemstack</h2><p><code>//go:systemstack</code>表示当前函数只能在系统栈上运行，即<code>m-&gt;g0</code>的栈上运行。进入该标签函数必须要在<code>func systemstack(fn func())</code>作为参数fn的一部分。<br>例如：创建新协程时需要使用系统栈进行创建相关操作</p><pre class=" language-go"><code class="language-go"><span class="token function">systemstack</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    newg <span class="token operator">:=</span> <span class="token function">newproc1</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> argp<span class="token punctuation">,</span> siz<span class="token punctuation">,</span> gp<span class="token punctuation">,</span> pc<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 创建新g</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//go:systemstack</span><span class="token keyword">func</span> <span class="token function">newproc1</span><span class="token punctuation">(</span>fn <span class="token operator">*</span>funcval<span class="token punctuation">,</span> argp unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">,</span> narg <span class="token builtin">int32</span><span class="token punctuation">,</span> callergp <span class="token operator">*</span>g<span class="token punctuation">,</span> callerpc <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token operator">*</span>g <span class="token punctuation">{</span>    <span class="token operator">...</span><span class="token operator">...</span><span class="token punctuation">}</span></code></pre><h2 id="nowritebarrier"><a href="#nowritebarrier" class="headerlink" title="nowritebarrier"></a>nowritebarrier</h2><p><code>//go:nowritebarrier</code>表示允许编译器用错误替换写屏障</p><h2 id="nowritebarrierrec"><a href="#nowritebarrierrec" class="headerlink" title="nowritebarrierrec"></a>nowritebarrierrec</h2><p><code>//go:nowritebarrierrec</code>表示允许编译器用错误替换写屏障，并允许递归</p><h2 id="yeswritebarrierrec"><a href="#yeswritebarrierrec" class="headerlink" title="yeswritebarrierrec"></a>yeswritebarrierrec</h2><p><code>//go:yeswritebarrierrec</code>表示编译器遇到写屏障时停止</p><h1 id="运行时或cgo标签"><a href="#运行时或cgo标签" class="headerlink" title="运行时或cgo标签"></a>运行时或cgo标签</h1><h2 id="notinheap"><a href="#notinheap" class="headerlink" title="notinheap"></a>notinheap</h2><p><code>//go:notinheap</code>表示当前对象不能使用堆内存进行分配<br>例如：<code>mcache</code>不是由GC内存分配的，所以需要标记</p><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">//go:notinheap</span><span class="token keyword">type</span> mcache <span class="token keyword">struct</span> <span class="token punctuation">{</span>    <span class="token operator">...</span><span class="token operator">...</span><span class="token punctuation">}</span></code></pre><h1 id="命令标签"><a href="#命令标签" class="headerlink" title="命令标签"></a>命令标签</h1><h2 id="build"><a href="#build" class="headerlink" title="build"></a>build</h2><p><code>//go:build</code></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> compile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux watch命令</title>
      <link href="/linux/linux-watch-ming-ling.html"/>
      <url>/linux/linux-watch-ming-ling.html</url>
      
        <content type="html"><![CDATA[<p>watch 是监视某个shell命令控制台输出。</p><pre class=" language-text"><code class="language-text">Usage: watch [options] commandOptions:  -b, --beep             beep if command has a non-zero exit  -c, --color            interpret ANSI color and style sequences  -d, --differences[=&lt;permanent&gt;]                         highlight changes between updates  -e, --errexit          exit if command has a non-zero exit  -g, --chgexit          exit when output from command changes  -n, --interval &lt;secs&gt;  seconds to wait between updates  -p, --precise          attempt run command in precise intervals  -t, --no-title         turn off header  -x, --exec             pass command to exec instead of "sh -c" -h, --help     display this help and exit -v, --version  output version information and exit</code></pre><p>参数说明：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-b, --beep</code></td><td>忽略命令有非零返回码</td></tr><tr><td><code>-c, --color</code></td><td>解释ANSI颜色和样式序列</td></tr><tr><td><code>-d, --differences[=&lt;permanent&gt;]</code></td><td>高亮变化的部分</td></tr><tr><td><code>-e, --errexit</code></td><td>当命令返回非零错误码时退出</td></tr><tr><td><code>-g, --chgexit</code></td><td>当输出有变化时退出</td></tr><tr><td><code>-n, --interval &lt;secs&gt;</code></td><td>执行命令的时间间隔，单位秒</td></tr><tr><td><code>-p, --precise</code></td><td>尝试以精确的间隔运行命令</td></tr><tr><td><code>-t, --no-title</code></td><td>不显示头部标题</td></tr><tr><td><code>-x, --exec</code></td><td>利用exec执行命令</td></tr><tr><td><code>-h, --help</code></td><td>打印帮助文档并退出</td></tr><tr><td><code>-v, --version</code></td><td>打印版本并退出</td></tr></tbody></table><p>示例：</p><pre class=" language-sh"><code class="language-sh">~ watch -b -c -d -p -t -n 1 'date;exit 1'</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cmd </tag>
            
            <tag> command </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>技术文章</title>
      <link href="/article/ji-zhu-wen-zhang.html"/>
      <url>/article/ji-zhu-wen-zhang.html</url>
      
        <content type="html"><![CDATA[<h1 id="记录有意思的博文"><a href="#记录有意思的博文" class="headerlink" title="记录有意思的博文"></a>记录有意思的博文</h1><ol><li><a href="https://research.swtch.com/vgo-principles" target="_blank" rel="noopener">go mod设计原则</a>，一切皆以软件工程为基础设计。</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> article </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> explain </tag>
            
            <tag> comment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sync包</title>
      <link href="/golang/sync-bao.html"/>
      <url>/golang/sync-bao.html</url>
      
        <content type="html"><![CDATA[<h1 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h1><h2 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h2><p>Add族函数是原子的加值操作，第一个参数是被操作值的地址，第二参数是要加的值是多少，返回值是加之后的值。<br>如果要在无符号上减操作，建议的方法<code>delta=^uint32(delta-1)</code>，特别的如果要递减使用<code>delta=^uint32(0)</code>。</p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">AddInt32</span><span class="token punctuation">(</span>addr <span class="token operator">*</span><span class="token builtin">int32</span><span class="token punctuation">,</span> delta <span class="token builtin">int32</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">new</span> <span class="token builtin">int32</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">AddUint32</span><span class="token punctuation">(</span>addr <span class="token operator">*</span><span class="token builtin">uint32</span><span class="token punctuation">,</span> delta <span class="token builtin">uint32</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">new</span> <span class="token builtin">uint32</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">AddInt64</span><span class="token punctuation">(</span>addr <span class="token operator">*</span><span class="token builtin">int64</span><span class="token punctuation">,</span> delta <span class="token builtin">int64</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">new</span> <span class="token builtin">int64</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">AddUint64</span><span class="token punctuation">(</span>addr <span class="token operator">*</span><span class="token builtin">uint64</span><span class="token punctuation">,</span> delta <span class="token builtin">uint64</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">new</span> <span class="token builtin">uint64</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">AddUintptr</span><span class="token punctuation">(</span>addr <span class="token operator">*</span><span class="token builtin">uintptr</span><span class="token punctuation">,</span> delta <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">new</span> <span class="token builtin">uintptr</span><span class="token punctuation">)</span></code></pre><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>CAS族函数是比较并替换操作，第一个参数被操作值的地址，第二个参数是被操作数的原值，第三个参数是被操作数的新值。<br>如果被操作数值不等于旧值则不进行替换，返回false，如果成功替换返回true。</p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">CompareAndSwapInt32</span><span class="token punctuation">(</span>addr <span class="token operator">*</span><span class="token builtin">int32</span><span class="token punctuation">,</span> old<span class="token punctuation">,</span> <span class="token builtin">new</span> <span class="token builtin">int32</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>swapped <span class="token builtin">bool</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">CompareAndSwapInt64</span><span class="token punctuation">(</span>addr <span class="token operator">*</span><span class="token builtin">int64</span><span class="token punctuation">,</span> old<span class="token punctuation">,</span> <span class="token builtin">new</span> <span class="token builtin">int64</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>swapped <span class="token builtin">bool</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">CompareAndSwapUint32</span><span class="token punctuation">(</span>addr <span class="token operator">*</span><span class="token builtin">uint32</span><span class="token punctuation">,</span> old<span class="token punctuation">,</span> <span class="token builtin">new</span> <span class="token builtin">uint32</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>swapped <span class="token builtin">bool</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">CompareAndSwapUint64</span><span class="token punctuation">(</span>addr <span class="token operator">*</span><span class="token builtin">uint64</span><span class="token punctuation">,</span> old<span class="token punctuation">,</span> <span class="token builtin">new</span> <span class="token builtin">uint64</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>swapped <span class="token builtin">bool</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">CompareAndSwapUintptr</span><span class="token punctuation">(</span>addr <span class="token operator">*</span><span class="token builtin">uintptr</span><span class="token punctuation">,</span> old<span class="token punctuation">,</span> <span class="token builtin">new</span> <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>swapped <span class="token builtin">bool</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">CompareAndSwapPointer</span><span class="token punctuation">(</span>addr <span class="token operator">*</span>unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">,</span> old<span class="token punctuation">,</span> <span class="token builtin">new</span> unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span> <span class="token punctuation">(</span>swapped <span class="token builtin">bool</span><span class="token punctuation">)</span></code></pre><h2 id="Load"><a href="#Load" class="headerlink" title="Load"></a>Load</h2><p>Load族函数是原子的取出被操作数，第一个参数是被操作数的地址，返回值是地址执行的值。</p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">LoadInt32</span><span class="token punctuation">(</span>addr <span class="token operator">*</span><span class="token builtin">int32</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>val <span class="token builtin">int32</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">LoadInt64</span><span class="token punctuation">(</span>addr <span class="token operator">*</span><span class="token builtin">int64</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>val <span class="token builtin">int64</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">LoadUint32</span><span class="token punctuation">(</span>addr <span class="token operator">*</span><span class="token builtin">uint32</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>val <span class="token builtin">uint32</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">LoadUint64</span><span class="token punctuation">(</span>addr <span class="token operator">*</span><span class="token builtin">uint64</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>val <span class="token builtin">uint64</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">LoadUintptr</span><span class="token punctuation">(</span>addr <span class="token operator">*</span><span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>val <span class="token builtin">uintptr</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">LoadPointer</span><span class="token punctuation">(</span>addr <span class="token operator">*</span>unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span> <span class="token punctuation">(</span>val unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span></code></pre><h2 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h2><p>Store族函数是原子的存储被操作数，第一个参数是操作数的地址，第二个参数是被设置的值。</p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">StoreInt32</span><span class="token punctuation">(</span>addr <span class="token operator">*</span><span class="token builtin">int32</span><span class="token punctuation">,</span> val <span class="token builtin">int32</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">StoreInt64</span><span class="token punctuation">(</span>addr <span class="token operator">*</span><span class="token builtin">int64</span><span class="token punctuation">,</span> val <span class="token builtin">int64</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">StoreUint32</span><span class="token punctuation">(</span>addr <span class="token operator">*</span><span class="token builtin">uint32</span><span class="token punctuation">,</span> val <span class="token builtin">uint32</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">StoreUint64</span><span class="token punctuation">(</span>addr <span class="token operator">*</span><span class="token builtin">uint64</span><span class="token punctuation">,</span> val <span class="token builtin">uint64</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">StoreUintptr</span><span class="token punctuation">(</span>addr <span class="token operator">*</span><span class="token builtin">uintptr</span><span class="token punctuation">,</span> val <span class="token builtin">uintptr</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">StorePointer</span><span class="token punctuation">(</span>addr <span class="token operator">*</span>unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">,</span> val unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span></code></pre><h2 id="Swap"><a href="#Swap" class="headerlink" title="Swap"></a>Swap</h2><p>Swap族函数是原子替换操作，第一个参数是操作数的地址，第二个参数是需要替换的新值，返回值是原来的旧值。</p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">SwapInt32</span><span class="token punctuation">(</span>addr <span class="token operator">*</span><span class="token builtin">int32</span><span class="token punctuation">,</span> <span class="token builtin">new</span> <span class="token builtin">int32</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>old <span class="token builtin">int32</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">SwapInt64</span><span class="token punctuation">(</span>addr <span class="token operator">*</span><span class="token builtin">int64</span><span class="token punctuation">,</span> <span class="token builtin">new</span> <span class="token builtin">int64</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>old <span class="token builtin">int64</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">SwapUint32</span><span class="token punctuation">(</span>addr <span class="token operator">*</span><span class="token builtin">uint32</span><span class="token punctuation">,</span> <span class="token builtin">new</span> <span class="token builtin">uint32</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>old <span class="token builtin">uint32</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">SwapUint64</span><span class="token punctuation">(</span>addr <span class="token operator">*</span><span class="token builtin">uint64</span><span class="token punctuation">,</span> <span class="token builtin">new</span> <span class="token builtin">uint64</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>old <span class="token builtin">uint64</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">SwapUintptr</span><span class="token punctuation">(</span>addr <span class="token operator">*</span><span class="token builtin">uintptr</span><span class="token punctuation">,</span> <span class="token builtin">new</span> <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>old <span class="token builtin">uintptr</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">SwapPointer</span><span class="token punctuation">(</span>addr <span class="token operator">*</span>unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">,</span> <span class="token builtin">new</span> unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span> <span class="token punctuation">(</span>old unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span></code></pre><h1 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h1><p>Mutex实现了互斥锁，即锁住的代码同一时间只有一个协程在执行。<br>提供函数：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>m <span class="token operator">*</span>Mutex<span class="token punctuation">)</span> <span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token punctuation">(</span>m <span class="token operator">*</span>Mutex<span class="token punctuation">)</span> <span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>Mutex实现了Locker接口。</p><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">// A Locker represents an object that can be locked and unlocked.</span><span class="token keyword">type</span> Locker <span class="token keyword">interface</span> <span class="token punctuation">{</span>    <span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h1 id="RWMutex"><a href="#RWMutex" class="headerlink" title="RWMutex"></a>RWMutex</h1><p>RWMutex是读写锁，适用于读多写少的场景。<br>提供函数：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>rw <span class="token operator">*</span>RWMutex<span class="token punctuation">)</span> <span class="token function">RLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token punctuation">(</span>rw <span class="token operator">*</span>RWMutex<span class="token punctuation">)</span> <span class="token function">RUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token punctuation">(</span>rw <span class="token operator">*</span>RWMutex<span class="token punctuation">)</span> <span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token punctuation">(</span>rw <span class="token operator">*</span>RWMutex<span class="token punctuation">)</span> <span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token punctuation">(</span>rw <span class="token operator">*</span>RWMutex<span class="token punctuation">)</span> <span class="token function">RLocker</span><span class="token punctuation">(</span><span class="token punctuation">)</span> Locker</code></pre><p>RLocker()函数返回读锁的接口对象，用于传入NewCond返回一个读锁的条件变量。</p><h1 id="Cond"><a href="#Cond" class="headerlink" title="Cond"></a>Cond</h1><p>Cond是条件变量，条件变量的作用并不是保证在同一时刻仅有一个线程访问某一个共享数据，而是在对应的共享数据的状态发生变化时，通知其他因此而被阻塞的线程。<br>提供函数：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">NewCond</span><span class="token punctuation">(</span>l Locker<span class="token punctuation">)</span> <span class="token operator">*</span>Cond<span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>Cond<span class="token punctuation">)</span> <span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>Cond<span class="token punctuation">)</span> <span class="token function">Signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>Cond<span class="token punctuation">)</span> <span class="token function">Broadcast</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><ul><li><code>cond.L.Lock()</code>和<code>cond.L.Unlock()</code>：也可以使用<code>lock.Lock()</code>和<code>lock.Unlock()</code>，完全一样，因为是指针转递</li><li><code>cond.Wait()</code>：Unlock()-&gt;<strong><em>阻塞等待通知(即等待Signal()或Broadcast()的通知)-&gt;收到通知</em></strong>-&gt;Lock()</li><li><code>cond.Signal()</code>：通知一个Wait()了的，若没有Wait()，也不会报错。<strong>Signal()通知的顺序是根据原来加入通知列表(Wait())的先入先出</strong></li><li><code>cond.Broadcast()</code>: 通知所有Wait()了的，若没有Wait()，也不会报错</li></ul><p>示例：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    data <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">}</span>    tmp <span class="token operator">:=</span> <span class="token number">0</span>    c <span class="token operator">:=</span> sync<span class="token punctuation">.</span><span class="token function">NewCond</span><span class="token punctuation">(</span><span class="token function">new</span><span class="token punctuation">(</span>sync<span class="token punctuation">.</span>Mutex<span class="token punctuation">)</span><span class="token punctuation">)</span>    c<span class="token punctuation">.</span>L<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">defer</span> c<span class="token punctuation">.</span>L<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    ctx<span class="token punctuation">,</span> cancel <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">WithCancel</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 生产者</span>    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> d <span class="token operator">:=</span> <span class="token keyword">range</span> data <span class="token punctuation">{</span>            tmp <span class="token operator">=</span> d            c<span class="token punctuation">.</span><span class="token function">Signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        c<span class="token punctuation">.</span><span class="token function">Signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 防止消费者进入wait死锁，但是会重复消费一次数据</span>    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 消费者</span>    <span class="token keyword">for</span> <span class="token punctuation">{</span>        <span class="token keyword">select</span> <span class="token punctuation">{</span>        <span class="token keyword">case</span> <span class="token operator">&lt;-</span>ctx<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        <span class="token keyword">default</span><span class="token punctuation">:</span>            c<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>            <span class="token keyword">if</span> tmp<span class="token operator">%</span><span class="token number">2</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>                fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> tmp<span class="token punctuation">)</span>                <span class="token keyword">continue</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>上例可以看到Cond的使用并没有channel方便，所以一般还是使用channel进行顺序调用。Cond一般使用场景是唤起一个Wait协程，或者唤起所有Wait协程。</p><h1 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h1><p>WaitGroup是等待一组进程运行完成。<br>提供函数：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>wg <span class="token operator">*</span>WaitGroup<span class="token punctuation">)</span> <span class="token function">Add</span><span class="token punctuation">(</span>delta <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token punctuation">(</span>wg <span class="token operator">*</span>WaitGroup<span class="token punctuation">)</span> <span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token punctuation">(</span>wg <span class="token operator">*</span>WaitGroup<span class="token punctuation">)</span> <span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>Add函数delta类型是int，所以支持参数为负数的值，但是不能让计数器为负数，否则会panic。<br>Done函数是递减1，也不能使计数器为负数，否则会panic。<br>Wait函数阻塞等待计数器为0。</p><p>WaitGroup一个计数周期，即计数器从0转到正数开始，到计数器从正数到0结束，即为一个周期。当计数器为0时，Wait函数停止阻塞返回，在后面仍可以调用Add函数进行加计数器，即开启下一个周期，可以调用Wait函数等待下一次周期的结束。</p><h1 id="Once"><a href="#Once" class="headerlink" title="Once"></a>Once</h1><p>Once提供一个只执行一次的保护罩。<br>提供函数：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>o <span class="token operator">*</span>Once<span class="token punctuation">)</span> <span class="token function">Do</span><span class="token punctuation">(</span>f <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>重复的调用同一Once对象的Do函数f只会执行一次，不管f是否相同。常用于init函数不能执行的执行一次操作，例如创建单例对象，初始化连接池，全局变量赋值等等。</p><h1 id="Pool"><a href="#Pool" class="headerlink" title="Pool"></a>Pool</h1><p>Pool表示一个临时对象池，常用于同类型对象重复利用的场景。<br>提供函数：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>p <span class="token operator">*</span>Pool<span class="token punctuation">)</span> <span class="token function">Put</span><span class="token punctuation">(</span>x <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token punctuation">(</span>p <span class="token operator">*</span>Pool<span class="token punctuation">)</span> <span class="token function">Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>Pool有个成员<code>New func() interface{}</code>表示如果Get的时候没有对象则使用New新建一个对象。<br>Get函数取到的值是随机的，不应该对Get函数取出的对象抱有任何假设，即在获取Get函数返回对象之后应该做一次重新赋值成默认值状态。</p><blockquote><p>摘自参考文献[1]<br>这样一个临时对象池在功能上与一个通用的缓存池有几分相似。但是实际上，临时对象池本身的特性决定了它是一个很独特的同步工具。下面讲一下它的两个非常突出的特性。<br>第一个特性，临时对象池可以把由其中的对象值产生的存储压力进行分摊。更进一步说，它会专门为每一个与操作它的goroutine相关联的P建立本地池。在临时对象池的Get方法被调用时，它一般会先尝试从与本地P对应的那个本地私有池和本地共享池中获取一个对象值。如果获取失败，它就会试图从其他P的本地共享池中偷一个对象值并直接返回给调用方。如果依然未果，它就只能把希望寄托于当前临时对象池的对象值生成函数了。注意，这个对象值生成函数产生的对象值永远不会被放置到池中，而是会被直接返回给调用方。另一方面，临时对象池的Put方法会把它的参数值存放到本地P的本地池中。每个相关P的本地共享池中的所有对象值，都是在当前临时对象池的范围内共享的。也就是说，它们随时可能会被偷走。<br>临时对象池的第二个突出特性是对垃圾回收友好。垃圾回收的执行一般会使临时对象池中的对象值全部被移除。也就是说，即使我们永远不会显式地从临时对象池取走某个对象值，该对象值也不会永远待在临时对象池中，它的生命周期取决于垃圾回收任务下一次的执行时间。</p></blockquote><p>示例：垃圾回收清空临时对象池中的数据</p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 禁用GC，并保证在main函数执行结束前恢复GC</span>    <span class="token keyword">defer</span> debug<span class="token punctuation">.</span><span class="token function">SetGCPercent</span><span class="token punctuation">(</span>debug<span class="token punctuation">.</span><span class="token function">SetGCPercent</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">var</span> count <span class="token builtin">int32</span>    newFunc <span class="token operator">:=</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> atomic<span class="token punctuation">.</span><span class="token function">AddInt32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>count<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    pool <span class="token operator">:=</span> sync<span class="token punctuation">.</span>Pool<span class="token punctuation">{</span>New<span class="token punctuation">:</span> newFunc<span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// New字段值的作用</span>    v1 <span class="token operator">:=</span> pool<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Value 1: %v\n"</span><span class="token punctuation">,</span> v1<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 临时对象池的存取</span>    pool<span class="token punctuation">.</span><span class="token function">Put</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>    pool<span class="token punctuation">.</span><span class="token function">Put</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span>    pool<span class="token punctuation">.</span><span class="token function">Put</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span>    v2 <span class="token operator">:=</span> pool<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Value 2: %v\n"</span><span class="token punctuation">,</span> v2<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 垃圾回收对临时对象池的影响</span>    debug<span class="token punctuation">.</span><span class="token function">SetGCPercent</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>    runtime<span class="token punctuation">.</span><span class="token function">GC</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    v3 <span class="token operator">:=</span> pool<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Value 3: %v\n"</span><span class="token punctuation">,</span> v3<span class="token punctuation">)</span>    pool<span class="token punctuation">.</span>New <span class="token operator">=</span> <span class="token boolean">nil</span>    v4 <span class="token operator">:=</span> pool<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Value 4: %v\n"</span><span class="token punctuation">,</span> v4<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>Map提供一个并发安全的map，由于golang的map并发操作会panic。<br>提供函数：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>m <span class="token operator">*</span>Map<span class="token punctuation">)</span> <span class="token function">Load</span><span class="token punctuation">(</span>key <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>value <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> ok <span class="token builtin">bool</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token punctuation">(</span>m <span class="token operator">*</span>Map<span class="token punctuation">)</span> <span class="token function">Store</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token punctuation">(</span>m <span class="token operator">*</span>Map<span class="token punctuation">)</span> <span class="token function">LoadOrStore</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>actual <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> loaded <span class="token builtin">bool</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token punctuation">(</span>m <span class="token operator">*</span>Map<span class="token punctuation">)</span> <span class="token function">Delete</span><span class="token punctuation">(</span>key <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token punctuation">(</span>m <span class="token operator">*</span>Map<span class="token punctuation">)</span> <span class="token function">Range</span><span class="token punctuation">(</span>f <span class="token keyword">func</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token builtin">bool</span><span class="token punctuation">)</span></code></pre><p>由于Map的性能并没有<code>map+mutex</code>的性能好，所以一般用的比较少。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol><li><a href="https://www.ituring.com.cn/book/tupubarticle/13514" target="_blank" rel="noopener">Go并发编程实战（第2版）</a></li><li><a href="https://ieevee.com/tech/2019/06/15/cond.html" target="_blank" rel="noopener">Golang中如何正确使用条件变量sync.Cond</a></li><li><a href="https://cyent.github.io/golang/goroutine/sync_cond/" target="_blank" rel="noopener">Go语言学习 - cyent笔记</a></li><li><a href="https://juejin.im/post/5d36a7cbf265da1bb47da444" target="_blank" rel="noopener">由浅入深聊聊Golang的sync.Map</a></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sync </tag>
            
            <tag> mutex </tag>
            
            <tag> condition variable </tag>
            
            <tag> atomic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux sort命令</title>
      <link href="/linux/linux-sort-ming-ling.html"/>
      <url>/linux/linux-sort-ming-ling.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>sort命令是将制定文件内容以行为单位进行ASCII码值排序，最后将他们按升序输出。<br>sort的帮助文档：</p><pre class=" language-text"><code class="language-text">sort --help用法：sort [选项]... [文件]...　或：sort [选项]... --files0-from=FWrite sorted concatenation of all FILE(s) to standard output.Mandatory arguments to long options are mandatory for short options too.排序选项：  -b, --ignore-leading-blanks    忽略前导的空白区域  -d, --dictionary-order    只考虑空白区域和字母字符  -f, --ignore-case        忽略字母大小写  -g, --general-numeric-sort  compare according to general numerical value  -i, --ignore-nonprinting    consider only printable characters  -M, --month-sort            compare (unknown) < 'JAN' < ... < 'DEC'  -h, --human-numeric-sort    使用易读性数字(例如： 2K 1G)  -n, --numeric-sort        根据字符串数值比较  -R, --random-sort        根据随机hash 排序      --random-source=文件    从指定文件中获得随机字节  -r, --reverse            逆序输出排序结果      --sort=WORD        按照WORD 指定的格式排序：                    一般数字-g，高可读性-h，月份-M，数字-n，                    随机-R，版本-V  -V, --version-sort        在文本内进行自然版本排序其他选项：      --batch-size=NMERGE    一次最多合并NMERGE 个输入；如果输入更多                    则使用临时文件  -c, --check, --check=diagnose-first    检查输入是否已排序，若已有序则不进行操作  -C, --check=quiet, --check=silent    类似-c，但不报告第一个无序行      --compress-program=程序    使用指定程序压缩临时文件；使用该程序                    的-d 参数解压缩文件      --debug            为用于排序的行添加注释，并将有可能有问题的                    用法输出到标准错误输出      --files0-from=文件    从指定文件读取以NUL 终止的名称，如果该文件被                    指定为"-"则从标准输入读文件名  -k, --key=KEYDEF          sort via a key; KEYDEF gives location and type  -m, --merge               merge already sorted files; do not sort  -o, --output=文件        将结果写入到文件而非标准输出  -s, --stable            禁用last-resort 比较以稳定比较算法  -S, --buffer-size=大小    指定主内存缓存大小  -t, --field-separator=分隔符    使用指定的分隔符代替非空格到空格的转换  -T, --temporary-directory=目录    使用指定目录而非$TMPDIR 或/tmp 作为                    临时目录，可用多个选项指定多个目录      --parallel=N        将同时运行的排序数改变为N  -u, --unique        配合-c，严格校验排序；不配合-c，则只输出一次排序结果  -z, --zero-terminated    以0 字节而非新行作为行尾标志      --help        显示此帮助信息并退出      --version        显示版本信息并退出KEYDEF is F[.C][OPTS][,F[.C][OPTS]] for start and stop position, where F is afield number and C a character position in the field; both are origin 1, andthe stop position defaults to the line's end.  If neither -t nor -b is ineffect, characters in a field are counted from the beginning of the precedingwhitespace.  OPTS is one or more single-letter ordering options [bdfgiMhnRrV],which override global ordering options for that key.  If no key is given, usethe entire line as the key.SIZE may be followed by the following multiplicative suffixes:内存使用率% 1%，b 1、K 1024 (默认)，M、G、T、P、E、Z、Y 等依此类推。如果不指定文件，或者文件为"-"，则从标准输入读取数据。*** 警告 ***本地环境变量会影响排序结果。如果希望以字节的自然值获得最传统的排序结果，请设置LC_ALL=C。</code></pre><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="b-忽略前置空白字符"><a href="#b-忽略前置空白字符" class="headerlink" title="-b 忽略前置空白字符"></a>-b 忽略前置空白字符</h2><h2 id="c-检查是否已排序"><a href="#c-检查是否已排序" class="headerlink" title="-c 检查是否已排序"></a>-c 检查是否已排序</h2><h2 id="f-忽略大小写"><a href="#f-忽略大小写" class="headerlink" title="-f 忽略大小写"></a>-f 忽略大小写</h2><h2 id="M-按月份排序"><a href="#M-按月份排序" class="headerlink" title="-M 按月份排序"></a>-M 按月份排序</h2><h2 id="n-数值排序"><a href="#n-数值排序" class="headerlink" title="-n 数值排序"></a>-n 数值排序</h2><p>由于sort采用的是ASCII码值排序只会导致100在11之前，如果有需要将其数值排序可以使用-n选项，sort也只会比较最开始一直是数值的字符。<br>示例：</p><pre class=" language-sh"><code class="language-sh">➜ seq 20 | sort1101112131415161718192203456789➜ seq 20 | sort -n1234567891011121314151617181920</code></pre><h2 id="o-输出重定向"><a href="#o-输出重定向" class="headerlink" title="-o 输出重定向"></a>-o 输出重定向</h2><p>sort默认输出位置是标准输出，可以使用-o重定向输出位置。</p><h2 id="t-k-列项排序"><a href="#t-k-列项排序" class="headerlink" title="-t -k 列项排序"></a>-t -k 列项排序</h2><p>sort支持列项排序，即对相同列项进行排序，以当前列项值为排序的索引，排序所有行。<br>-t指定列项分隔符，默认是空白字符，-k指定按照分隔符划分出的第几列。<br>示例：</p><pre class=" language-sh"><code class="language-sh">➜ netstat -an | grep tcp | awk '{print $1,$2,$3,$6}' | sort -k4tcp 0 0 ESTABLISHEDtcp 0 0 ESTABLISHEDtcp 0 0 ESTABLISHEDtcp 0 0 ESTABLISHEDtcp 0 0 ESTABLISHEDtcp 0 140 ESTABLISHEDtcp6 0 0 ESTABLISHEDtcp6 0 0 ESTABLISHEDtcp 0 0 LISTENtcp 0 0 LISTENtcp 0 0 LISTENtcp6 0 0 LISTENtcp6 0 0 LISTENtcp6 0 0 LISTENtcp 0 0 TIME_WAITtcp 0 0 TIME_WAITtcp 0 0 TIME_WAITtcp 0 0 TIME_WAIT</code></pre><h2 id="r-逆序"><a href="#r-逆序" class="headerlink" title="-r 逆序"></a>-r 逆序</h2><p>sort默认输出是升序，如果我们需要降序就可以利用-r参数。<br>示例：</p><pre class=" language-sh"><code class="language-sh">➜ seq 9 | sort -r987654321</code></pre><h2 id="R-随机排序"><a href="#R-随机排序" class="headerlink" title="-R 随机排序"></a>-R 随机排序</h2><p>乱序。</p><pre class=" language-sh"><code class="language-sh">➜ seq 9 | sort -R168549723</code></pre><h2 id="u-去重"><a href="#u-去重" class="headerlink" title="-u 去重"></a>-u 去重</h2><p>sort排序内容如果有很多重复行，可以使用去重，排序后，在输出行中去除重复行。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cmd </tag>
            
            <tag> command </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP协议</title>
      <link href="/net/tcp-xie-yi.html"/>
      <url>/net/tcp-xie-yi.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>TCP协议是传输层重要的协议，TCP是面向连接、字节流和提供可靠传输。要使用TCP连接的双方必须先建立连接，然后才能开始数据的读写。TCP是全双工的，所以双发的内核都需要一定的资源保存TCP连接的状态和连接上的数据。在完成数据交换之后，通信双方都必须断开连接已释放系统资源。</p><h1 id="头部结构"><a href="#头部结构" class="headerlink" title="头部结构"></a>头部结构</h1><p>头部结构字段：</p><pre class=" language-text"><code class="language-text">0                   1                   2                   3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|          Source Port          |       Destination Port        |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                        Sequence Number                        |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                    Acknowledgment Number                      |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|  Data |           |U|A|P|R|S|F|                               || Offset| Reserved  |R|C|S|S|Y|I|            Window             ||       |           |G|K|H|T|N|N|                               |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|           Checksum            |         Urgent Pointer        |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                    Options                    |    Padding    |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                             data                              |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre><ul><li>Source Port:  16 bits</li><li>Destination Port:  16 bits</li><li>Sequence Number:  32 bits</li><li>Acknowledgment Number:  32 bits</li><li>Data Offset:  4 bits</li><li>Reserved:  6 bits</li><li>Control Bits:  6 bits</li><li>Window:  16 bits</li><li>Checksum:  16 bits</li><li>Urgent Pointer:  16 bits</li><li>Options:  variable</li><li>Padding:  variable</li></ul><h2 id="Sequence-Number"><a href="#Sequence-Number" class="headerlink" title="Sequence Number"></a>Sequence Number</h2><h2 id="Acknowledgment-Number"><a href="#Acknowledgment-Number" class="headerlink" title="Acknowledgment Number"></a>Acknowledgment Number</h2><h2 id="Data-Offset"><a href="#Data-Offset" class="headerlink" title="Data Offset"></a>Data Offset</h2><h2 id="Control-Bits"><a href="#Control-Bits" class="headerlink" title="Control Bits"></a>Control Bits</h2><h2 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h2><h2 id="Checksum"><a href="#Checksum" class="headerlink" title="Checksum"></a>Checksum</h2><p>检验和是填充一个伪包头加上TCP报文求和算出。<br>伪包头结构字段：</p><pre class=" language-text"><code class="language-text">+--------+--------+--------+--------+|           Source Address          |+--------+--------+--------+--------+|         Destination Address       |+--------+--------+--------+--------+|  zero  |  PTCL  |    TCP Length   |+--------+--------+--------+--------+</code></pre><ul><li>Source Address: 32 bits</li><li>Destination Address: 32 bits</li><li>zero: 8 bits</li><li>PTCL: 8 bits</li><li>TCP Length: 16 bits</li></ul><h2 id="Urgent-Pointer"><a href="#Urgent-Pointer" class="headerlink" title="Urgent Pointer"></a>Urgent Pointer</h2><h2 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h2><p>  当前定义的选项字段</p><table><thead><tr><th>Kind</th><th>Length</th><th>Meaning</th></tr></thead><tbody><tr><td>0</td><td>-</td><td>End of option list.</td></tr><tr><td>1</td><td>-</td><td>No-Operation.</td></tr><tr><td>2</td><td>4</td><td>Maximum Segment Size.</td></tr></tbody></table><h1 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h1><h2 id="TCP-连接状态机"><a href="#TCP-连接状态机" class="headerlink" title="TCP 连接状态机"></a>TCP 连接状态机</h2><pre class=" language-text"><code class="language-text">                              +---------+ ---------\      active OPEN                              |  CLOSED |            \    -----------                              +---------+<---------\   \   create TCB                                |     ^              \   \  snd SYN                   passive OPEN |     |   CLOSE        \   \                   ------------ |     | ----------       \   \                    create TCB  |     | delete TCB         \   \                                V     |                      \   \                              +---------+            CLOSE    |    \                              |  LISTEN |          ---------- |     |                              +---------+          delete TCB |     |                   rcv SYN      |     |     SEND              |     |                  -----------   |     |    -------            |     V +---------+      snd SYN,ACK  /       \   snd SYN          +---------+ |         |<-----------------           ------------------>|         | |   SYN   |                    rcv SYN                     |   SYN   | |   RCVD  |<-----------------------------------------------|   SENT  | |         |                    snd ACK                     |         | |         |------------------           -------------------|         | +---------+   rcv ACK of SYN  \       /  rcv SYN,ACK       +---------+   |           --------------   |     |   -----------   |                  x         |     |     snd ACK   |                            V     V   |  CLOSE                   +---------+   | -------                  |  ESTAB  |   | snd FIN                  +---------+   |                   CLOSE    |     |    rcv FIN   V                  -------   |     |    ------- +---------+          snd FIN  /       \   snd ACK          +---------+ |  FIN    |<-----------------           ------------------>|  CLOSE  | | WAIT-1  |------------------                              |   WAIT  | +---------+          rcv FIN  \                            +---------+   | rcv ACK of FIN   -------   |                            CLOSE  |   | --------------   snd ACK   |                           ------- |   V        x                   V                           snd FIN V +---------+                  +---------+                   +---------+ |FINWAIT-2|                  | CLOSING |                   | LAST-ACK| +---------+                  +---------+                   +---------+   |                rcv ACK of FIN |                 rcv ACK of FIN |   |  rcv FIN       -------------- |    Timeout=2MSL -------------- |   |  -------              x       V    ------------        x       V    \ snd ACK                 +---------+delete TCB         +---------+     ------------------------>|TIME WAIT|------------------>| CLOSED  |                              +---------+                   +---------+</code></pre><h3 id="各个状态意义"><a href="#各个状态意义" class="headerlink" title="各个状态意义"></a>各个状态意义</h3><ul><li>LISTEN - represents waiting for a connection request from any remote<br>  TCP and port.</li><li>SYN-SENT - represents waiting for a matching connection request<br>  after having sent a connection request.</li><li>SYN-RECEIVED - represents waiting for a confirming connection<br>  request acknowledgment after having both received and sent a<br>  connection request.</li><li>ESTABLISHED - represents an open connection, data received can be<br>  delivered to the user.  The normal state for the data transfer phase<br>  of the connection.</li><li>FIN-WAIT-1 - represents waiting for a connection termination request<br>  from the remote TCP, or an acknowledgment of the connection<br>  termination request previously sent.</li><li>FIN-WAIT-2 - represents waiting for a connection termination request<br>  from the remote TCP.</li><li>CLOSE-WAIT - represents waiting for a connection termination request<br>  from the local user.</li><li>CLOSING - represents waiting for a connection termination request<br>  acknowledgment from the remote TCP.</li><li>LAST-ACK - represents waiting for an acknowledgment of the<br>  connection termination request previously sent to the remote TCP<br>  (which includes an acknowledgment of its connection termination<br>  request).</li><li>TIME-WAIT - represents waiting for enough time to pass to be sure<br>  the remote TCP received the acknowledgment of its connection<br>  termination request.</li><li>CLOSED - represents no connection state at all.</li></ul><h2 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h2><h2 id="Establishing"><a href="#Establishing" class="headerlink" title="Establishing"></a>Establishing</h2><h2 id="断开连接"><a href="#断开连接" class="headerlink" title="断开连接"></a>断开连接</h2><h1 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h1><h1 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h1><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://tools.ietf.org/html/rfc793" target="_blank" rel="noopener">TRANSMISSION CONTROL PROTOCOL</a></li><li><a href="https://tools.ietf.org/html/rfc1122" target="_blank" rel="noopener">Requirements for Internet Hosts – Communication Layers</a></li><li>《Linux高性能服务器编程》</li><li><a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">传输控制协议</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tcp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux cut命令</title>
      <link href="/linux/linux-cut-ming-ling.html"/>
      <url>/linux/linux-cut-ming-ling.html</url>
      
        <content type="html"><![CDATA[<p>在linux中，cut常用修剪出指定位置的数据，cut是按行为单位进行裁剪。<br>它有三个裁剪模式：</p><pre class=" language-text"><code class="language-text">用法：cut [选项]... [文件]...  -b, --bytes=列表        只选中指定的这些字节  -c, --characters=列表    只选中指定的这些字符  -d, --delimiter=分界符    使用指定分界符代替制表符作为区域分界  -f, --fields=LIST       select only these fields;  also print any line                            that contains no delimiter character, unless                            the -s option is specified  -n                      with -b: don't split multibyte characters      --complement        补全选中的字节、字符或域  -s, --only-delimited        不打印没有包含分界符的行      --output-delimiter=字符串    使用指定的字符串作为输出分界符，默认采用输入                的分界符      --help        显示此帮助信息并退出      --version        显示版本信息并退出仅使用 -b, -c 或-f 中的一个。每一个列表都是专门为一个类别作出的，或者您可以用逗号隔开要同时显示的不同类别。您的输入顺序将作为读取顺序，每个仅能输入一次。每种参数格式表示范围如下：    N    第N 个字节、字符或域    N-    从第N 个开始到所在行结束的所有字符、字节或域    N-M    从第N 个开始到第M 个之间(包括第M 个)的所有字符、字节或域    -M    从第1 个开始到第M 个之间(包括第M 个)的所有字符、字节或域当没有文件参数，或者文件不存在时，从标准输入读取      </code></pre><p>常用选项：</p><ul><li>b，按照字节长度裁剪，-n表示</li><li>c，按照字符长度来裁剪</li><li>d，表示自定义分隔符，默认为制表符</li><li>f，按照域长度来裁剪，-s表示</li></ul><p>示例：</p><pre class=" language-sh"><code class="language-sh">➜ echo "你好:哈哈" | cut -b 1-3你➜ echo "你好:哈哈" | cut -c 1-2你好➜ echo "你好:哈哈" | cut -d: -f 1-1你好</code></pre><p>complement表示反选。<br>示例：</p><pre class=" language-sh"><code class="language-sh">➜ echo "12 34 56 67" | cut -b 1,413➜ echo "12 34 56 67" | cut -b 1,4 --complement2 4 56 67➜ echo "12 34 56 67" | cut -b 1-4 --complement4 56 67</code></pre><p>output-delimiter表示设置输出的分隔符。<br>示例：</p><pre class=" language-sh"><code class="language-sh">➜ echo "你好:哈哈:hello" | cut -d: -f 1-2 --output-delimiter=!你好!哈哈</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cmd </tag>
            
            <tag> command </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux awk命令</title>
      <link href="/linux/linux-awk-ming-ling.html"/>
      <url>/linux/linux-awk-ming-ling.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>awk是一个强大的文本处理和文本分析工具，不仅可以通过行为单位处理文本，还可以通过列为单位处理文本，默认行分隔符是换行符，默认列分隔符是连续空格和Tab，可以定义分隔符。awk提供了极其强大的功能：可以进行正则表达式的匹配，样式装入、流控制、数学运算符、进程控制语句甚至于内置的变量和函数。<br>获取帮助信息，gawk是awk的GNU版本</p><pre class=" language-sh"><code class="language-sh">➜ awk --helpUsage: awk [POSIX or GNU style options] -f progfile [--] file ...Usage: awk [POSIX or GNU style options] [--] 'program' file ...POSIX options:        GNU long options: (standard)    -f progfile        --file=progfile    -F fs            --field-separator=fs    -v var=val        --assign=var=valShort options:        GNU long options: (extensions)    -b            --characters-as-bytes    -c            --traditional    -C            --copyright    -d[file]        --dump-variables[=file]    -e 'program-text'    --source='program-text'    -E file            --exec=file    -g            --gen-pot    -h            --help    -L [fatal]        --lint[=fatal]    -n            --non-decimal-data    -N            --use-lc-numeric    -O            --optimize    -p[file]        --profile[=file]    -P            --posix    -r            --re-interval    -S            --sandbox    -t            --lint-old    -V            --versionTo report bugs, see node `Bugs' in `gawk.info', which issection `Reporting Problems and Bugs' in the printed version.gawk is a pattern scanning and processing language.By default it reads standard input and writes standard output.Examples:    gawk '{ sum += $1 }; END { print sum }' file    gawk -F: '{ print $1 }' /etc/passwd</code></pre><h1 id="执行方式"><a href="#执行方式" class="headerlink" title="执行方式"></a>执行方式</h1><p>awk命令行的基本执行形式为：</p><pre class=" language-sh"><code class="language-sh">awk option 'script' file1 file2 ...awk option -f scriptfile file1 file2 ...</code></pre><p>awk的操作对象既可以是文本文件，也可以是标准输入重定向得到，亦或是命令行参数传入。</p><h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>常用命令行参数说明：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-f</td><td>执行awk脚本文件路径</td></tr><tr><td>-F</td><td>输入域分隔符</td></tr><tr><td>-v</td><td>传入shell变量</td></tr><tr><td>-b</td><td>字符按照字节区分</td></tr><tr><td>-h</td><td>帮助文档</td></tr><tr><td>-V</td><td>显示版本</td></tr></tbody></table><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>script一般格式为<code>/pattern/{actions}</code>，pattern表示正则表达式，actions表示一系列操作。awk利用正则表达式pattern匹配出需要执行actions的行，如果没有pattern表示每一行都执行actions。</p><p>示例：打印所有行</p><pre class=" language-sh"><code class="language-sh">➜ seq 20 | awk '{print $1}'1234567891011121314151617181920</code></pre><p>示例：打印包含1的行</p><pre><code>➜ seq 20 | awk '/1/{print $1}'110111213141516171819</code></pre><p>print表示打印；<code>$1</code>表示第一列，<code>$2</code>表示第二列，以此类推，<code>$0</code>表示当前行。</p><p>awk利用运算符<code>~</code>表示符合正则运算，<code>!~</code>表示不符合正则运算。<br>示例：</p><pre class=" language-sh"><code class="language-sh">➜ seq 20 | awk '$1 !~ /1/{print $1}'            2345678920</code></pre><h2 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h2><p>awk支持使用数学条件筛选，支持运算符表格：</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td><code>= += -= *= /= %= ^= **=</code></td><td>赋值</td></tr><tr><td><code>?:</code></td><td>C条件表达式</td></tr><tr><td><code>||</code></td><td>逻辑或</td></tr><tr><td><code>&amp;&amp;</code></td><td>逻辑与</td></tr><tr><td><code>~</code> 和 <code>!~</code></td><td>匹配正则表达式和不匹配正则表达式</td></tr><tr><td><code>&lt; &lt;= &gt; &gt;= != ==</code></td><td>关系运算符</td></tr><tr><td>空格</td><td>连接</td></tr><tr><td><code>+ -</code></td><td>加，减</td></tr><tr><td><code>* / %</code></td><td>乘，除与求余</td></tr><tr><td><code>+ - !</code></td><td>一元加，减和逻辑非</td></tr><tr><td><code>^ ***</code></td><td>求幂</td></tr><tr><td><code>++ --</code></td><td>增加或减少，作为前缀或后缀</td></tr><tr><td><code>$</code></td><td>字段引用</td></tr><tr><td><code>in</code></td><td>数组成员</td></tr></tbody></table><p>示例：1-20中筛选大于10的偶数</p><pre class=" language-sh"><code class="language-sh">➜ seq 20 | awk '$1%2==0&&$1>=10{print $1,"Y"}'10 Y12 Y14 Y16 Y18 Y20 Y</code></pre><p>awk还支持算术函数</p><table><thead><tr><th align="center">函数名</th><th>说明</th></tr></thead><tbody><tr><td align="center"><code>atan2( y, x )</code></td><td>返回 y/x 的反正切。</td></tr><tr><td align="center"><code>cos( x )</code></td><td>返回 x 的余弦；x 是弧度。</td></tr><tr><td align="center"><code>sin( x )</code></td><td>返回 x 的正弦；x 是弧度。</td></tr><tr><td align="center"><code>exp( x )</code></td><td>返回 x 幂函数。</td></tr><tr><td align="center"><code>log( x )</code></td><td>返回 x 的自然对数。</td></tr><tr><td align="center"><code>sqrt( x )</code></td><td>返回 x 平方根。</td></tr><tr><td align="center"><code>int( x )</code></td><td>返回 x 的截断至整数的值。</td></tr><tr><td align="center"><code>rand()</code></td><td>返回任意数字 n，其中 0 &lt;= n &lt; 1。</td></tr><tr><td align="center"><code>srand([Expr])</code></td><td>将rand函数的种子值设置为Expr参数的值，或如果省略Expr参数则使用某天的时间。返回先前的种子值。</td></tr></tbody></table><p>示例：打印$e^{$1}$，上次随机数种子，随机数</p><pre><code>➜ seq 20 | awk '{print exp($1), srand($1), rand()}'2.71828 0 0.8401887.38906 1 0.70097620.0855 2 0.5613854.5982 3 0.916458148.413 4 0.274746403.429 5 0.1354391096.63 6 0.4869042980.96 7 0.3527618103.08 8 0.20696522026.5 9 0.56581159874.1 10 0.926345162755 11 0.7856442413 12 0.6326431.2026e+06 13 0.9994983.26902e+06 14 0.3549738.88611e+06 15 0.2154372.4155e+07 16 0.5717946.566e+07 17 0.9290731.78482e+08 18 0.2902334.85165e+08 19 0.148812</code></pre><h2 id="BEGIN-END"><a href="#BEGIN-END" class="headerlink" title="BEGIN-END"></a>BEGIN-END</h2><p>awk有两个特殊的条件，对待每个处理的文件，BEGIN后面的actions在执行整个文件<strong>之前</strong>执行一次，END后面的actions在执行整个文件<strong>之后</strong>执行一次。awk可以像c一样使用使用变量，但是不需要定义变量。<br>示例：</p><pre class=" language-sh"><code class="language-sh">➜ seq 20 | awk  '/1/{x=x+1;}END{print x}'   11➜ seq 20 | awk 'BEGIN{x=100}/1/{x=x+1;}END{print x}' 111</code></pre><h2 id="内建变量"><a href="#内建变量" class="headerlink" title="内建变量"></a>内建变量</h2><table><thead><tr><th>变量</th><th>描述</th></tr></thead><tbody><tr><td><code>$n</code></td><td>当前记录的第n个字段，字段间由FS分隔</td></tr><tr><td><code>$0</code></td><td>完整的输入记录</td></tr><tr><td><code>ARGC</code></td><td>命令行参数的数目</td></tr><tr><td><code>ARGIND</code></td><td>命令行中当前文件的位置(从0开始算)</td></tr><tr><td><code>ARGV</code></td><td>包含命令行参数的数组</td></tr><tr><td><code>CONVFMT</code></td><td>数字转换格式(默认值为%.6g)ENVIRON环境变量关联数组</td></tr><tr><td><code>ERRNO</code></td><td>最后一个系统错误的描述</td></tr><tr><td><code>FIELDWIDTHS</code></td><td>字段宽度列表(用空格键分隔)</td></tr><tr><td><code>FILENAME</code></td><td>当前文件名</td></tr><tr><td><code>FNR</code></td><td>各文件分别计数的行号</td></tr><tr><td><code>FS</code></td><td>字段分隔符(默认是任何空格)</td></tr><tr><td><code>IGNORECASE</code></td><td>如果为真，则进行忽略大小写的匹配</td></tr><tr><td><code>NF</code></td><td>一条记录的字段的数目</td></tr><tr><td><code>NR</code></td><td>已经读出的记录数，就是行号，从1开始</td></tr><tr><td><code>OFMT</code></td><td>数字的输出格式(默认值是%.6g)</td></tr><tr><td><code>OFS</code></td><td>print函数输出字段分隔符（输出空格），输出时用指定的符号代替分隔符</td></tr><tr><td><code>ORS</code></td><td>输出记录分隔符(默认值是一个换行符)</td></tr><tr><td><code>RLENGTH</code></td><td>由match函数所匹配的字符串的长度</td></tr><tr><td><code>RS</code></td><td>记录分隔符(默认是一个换行符)</td></tr><tr><td><code>RSTART</code></td><td>由match函数所匹配的字符串的第一个位置</td></tr><tr><td><code>SUBSEP</code></td><td>数组下标分隔符(默认值是/034)</td></tr></tbody></table><p>示例：打印最后一列，并打印当前行数</p><pre class=" language-sh"><code class="language-sh">➜ seq 20 | sort | awk '{print $NF "\t" NR}'1    110    211    312    413    514    615    716    817    918    1019    112    1220    133    144    155    166    177    188    199    20</code></pre><p>示例：替换输出分隔符和换行符</p><pre class=" language-sh"><code class="language-sh">➜ echo "this is a test\nthis is a test" | awk 'BEGIN{OFS="_";ORS="--"}{print $1,$2,$3,$4}'this_is_a_test--this_is_a_test--</code></pre><h2 id="一般函数"><a href="#一般函数" class="headerlink" title="一般函数"></a>一般函数</h2><table><thead><tr><th><strong>函数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><code>close( Expression )</code></td><td>用同一个带字符串值的 Expression 参数来关闭由 print 或 printf 语句打开的或调用 getline 函数打开的文件或管道。如果文件或管道成功关闭，则返回 0；其它情况下返回非零值。如果打算写一个文件，并稍后在同一个程序中读取文件，则 close 语句是必需的。</td></tr><tr><td><code>system(Command )</code></td><td>执行 Command 参数指定的命令，并返回退出状态。</td></tr><tr><td><code>Expression | getline [ Variable ]</code></td><td>从来自 Expression 参数指定的命令的输出中通过管道传送的流中读取一个输入记录，并将该记录的值指定给 Variable 参数指定的变量。如果当前未打开将 Expression 参数的值作为其命令名称的流，则创建流。此时 Command 参数取 Expression 参数的值且 Mode 参数设置为一个是 r 的值。只要流保留打开且 Expression 参数求得同一个字符串，则对 getline 函数的每次后续调用读取另一个记录。如果未指定 Variable 参数，则 $0 记录变量和 NF 特殊变量设置为从流读取的记录。</td></tr><tr><td><code>getline [ Variable ] &lt; Expression</code></td><td>从 Expression 参数指定的文件读取输入的下一个记录，并将 Variable 参数指定的变量设置为该记录的值。只要流保留打开且 Expression 参数对同一个字符串求值，则对 getline 函数的每次后续调用读取另一个记录。如果未指定 Variable 参数，则 $0 记录变量和 NF 特殊变量设置为从流读取的记录。</td></tr><tr><td><code>getline [ Variable ]</code></td><td>将 Variable 参数指定的变量设置为从当前输入文件读取的下一个输入记录。如果未指定 Variable 参数，则 $0 记录变量设置为该记录的值，还将设置 NF、NR 和 FNR 特殊变量。</td></tr></tbody></table><p>示例：通过system函数执行shell语句，最后0表示Errno</p><pre class=" language-sh"><code class="language-sh">➜ awk 'BEGIN{print system("ps -ef | grep awk")}'root      6490 10366  0 17:16 pts/0    00:00:00 awk BEGIN{print system("ps -ef | grep awk")}root      6491  6490  0 17:16 pts/0    00:00:00 sh -c ps -ef | grep awkroot      6493  6491  0 17:16 pts/0    00:00:00 grep awk0</code></pre><h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><p>awk还有内置字符串函数</p><table><thead><tr><th><strong>函数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><code>gsub( Ere, Repl, [ In ] )</code></td><td>除了正则表达式所有具体值被替代这点，它和 sub 函数完全一样地执行。</td></tr><tr><td><code>sub( Ere, Repl, [ In ] )</code></td><td>用 Repl 参数指定的字符串替换 In 参数指定的字符串中的由 Ere 参数指定的扩展正则表达式的第一个具体值。sub 函数返回替换的数量。出现在 Repl 参数指定的字符串中的 &amp;（和符号）由 In 参数指定的与 Ere 参数的指定的扩展正则表达式匹配的字符串替换。如果未指定 In 参数，缺省值是整个记录（$0 记录变量）。</td></tr><tr><td><code>index( String1, String2 )</code></td><td>在由 String1 参数指定的字符串（其中有出现 String2 指定的参数）中，返回位置，从 1 开始编号。如果 String2 参数不在 String1 参数中出现，则返回 0（零）。</td></tr><tr><td><code>length [(String)]</code></td><td>返回 String 参数指定的字符串的长度（字符形式）。如果未给出 String 参数，则返回整个记录的长度（$0 记录变量）。</td></tr><tr><td><code>substr( String, M, [ N ] )</code></td><td>返回具有 N 参数指定的字符数量子串。子串从 String 参数指定的字符串取得，其字符以 M 参数指定的位置开始。M 参数指定为将 String 参数中的第一个字符作为编号 1。如果未指定 N 参数，则子串的长度将是 M 参数指定的位置到 String 参数的末尾 的长度。</td></tr><tr><td><code>match( String, Ere )</code></td><td>在 String 参数指定的字符串（Ere 参数指定的扩展正则表达式出现在其中）中返回位置（字符形式），从 1 开始编号，或如果 Ere 参数不出现，则返回 0（零）。RSTART 特殊变量设置为返回值。RLENGTH 特殊变量设置为匹配的字符串的长度，或如果未找到任何匹配，则设置为 -1（负一）。</td></tr><tr><td><code>split( String, A, [Ere] )</code></td><td>将 String 参数指定的参数分割为数组元素 <code>A[1], A[2], . . ., A[n]</code>，并返回 n 变量的值。此分隔可以通过 Ere 参数指定的扩展正则表达式进行，或用当前字段分隔符（FS 特殊变量）来进行（如果没有给出 Ere 参数）。除非上下文指明特定的元素还应具有一个数字值，否则 A 数组中的元素用字符串值来创建。</td></tr><tr><td><code>tolower( String )</code></td><td>返回 String 参数指定的字符串，字符串中每个大写字符将更改为小写。大写和小写的映射由当前语言环境的 LC_CTYPE 范畴定义。</td></tr><tr><td><code>toupper( String )</code></td><td>返回 String 参数指定的字符串，字符串中每个小写字符将更改为大写。大写和小写的映射由当前语言环境的 LC_CTYPE 范畴定义。</td></tr><tr><td><code>printf(Format, Expr, Expr, . . . )</code></td><td>根据 Format 参数指定的格式字符串来格式化 Expr 参数指定的表达式并返回最后生成的字符串。</td></tr></tbody></table><p>sprintf函数format格式化参数转换表</p><table><thead><tr><th><strong>格式符</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><code>%d</code></td><td>十进制有符号整数</td></tr><tr><td><code>%u</code></td><td>十进制无符号整数</td></tr><tr><td><code>%f</code></td><td>浮点数</td></tr><tr><td><code>%s</code></td><td>字符串</td></tr><tr><td><code>%c</code></td><td>单个字符</td></tr><tr><td><code>%p</code></td><td>指针的值</td></tr><tr><td><code>%e</code></td><td>指数形式的浮点数</td></tr><tr><td><code>%x</code></td><td>%X 无符号以十六进制表示的整数</td></tr><tr><td><code>%o</code></td><td>无符号以八进制表示的整数</td></tr><tr><td><code>%g</code></td><td>自动选择合适的表示法</td></tr></tbody></table><p>示例：打印字符串，转换大小写</p><pre class=" language-sh"><code class="language-sh">➜ awk 'BEGIN{str="Hello World";print str "\n" tolower(str) "\n" toupper(str)}'Hello Worldhello worldHELLO WORLD</code></pre><p>示例：打印字符串长度，查找指定字串并返回子串索引，匹配正则字串并返回子串索引</p><pre class=" language-sh"><code class="language-sh">➜ awk 'BEGIN{str="Hello World";printf("len:%d, index:%d, match:%d\n",length(str),index(str,"world"),match(str,/[wW]orld/))}'len:11, index:0, match:7</code></pre><p>示例：利用split函数，打印字串数组</p><pre class=" language-sh"><code class="language-sh">➜ awk 'BEGIN{str="this is a test";split(str,t," ");print length(t);for(k in t){print k,t[k];}}'44 test1 this2 is3 a</code></pre><h2 id="时间函数"><a href="#时间函数" class="headerlink" title="时间函数"></a>时间函数</h2><table><thead><tr><th><strong>函数名</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><code>mktime( YYYY MM DD HH MM SS[ DST])</code></td><td>生成时间格式</td></tr><tr><td><code>strftime([format [, timestamp]])</code></td><td>格式化时间输出，将时间戳转为时间字符串具体格式，见下表.</td></tr><tr><td><code>systime()</code></td><td>得到时间戳,返回从1970年1月1日开始到当前时间（不计闰年）的整秒数</td></tr></tbody></table><p>strftime函数format格式化参数转换表</p><table><thead><tr><th>格式</th><th>描述</th></tr></thead><tbody><tr><td><code>%a</code></td><td>星期几的缩写（Sun）</td></tr><tr><td><code>%A</code></td><td>星期几的完整写法（Sunday）</td></tr><tr><td><code>%b</code></td><td>月名的缩写（Oct）</td></tr><tr><td><code>%B</code></td><td>月名的完整写法（October）</td></tr><tr><td><code>%c</code></td><td>本地日期和时间</td></tr><tr><td><code>%d</code></td><td>十进制日期</td></tr><tr><td><code>%D</code></td><td>日期 08/20/99</td></tr><tr><td><code>%e</code></td><td>日期，如果只有一位会补上一个空格</td></tr><tr><td><code>%H</code></td><td>用十进制表示24小时格式的小时</td></tr><tr><td><code>%I</code></td><td>用十进制表示12小时格式的小时</td></tr><tr><td><code>%j</code></td><td>从1月1日起一年中的第几天</td></tr><tr><td><code>%m</code></td><td>十进制表示的月份</td></tr><tr><td><code>%M</code></td><td>十进制表示的分钟</td></tr><tr><td><code>%p</code></td><td>12小时表示法（AM/PM）</td></tr><tr><td><code>%S</code></td><td>十进制表示的秒</td></tr><tr><td><code>%U</code></td><td>十进制表示的一年中的第几个星期（星期天作为一个星期的开始）</td></tr><tr><td><code>%w</code></td><td>十进制表示的星期几（星期天是0）</td></tr><tr><td><code>%W</code></td><td>十进制表示的一年中的第几个星期（星期一作为一个星期的开始）</td></tr><tr><td><code>%x</code></td><td>重新设置本地日期（08/20/99）</td></tr><tr><td><code>%X</code></td><td>重新设置本地时间（12:00:00）</td></tr><tr><td><code>%y</code></td><td>两位数字表示的年（99）</td></tr><tr><td><code>%Y</code></td><td>当前月份</td></tr><tr><td><code>%Z</code></td><td>时区（PDT）</td></tr><tr><td><code>%%</code></td><td>百分号（%）</td></tr></tbody></table><p>示例：获取当前时间，并格式化输出</p><pre class=" language-sh"><code class="language-sh">➜ awk 'BEGIN{st=systime();print st, strftime("%c %Z", st)}'1576744487 2019年12月19日 星期四 16时34分47秒 CST</code></pre><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><p>awk可以利用类c风格的代码进行简单的程序编写，使之能完成更多的事情。</p><h2 id="编程语法"><a href="#编程语法" class="headerlink" title="编程语法"></a>编程语法</h2><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><p>awk的条件判断格式是类c风格的</p><pre class=" language-c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>expression<span class="token punctuation">)</span> <span class="token punctuation">{</span>    statement<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>expression<span class="token punctuation">)</span> <span class="token punctuation">{</span>    statement1<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    statement2<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>expression1<span class="token punctuation">)</span> <span class="token punctuation">{</span>    statement1<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>expression2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    statement2<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>    statement3<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>awk支持while、for和do-while循环，格式也是类c风格的</p><pre class=" language-sh"><code class="language-sh">while (expression) {    statement;}// for-in 输出的var顺序可能不一致for (var in array) {    statement;}for (var; condtion; expression) {    statement;}do {    statement;} while (expression);</code></pre><p>同时awk也支持退出循环</p><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>break</td><td>当 break 语句用于 while 或 for 语句时，导致退出程序循环。</td></tr><tr><td>continue</td><td>当 continue 语句用于 while 或 for 语句时，使程序循环移动到下一个迭代。</td></tr><tr><td>next</td><td>能能够导致读入下一个输入行，并返回到脚本的顶部。这可以避免对当前输入行执行其他的操作过程。</td></tr><tr><td>exit</td><td>语句使主输入循环退出并将控制转移到END,如果END存在的话。如果没有定义END规则，或在END中应用exit语句，则终止脚本的执行。</td></tr></tbody></table><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>awk数组支持数字下标和字符串下标，底层是哈希表，所以每次遍历不能保证都是相同顺序。<br>示例：</p><pre class=" language-sh"><code class="language-sh">array_name[key]=value</code></pre><ul><li>array_name：数组的名称</li><li>key：数组索引</li><li>value：数组中元素所赋予的值</li></ul><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p>awk可以直接声明元素key-value对<br>示例：</p><pre class=" language-sh"><code class="language-sh">➜ awk 'BEGIN{keys[1]=2;keys["start"]="start";print keys[1], keys["start"]}'2 start</code></pre><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>使用delete可以删除数组的元素<br>示例：删除key为1的值，最后打印keys[1]的值为空字符串</p><pre class=" language-sh"><code class="language-sh">➜ awk 'BEGIN{keys[1]=2;keys["start"]="start";delete keys[1];print keys[1], keys["start"]}' start</code></pre><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>awk 多维数组在本质上是一维数组，因awk在存储上并不支持多维数组，awk提供了逻辑上模拟二维数组的访问方式。例如，array[2,3] = 1这样的访问是允许的。<br>awk使用一个特殊的字符串SUBSEP （<code>\034</code>）作为分割字段，在上面的例子 array[2,3] = 1 中，关联数组array存储的键值实际上是2<code>\034</code>3，2和3分别为下标（2，3），<code>\034</code>为SUBSEP分隔符。<br>示例：</p><pre class=" language-sh"><code class="language-sh">➜ awk 'BEGIN{a[1,1]=1;a["1,1"]=2;a[11]=3;for(i in a){print i,a[i]}}'1,1 211 311 1</code></pre><h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h3><p>asort对数组array按照首字母进行排序，返回数组长度。如果要得到数组原本顺序，需要使用数组下标依次访问。<br>for-in 输出关联数组的顺序是无序的，所以通过for-in 得到是无序的数组。如果需要得到有序数组，需要通过下标获得。<br>示例：</p><pre class=" language-sh"><code class="language-sh">➜ awk 'BEGIN{str="it is a test";l=split(str,array," ");for(i in array){print i,array[i];};asort(array);for(i in array){print i,array[i;}}'4 test1 it2 is3 a4 test1 a2 is3 it</code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>一个程序包含有多个功能，每个功能我们可以独立一个函数，函数可以提高代码的复用性。用户自定义函数的语法格式为：</p><pre class=" language-sh"><code class="language-sh">function function_name(argument1, argument2,  ...){  function body }</code></pre><p><strong>解析：</strong></p><ul><li><strong>function_name</strong> 是用户自定义函数的名称。函数名称应该以字母开头，其后可以是数字、字母或下划线的自由组合。AWK 保留的关键字不能作为用户自定义函数的名称。</li><li>自定义函数可以接受多个输入参数，这些参数之间通过逗号分隔。参数并不是必须的。我们也可以定义没有任何输入参数的函数。</li><li><strong>function body</strong> 是函数体部分，它包含 AWK 程序代码。</li></ul><p>示例：写一个求和函数</p><pre class=" language-sh"><code class="language-sh">➜ awk 'function sum(n1,n2){return n1+n2}BEGIN{print sum(1,2)}'3</code></pre><p>如果函数比较复杂，我们可以写成一个文件的形式来执行awk。</p><pre class=" language-sh"><code class="language-sh"># 返回最小值function find_min(num1, num2){  if (num1 < num2)    return num1  return num2}# 返回最大值function find_max(num1, num2){  if (num1 > num2)    return num1  return num2}# 主函数function main(num1, num2){  # 查找最小值  result = find_min(10, 20)  print "Minimum =", result  # 查找最大值  result = find_max(10, 20)  print "Maximum =", result}# 脚本从这里开始执行BEGIN {  main(10, 20)}</code></pre><p>执行可以得到</p><pre class=" language-sh"><code class="language-sh">Minimum = 10Maximum = 20</code></pre><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://zh.wikipedia.org/wiki/AWK" target="_blank" rel="noopener">维基百科</a></li><li><a href="https://www.runoob.com/linux/linux-comm-awk.html" target="_blank" rel="noopener">菜鸟教程</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cmd </tag>
            
            <tag> command </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP协议</title>
      <link href="/net/ip-xie-yi.html"/>
      <url>/net/ip-xie-yi.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>IP协议是TCP/IP协议族的动力，它为上层协议提供无状态、无连接、不可靠的服务。</p><ul><li>无状态（stateless），是指IP通信双方不同步传输数据的状态信息，因此所有IP数据报的发送、传输和接收都是相互独立的</li><li>无连接（connectionless），是指IP通信双方都不长久地维持对方的任何信息，因此每个IP数据报都要带上对方的IP地址</li><li>不可靠（unreliable），是指IP协议不能保证IP数据报准确到达接收端，只是尽最大努力</li></ul><h1 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h1><h2 id="头部结构"><a href="#头部结构" class="headerlink" title="头部结构"></a>头部结构</h2><p>IPv4头部结构，固定长度为20字节，选项最多可有40字节<br><img src="https://img-1251474779.cos.ap-beijing.myqcloud.com/IP%E5%8D%8F%E8%AE%AE/v4header.png" alt="IPv4 header"></p><ul><li>4位版本号（version），指定IP协议的版本，IPv4的值是4，其他IPv4的扩展版本（SIP和PIP）拥有不同的版本和不同的头部结构</li><li>4位头部长度（header length），标识IP头部有多少个4字节，4位比特最大能表示15，所以IP头部长度最长为$4*15=60$字节</li><li>8位服务类型（type of service，TOS）<ul><li>3位优先权字段（现已被忽略）</li><li>4位TOS分别表示，最小延迟、最大吞吐量、最高可靠性和最小费用，同时只能一个置1，应用程序根据实际情况来设置</li><li>1位保留字段（必须置0）</li></ul></li><li>16位总长度（total length），是指整个IP数据报的长度，以字节为单位，因此IP数据报的最大长度为$2^{16}-1=65535$，但是由于MTU（最大传输单元）限制，超过MTU的数据报将被分片传输</li><li>16位标识（identification）唯一的标识主机发送的每一个数据报，初始值由系统随机生成，每发送一个数据报其值加一，该值在数据报分片时复制到每个分片，因此同一个数据报的所有分片都具有相同的标识值</li><li>3位标志字段（flag）<ul><li>第一位保留</li><li>第二位（Don’t Fragment，DF）表示禁止分片，如果设置了这个值，IP模块将不对数据报进行分片，如果数据报超过MTU，IP模块将丢弃数据报并返回一个ICMP差错报文</li><li>第三位（More Fragment，MF）表示更多分片，除了最后一个分片外其他分片都要把它置1</li></ul></li><li>13位分片偏移（fragmentation offset）是分片相对原始IP数据报开始处（仅指数据部分）偏移，实际的偏移值是左移3位（$*8$）后得到的，因为这个原因，除了最后一个IP分片外，每个IP分片的数据部分的长度必须是8的整数倍（保证每个分片有一个合适偏移值）</li><li>8位生存时间（Time To Live，TTL）是数据报到达目的地址之前允许经过路由器的跳数，TTL由发送端设置（常见值64），每经过一个路由，该值就减一，当减为0时，路由器将丢弃数据报，并向发送源发送一个ICMP差错报文，TTL可以防止数据报陷入路由循环</li><li>8位协议（protocol）用来区分上层协议，<code>/etc/protocols</code>文件定义了所有上层协议对应的protocol字段的数值，也可以通过<a href="https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xml" target="_blank" rel="noopener">IANA</a>获取</li><li>16位头部校验和（header checksum）由发送端填充，接收端对其使用CRC算法检验<strong>IP数据报头部</strong>在传输过程中是否损坏</li><li>32位源IP地址和目的端IP地址用来表示IP数据报的发送端和接收端，一般情况下这两个地址在整个数据报的传递过程中保持不变</li><li>选项字段（option）是一个可变长可选信息，这部分最多包含40字节，可选内容有<ul><li>记录路由（record route）告诉数据报途经的所有路由器都将自己的IP地址填入IP头部的选项部分，这样可以追踪数据报的传递路径</li><li>时间戳（timestamp）告诉每个路由器都将数据报被转发的时间（或时间与IP地址对）填入IP头部的选项部分，这样可以测量途经路由之间数据报传输的时间</li><li>松散源路由选择（loose source routing）指定一个路由器IP地址列表，数据报发送过程中必须经过其中所有路由器</li><li>严格源路由选择（strict source routing）和松散源路由选择类似，不过数据报只能经过被指定的路由器</li></ul></li></ul><h2 id="IP分片"><a href="#IP分片" class="headerlink" title="IP分片"></a>IP分片</h2><p>当IP数据报的长度超过帧的MTU时，它将被分片传输。分片可能发生在发送端，也有可能发生在中转路由器中，而且可能在传输的过程中多次分片，但只有再最终的目标机器上，这些分片才会被内核中的IP模块重新组装。<br>IP头部中提供数据报标识、标志和片偏移提供了足够的重组信息。一个IP数据报的每个分片都具有相同的标识值，但具有不同的片偏移。除了最后一个分片外，其他分片都将设置MF标志，每个分片的IP数据报总长度会被字段将会被设置为该分片的长度。<br>一般以太网帧的MTU是1500字节（可以通过ifconfig和netstat查看），IP数据报头部占用20字节，所以最大传输1480字节，这里利用ICMP可以产生IP数据报分片，ICMP头部信息占8字节，所以数据只用传输1473字节就能使IP数据报分片。<br>使用golang模拟这个情况</p><pre class=" language-go"><code class="language-go"><span class="token keyword">type</span> ICMP <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Type        <span class="token builtin">uint8</span>    Code        <span class="token builtin">uint8</span>    CheckSum    <span class="token builtin">uint16</span>    Identifier  <span class="token builtin">uint16</span>    SequenceNum <span class="token builtin">uint16</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">Checksum</span><span class="token punctuation">(</span>data <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token builtin">uint16</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> <span class="token punctuation">(</span>        sum    <span class="token builtin">uint32</span>        length <span class="token operator">=</span> <span class="token function">len</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>        index  <span class="token builtin">int</span>    <span class="token punctuation">)</span>    <span class="token keyword">for</span> length <span class="token operator">></span> <span class="token number">1</span> <span class="token punctuation">{</span>        sum <span class="token operator">+=</span> <span class="token function">uint32</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span> <span class="token operator">+</span> <span class="token function">uint32</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        index <span class="token operator">+=</span> <span class="token number">2</span>        length <span class="token operator">-=</span> <span class="token number">2</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> length <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">{</span>        sum <span class="token operator">+=</span> <span class="token function">uint32</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    sum <span class="token operator">+=</span> sum <span class="token operator">>></span> <span class="token number">16</span>    <span class="token keyword">return</span> <span class="token function">uint16</span><span class="token punctuation">(</span><span class="token operator">^</span>sum<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">getICMP</span><span class="token punctuation">(</span>seq <span class="token builtin">uint16</span><span class="token punctuation">)</span> ICMP <span class="token punctuation">{</span>    icmp <span class="token operator">:=</span> ICMP<span class="token punctuation">{</span>        Type<span class="token punctuation">:</span>        <span class="token number">8</span><span class="token punctuation">,</span>        Code<span class="token punctuation">:</span>        <span class="token number">0</span><span class="token punctuation">,</span>        CheckSum<span class="token punctuation">:</span>    <span class="token number">0</span><span class="token punctuation">,</span>        Identifier<span class="token punctuation">:</span>  <span class="token number">0</span><span class="token punctuation">,</span>        SequenceNum<span class="token punctuation">:</span> seq<span class="token punctuation">,</span>    <span class="token punctuation">}</span>    <span class="token keyword">var</span> buffer bytes<span class="token punctuation">.</span>Buffer    binary<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buffer<span class="token punctuation">,</span> binary<span class="token punctuation">.</span>BigEndian<span class="token punctuation">,</span> icmp<span class="token punctuation">)</span>    icmp<span class="token punctuation">.</span>CheckSum <span class="token operator">=</span> <span class="token function">Checksum</span><span class="token punctuation">(</span>buffer<span class="token punctuation">.</span><span class="token function">Bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    buffer<span class="token punctuation">.</span><span class="token function">Reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> icmp<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    icmp <span class="token operator">:=</span> <span class="token function">getICMP</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">DialIP</span><span class="token punctuation">(</span><span class="token string">"ip4:icmp"</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>net<span class="token punctuation">.</span>IPAddr<span class="token punctuation">{</span>IP<span class="token punctuation">:</span> net<span class="token punctuation">.</span>IP<span class="token punctuation">{</span><span class="token number">220</span><span class="token punctuation">,</span> <span class="token number">181</span><span class="token punctuation">,</span> <span class="token number">38</span><span class="token punctuation">,</span> <span class="token number">150</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token keyword">defer</span> conn<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    arr <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token number">1473</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> arr <span class="token punctuation">{</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">byte</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 将最后一个字节设置为0</span>    arr<span class="token punctuation">[</span><span class="token number">1472</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">var</span> buffer bytes<span class="token punctuation">.</span>Buffer    binary<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buffer<span class="token punctuation">,</span> binary<span class="token punctuation">.</span>BigEndian<span class="token punctuation">,</span> icmp<span class="token punctuation">)</span>    binary<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buffer<span class="token punctuation">,</span> binary<span class="token punctuation">.</span>BigEndian<span class="token punctuation">,</span> arr<span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">:=</span> conn<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>buffer<span class="token punctuation">.</span><span class="token function">Bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    conn<span class="token punctuation">.</span><span class="token function">SetReadDeadline</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second <span class="token operator">*</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    recv <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token number">2048</span><span class="token punctuation">)</span>    n<span class="token punctuation">,</span> err <span class="token operator">:=</span> conn<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>recv<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%#v"</span><span class="token punctuation">,</span> recv<span class="token punctuation">[</span><span class="token punctuation">:</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>我们可以通过wireshark查看数据报具体信息</p><p><img src="http://img-1251474779.cos.ap-beijing.myqcloud.com/IP%E5%8D%8F%E8%AE%AE/20191211022407734.png" alt="第一分片IP数据报头部信息"></p><p>上图可以看到Flags设置了MF标志</p><p><img src="http://img-1251474779.cos.ap-beijing.myqcloud.com/IP%E5%8D%8F%E8%AE%AE/20191211022558072.png" alt="第二分片IP数据报头部信息"></p><p>上图可以看到设置了数据报偏移量$185*8=1480$</p><p><img src="http://img-1251474779.cos.ap-beijing.myqcloud.com/IP%E5%8D%8F%E8%AE%AE/20191211022814706.png" alt="第一分片IP数据报局部内容"></p><p>上图蓝色区域表示IP数据报的数据部分，前8字节表示ICMP头部信息，后面是ICMP数据</p><p><img src="http://img-1251474779.cos.ap-beijing.myqcloud.com/IP%E5%8D%8F%E8%AE%AE/20191211022830044.png" alt="第二分片IP数据报内容"></p><p>上图说明分片后的IP数据报数据是承接上一个数据报，内核收到这些数据后将其拼装成一个完整IP数据报</p><h2 id="IP路由"><a href="#IP路由" class="headerlink" title="IP路由"></a>IP路由</h2><p>IP协议一个核心任务是数据报的路由，即决定发送数据报到目标机器的路径。</p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p><img src="http://img-1251474779.cos.ap-beijing.myqcloud.com/IP%E5%8D%8F%E8%AE%AE/IP%E6%A8%A1%E5%9D%97%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B.png" alt="IP模块基本工作流程"></p><p>当IP模块收到来自数据链路层的IP数据报时，先对数据报头部做CRC校验，确认无误后就分析其头部的具体信息。<br>如果IP数据报头部设置了源站路由选择（松散源路由选择或严格源路由选择），则IP模块调用数据报转发子模块来处理数据报。如果该IP数据报的头部中目标IP地址是本机的某个IP地址或者是广播地址（即该数据报是发给本机的），则IP模块就根据数据报头部中的协议来决定将它派发给那个上层协议处理。如果IP模块发现这个数据报不是发给本机的，则调用数据报转发子模块来处理数据报。<br>IP数据报转发子模块首先检查系统是否允许转发，如果不允许，IP模块就将数据报丢弃，如果允许则将会进行数据报转发。<br>IP数据报应该发送至哪一个路由（或目标机器），以及用哪张网卡发送，就是IP路由的过程，都是由计算下一跳路由子模块处理。数据报路由的核心结构是路由表，由目标IP进行分类，同一类型的IP数据报将被发往相同的下一跳路由。<br>IP输出队列中存放的是所有等待发送的IP数据报，其中除了需要转发的数据报外，还有本机封装的上层协议的IP数据报。<br>虚线箭头显示路由表更新过程，这个过程是指通过路由协议或者route命令调整路由表，是指更适应最新的网络拓扑结构，称之为IP路由策略。</p><h3 id="路由机制"><a href="#路由机制" class="headerlink" title="路由机制"></a>路由机制</h3><p>IP路由机制的核心就是IP路由表，可以使用route或者netstat查看路由表<br>路由表包含每项都有8个字段，字段含义如下：</p><table><thead><tr><th align="center">字段</th><th align="left">含义</th></tr></thead><tbody><tr><td align="center">Destination</td><td align="left">目标网络或主机</td></tr><tr><td align="center">Gateway</td><td align="left">网关地址，<code>*</code>表示和本机在同一个网络</td></tr><tr><td align="center">Genmask</td><td align="left">网络掩码</td></tr><tr><td align="center">Flags</td><td align="left">路由标志常见的标志有：<br><ul><li>U，该路由项是活动的</li><li>H，该路由项的目标是一台主机</li><li>G，该路由项的目标是网关</li><li>D，该路由项是有重定向生成的</li><li>M，该路由项被重新修改过</li></ul></td></tr><tr><td align="center">Metric</td><td align="left">路由距离，即到达指定网络所需的中转数</td></tr><tr><td align="center">Ref</td><td align="left">路由项被引用的次数（Linux未使用）</td></tr><tr><td align="center">Use</td><td align="left">该路由项被使用的次数</td></tr><tr><td align="center">Iface</td><td align="left">该路由项对应的输出网卡接口</td></tr></tbody></table><p>我们可以执行route命令获取当前的路由表</p><pre class=" language-sh"><code class="language-sh"># routeKernel IP routing tableDestination     Gateway         Genmask         Flags Metric Ref    Use Ifacedefault         gateway         0.0.0.0         UG    0      0        0 eth0172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</code></pre><p>目标地址表示default，即默认路由，在标志中有<code>G</code>表示下一跳是网关，网关地址是<code>gateway</code>，如果Gateway是<code>*</code>，则不需要中转，直接发送目标机器。<br>IP的路由机制分为以下3个步骤：</p><ul><li>步骤1，查找路由表中和数据报的目标地址IP地址完全匹配的主机IP地址，如果找到就使用该路由项，如果没有找到则转到步骤2</li><li>步骤2，查找路由表中和数据报的目标IP地址具有相同网络ID的网络IP地址，如果找到就使用该路由项，没有找到则转到步骤3</li><li>步骤3，选择默认路由项，通常意味着下一跳路由是网关</li></ul><p>有上面的路由表可知，发送到IP地址为<code>172.17.*.*</code>（<code>172.17.0.0/16</code>）的地址都可以将数据报直接发送到目标机器（路由表第二项），所有访问Internet的请求都将通过默认网关转发。</p><h3 id="路由表更新"><a href="#路由表更新" class="headerlink" title="路由表更新"></a>路由表更新</h3><p>路由表必须能够更新，以适应网络连接的变化，这样IP模块才能准确、高效的转发数据报。可以通过route命令手动修改路由表，是属于静态的路由更新方式，对于大型路由器，一般通过BGP（Border Gateway Protocol，边际网关协议）、RIP（Routing Information Protocol，路由信息协议）、OSPF（Open Shortest Path First，开放式最短路径优先）等协议来发现路径，并动态更新自己的路由表。</p><h2 id="IP转发"><a href="#IP转发" class="headerlink" title="IP转发"></a>IP转发</h2><p>IP模块把不是发送给本机的IP数据报将由数据报转发子模块来处理，路由器都能执行数据报的转发操作，而主机一般只发送和接收数据报，这是因为主机上的<code>/proc/sys/net/ipv4/ip_forward</code>内核参数默认设置为0，我们可以修改这个值来使主机的数据报转发功能。<br>IP数据报转发操作流程：</p><ul><li>检查数据报头部的TTL值，如果TTL值是0，则丢弃该数据报</li><li>查看数据报头部的阉割路由选择选项，如果该选项被设置，则检测数据报的目标IP地址是否是本机的某个IP地址，如果不是，则发送一个ICMP源站选路失败报文给发送端</li><li>如果有必要，则给源端发送一个ICMP重定向报文，以告诉它一个更合理的下一跳路由器</li><li>将TTL减1</li><li>处理IP头部选项</li><li>如果有必要，则执行IP分片操作</li></ul><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><h3 id="ICMP重定向报文"><a href="#ICMP重定向报文" class="headerlink" title="ICMP重定向报文"></a>ICMP重定向报文</h3><p>利用ICMP重定向报文可以告诉目标机器IP数据报应该使用哪个路由器转发，并且以此来更新路由表（通常是更新路由表缓冲，而不是直接更改路由表）。<br><code>/proc/sys/net/ipv4/conf/all/send_redirects</code>内核参数指定是否允许发送ICMP重定向报文，<code>/proc/sys/net/ipv4/conf/all/accept_redirects</code>内核参数则指定是否允许接收ICMP重定向报文，一般来说主机只能接收ICMP从定向报文，而路由器只能发送ICMP重定向报文。</p><h3 id="主机重定向"><a href="#主机重定向" class="headerlink" title="主机重定向"></a>主机重定向</h3><p>我们可以将目标主机设置开启转发功能，将本机网关设置为目标主机，这样就可以通过目标主机来访问Internet。<br>主机重定向流程：</p><ul><li>主机向目标主机发送IP数据报</li><li>目标主机向路由器发送数据，发现主机可以直接发送给它的路由器是比较合理的路径</li><li>目标主机向主机发送一个ICMP重定向报文</li><li>后序的IP数据报，主机都会直接发送给路由器</li></ul><h1 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h1><p>随着网络技术的发展IPv4已经无法满足需求，而且目前IPv4的地址已经分配完毕。IPv6协议不仅解决了IPv4地址不够用的情况，还做了很多改进。比如：增加了多播和流功能，为网络上多媒体内容的质量提供精细的控制；引入自动配置功能，使局域网管理更方便；增加了专门的网络安全功能等。</p><h2 id="头部结构-1"><a href="#头部结构-1" class="headerlink" title="头部结构"></a>头部结构</h2><p>IPv6头部由40字节固定头部和可变长的扩展头部组成</p><p><img src="http://img-1251474779.cos.ap-beijing.myqcloud.com/IP%E5%8D%8F%E8%AE%AE/IPv6header.png" alt="IPv6固定头部结构"></p><ul><li>4位版本号（version）对于IPv6来说，其值是6</li><li>8位通信类型（traffic class）只是数据流通信类型或优先级，和IPv4的TOS类似</li><li>20位流标签（flow label）是IPv6新加字段，对于某些对连接的服务质量有特殊要求的通信，比如音频或视频等实时数据传输</li><li>16位荷载长度（payload length）指的是IPv6扩展头部和应用程序长度之和，不包括固定头部长度</li><li>8位下一个包头（next header）指出紧跟IPv6固定头部后的包头类型，如扩展头（如果有的话）或某个上层协议头（比如TCP，UPD和ICMP），它类似于IPv4头部中的协议字段，且取值相同含义相同</li><li>8位跳数限制（hop limit）和IPv4的TTL相同</li><li>128位表示源IP和目的IP地址，16字节使IP地址的总量达到了$2^{128}$个，号称IPv6能使地球上每一粒沙子都能分配一个IP地址</li></ul><p>IPv4使用点分十进制表示IP地址，而IPv6地址则使用16进制字符串表示，比如<code>fe80:0000:0000:0000:0000:0000:0000:0001</code>。IPv6地址使用<code>:</code>分隔成8组，每组包含，使用16进制表示2个字节。由于0太多的话，这样表示过于麻烦，所以可以使用零压缩法将其简写，就是省略中间全是0的组，上面的例子就可以简写成<code>fe80::1</code>，零压缩法只能在IPv6地址中使用一次，不然无法知道中间的省略了多少个零。</p><h2 id="扩展头"><a href="#扩展头" class="headerlink" title="扩展头"></a>扩展头</h2><p>可变长的扩展头部使得IPv6能支持更多的选项，并且很便于将来的扩展需要。它的长度可以是零，表示数据报没有使用任何扩展头部，一个数据报可以包含多个扩展头部，每个扩展头部的类型由前一个头部（固定头部或扩展头部）中的下一个报头字段指定，目前使用的扩展头部有：</p><table><thead><tr><th align="center">扩展头部</th><th>含义</th></tr></thead><tbody><tr><td align="center">Hop-by-Hop</td><td>逐跳选项头部，它包含每个路由器都必须检查和处理的特殊参数选项</td></tr><tr><td align="center">Destination option</td><td>目的选项头部，指定由最终目的节点处理的选项</td></tr><tr><td align="center">Routing</td><td>路由头部，指定数据报要经过哪些中转路由，功能类似于IPv4的松散源路由选择选项和记录路由选项</td></tr><tr><td align="center">Fragment</td><td>分片头部，处理分片和重组的细节</td></tr><tr><td align="center">Authentication</td><td>认证头部，提供数据源认证、数据完整性检查和反重播保护</td></tr><tr><td align="center">Encapsulation Security Payload</td><td>加密头部，提供加密服务</td></tr><tr><td align="center">No next header</td><td>没有后续扩展头部</td></tr></tbody></table><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li>《Linux高性能服务器编程》</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IP </tag>
            
            <tag> IPv4 </tag>
            
            <tag> IPv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git stash</title>
      <link href="/git/git-stash.html"/>
      <url>/git/git-stash.html</url>
      
        <content type="html"><![CDATA[<h1 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h1><p>将当前所有更改记录存放于栈区，可以在必要时将当前的更改恢复<br>应用场景：</p><ul><li>需要切换分支，但是不想commit目前的文件更改</li><li>用于临时切换分支</li></ul><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>git stash<br>将当前更改存储到栈区，当前文件目录就会回退到最近分支commit的状态</p><p>apply   – 应用stash中的更改记录，调回指定的存储，如果不指明则默认最新存储。如果应用存储是会发生冲突的，所以应用后需要合并冲突<br>branch  – 在最初创建存储的提交处分支，如果你存储一份修改，暂时不去理会，然后继续在你存储的分支上工作，你在重新应用工作时可能会碰到一些问题合并冲突的问题<br>这个命令会创建一个新的分支，检查你存储的提交，重新应用分支，如果成功，将会丢弃储藏<br>clear   – 删除所有stash<br>create  – 创建一个存储而不将其存储在ref命名空间中<br>drop    – 从list中删除一个stash<br>list    – 列出所有的stash<br>pop     – 从stash列表中删除并应用最近的stash<br>save    – 将您的本地修改保存到新的stash中<br>show    – 展示在stash中的修改记录的差异</p><h2 id="与commit的区别"><a href="#与commit的区别" class="headerlink" title="与commit的区别"></a>与commit的区别</h2><p>commit会记录在历史记录中，而stash不会</p><p>实体包：数据传输结构体定义<br>工具包：功能函数实现<br>错误包：产生错误定义<br>模拟包：mock数据定义，函数实现<br>部署包：部署远端服务器实现<br>数据层：远端数据层实现<br>服务层：本地功能实现<br>路由层：分配路由，指定处理服务handle</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> cmd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis conf 说明</title>
      <link href="/redis/redis-pei-zhi-wen-jian.html"/>
      <url>/redis/redis-pei-zhi-wen-jian.html</url>
      
        <content type="html"><![CDATA[<p>最新Redis配置文件获取<a href="http://download.redis.io/redis-stable/redis.conf" target="_blank" rel="noopener">redis.conf</a></p><h1 id="start"><a href="#start" class="headerlink" title="start"></a>start</h1><p>启动Redis启动。</p><pre class=" language-sh"><code class="language-sh">$ ./redis-server /path/to/redis.conf</code></pre><p>配置文件单位说明，单位不区分大小写。</p><pre class=" language-sh"><code class="language-sh"># 1k => 1000 bytes# 1kb => 1024 bytes# 1m => 1000000 bytes# 1mb => 1024 * 1024 bytes# 1g => 1000000000 bytes# 1gb => 1024 * 1024 * 1024 bytes</code></pre><h1 id="include"><a href="#include" class="headerlink" title="include"></a>include</h1><p><code>include</code>可以引入其他的配置文件，且不会被<code>CONFIG REWRITE</code>命令复写。Redis总是使用最后处理的行作为配置指令的值，最好在文件开始的时候<code>include</code>，避免运行时复写配置。如果想用<code>include</code>覆盖之前的配置可以放在文件末尾。</p><pre class=" language-sh"><code class="language-sh"># include /path/to/local.conf# include /path/to/other.conf</code></pre><h1 id="module"><a href="#module" class="headerlink" title="module"></a>module</h1><p>在启动时加载模块，如果无法加载，Redis会<code>abort</code>，可以同时加载多个模块。</p><pre class=" language-sh"><code class="language-sh"># loadmodule /path/to/my_module.so# loadmodule /path/to/other_module.so</code></pre><h1 id="network"><a href="#network" class="headerlink" title="network"></a>network</h1><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><p>默认地，如果没有指定<code>bind</code>指令，Redis监听监听服务器上所有可用网络接口的连接。可以使用<code>bind</code>配置指令只侦听一个或多个选定的网卡接口，后跟一个或多个IP地址。<br>如果不指定bind指定是一件很危险的事，所以Redis默认指定本地的环回地址。</p><pre class=" language-sh"><code class="language-sh"># bind 192.168.1.100 10.0.0.1bind 127.0.0.1 ::1</code></pre><h2 id="protected-mode"><a href="#protected-mode" class="headerlink" title="protected-mode"></a>protected-mode</h2><p>保护模式是一层安全保护，以避免Redis实例在Internet上保持打开状态被访问和利用。<br>当保护模式打开，并且：</p><ul><li>Redis未<code>bind</code>到一组地址</li><li>没有配置密码</li></ul><p>Redis只能接受来自IPv4和IPv6环回地址（127.0.0.1和::1）、Unix域套接字的连接。<br>保护模式默认是打开的。如果想其他地址访问Redis没有使用密码，或没有使用bind指定网络接口可以关闭保护模式。</p><pre class=" language-sh"><code class="language-sh">protected-mode yes</code></pre><h2 id="port"><a href="#port" class="headerlink" title="port"></a>port</h2><p>接受指定端口的连接。如果指定为0，Redis不会监听TCP socket。</p><pre class=" language-sh"><code class="language-sh">port 6379</code></pre><h2 id="tcp-backlog"><a href="#tcp-backlog" class="headerlink" title="tcp-backlog"></a>tcp-backlog</h2><p>TCP listen()函数的backlog参数，挂起连接队列的最大长度。</p><pre class=" language-sh"><code class="language-sh">tcp-backlog 511</code></pre><h2 id="Unix-socket"><a href="#Unix-socket" class="headerlink" title="Unix socket"></a>Unix socket</h2><p>指定<code>Unix socket</code>的路径，Redis默认不监听<code>Unix socket</code>。</p><pre class=" language-sh"><code class="language-sh"># unixsocket /tmp/redis.sock# unixsocketperm 700</code></pre><h2 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h2><p>设置连接多少秒没有使用后断开连接，0表示不启用。</p><pre class=" language-sh"><code class="language-sh">timeout 0</code></pre><h2 id="TCP-keepalive"><a href="#TCP-keepalive" class="headerlink" title="TCP keepalive"></a>TCP keepalive</h2><p>如果非零，使用SO_KEEPALIVE发送TCP ACK，来保活连接。<br>这样做有两个理由：</p><ul><li>检测对端状态</li><li></li></ul><p>在Linux上，每隔指定的值（单位秒）都会发送TCP ACK，如果需要关闭连接则需要两倍这个时间。<br>其他内核取决于内核配置。<br>Redis默认300秒。</p><pre class=" language-sh"><code class="language-sh">tcp-keepalive 300</code></pre><h1 id="general"><a href="#general" class="headerlink" title="general"></a>general</h1><h2 id="daemonize"><a href="#daemonize" class="headerlink" title="daemonize"></a>daemonize</h2><p>Redis默认是不作为<code>daemon</code>运行，可以使用<code>yes</code>启动该选项。<br>Redis在启用指令后会在<code>/var/run/redis.pid</code>产生<code>pid</code>文件。</p><pre class=" language-sh"><code class="language-sh">daemonize no</code></pre><h2 id="supervised"><a href="#supervised" class="headerlink" title="supervised"></a>supervised</h2><p>如果使用upstart或者systemd启动Redis，可以使用supervised指令进行交互。<br>选项：</p><ul><li>no - 不使用supervision交互</li><li>upstart - 让Redis进入<code>SIGSTOP</code>模式</li><li>systemd - 向<code>$NOTIFY_SOCKET</code>写入<code>READY=1</code></li><li>auto - 基于环境变量<code>UPSTART_JOB</code>或 <code>NOTIFY_SOCKET</code>来设置upstart还是systemd模式</li></ul><p>supervised只表示进程已经就绪，并不持续supervisor。</p><pre class=" language-sh"><code class="language-sh">supervised no</code></pre><h2 id="pidfile"><a href="#pidfile" class="headerlink" title="pidfile"></a>pidfile</h2><p>如果指定了pidfile，那么Redis将会在启动的时候写入，退出的时候删除。<br>当Redis启动是使用非daemonized，配置中没有指定pidfile，则不会有pidfile创建；当Redis使用daemonized启动时，即使没有指定pidfile，也会创建，默认是<code>/var/run/redis.pid</code>。<br>如果Redis无法创建pidfile，也不会产生任何影响，Redis依旧可以正常启动和运行。</p><pre class=" language-sh"><code class="language-sh">pidfile /var/run/redis_6379.pid</code></pre><h2 id="loglevel"><a href="#loglevel" class="headerlink" title="loglevel"></a>loglevel</h2><p>设置日志等级：</p><ul><li>debug，对开发测试有用</li><li>verbose，一些有用的信息，不像debug那么杂乱</li><li>notice，一般生产日志</li><li>warning，记录关键信息</li></ul><pre class=" language-sh"><code class="language-sh">loglevel notice</code></pre><h2 id="logfile"><a href="#logfile" class="headerlink" title="logfile"></a>logfile</h2><p>指定日志文件名，空字符串表示Redis日志强制输出到标准输出。如果使用daemonized并且把日志输出到标准输出，则日志会被发送到<code>/dev/null</code>。</p><pre class=" language-sh"><code class="language-sh">logfile ""</code></pre><h2 id="syslog"><a href="#syslog" class="headerlink" title="syslog"></a>syslog</h2><h3 id="enabled"><a href="#enabled" class="headerlink" title="enabled"></a>enabled</h3><p>将日志输出到system logger，指定<code>syslog-enabled</code>为<code>yes</code>，可以按照需求添加其他参数。</p><pre class=" language-sh"><code class="language-sh"># syslog-enabled no</code></pre><h3 id="ident"><a href="#ident" class="headerlink" title="ident"></a>ident</h3><p>指定syslog标识。</p><pre class=" language-sh"><code class="language-sh"># syslog-ident redis</code></pre><h3 id="facility"><a href="#facility" class="headerlink" title="facility"></a>facility</h3><p>指定syslog的<code>facility</code>，必须是<code>USER</code>或介于<code>LOCAL0-LOCAL7</code>。</p><pre class=" language-sh"><code class="language-sh"># syslog-facility local0</code></pre><h2 id="databases"><a href="#databases" class="headerlink" title="databases"></a>databases</h2><p>设置Redis数据库的数量，默认<code>DB</code>是0，可以使用<code>SELECT</code>选择<code>dbid</code>介于<code>0-databases-1</code>。</p><pre class=" language-sh"><code class="language-sh">databases 16</code></pre><h2 id="show-logo"><a href="#show-logo" class="headerlink" title="show logo"></a>show logo</h2><p>默认在Redis启动的时候打印<code>ASCII logo</code>，仅在log输出在标准输出或标准输出是TTY的时候。只有在交互式的时候才显示<code>logo</code>。</p><pre class=" language-sh"><code class="language-sh">always-show-logo yes</code></pre><h1 id="snapshotting"><a href="#snapshotting" class="headerlink" title="snapshotting"></a>snapshotting</h1><h2 id="save"><a href="#save" class="headerlink" title="save"></a>save</h2><p>数据库快照，将Redis数据保存到disk，命令<code>save second changes</code>。<br>当指定秒和写操作次数同时满足的时候写入disk。<br>可以通过注释掉save来禁用快照，也可以使用<code>save ""</code>来禁用已经设置的快照选项。<br>示例表示：</p><ul><li>900秒（15分钟）至少有一个键改动</li><li>300秒（5分钟）至少有10个键改动</li><li>60秒（1分钟）至少有10000个键改动<pre class=" language-sh"><code class="language-sh">save 900 1save 300 10save 60 10000</code></pre></li></ul><h2 id="stop-writes-on-bgsave-error"><a href="#stop-writes-on-bgsave-error" class="headerlink" title="stop-writes-on-bgsave-error"></a>stop-writes-on-bgsave-error</h2><p>当启动RDB快照时，Redis会停止写入，并且最后一次后台保存会失败。</p><pre class=" language-sh"><code class="language-sh">stop-writes-on-bgsave-error yes</code></pre><h2 id="rdbcompression"><a href="#rdbcompression" class="headerlink" title="rdbcompression"></a>rdbcompression</h2><p>当使用dump .rdb数据库时，是否使用LZF压缩字符串对象</p><pre class=" language-sh"><code class="language-sh">rdbcompression yes</code></pre><h2 id="rdbchecksum"><a href="#rdbchecksum" class="headerlink" title="rdbchecksum"></a>rdbchecksum</h2><p>CRC64校验和存放于RDB文件的末尾，这可以抵抗损坏，但是有性能问题，可以禁用。</p><pre class=" language-sh"><code class="language-sh">rdbchecksum yes</code></pre><h2 id="dbfilename"><a href="#dbfilename" class="headerlink" title="dbfilename"></a>dbfilename</h2><p>指定dump文件</p><pre class=" language-sh"><code class="language-sh">dbfilename dump.rdb</code></pre><h2 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h2><p>指定工作目录，<code>dbfilename</code>指定的文件将会在<code>dir</code>中创建，只追加的文件也在此目录中创建。<br><code>dir</code>必须指定一个目录，非文件路径。</p><pre class=" language-sh"><code class="language-sh">dir ./</code></pre><h1 id="replication"><a href="#replication" class="headerlink" title="replication"></a>replication</h1><h2 id="replicaof"><a href="#replicaof" class="headerlink" title="replicaof"></a>replicaof</h2><p><code>Master-Replica</code>拷贝，使用replicaof让一个Redis实例复制另一个Redis实例。<br>相关概念：</p><ul><li>Redis复制是异步的，如果一个主Redis实例没有与给定数量的副本连接，那么可以配置他停止接收写操作</li><li>如果复制链接丢失的时间相对较少，Redis副本可以与主服务器执行部分重新同步。根据需要，您可能需要使用合理的值配置复制积压工作的大小（请参阅此文件的下一节）。</li><li>复制是一个自动的过程，网络分区副本自动尝试重新连接到主服务器，并与它们重新同步。</li></ul><pre class=" language-sh"><code class="language-sh"># replicaof masterip masterport</code></pre><h2 id="masterauth"><a href="#masterauth" class="headerlink" title="masterauth"></a>masterauth</h2><p>如果master有密码（使用requirepass配置），副本在复制的之前必须要验证密码，否则将拒绝复制。</p><pre class=" language-sh"><code class="language-sh"># masterauth <master-password></code></pre><h2 id="replica-serve-stale-data"><a href="#replica-serve-stale-data" class="headerlink" title="replica-serve-stale-data"></a>replica-serve-stale-data</h2><p>当副本与master断开连接，或当复制正在进行时，副本可以以两种不同的方式发挥做用：</p><ul><li>如果将<code>replica-serve-stale-data</code>设置成<code>yes</code>，副本将仍然回复客户端的请求，可能数据已过期，或者为空</li><li>如果将<code>replica-serve-stale-data</code>设置成<code>no</code>，副本将用<code>SYNC with master in progress</code>回复所有请求，除了<code>INFO</code>，<code>replicaOF</code>，<code>AUTH</code>，<code>PING</code>，<code>SHUTDOWN</code>，<code>REPLCONF</code>，<code>ROLE</code>，<code>CONFIG</code>，<code>SUBSCRIBE</code>，<code>UNSUBSCRIBE</code>，<code>PSUBSCRIBE</code>，<code>PUNSUBSCRIBE</code>，<code>PUBLISH</code>，<code>PUBSUB</code>，<code>COMMAND</code>，<code>POST</code>，<code>HOST:</code>，<code>LATENCY</code></li></ul><pre class=" language-sh"><code class="language-sh">replica-serve-stale-data yes</code></pre><h2 id="replica-read-only"><a href="#replica-read-only" class="headerlink" title="replica-read-only"></a>replica-read-only</h2><p>设置副本实例是否可以写，默认副本是只读的。副本仍可以执行所有管理命令，可以使用<code>rename-command</code>遮蔽这些管理命令。</p><pre class=" language-sh"><code class="language-sh">replica-read-only yes</code></pre><h2 id="repl-diskless-sync"><a href="#repl-diskless-sync" class="headerlink" title="repl-diskless-sync"></a>repl-diskless-sync</h2><p>新的复制副本和重新连接的复制副本无法继续仅接收差异的复制过程，需要执行所谓的“完全同步”。RDB文件从主服务器传输到副本服务器。<br>传输可以通过两种不同的方式进行：</p><ul><li>磁盘支持，Redis主服务器创建一个新进程，将RDB文件写入磁盘，稍后，父进程将文件以递增方式传输到副本。</li><li>无磁盘，Redis主服务器创建一个新进程，将RDB文件写入副本套接字，不通过磁盘。</li></ul><p>使用磁盘备份复制，在生成RDB文件的同时，可以在生成RDB文件的当前子级完成工作后，将更多的副本排队并与RDB文件一起提供服务。<br>在无盘复制中，一旦传输开始，到达的新副本将排队，当当前副本终止时，将开始新的传输。<code>master</code>实例机会在开始传输之前等待一段可配置的时间（以秒为单位），以希望多个副本能够到达，并且可以并行传输。<br>使用低速磁盘和快速（大带宽）网络，无盘复制工作得更好。</p><pre class=" language-sh"><code class="language-sh">repl-diskless-sync no</code></pre><h2 id="repl-diskless-sync-delay"><a href="#repl-diskless-sync-delay" class="headerlink" title="repl-diskless-sync-delay"></a>repl-diskless-sync-delay</h2><p>启动无盘复制时，可以配置服务器的等待延迟，这一点很重要，因为一旦传输开始，就不可能为到达的新副本提供服务，这些副本将排队等待下一次RDB传输，因此服务器将等待一段延迟，以便让更多副本到达。<br>默认5秒，设置为0表示禁用</p><pre class=" language-sh"><code class="language-sh">repl-diskless-sync-delay 5</code></pre><h2 id="repl-ping-replica-period"><a href="#repl-ping-replica-period" class="headerlink" title="repl-ping-replica-period"></a>repl-ping-replica-period</h2><p>副本以预先定义的间隔向服务器发送ping。可以使用<code>repl-ping-replica-period</code>选项更改此间隔。默认值为10秒。</p><pre class=" language-sh"><code class="language-sh"># repl-ping-replica-period 10</code></pre><h2 id="repl-timeout"><a href="#repl-timeout" class="headerlink" title="repl-timeout"></a>repl-timeout</h2><p>以下情况会复制超时：</p><ul><li>从副本角度看，同步期间的批量传输I/O。</li><li>从副本角度看，master实例超时。</li><li>从master实例看，复制超时。</li></ul><p>确保<code>repl-timeout</code>比<code>repl-ping-replica-period</code>大，否则每次主服务器和副本之间的通信量低时都会检测到超时。</p><pre class=" language-sh"><code class="language-sh"># repl-timeout 60</code></pre><h2 id="repl-disable-tcp-nodelay"><a href="#repl-disable-tcp-nodelay" class="headerlink" title="repl-disable-tcp-nodelay"></a>repl-disable-tcp-nodelay</h2><p>在副本发送<code>SYNC</code>后禁用<code>TCP_NODELAY</code>？<br>如果选择<code>yes</code>，Redis会占用少量带宽发送少量TCP包给副本，但这可能会增加副本同步延迟，使用Linux内核默认配置最多可延迟40毫秒。<br>如果选择<code>no</code>，延迟会减少，但是会占用更多带宽用于复制。<br>默认选择<code>no</code>，但是在非常高流量下或者master和副本之间有多跳时，<code>yes</code>也是不错的选择。</p><pre class=" language-sh"><code class="language-sh">repl-disable-tcp-nodelay no</code></pre><h2 id="repl-backlog-size"><a href="#repl-backlog-size" class="headerlink" title="repl-backlog-size"></a>repl-backlog-size</h2><p>设置副本<code>backlog</code>大小，<code>backlog</code>是一个缓冲区，当副本断开连接一段时间后，它会累积副本数据，因此当副本希望再次重新连接时，通常不需要完全重新同步，部分重新同步就足够了，只需传递断开连接时副本丢失的数据部分。只有在至少连接了一个副本后，才会分配积压工作。</p><pre class=" language-sh"><code class="language-sh">#repl-backlog-size 1mb</code></pre><h2 id="repl-backlog-ttl"><a href="#repl-backlog-ttl" class="headerlink" title="repl-backlog-ttl"></a>repl-backlog-ttl</h2><p>当master不在连接副本一段时间后释放backlog，该选项设置最后一个断开连接的副本后多久释放backlog，单位秒。如果为0，则永不释放。副本不会释放backlog，所以总是积压。</p><pre class=" language-sh"><code class="language-sh"># repl-backlog-ttl 3600</code></pre><h2 id="replica-priority"><a href="#replica-priority" class="headerlink" title="replica-priority"></a>replica-priority</h2><p>副本优先级，当master不在工作时，升级优先级编号低的成为master。当设置成0时，表示无法变成master。默认情况下优先级为100。</p><pre class=" language-sh"><code class="language-sh">replica-priority 100</code></pre><h2 id="min-replicas-to-write"><a href="#min-replicas-to-write" class="headerlink" title="min-replicas-to-write"></a>min-replicas-to-write</h2><p>如果小于指定副本数量，并且通信小于指定时间，master会停止写入操作。副本必须都处于在线状态。其中一个选项为0表示禁用。默认禁用。<br>示例表示，3个副本并且滞后10秒。</p><pre class=" language-sh"><code class="language-sh"># min-replicas-to-write 3# min-replicas-max-lag 10</code></pre><h2 id="replica-announce-ip"><a href="#replica-announce-ip" class="headerlink" title="replica-announce-ip"></a>replica-announce-ip</h2><p>Redis master可以通过指定副本地址连接副本，Redis Sentinel可以发现副本实例。<br>复制副本通常报告的列出的IP和地址是通过以下方式获得的：</p><ul><li>IP，通过检查复制副本用于与主服务器连接的套接字的对等地址，可以自动检测该地址。</li><li>port，在复制握手期间，该端口由副本通信，通常是副本用来侦听连接的端口。</li></ul><p>但是，当使用端口转发或网络地址转换（NAT）时，复制副本实际上可以通过不同的IP和端口对访问。副本可以使用以下两个选项向其主服务器报告一组特定的IP和端口，以便信息和角色都报告这些值。</p><pre class=" language-sh"><code class="language-sh"># replica-announce-ip 5.5.5.5# replica-announce-port 1234</code></pre><h1 id="security"><a href="#security" class="headerlink" title="security"></a>security</h1><h2 id="requirepass"><a href="#requirepass" class="headerlink" title="requirepass"></a>requirepass</h2><p>设置密码，客户端在使用的时候需要使用<code>AUTH</code>鉴权。</p><pre class=" language-sh"><code class="language-sh"># requirepass foobared</code></pre><h2 id="rename-command"><a href="#rename-command" class="headerlink" title="rename-command"></a>rename-command</h2><p>重命名命令。如果设置为空表示禁用命令。修改命令可能会在AOF模式或传输到副本中引发问题。</p><pre class=" language-sh"><code class="language-sh"># rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52# rename-command CONFIG ""</code></pre><h1 id="client"><a href="#client" class="headerlink" title="client"></a>client</h1><h2 id="maxclient"><a href="#maxclient" class="headerlink" title="maxclient"></a>maxclient</h2><p>设置客户端最大连接数，如果不指定则是当前文件系统最大值减32，达到限制后新的连接会收到<code>max number of clients reached</code>错误。</p><pre class=" language-sh"><code class="language-sh"># maxclients 10000</code></pre><h1 id="memory-management"><a href="#memory-management" class="headerlink" title="memory management"></a>memory management</h1><h2 id="maxmemory"><a href="#maxmemory" class="headerlink" title="maxmemory"></a>maxmemory</h2><p>设置占用内存最大值字节数，达到内存限制时，会采用所选的策略删除键。<br>如果Redis无法根据策略删除密钥，或者策略设置为<code>noeviction</code>。如果命令将使用更多内存，如SET，LPUSH等时，Redis将开始回复错误。只读命令正常回复。<br>当将Redis用作LRU或LFU缓存，或为实例设置硬内存限制（使用<code>noevection</code>策略）时，此选项通常很有用。<br>如果将副本附加到一个启用了<code>maxmemory</code>的实例上，则会从已用的内存计数中减去提供副本所需的输出缓冲区的大小，这样网络问题或重新同步就不会触发一个循环，在该循环中取出键，而反过来，输出缓冲区的复制副本中充满了被收回的键的del，从而导致删除更多的键，等等，直到数据库完全清空。<br>简而言之，如果您附加了副本，建议您为<code>maxmemory</code>设置一个较低的限制，以便系统上有一些用于副本输出缓冲区的可用RAM（但如果策略为<code>noevicetion</code>，则不需要这样做）。</p><pre class=" language-sh"><code class="language-sh"># maxmemory <bytes></code></pre><h2 id="maxmemory-policy"><a href="#maxmemory-policy" class="headerlink" title="maxmemory-policy"></a>maxmemory-policy</h2><p>当内存到达maxmemory的限制时，可以采用以下选项清理内存：</p><ul><li>volatile-lru，在具有过期集的密钥中使用近似的LRU逐出。</li><li>allkeys-lru，使用近似的LRU逐出任何密钥。</li><li>volatile-lfu，在具有过期集的键中使用近似的逐出。</li><li>allkeys-lfu，使用近似的LFU逐出任何键。</li><li>volatile-random，在有过期集的密钥中删除一个随机密钥。</li><li>allkeys-random，随机删除任意键。</li><li>volatile-ttl，删除最接近过期时间的密钥（次要TTL）。</li><li>noeviction，不要逐出任何内容，只返回写操作错误。</li></ul><p>LRU指<code>Least Recently Used</code>，LFU指<code>Least Frequently Used</code>。<br>当操作命令是<code>set</code> <code>setnx</code> <code>setex</code> <code>append</code> <code>incr</code> <code>decr</code> <code>rpush</code> <code>lpush</code> <code>rpushx</code> <code>lpushx</code> <code>linsert</code> <code>lset</code> <code>rpoplpush</code> <code>sadd</code> <code>sinter</code> <code>sinterstore</code> <code>sunion</code> <code>sunionstore</code> <code>sdiff</code> <code>sdiffstore</code> <code>zadd</code> <code>zincrby</code> <code>zunionstore</code> <code>zinterstore</code> <code>hset</code> <code>hsetnx</code> <code>hmset</code> <code>hincrby</code> <code>incrby</code> <code>decrby</code> <code>getset</code> <code>mset</code> <code>msetnx</code> <code>exec</code> <code>sort</code>时，如果没有合适的键删除时返回错误。<br>默认<code>noeviction</code>。</p><pre class=" language-sh"><code class="language-sh"># maxmemory-policy noeviction</code></pre><h2 id="maxmemory-samples"><a href="#maxmemory-samples" class="headerlink" title="maxmemory-samples"></a>maxmemory-samples</h2><p>LRU，LFU和最小的TTL算法是不准确的算法，可以通过设置改选项提高精确度。<br>默认值为5会产生足够好的结果。10近似非常接近但成本更高的CPU，3更快但不是很准确。</p><pre class=" language-sh"><code class="language-sh"># maxmemory-samples 5</code></pre><h2 id="replica-ignore-maxmemory"><a href="#replica-ignore-maxmemory" class="headerlink" title="replica-ignore-maxmemory"></a>replica-ignore-maxmemory</h2><p>副本会忽略<code>maxmemory</code>指令，当master剔除键会发送DEL进行同步。但是如果副本可写，或者希望与master内存设置不一样，并且确定写入是幂等的，可以设置此值。</p><pre class=" language-sh"><code class="language-sh"># replica-ignore-maxmemory yes</code></pre><h1 id="lazy-freeing"><a href="#lazy-freeing" class="headerlink" title="lazy freeing"></a>lazy freeing</h1><p>Redis有两种方法删除键。一种是通过DEL阻塞的删除对象，删除时间与键关联的内存大小有关，如果是大key则可能会阻塞服务器很久。所以Redis提供异步删除。例如：<code>UNLINK</code>，<code>FLUSHALL</code>，<code>FLUSHDB</code>，会以恒定的时间，后台逐步释放。<br>这些命令是用户主动调用的，在某些情况下，Redis会主动的删除键：</p><ul><li>到达内存限制的时候，会主动调用剔除策略进行删除键；</li><li>键到达了过期时间；</li><li>修改键值可能会删除原有内容，例如<code>RENAME</code>，<code>SET</code>等；</li><li>在复制过程中，当一个副本与其主服务器执行完全重新同步时，将删除整个数据库的内容，以便加载刚刚传输的RDB文件。</li></ul><p>在上述所有情况下，默认情况是以阻塞方式删除对象，就像调用<code>DEL</code>一样。但是，您可以具体配置每种情况，以便以非阻塞方式释放内存，就像调用<code>UNLINK</code>时一样，使用以下配置指令：</p><pre class=" language-sh"><code class="language-sh">lazyfree-lazy-eviction nolazyfree-lazy-expire nolazyfree-lazy-server-del noreplica-lazy-flush no</code></pre><h1 id="append-only-mode"><a href="#append-only-mode" class="headerlink" title="append only mode"></a>append only mode</h1><h2 id="appendonly-no"><a href="#appendonly-no" class="headerlink" title="appendonly no"></a>appendonly no</h2><p>默认情况，Redis采用异步的方式转储磁盘，但有可能丢失数据，取决于保存点。<br>Redis提供追加模式，一种更好的持久性。例如使用fsync policy，Redis仅会丢失1秒的写入或Redis进程本身发生什么错误丢失写入数据，但是系统仍能正常运行。<br><code>AOF</code>和<code>RDB</code>持久性可以同时启用而不会出现问题。如果在启动时启用<code>AOF</code>，Redis将加载<code>AOF</code>。</p><pre class=" language-sh"><code class="language-sh">appendonly no</code></pre><h2 id="appendfilename"><a href="#appendfilename" class="headerlink" title="appendfilename"></a>appendfilename</h2><p>指定追加文件</p><pre class=" language-sh"><code class="language-sh">appendfilename "appendonly.aof"</code></pre><h2 id="appendfsync"><a href="#appendfsync" class="headerlink" title="appendfsync"></a>appendfsync</h2><p><code>fsync()</code>调用告诉操作系统在磁盘上实际写入数据，而不是在输出缓冲区中等待更多数据。有些操作系统将真正刷新磁盘上的数据，而另一些操作系统则会尽快进行刷新。<br>Redis支持三种模式：</p><ul><li><code>no</code>，不调用<code>fsync()</code>，仅让操作系统管理刷新数据，快速；</li><li><code>always</code>，每次写入数据的时候添加文件，慢，安全；</li><li><code>everysec</code>，每秒添加一次，折中。</li></ul><p>默认采用<code>everysec</code>。</p><pre class=" language-sh"><code class="language-sh"># appendfsync alwaysappendfsync everysec# appendfsync no</code></pre><h2 id="no-appendfsync-on-rewrite"><a href="#no-appendfsync-on-rewrite" class="headerlink" title="no-appendfsync-on-rewrite"></a>no-appendfsync-on-rewrite</h2><p>当<code>AOF</code>的同步策略设置为<code>always</code>或<code>everysec</code>时，后台保存数据，这会有大量<code>IO</code>操作，在某些平台下，调用<code>fsync()</code>会阻塞很长时间。<br>为了缓解这个问题，可以使用<code>BGSAVE</code>或<code>BGREWRITEAOF</code>止主进程调用<code>fsync()</code>阻塞。<br>这意味着当另一个子进程正在保存时，redis的耐久性与<code>appendfsync none</code>相同。实际上，这意味着在最坏的情况下（使用默认的Linux设置），可能会丢失长达30秒的日志。<br>如果遇到延迟问题，请将其转为<code>yes</code>。否则 ，从耐久性的角度来看，<code>no</code>，这是最安全的选择。</p><pre class=" language-sh"><code class="language-sh">no-appendfsync-on-rewrite no</code></pre><h2 id="auto-aof-rewrite-percentage"><a href="#auto-aof-rewrite-percentage" class="headerlink" title="auto-aof-rewrite-percentage"></a>auto-aof-rewrite-percentage</h2><p>自动重写仅附加文件。 当<code>AOF</code>日志大小增长指定的百分比时， Redis能够自动重写日志文件，隐式调用<code>BGREWRITEAOF</code>。<br>工作方式：Redis会记录最后一次复写时<code>AOF</code>文件大小，如果复写发生在重启时，这个大小是<code>AOF</code>在启动的时使用。<br>将此基本大小与当前大小进行比较。如果当前大小大于指定的百分比，则会触发重写。另外需要为要重写的<code>AOF</code>文件指定最小大小，这对于避免重写<code>AOF</code>文件很有用，即使达到了增加的百分比，但仍然很小。<br>指定零的百分比以禁用自动AOF重写功能。</p><pre class=" language-sh"><code class="language-sh">auto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mb</code></pre><h2 id="aof-load-truncated"><a href="#aof-load-truncated" class="headerlink" title="aof-load-truncated"></a>aof-load-truncated</h2><p>在Redis启动过程中，当<code>AOF</code>数据被加载回内存时，可能会发现<code>AOF</code>文件在末尾被截断。当运行Redis的系统崩溃时可能会发生这种情况，尤其是当安装<code>ext4</code>文件系统时，如果没有<code>data=ordered</code>选项（但是，当Redis本身崩溃或中止，但操作系统仍然正常工作时，则不会发生这种情况）。<br>当发生这种情况时，Redis退出并报错，也可以加载尽可能多的数据（现在是默认值），如果在末尾发现<code>AOF</code>文件被截断，则可以启动它。以下选项控制此行为。<br>如果设置为<code>yes</code>，则会加载一个已截断的<code>AOF</code>文件，并且Redis服务器开始发出日志，通知用户事件。否则，如果该选项设置为<code>no</code>，则服务器将以错误中止并拒绝启动。<br>当选项设置为否时，用户需要在重新启动服务器之前使用<code>redis-check-aof</code>修复<code>aof</code>文件。如果在中间发现AOF文件已损坏，服务器仍将退出并出现错误。此选项仅适用于Redis尝试从AOF文件读取更多数据但未找到足够字节的情况。</p><pre class=" language-sh"><code class="language-sh">aof-load-truncated yes</code></pre><h2 id="aof-use-rdb-preamble"><a href="#aof-use-rdb-preamble" class="headerlink" title="aof-use-rdb-preamble"></a>aof-use-rdb-preamble</h2><p>在重写<code>AOF</code>文件时，Redis可以使用AOF文件中的RDB前导码来更快地重写和恢复。启用此选项时，重写的<code>AOF</code>文件由两个不同的节<code>[RDB file][AOF tail]</code>组成。<br>Redis加载时，会识别出<code>AOF</code>文件以<code>REDIS</code>字符串开始并加载前缀<code>RDB</code>文件，然后继续加载<code>AOF</code>尾部。</p><pre class=" language-sh"><code class="language-sh">aof-use-rdb-preamble yes</code></pre><h1 id="LUA-scripting"><a href="#LUA-scripting" class="headerlink" title="LUA scripting"></a>LUA scripting</h1><p>Lua脚本的最大执行时间（以毫秒为单位）。<br>如果达到最大执行时间，redis将记录脚本在最大允许时间之后仍在执行中，并开始对出现错误的查询进行回复。<br>当长时间运行的脚本超过最大执行时间时，只有<code>SCRIPT KILL</code>和<code>SHUTDOWN NOSAVE</code>命令可用。第一个可以用于停止尚未调用写入命令的脚本。第二种方法是在脚本已经发出写命令但用户不希望等待脚本自然终止的情况下关闭服务器。<br>将其设置为0或负值，以便无警告地无限执行。</p><pre class=" language-sh"><code class="language-sh">lua-time-limit 5000</code></pre><h1 id="Redis-cluster"><a href="#Redis-cluster" class="headerlink" title="Redis cluster"></a>Redis cluster</h1><h2 id="cluster-enabled"><a href="#cluster-enabled" class="headerlink" title="cluster-enabled"></a>cluster-enabled</h2><p>普通的redis实例不能是redis集群的一部分；只有作为集群节点启动的节点才能。为了启动Redis实例作为群集节点，解注释并设置成<code>yes</code>即可。</p><pre class=" language-sh"><code class="language-sh"># cluster-enabled yes</code></pre><h2 id="cluster-config-file"><a href="#cluster-config-file" class="headerlink" title="cluster-config-file"></a>cluster-config-file</h2><p>每个集群节点都有一个集群配置文件，此文件不需要手动编辑。它创建和更新都有Redis节点进行。每个Redis集群节点都需要不同的集群配置文件。确保在同一系统中运行的实例没有重叠的群集配置文件名。</p><pre class=" language-sh"><code class="language-sh"># cluster-config-file nodes-6379.conf</code></pre><h2 id="cluster-node-timeout"><a href="#cluster-node-timeout" class="headerlink" title="cluster-node-timeout"></a>cluster-node-timeout</h2><p>集群节点超时，单位毫秒。</p><pre class=" language-sh"><code class="language-sh"># cluster-node-timeout 15000</code></pre><h2 id="cluster-replica-validity-factor"><a href="#cluster-replica-validity-factor" class="headerlink" title="cluster-replica-validity-factor"></a>cluster-replica-validity-factor</h2><p>如果故障主机的数据看起来太旧，那么它的副本将避免启动故障转移。<br>对于副本来说没法验证数据的是否太旧，所以需要执行两项检查：</p><ul><li>如果有多个副本能够进行故障转移，它们会交换消息，以尽量利用具有最佳复制偏移量的副本（从主处理的更多数据）。副本将尝试按偏移量获取它们的列组，并将与列组成比例的延迟应用于故障转移的开始。</li><li>每个副本都计算与主副本的最后一次交互的时间。这可以是接收到的最后一个ping或命令（如果主服务器仍然处于“已连接”状态），也可以是断开与主服务器的连接后经过的时间（如果复制链接当前已关闭）。如果上一次交互太旧，则复制副本将不会尝试进行故障转移。</li></ul><p>第二点可以由用户进行调整，即，如果副本上次与主服务器交互时间超过时间大于：<code>(node-timeout * replica-validity-factor) + repl-ping-replica-period</code>。<br>因此，例如，如果节点超时为30秒，副本有效性系数为10，并且假设默认的复制副本周期为10秒，那么如果副本无法与主副本进行超过310秒的对话，则不会尝试进行故障转移。<br>较大的副本有效性系数可能允许具有太旧数据的副本故障转移到主服务器，而太小的值可能会阻止群集根本无法选择副本。<br>为了获得最大的可用性，可以将副本有效性系数设置为0，这意味着，无论副本上次与主服务器交互的时间如何，它们都将始终尝试对主服务器进行故障转移。（然而，他们总是尝试应用与他们的偏移等级成比例的延迟）。<br>零是唯一能够保证当所有分区恢复时群集始终能够继续运行的值。</p><pre class=" language-sh"><code class="language-sh"># cluster-replica-validity-factor 10</code></pre><h2 id="cluster-migration-barrier"><a href="#cluster-migration-barrier" class="headerlink" title="cluster-migration-barrier"></a>cluster-migration-barrier</h2><p>群集副本能够迁移到孤立的主服务器，即没有工作副本的主服务器。这提高了集群抵御故障的能力，否则，如果一个孤立的主机没有工作的副本，它就不能在发生故障的情况下进行故障转移。<br>只有在至少有一个给定数量的旧主控形状的其他工作副本的情况下，副本才会迁移到孤立的主控形状。这个数字是“移民壁垒”。迁移屏障为1意味着只有在主副本至少有一个其他工作副本的情况下，副本才会迁移，以此类推。它通常反映出集群中每个主服务器所需的副本数量。<br>默认值为1（仅当主副本至少保留一个副本时才迁移副本）。要禁用迁移，只需将其设置为非常大的值。#可以设置值0，但仅对调试和生产中的危险有用。</p><pre class=" language-sh"><code class="language-sh"># cluster-migration-barrier 1</code></pre><h2 id="cluster-require-full-coverage"><a href="#cluster-require-full-coverage" class="headerlink" title="cluster-require-full-coverage"></a>cluster-require-full-coverage</h2><p>默认情况下，如果Redis群集节点检测到至少有一个散列槽未被发现（没有可用节点提供服务），则它们将停止接受查询。这样，如果集群部分关闭（例如一系列散列槽不再被覆盖），所有集群最终都将不可用。一旦所有插槽再次被覆盖，它就会自动返回可用状态。<br>然而，有时您希望集群的子集工作，继续接受对仍然被覆盖的密钥空间部分的查询。为此，只需将<code>cluster-require-full-coverage</code>选项设置为no。</p><pre class=" language-sh"><code class="language-sh"># cluster-require-full-coverage yes</code></pre><h2 id="cluster-replica-no-failover"><a href="#cluster-replica-no-failover" class="headerlink" title="cluster-replica-no-failover"></a>cluster-replica-no-failover</h2><p>当设置为“是”时，此选项可防止副本在主服务器故障时尝试故障转移其主服务器。但是，如果强制的话，主服务器仍然可以执行手动故障转移。<br>这在不同的情况下很有用，特别是在多个数据中心操作的情况下，如果不升级，我们希望一方永远不会升级；如果发生完全的DC故障。</p><pre class=" language-sh"><code class="language-sh"># cluster-replica-no-failover no</code></pre><h1 id="CLUSTER-DOCKER-NAT-support"><a href="#CLUSTER-DOCKER-NAT-support" class="headerlink" title="CLUSTER DOCKER/NAT support"></a>CLUSTER DOCKER/NAT support</h1><p>在某些部署中，Redis群集节点地址发现失败，原因是地址是NAT，或者端口是转发的（典型情况是Docker和其他容器）。<br>为了使redis集群在这样的环境中工作，需要一个静态配置，其中每个节点都知道其公共地址。以下两个选项用于此范围，分别是：</p><ul><li>cluster-announce-ip</li><li>cluster-announce-port</li><li>cluster-announce-bus-port</li></ul><p>每个节点都指示其地址、客户机端口和集群消息总线端口。然后将信息发布到总线数据包的头部，以便其他节点能够正确映射发布信息的节点的地址。<br>如果不使用上述选项，则将使用普通的Redis群集自动检测。<br>请注意，重新映射时，总线端口可能不在客户机端口+10000的固定偏移量处，因此您可以根据重新映射的方式指定任何端口和总线端口。如果未设置总线端口，则通常使用固定偏移量10000。<br>例如：</p><pre class=" language-sh"><code class="language-sh"># cluster-announce-ip 10.1.1.5# cluster-announce-port 6379# cluster-announce-bus-port 6380</code></pre><h1 id="slow-log"><a href="#slow-log" class="headerlink" title="slow log"></a>slow log</h1><p>Redis slow log是一个系统日志查询，它超过了指定的执行时间。执行时间不包括I/O操作，如与客户机交谈、发送回复等，而只包括实际执行命令所需的时间（这是命令执行的唯一阶段，线程被阻塞，无法以平均值服务其他请求时间）。<br>您可以用两个参数配置慢日志：一个参数告诉redis命令要记录的执行时间（以微秒计），另一个参数是慢日志的长度。当记录新命令时，最旧的命令将从记录的命令队列中删除。</p><h2 id="slowlog-slower-than"><a href="#slowlog-slower-than" class="headerlink" title="slowlog-slower-than"></a>slowlog-slower-than</h2><p>以下时间以微秒表示，因此1000000等于一秒。注意，负数会禁用慢速日志，而零值会强制记录每个命令。</p><pre class=" language-sh"><code class="language-sh">slowlog-log-slower-than 10000</code></pre><h2 id="slowlog-max-len"><a href="#slowlog-max-len" class="headerlink" title="slowlog-max-len"></a>slowlog-max-len</h2><p>这个长度没有限制。只是要知道它会消耗内存。可以使用<code>SLOWLOG RESET</code>来回收慢速日志使用的内存。</p><pre class=" language-sh"><code class="language-sh">slowlog-max-len 128</code></pre><h1 id="latency-monitor"><a href="#latency-monitor" class="headerlink" title="latency monitor"></a>latency monitor</h1><p>Redis延迟监控子系统在运行时对不同的操作进行采样，以便收集与Redis实例的可能延迟源相关的数据。<br>通过<code>LATENCY</code>命令，用户可以使用这些信息来打印图形和获取报告。<br>系统只记录在时间等于或大于通过延迟监视器阈值配置指令指定的毫秒数内执行的操作。当其值设置为零时，延迟监视器将关闭。<br>默认情况下，延迟监控是禁用的，因为如果您没有延迟问题，则通常不需要它，并且收集数据会对性能产生影响，尽管这一影响很小，但可以在大负载下进行测量。如果需要，可以使用命令<code>CONFIG SET latency-monitor-threshold &lt;milliseconds&gt;</code>在运行时轻松启用延迟监控。</p><pre class=" language-sh"><code class="language-sh">latency-monitor-threshold 0</code></pre><h1 id="event-notification"><a href="#event-notification" class="headerlink" title="event notification"></a>event notification</h1><p>例如，如果启用了keyspace事件通知，并且客户机对存储在数据库0中的密钥<code>foo</code>执行<code>DEL</code>操作，则将通过pub/sub发布两条消息：</p><pre class=" language-sh"><code class="language-sh">PUBLISH __keyspace@0__:foo delPUBLISH __keyevent@0__:del foo</code></pre><p>可以在一组类中选择Redis将通知的事件。每个类都由单个字符标识：</p><pre class=" language-sh"><code class="language-sh">#  K     Keyspace events, published with __keyspace@<db>__ prefix.#  E     Keyevent events, published with __keyevent@<db>__ prefix.#  g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...#  $     String commands#  l     List commands#  s     Set commands#  h     Hash commands#  z     Sorted set commands#  x     Expired events (events generated every time a key expires)#  e     Evicted events (events generated when a key is evicted for maxmemory)#  A     Alias for g$lshzxe, so that the "AKE" string means all the events.</code></pre><p><code>notify-keyspace-events</code>将一个由零个或多个字符组成的字符串作为参数。空字符串表示通知被禁用。</p><p>默认情况下，所有通知都被禁用，因为大多数用户不需要此功能，而且此功能有一些开销。请注意，如果不指定<code>K</code>或<code>E</code>中的至少一个，则不会传递任何事件。</p><pre class=" language-sh"><code class="language-sh">notify-keyspace-events ""</code></pre><h1 id="advanced-config"><a href="#advanced-config" class="headerlink" title="advanced config"></a>advanced config</h1><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> config </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见负载均衡算法</title>
      <link href="/program/chang-jian-fu-zai-jun-heng-suan-fa.html"/>
      <url>/program/chang-jian-fu-zai-jun-heng-suan-fa.html</url>
      
        <content type="html"><![CDATA[<h1 id="常见负载均衡算法"><a href="#常见负载均衡算法" class="headerlink" title="常见负载均衡算法"></a>常见负载均衡算法</h1><h2 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h2><p>随机负载均衡<br>随机，按权重设置随机概率。<br>在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</p><h3 id="Weight-Random"><a href="#Weight-Random" class="headerlink" title="Weight Random"></a>Weight Random</h3><p>不同的服务器性能不同，所以不能一概而论，需要给性能低的服务器给比较低的<br>权重，性能高的给跟高的权重。</p><h2 id="Round-Robin"><a href="#Round-Robin" class="headerlink" title="Round Robin"></a>Round Robin</h2><p>轮询负载均衡<br>轮循，按公约后的权重设置轮循比率。<br>存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</p><h3 id="Weight-Round-Robin"><a href="#Weight-Round-Robin" class="headerlink" title="Weight Round Robin"></a>Weight Round Robin</h3><p>加权轮询<br>不同的服务器性能不同，所以不能一概而论，需要给性能低的服务器给比较低的<br>权重，性能高的给跟高的权重。</p><h2 id="Least-Connections"><a href="#Least-Connections" class="headerlink" title="Least Connections"></a>Least Connections</h2><p>最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。<br>使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</p><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>哈希负载均衡</p><h3 id="Parameter-Hash"><a href="#Parameter-Hash" class="headerlink" title="Parameter Hash"></a>Parameter Hash</h3><p>利用参数进行哈希</p><h3 id="Source-IP-Hash"><a href="#Source-IP-Hash" class="headerlink" title="Source IP Hash"></a>Source IP Hash</h3><p>源地址hash法的思想是获取客户端访问的ip地址，通过hash函数计算出一个hash值，用该hash值对服<br>务器列表的大小进行取模运算，得到的值就是要访问的服务器的序号。</p><h3 id="ConsistentHash"><a href="#ConsistentHash" class="headerlink" title="ConsistentHash"></a>ConsistentHash</h3><p>一致性哈希<br>一致性 Hash，相同参数的请求总是发到同一提供者。<br>当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</p><h2 id="Message-Queue"><a href="#Message-Queue" class="headerlink" title="Message Queue"></a>Message Queue</h2><p>消息队列</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol><li><a href="https://dubbo.gitbooks.io/dubbo-user-book/content/demos/loadbalance.html" target="_blank" rel="noopener">dubbo loadbalance</a></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> load balance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闭包问题</title>
      <link href="/program/bi-bao-wen-ti.html"/>
      <url>/program/bi-bao-wen-ti.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h1><p>参考<a href="https://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6" target="_blank" rel="noopener">闭包wikipedia</a></p><h1 id="怎样产生闭包"><a href="#怎样产生闭包" class="headerlink" title="怎样产生闭包"></a>怎样产生闭包</h1><p>闭包可以让一个函数和一组变量产生关系，让这些变量的生命周期保持持久性。<br>变量可以是在闭包内部声明，也可以引用外部变量，例如：</p><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">// 在函数内部创建变量</span><span class="token keyword">func</span> <span class="token function">incr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> x <span class="token builtin">int</span>      <span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>        x<span class="token operator">++</span>         <span class="token keyword">return</span> x     <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 在函数外面创建变量</span><span class="token keyword">var</span> x <span class="token builtin">int</span> <span class="token keyword">func</span> <span class="token function">incr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>     <span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>        x<span class="token operator">++</span>         <span class="token keyword">return</span> x     <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p>在函数内部创建变量可以对外部进行隐藏，在外部声明变量可以在任意点修改。<br>闭包特点是：函数内部有引用外部变量，且有延迟执行的特点。<br>在golang中比较常见的就是遍历元素，启动一个协程去执行，例如：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> data <span class="token punctuation">{</span>    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>为了防止执行时<code>i</code>的值相同，需要做一些出，例如：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> data <span class="token punctuation">{</span>    i <span class="token operator">:=</span> i    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 或者</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> data <span class="token punctuation">{</span>    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h1 id="闭包的用处"><a href="#闭包的用处" class="headerlink" title="闭包的用处"></a>闭包的用处</h1><p>闭包最大的用处是利用延迟执行特性，进行一些操作。</p><h2 id="go函数"><a href="#go函数" class="headerlink" title="go函数"></a>go函数</h2><p>启动定时任务，且可控制关闭它，可以使用闭包：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">startTicker</span><span class="token punctuation">(</span>dur time<span class="token punctuation">.</span>Duration<span class="token punctuation">)</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    ticker <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">NewTicker</span><span class="token punctuation">(</span>dur<span class="token punctuation">)</span>    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">for</span> <span class="token keyword">range</span> ticker<span class="token punctuation">.</span>C <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// do something</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> ticker<span class="token punctuation">.</span>Stop<span class="token punctuation">}</span></code></pre><p><a href="https://play.golang.org/p/ZAnKV6h8PtA" target="_blank" rel="noopener">执行代码</a></p><h2 id="defer函数"><a href="#defer函数" class="headerlink" title="defer函数"></a>defer函数</h2><p>常用模式还是在defer中使用闭包，而且defer+return的组合经常会让人摸不清头脑。</p><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">// 1.</span><span class="token keyword">func</span> <span class="token function">increaseA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> i <span class="token builtin">int</span>    <span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        i<span class="token operator">++</span>    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> i<span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 2.</span><span class="token keyword">func</span> <span class="token function">increaseB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>r <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        r<span class="token operator">++</span>    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> r<span class="token punctuation">}</span></code></pre><p>defer中的函数将会在return后延迟执行，即先会确定返回值再执行defer函数。<br>这样会导致increaseA函数返回时拷贝<code>i</code>值作为返回值，原有的<code>i</code>去执行defer函数，并不会影响返回值。<br>而increaseB函数返回的是预先定义好的返回时的地址是确定的，这样defer函数改变的还是预先定义的<code>r</code>值。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol><li><a href="https://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6" target="_blank" rel="noopener">闭包wikipedia</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&amp;mid=2648466918&amp;idx=2&amp;sn=151a8135f22563b7b97bf01ff480497b&amp;chksm=f2474389c530ca9f3dc2ae1124e4e5ed3db4c45096924265bccfcb8908a829b9207b0dd26047&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">5 年 Gopher 都不知道的 defer 细节，你别再掉进坑里！</a></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> closure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建私有docker-image服务器</title>
      <link href="/docker/chuang-jian-si-you-docker-image-fu-wu-qi.html"/>
      <url>/docker/chuang-jian-si-you-docker-image-fu-wu-qi.html</url>
      
        <content type="html"><![CDATA[<p>本文介绍怎样搭建和使用私有化的docker image服务器。</p><h1 id="docker-hub-image-server"><a href="#docker-hub-image-server" class="headerlink" title="docker hub image server"></a>docker hub image server</h1><h2 id="pull官方registry镜像"><a href="#pull官方registry镜像" class="headerlink" title="pull官方registry镜像"></a>pull官方registry镜像</h2><p>首先需要获取官方的registry镜像包。</p><pre class=" language-shell"><code class="language-shell">$ docker pull registry:2.6.2Trying to pull repository docker.io/library/registry ... 2.6.2: Pulling from docker.io/library/registry4064ffdc82fe: Pull complete c12c92d1c5a2: Pull complete 4fbc9b6835cc: Pull complete 765973b0f65f: Pull complete 3968771a7c3a: Pull complete Digest: sha256:51bb55f23ef7e25ac9b8313b139a8dd45baa832943c8ad8f7da2ddad6355b3c8</code></pre><h2 id="insecure-registry"><a href="#insecure-registry" class="headerlink" title="insecure registry"></a>insecure registry</h2><p>docker默认image server使用https协议传输，但是内网传输可以简单的使用http，所以我们可以在<code>/etc/docker/daemon.json</code>添加<code>"insecure-registries": ["image_server_ip:port"]</code>，这样我们的image server就支持http传输了。</p><h2 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h2><p>为了让docker image server的数据持久化，我们需要将本地磁盘映射到容器内部的<code>/var/lib/registry</code>，这样方便我们的image server迁移。</p><h2 id="运行registry镜像"><a href="#运行registry镜像" class="headerlink" title="运行registry镜像"></a>运行registry镜像</h2><pre class=" language-shell"><code class="language-shell">$ docker run -d -p 5000:5000 -v `pwd`/data:/var/lib/registry --restart=always --name registry docker.io/registry:2.6.2dccda7ae748e2b0a485ea9e501e09567c012acb392412727b7ee0e73ffff5961</code></pre><p>这样我们就可以启动我们的镜像服务器了，映射端口5000，映射本地磁盘。</p><h1 id="docker-client"><a href="#docker-client" class="headerlink" title="docker client"></a>docker client</h1><h2 id="image-命名"><a href="#image-命名" class="headerlink" title="image 命名"></a>image 命名</h2><p>镜像命名格式image-hub-ip:port/image_name，例如：<code>172.16.220.41:5000/myhub/nginx</code>。这样我们就可以往我们自己的image server推送我们私有的image了。</p><pre class=" language-shell"><code class="language-shell">$ docker push 172.16.220.41:5000/myhub/nginx:v0.1The push refers to a repository [172.16.220.41:5000/myhub/nginx]08d25fa0442e: Pushed a8c4aeeaa045: Pushed cdb3f9544e4c: Pushed v0.1: digest: sha256:4ffd9758ea9ea360fd87d0cee7a2d1cf9dba630bb57ca36b3108dcd3708dc189 size: 948</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>删除本地镜像</p><pre class=" language-shell"><code class="language-shell">$ docker rmi 172.16.220.41:5000/myhub/nginx:v0.1Untagged: 172.16.220.41:5000/myhub/nginx:v0.1Untagged: 172.16.220.41:5000/myhub/nginx@sha256:4ffd9758ea9ea360fd87d0cee7a2d1cf9dba630bb57ca36b3108dcd3708dc189</code></pre><p>拉取image</p><pre class=" language-shell"><code class="language-shell">$ docker pull 172.16.220.41:5000/myhub/nginx:v0.1Trying to pull repository 172.16.220.41:5000/myhub/nginx ... v0.1: Pulling from 172.16.220.41:5000/myhub/nginxDigest: sha256:4ffd9758ea9ea360fd87d0cee7a2d1cf9dba630bb57ca36b3108dcd3708dc189Status: Downloaded newer image for 172.16.220.41:5000/myhub/nginx:v0.1</code></pre><p>可以看到我们又重新获取到了镜像，这样我们的image server就搭建完成了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> image </tag>
            
            <tag> registry </tag>
            
            <tag> server </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
