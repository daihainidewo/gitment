{"meta":{"version":1,"warehouse":"3.0.1"},"models":{"Asset":[{"_id":"themes/matery/source/favicon.png","path":"favicon.png","modified":1,"renderable":1},{"_id":"themes/matery/source/icon.png","path":"icon.png","modified":1,"renderable":1},{"_id":"themes/matery/source/css/gitment.css","path":"css/gitment.css","modified":1,"renderable":1},{"_id":"themes/matery/source/css/my-gitalk.css","path":"css/my-gitalk.css","modified":1,"renderable":1},{"_id":"themes/matery/source/css/my.css","path":"css/my.css","modified":1,"renderable":1},{"_id":"themes/matery/source/js/matery.js","path":"js/matery.js","modified":1,"renderable":1},{"_id":"themes/matery/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/icp.png","path":"medias/icp.png","modified":1,"renderable":1},{"_id":"themes/matery/source/css/matery.css","path":"css/matery.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/animate/animate.min.css","path":"libs/animate/animate.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/aos/aos.css","path":"libs/aos/aos.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/aos/aos.js","path":"libs/aos/aos.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.css","path":"libs/aplayer/APlayer.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/background/canvas-nest.js","path":"libs/background/canvas-nest.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/background/ribbon.min.js","path":"libs/background/ribbon.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/background/ribbon-dynamic.js","path":"libs/background/ribbon-dynamic.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/gitalk/gitalk.css","path":"libs/gitalk/gitalk.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.css","path":"libs/dplayer/DPlayer.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/codeCopy.js","path":"libs/codeBlock/codeCopy.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/codeBlockFuction.js","path":"libs/codeBlock/codeBlockFuction.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/codeLang.js","path":"libs/codeBlock/codeLang.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/codeShrink.js","path":"libs/codeBlock/codeShrink.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/gitment/gitment-default.css.bk","path":"libs/gitment/gitment-default.css.bk","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/instantpage/instantpage.js","path":"libs/instantpage/instantpage.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/jqcloud/jqcloud-1.0.4.min.js","path":"libs/jqcloud/jqcloud-1.0.4.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/gitment/gitment-default.css","path":"libs/gitment/gitment-default.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/jqcloud/jqcloud.css","path":"libs/jqcloud/jqcloud.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/scrollprogress/scrollProgress.min.js","path":"libs/scrollprogress/scrollProgress.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/others/clicklove.js","path":"libs/others/clicklove.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/tocbot/tocbot.css","path":"libs/tocbot/tocbot.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/tocbot/tocbot.min.js","path":"libs/tocbot/tocbot.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/masonry/masonry.pkgd.min.js","path":"libs/masonry/masonry.pkgd.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/others/busuanzi.pure.mini.js","path":"libs/others/busuanzi.pure.mini.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/cryptojs/crypto-js.min.js","path":"libs/cryptojs/crypto-js.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.js","path":"libs/aplayer/APlayer.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/gitment/gitment.js.bk","path":"libs/gitment/gitment.js.bk","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/jquery/jquery.min.js","path":"libs/jquery/jquery.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/valine/Valine.min.js","path":"libs/valine/Valine.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-regular-400.ttf","path":"libs/awesome/webfonts/fa-regular-400.ttf","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-regular-400.woff","path":"libs/awesome/webfonts/fa-regular-400.woff","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-regular-400.woff2","path":"libs/awesome/webfonts/fa-regular-400.woff2","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/gitalk/gitalk.min.js","path":"libs/gitalk/gitalk.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.js","path":"libs/dplayer/DPlayer.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.ttf","path":"libs/lightGallery/fonts/lg.ttf","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.eot","path":"libs/lightGallery/fonts/lg.eot","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.woff","path":"libs/lightGallery/fonts/lg.woff","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/css/lightgallery.min.css","path":"libs/lightGallery/css/lightgallery.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/loading.gif","path":"libs/lightGallery/img/loading.gif","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.svg","path":"libs/lightGallery/fonts/lg.svg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/vimeo-play.png","path":"libs/lightGallery/img/vimeo-play.png","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/video-play.png","path":"libs/lightGallery/img/video-play.png","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/youtube-play.png","path":"libs/lightGallery/img/youtube-play.png","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/gitment/gitment.js","path":"libs/gitment/gitment.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/css/share.min.css","path":"libs/share/css/share.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.svg","path":"libs/share/fonts/iconfont.svg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.eot","path":"libs/share/fonts/iconfont.eot","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.ttf","path":"libs/share/fonts/iconfont.ttf","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/js/jquery.share.min.js","path":"libs/share/js/jquery.share.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/js/social-share.min.js","path":"libs/share/js/social-share.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.woff","path":"libs/share/fonts/iconfont.woff","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/materialize/materialize.min.css","path":"libs/materialize/materialize.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/css/all.css","path":"libs/awesome/css/all.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-brands-400.woff","path":"libs/awesome/webfonts/fa-brands-400.woff","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-regular-400.eot","path":"libs/awesome/webfonts/fa-regular-400.eot","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-solid-900.woff2","path":"libs/awesome/webfonts/fa-solid-900.woff2","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-solid-900.woff","path":"libs/awesome/webfonts/fa-solid-900.woff","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/js/lightgallery-all.min.js","path":"libs/lightGallery/js/lightgallery-all.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/valine/av-min.js","path":"libs/valine/av-min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/materialize/materialize.min.js","path":"libs/materialize/materialize.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-brands-400.eot","path":"libs/awesome/webfonts/fa-brands-400.eot","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-brands-400.ttf","path":"libs/awesome/webfonts/fa-brands-400.ttf","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-brands-400.woff2","path":"libs/awesome/webfonts/fa-brands-400.woff2","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-regular-400.svg","path":"libs/awesome/webfonts/fa-regular-400.svg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-solid-900.eot","path":"libs/awesome/webfonts/fa-solid-900.eot","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-solid-900.ttf","path":"libs/awesome/webfonts/fa-solid-900.ttf","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/echarts/echarts.min.js","path":"libs/echarts/echarts.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-brands-400.svg","path":"libs/awesome/webfonts/fa-brands-400.svg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-solid-900.svg","path":"libs/awesome/webfonts/fa-solid-900.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"43214ef0c1738182679b5ed791ff60a21e692b42","modified":1587955398542},{"_id":"source/.gitignore","hash":"64f48012584e915e284e6e78bcb0a95e99462f8e","modified":1594626870673},{"_id":"themes/matery/.DS_Store","hash":"e93135fa7ac1a4d8e2377e6b1a6064229487fd14","modified":1587955391615},{"_id":"themes/matery/.gitignore","hash":"727607929a51db7ea10968f547c26041eee9cfff","modified":1575005960000},{"_id":"themes/matery/LICENSE","hash":"7df059597099bb7dcf25d2a9aedfaf4465f72d8d","modified":1575005960000},{"_id":"themes/matery/README.md","hash":"85c6db8d23df7ee61a14bf43bee751f0dfeee8fa","modified":1575005960000},{"_id":"themes/matery/README_CN.md","hash":"a2a0a0e9122575d84cf3041cc7e951632fda588d","modified":1575005960000},{"_id":"themes/matery/_config.yml","hash":"c80ad3bfa90608e865601411fa94af5780bc79fb","modified":1584502335596},{"_id":"source/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1575596401256},{"_id":"source/.git/config","hash":"257f6da744a24cc90fbcae2eb94fedb3ff592636","modified":1577092166938},{"_id":"source/.git/index","hash":"7e387ebe94b452dca3dcaeacc0db35d7897fb064","modified":1604478428181},{"_id":"source/.git/COMMIT_EDITMSG","hash":"35e23e581264babbf5d89ed3f1513e257a939418","modified":1604478428183},{"_id":"source/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1575596401245},{"_id":"source/_drafts/redis集群方案.md","hash":"cac4f23ea5d31cff1dacf6bf1041b5010ed1ee25","modified":1600243142880},{"_id":"source/_data/friends.json","hash":"7d7e0d3b77fbf0860b19ff45be1b3b82c225e941","modified":1588055396197},{"_id":"source/404/index.md","hash":"ada0118d57c8f9cc0e5c34f7adbb6cf1d9702de8","modified":1578384889414},{"_id":"source/_drafts/ss运行原理.md","hash":"7905c39a997a3b8a5b63b2c0eabb7e19e41e7f3e","modified":1601373172629},{"_id":"source/_posts/Git stash.md","hash":"e86d62349550bd773f744a984b42fb5a981a9bce","modified":1576221203168},{"_id":"source/about/index.md","hash":"c60433a0619346e13852b5d97bac0cefaecea22e","modified":1575273456328},{"_id":"source/_drafts/编译指示.md","hash":"eeb001dad4f4499af05beeb8849ce8ddb9517383","modified":1575961348531},{"_id":"source/_posts/IP协议.md","hash":"3af1dd85e04cf42171257380815f82d934dffec7","modified":1576828806346},{"_id":"source/_posts/TCP协议.md","hash":"eb95e405aee71cdc6a428d0d10d6c1e347861c0d","modified":1595302574389},{"_id":"source/_posts/Redis配置文件.md","hash":"4412e0956c60ba303c7d1dd056dbc0fef88160a9","modified":1576828121848},{"_id":"source/_posts/etcdctl命令行交互.md","hash":"697c1d36fe6ecf460e88fdee03925a4f3e163189","modified":1585822594202},{"_id":"source/_posts/golang-MPG-场景源码剖析.md","hash":"a1b542bd8ae99e42c137c0e38601cb292a445494","modified":1603783098605},{"_id":"source/_posts/golang-MPG-有限状态机.md","hash":"5103a128b5ae483e63fbed1c99ce3af2fd6a52a7","modified":1603784871959},{"_id":"source/_posts/golang-协程栈.md","hash":"172bf7d890d244972f681de715f5247d1223bac4","modified":1603854318347},{"_id":"source/_posts/golang-MPG调度.md","hash":"e363ffb20453e5d26eb2febfee163bb8f86ad86b","modified":1601373234010},{"_id":"source/_posts/golang内存管理.md","hash":"5e076205e99cd89b1a0d75a34abf4ec00c5233bd","modified":1600690704640},{"_id":"source/_posts/golang的TCPSocket编程.md","hash":"4e0bb3a651d2f2e1d557e5f3a42005b7c982ca98","modified":1587347752591},{"_id":"source/_posts/golang-协程调度管理源码分析.md","hash":"a7f42a5e3f3dbc18607fec99dd10b35e060958ba","modified":1603765389341},{"_id":"source/_posts/golang编译指示.md","hash":"6b36539d4f5c560a23efed8ccf4eedf51a6d82e9","modified":1604460501766},{"_id":"source/_posts/golang调用IPC.md","hash":"c63e88724eceb14067725423eccade2fc1a9112c","modified":1587017969778},{"_id":"source/_posts/golang调用syscall.md","hash":"025bf375c1304b477d966340ac5fa381feed91a2","modified":1587095096925},{"_id":"source/_posts/linux-cut命令.md","hash":"d03e049726178a4b8e25b13b4fdde480804ebee8","modified":1576834056378},{"_id":"source/_posts/linux-awk命令.md","hash":"67d04d556488f43370bc385648ccef3a0c13faae","modified":1586769744498},{"_id":"source/_posts/linux-find命令.md","hash":"eb13e36083bc711055ac083e4b6c9f2eaa7a859d","modified":1600334859772},{"_id":"source/_posts/linux-sar命令.md","hash":"665c048022f957c2b41fa74b7dc435cbe9bcdca0","modified":1602728782159},{"_id":"source/_posts/linux-sort命令.md","hash":"28cd8a4d8a1ae616fc1ffbfbed38b50f74d8947a","modified":1586402616580},{"_id":"source/_posts/linux-sed命令.md","hash":"0aba66a2b2dae8d6e20919c43ababf84ec28366f","modified":1600658392613},{"_id":"source/_posts/linux-watch命令.md","hash":"b71c182aeee3eeccd429b3f0c00fe59cf4a4ff67","modified":1579073866573},{"_id":"source/_posts/linux软链接和硬链接.md","hash":"c94a46f00ff4e932bc02990eb0d4c9e26840d448","modified":1586410010220},{"_id":"source/_posts/protocol-buffer.md","hash":"0f2aabb715acd8c6b66f4af249ea639cef94b49a","modified":1596767454305},{"_id":"source/_posts/redis大key处理.md","hash":"b3941a4532ce612b97c20d315a4fcd3dcdf99bb8","modified":1587451860324},{"_id":"source/_posts/sync包.md","hash":"890eeda03fb100b5e1a2ddd02f0a5f97663b11c4","modified":1578992573186},{"_id":"source/_posts/wireshark解析自定义协议.md","hash":"10bead3fa18143dc45e181ff83a7b7830dd19937","modified":1596716651890},{"_id":"source/_posts/常见负载均衡算法.md","hash":"fff5837ae01130872c9da4b8edf001695b11bb82","modified":1575961207330},{"_id":"source/_posts/创建私有docker-image服务器.md","hash":"5062411b51dd94b6d7f9b9b616a27470f5a6a7de","modified":1576735707679},{"_id":"source/_posts/技术文章.md","hash":"3af553359766833baabdf17b12910b6bd15e7fe7","modified":1578989413384},{"_id":"source/_posts/服务注册与发现.md","hash":"79eed5bc57e6fe03ff23090f7a84af5d44061886","modified":1594626737813},{"_id":"source/_posts/闭包问题.md","hash":"9449c92ae67dda8e9016b312c3f9a5096445a549","modified":1575961745595},{"_id":"source/categories/index.md","hash":"69c7a5bb3cb0a2181b8553d8e742121b900850f3","modified":1575273293194},{"_id":"source/contact/index.md","hash":"08dcc6cfcac006d9480af6ff9c6e965c5ee5ed6d","modified":1575273485936},{"_id":"source/friends/index.md","hash":"8f9d28d51f93a7045d175577bbfa2f0213b74727","modified":1575273510854},{"_id":"source/tags/index.md","hash":"5156930759b53aa07c8cbdd31cb28db85fec0006","modified":1575273434955},{"_id":"themes/matery/languages/default.yml","hash":"54ccc01b097c5bf6820f0edfcece1a87b78ab32d","modified":1575005960000},{"_id":"themes/matery/languages/zh-CN.yml","hash":"a957b05f70265a86a87d922e18488571809d2472","modified":1575005960000},{"_id":"themes/matery/layout/about.ejs","hash":"ee639d0310867976b3e5fb9f92c215a17a433703","modified":1575005960000},{"_id":"themes/matery/layout/archive.ejs","hash":"7fe7b9028b0da9c84715c3583b6b4172c2342ac8","modified":1575005960000},{"_id":"themes/matery/layout/categories.ejs","hash":"8e54665cc25d7c333da7d9f312987190be6215da","modified":1575005960000},{"_id":"themes/matery/layout/category.ejs","hash":"720d02e5fc37d154b60590bb7f64a2a4651c02db","modified":1575005960000},{"_id":"themes/matery/layout/friends.ejs","hash":"4cb216b2a650ad5d2942047a65d0883a188c2abb","modified":1575005960000},{"_id":"themes/matery/layout/contact.ejs","hash":"c3396cc5b1cbb102f500554f76946f5b45ee6d54","modified":1575005960000},{"_id":"themes/matery/layout/tag.ejs","hash":"0c0194cf006fab2dccf4f788075e51cd06637df4","modified":1575005960000},{"_id":"themes/matery/layout/index.ejs","hash":"92f053ac3e335129269036f862521326f10e80d8","modified":1575005960000},{"_id":"themes/matery/layout/tags.ejs","hash":"cf9517aa6a0111355121f44615d6923e312283c7","modified":1575005960000},{"_id":"themes/matery/layout/layout.ejs","hash":"ce0ccbb10063741827ea870a477c53800221d878","modified":1575005960000},{"_id":"themes/matery/layout/post.ejs","hash":"f1c86cca42841d944268d05713025f35db7f9215","modified":1583914289440},{"_id":"themes/matery/source/.DS_Store","hash":"f11ed2c86a5a8c993bb8cd41e77b83f91817ed04","modified":1577092422284},{"_id":"themes/matery/source/favicon.png","hash":"20674c497b75fc889194b47fd18ecea12303d8ec","modified":1575005960000},{"_id":"themes/matery/source/icon.png","hash":"0796e93ed5031a6e3a48af143c39d5906fb76120","modified":1551323706000},{"_id":"source/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1575596401248},{"_id":"source/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1575596401246},{"_id":"source/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1575596401250},{"_id":"source/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1575596401248},{"_id":"source/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1575596401250},{"_id":"source/.git/hooks/pre-commit.sample","hash":"33729ad4ce51acda35094e581e4088f3167a0af8","modified":1575596401247},{"_id":"source/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1575596401250},{"_id":"source/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1575596401248},{"_id":"source/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1575596401247},{"_id":"source/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1575596401249},{"_id":"source/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1575596401244},{"_id":"source/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1575596401251},{"_id":"source/.git/logs/HEAD","hash":"d6a887105476a7fbadb486030cb5ba6caf661984","modified":1604478428185},{"_id":"themes/matery/layout/_partial/baidu-push.ejs","hash":"2cebcc5ea3614d7f76ec36670e68050cbe611202","modified":1575005960000},{"_id":"themes/matery/layout/_partial/bg-cover.ejs","hash":"02191109712f61c0e487b8f0b8466597181a9004","modified":1575005960000},{"_id":"themes/matery/layout/_partial/back-top.ejs","hash":"47ee36a042bb6d52bbe1d0f329637e8ffcf1d0aa","modified":1575005960000},{"_id":"themes/matery/layout/_partial/gitalk.ejs","hash":"fe7c785f0536ad828d957a9565ca5c53a0cead43","modified":1575005960000},{"_id":"themes/matery/layout/_partial/baidu-analytics.ejs","hash":"3bbcdb474ca1dcad514bdc4b7763e17c55df04fd","modified":1575005960000},{"_id":"themes/matery/layout/_partial/disqus.ejs","hash":"a0f53d1a9b579d52e52ccad8c6e330bf3b89547e","modified":1575005960000},{"_id":"themes/matery/layout/_partial/github-link.ejs","hash":"3aeb581bd78ab8e15b858e4c44c03bcf92f20b9e","modified":1575005960000},{"_id":"themes/matery/layout/_partial/gitment.ejs","hash":"4f3a8f243ea07644fc599bdb44cc6be1a78fb0a1","modified":1575005960000},{"_id":"themes/matery/layout/_partial/google-analytics.ejs","hash":"5f4992205617da5f8cc5863c62b5ec46e414e2fb","modified":1575005960000},{"_id":"themes/matery/layout/_partial/header.ejs","hash":"f555d813f568a2dbf6f572559020c44d13975449","modified":1575005960000},{"_id":"themes/matery/layout/_partial/index-cover.ejs","hash":"489e629d460ea8c732cd2c1b38d7871af84cac89","modified":1575005960000},{"_id":"themes/matery/layout/_partial/livere.ejs","hash":"9c3401b42ea7f26410a5593bae93ada7e57b43be","modified":1575005960000},{"_id":"themes/matery/layout/_partial/mobile-nav.ejs","hash":"153b80047ac06a8d06a97002a98d38111d92b494","modified":1575005960000},{"_id":"themes/matery/layout/_partial/paging.ejs","hash":"e2df12cf92a82b1a7a7add2eac1db1d954bc5511","modified":1575005960000},{"_id":"themes/matery/layout/_partial/footer.ejs","hash":"dbc47fd6304bd9f64ca3865ea45a7783cd97b95d","modified":1575285979224},{"_id":"themes/matery/layout/_partial/post-cover.ejs","hash":"17637ee6402e3b547d3ec71423de6467cb217441","modified":1575005960000},{"_id":"themes/matery/layout/_partial/navigation.ejs","hash":"5ff6fdfe973619120a9eda4505bbff4545e39ff0","modified":1575005960000},{"_id":"themes/matery/layout/_partial/post-detail-toc.ejs","hash":"78a9ea7cb06f7eb7a39a854ca25864e5dc574800","modified":1575005960000},{"_id":"themes/matery/layout/_partial/bg-cover-content.ejs","hash":"86eb03c1655186d5ca742289308b4e41c605ecb0","modified":1575357614467},{"_id":"themes/matery/layout/_partial/post-statis.ejs","hash":"04889f9031743c6b081d02fa4027b0dbfcc45ecf","modified":1575005960000},{"_id":"themes/matery/layout/_partial/search.ejs","hash":"84e1073b3bef478c352c271f8169d667db42f5eb","modified":1575005960000},{"_id":"themes/matery/layout/_partial/prev-next.ejs","hash":"35b6b4a0200c10be6ae9d9558367718290476f84","modified":1575005960000},{"_id":"themes/matery/layout/_partial/head.ejs","hash":"d18e20d74a6a060a70b6a01888299a01775c7448","modified":1575355831829},{"_id":"themes/matery/layout/_partial/reprint-statement.ejs","hash":"01f5eef82bbcb9d432631dbb78dd51d4d4b3b8b5","modified":1575005960000},{"_id":"themes/matery/layout/_partial/social-link.ejs","hash":"6f871bd3a70f720e4e451f1f4f625cbc6d8994a4","modified":1575005960000},{"_id":"themes/matery/layout/_partial/share.ejs","hash":"5bf9dabd3ab2e298ead92256f5a732f27939ec66","modified":1575005960000},{"_id":"themes/matery/layout/_partial/valine.ejs","hash":"60bcc9b0a0983d631c0fb69f6d1672d895df5107","modified":1575005960000},{"_id":"themes/matery/layout/_partial/post-detail.ejs","hash":"a8b2c1a76cb1aec77e70d487ca3cec5e60861171","modified":1579072649193},{"_id":"themes/matery/layout/_partial/reward.ejs","hash":"38b3fe1b5eebf29d75eaaadbac4920235c4ac850","modified":1576225067162},{"_id":"themes/matery/layout/_widget/category-cloud.ejs","hash":"424ef5db791264a79c1f3338e7c43a2f445cb2ab","modified":1575005960000},{"_id":"themes/matery/layout/_widget/dream.ejs","hash":"ba83115ce66f4328601e567aa30f50d1410b9bfa","modified":1575005960000},{"_id":"themes/matery/layout/_widget/music.ejs","hash":"1b7e97c73a6c466a521a277691e19b5c057f0546","modified":1575005960000},{"_id":"themes/matery/layout/_widget/my-projects.ejs","hash":"dbd8df5146bd6e873535e24f09dd7cf04e17a4e4","modified":1575005960000},{"_id":"themes/matery/layout/_widget/my-gallery.ejs","hash":"de2e0abc085b721318f35c0b5d4891230be36529","modified":1575005960000},{"_id":"themes/matery/layout/_widget/post-calendar.ejs","hash":"06c5196b3115b2a30cc6001529b08f21b54ce31f","modified":1575005960000},{"_id":"themes/matery/layout/_widget/post-charts.ejs","hash":"a3666971c96169aac38708675dbd2df2b44a4cdd","modified":1575005960000},{"_id":"themes/matery/layout/_widget/my-skills.ejs","hash":"89a0092df72d23093128f2fbbdc8ca7f83ebcfd9","modified":1575005960000},{"_id":"themes/matery/layout/_widget/recommend.ejs","hash":"a40f466dc96cedfcde66b89acdc0a2fa8a8dfefe","modified":1575005960000},{"_id":"themes/matery/layout/_widget/tag-wordcloud.ejs","hash":"e3f245c42d8a7c5810f689bd9a4ac48e77217260","modified":1575005960000},{"_id":"themes/matery/layout/_widget/tag-cloud.ejs","hash":"fc42b72cddc231f7485cdc1fd6852b66be6add26","modified":1575005960000},{"_id":"themes/matery/layout/_widget/category-radar.ejs","hash":"f5561dd7d53d68897a33090bf677719213459b19","modified":1575005960000},{"_id":"themes/matery/layout/_widget/video.ejs","hash":"4162453e7e125013c8b1ad18ffc691a6ba124b88","modified":1575005960000},{"_id":"themes/matery/source/css/gitment.css","hash":"2bd15cc17dca35ac3ecc0acf167a23a1dd362acd","modified":1575005960000},{"_id":"themes/matery/source/css/my-gitalk.css","hash":"eeda46a83d0db1cc239a9cd27d544faf663f9883","modified":1575005960000},{"_id":"themes/matery/source/css/my.css","hash":"10577fbc30f241b126d1b51b1f56136ecba86b19","modified":1575005960000},{"_id":"themes/matery/source/js/matery.js","hash":"07ed4f743a497d7850b3fdda2a5d9beccc5a8fb5","modified":1575005960000},{"_id":"themes/matery/source/js/search.js","hash":"499e11786efbb04815b54a1de317cc8606a37555","modified":1575005960000},{"_id":"themes/matery/source/medias/icp.png","hash":"5d1a1f3051c8a4ad70afa0a5488dfa7f0bb27bd5","modified":1584502456068},{"_id":"themes/matery/source/medias/.DS_Store","hash":"55fd7b8054951e9f7ed1fa4f1c6458e131a3138d","modified":1579067754784},{"_id":"themes/matery/source/css/matery.css","hash":"43c651b783e768dc62c242bf09648fcde6ad5f88","modified":1583918245358},{"_id":"source/.git/refs/heads/master","hash":"8d4998bbd82b5aad703ceea157c6e5dd77c30f0f","modified":1604478428185},{"_id":"source/.git/objects/07/d1863ab2d689cdf3eaab7c51ac7ebf3afa2362","hash":"89a6fb52d77a2d8648c16bd2b41005a9990ff7b2","modified":1600346961691},{"_id":"source/.git/objects/00/84e7ba0abfed2f525607fbf4ff892c5a11ea4e","hash":"eb2256e3a9b67a4f42802baf33a00a758c976b38","modified":1575596588919},{"_id":"source/.git/objects/04/790777129371d1dde7ef35a60a0366c0450074","hash":"7f7275240fe8588d979586ecbf64b2b7224edcfe","modified":1575596560000},{"_id":"source/.git/objects/04/8f96bc2b0560e8b863d39441aa07aed855b68f","hash":"fd9c912587058fd667b1727c0d5d44233cd988fd","modified":1594626879939},{"_id":"source/.git/objects/0a/9d618cebca1e217bf704e247c6f1c7ed59bd50","hash":"15db5325bb1fa1d563fb58f1ddec1b2e3b532e62","modified":1603684146428},{"_id":"source/.git/objects/0a/9f76779035c5bbaf14840a8b41ad8773568fa0","hash":"12f70a25b1f3fc15ebf44474cede1cfeaa2e76a8","modified":1577092149511},{"_id":"source/.git/objects/08/06f87364e2b3d6d13c73a867c4e63f1c65dff7","hash":"efb055a2e15faec593847fc8d84ab99e8cdce976","modified":1594626879937},{"_id":"source/.git/objects/0e/2101fa3f11c0d8982e1afc61cc5d2c504d9f9a","hash":"3bbdf6120e16b2f363ccb275034bec97d5f7eecd","modified":1594626879918},{"_id":"source/.git/objects/14/29e3876d9eb78a79f7a680cf90acf1f4b8cba2","hash":"5d8c57e07734f3989ba0aa30b2b3c46837021c22","modified":1575596588919},{"_id":"source/.git/objects/20/956cdfcff40dbe3ddb041b052b9e03c7e81345","hash":"bb790b5aeb9c7692a744fb4324fe9a0d4d10b594","modified":1603684146427},{"_id":"source/.git/objects/0e/4836dac7de2ab135e029e6f8078088ef7c940b","hash":"bd52fa933fafb254a7b4daa8e1098827bf26d297","modified":1575596588917},{"_id":"source/.git/objects/12/817a24a9ff914bebedd2f9cc39efeaeed50ee5","hash":"4959dcdac61d74567912da41557d7f003483307f","modified":1575596560000},{"_id":"source/.git/objects/18/7f5c2149edb5af5176ba73d7e5660bc4246ca1","hash":"2f680b6b800e575853c9cade9d5e53de17183933","modified":1594626879919},{"_id":"source/.git/objects/1d/5fa300ec2744c08c48c7dc8ee5133db3f49759","hash":"637741d3723320f399a85331834a30bc636672d0","modified":1575596560000},{"_id":"source/.git/objects/26/264d44dba97da16862a91cb3366b44cf75b056","hash":"a18413f494c59d07ca5fc12ecc8580225db49a03","modified":1604478428180},{"_id":"source/.git/objects/24/a43e0ded8bb741975d672bbc8571541aaae02a","hash":"580ccf6c99b23e845530ff434e45b842ddc2fa51","modified":1575596560000},{"_id":"source/.git/objects/27/4a793152a484f5f58fba0854de710d1559f3cc","hash":"88fe7715551dd619e036b840e36666b6c2a505e7","modified":1604478406808},{"_id":"source/.git/objects/2a/faa7657a5636c89a7663d23f972a08646bf4d7","hash":"478f8bb67fc90fee608423f3a38cd1b5f441a2f6","modified":1575596560000},{"_id":"source/.git/objects/2c/b0889b25dc33447c827ba65d2c0d856e21c62b","hash":"15d40d011a4aa6bc53a785c4a9d92944a1bd986f","modified":1577092071754},{"_id":"source/.git/objects/2b/5184576508f8476adf4347b6e21a15ed1a9491","hash":"6237583121917b92847b7996982fed577b9a66c8","modified":1575596560000},{"_id":"source/.git/objects/2c/630d43d377ec7b641c6a4259fbcde4cd039d2b","hash":"97e5dd9ba730cff730f9c64559e9a0a67dcec0b3","modified":1594626893190},{"_id":"source/.git/objects/36/ba3cf5410ac2033010960be9c3a97521ecdeaa","hash":"e046c584eb062326e6a729c77219bf4391eb75e9","modified":1603684112582},{"_id":"source/.git/objects/3a/a1e486798d90bad40910a995ad2bed64706f30","hash":"6d7ccb0a0d655dcbf769eee0af4a41a6e39aeb4d","modified":1604478428184},{"_id":"source/.git/objects/39/a5f6a2dd6fbffd86bcc6b06bb4c299732dbb97","hash":"f42d083804484d461cae80c2882d239c1ba676a4","modified":1575596588918},{"_id":"source/.git/objects/36/d73993e491804a5df7bf10e9d51cc14ab2d52b","hash":"543c5525199b67a2fc2d997bb1655504fbb2e757","modified":1603684112590},{"_id":"source/.git/objects/3c/5a9a168b007f994b59367e66b1b299bd98ba76","hash":"1591af2b183dc3147c79e2c10c02cb28aa8cecb2","modified":1575596560000},{"_id":"source/.git/objects/22/b9b0e9492667b7c67da3edb1f4802de93f12a2","hash":"f7336dc68de063e4313477fe8b6e9fdee2d5fd5c","modified":1575960519722},{"_id":"source/.git/objects/3d/40ea7897c1967b608780828e791ad6c0719bc1","hash":"6df7091e316e7f96b60f3c45d7cc5280534140ed","modified":1575596560000},{"_id":"source/.git/objects/40/1e4a66f0ee719f8a147462f0c7ed1322543849","hash":"72f23557264ab9821e661943df80d119ce38d574","modified":1575596560000},{"_id":"source/.git/objects/45/da48357971934801a5408e97e07acfd6470b4b","hash":"755f20f7d61a1a33e5d48e559a675631f1f2f251","modified":1575596560000},{"_id":"source/.git/objects/43/5f19e8ff1e8e8c55caf4f84aa2b0c1b9b2115c","hash":"136750762f52d3ae9ee24839820ab43a6dc2aa02","modified":1575596560000},{"_id":"source/.git/objects/09/8f76f0778e07dcfa3b7b393e101e61d21ca511","hash":"ea17b44a47d131c51f2aaace35568c3400d5eef8","modified":1575960519717},{"_id":"source/.git/objects/43/b1c851cd8046db790c5efd0f85d812aeb69ff4","hash":"772d82e7eaa687330b7cc9d496fdc9589839bc91","modified":1575960531921},{"_id":"source/.git/objects/4b/d5193a24c31443bf3d84186b2278f36fa974e8","hash":"91a84dafb8a946c386d75f12436306035979ab23","modified":1575596560000},{"_id":"source/.git/objects/46/3ce1de8c8fc95026df70ef1b672f3c0035fbcb","hash":"ea9c58749afc4d60a40a60d3cdcb7b0a94f10cf1","modified":1594626879926},{"_id":"source/.git/objects/4a/b05ec6e6ba1e4a630eb890dc4eb7eb5f33f4a6","hash":"2f3ba4d4e7d884594b171866ffe9687990b7a989","modified":1596717054700},{"_id":"source/.git/objects/4f/44d2e66c9570b8a1868db25dbdf45378d634dd","hash":"a29f0e75792608d40d6f06496fdf531a855fab4f","modified":1603684112576},{"_id":"source/.git/objects/58/53d4cc27df5b599e4e176535c387b5576c7294","hash":"00b3554acd45f70aaa78032014a13dc755a66c37","modified":1594626879941},{"_id":"source/.git/objects/4f/9297a537d5d62cbc6aa9a4672690305d2b14d0","hash":"ce2134993e17c8400be041150b4c4a793477af0e","modified":1575960519720},{"_id":"source/.git/objects/52/e72617f074a60426e2b7b2cba340ab9bb2b3c1","hash":"931cbba1f52a12e839b9c0eba583250109702798","modified":1600347009691},{"_id":"source/.git/objects/57/b59d51184d629a523cc87ef88293f2fe1fbaac","hash":"2103bff22dceb2d25f0eda4b8862f62513612706","modified":1596717054699},{"_id":"source/.git/objects/57/7dd180e8678b85d784bdd0146e23e6d2ca5daa","hash":"226c49e0984d2920fdff0b459e66833aeaa4bed6","modified":1600346961691},{"_id":"source/.git/objects/4e/1a2e49c6da8c7a29c35a504ca45e4ffba48ff3","hash":"e19e953fed2af18f7264b65fca81d8d59cc4d036","modified":1575596560319},{"_id":"source/.git/objects/59/da1aa86f260c5fe2378c13002dba1ccae6079f","hash":"1514e5269d68cc4505de583332168d8a58364757","modified":1575596560000},{"_id":"source/.git/objects/5a/dbb296d3ca7c46a3ef7c080086f9ab380ef182","hash":"7282726892b362ee8c72fc05d0aaa7b3809c36b5","modified":1604478406810},{"_id":"source/.git/objects/5f/f59cf6bfa8efb09db13537b6009ba2ce245d07","hash":"5abdfea2c040dc1088353caad3df4877b4ec85dc","modified":1594626879935},{"_id":"source/.git/objects/5c/88bd35ad713b42da0e130edb0f3db63e426760","hash":"1a8c6e6c0dc6eacafe3ad94624f578b11e9a04ac","modified":1577092071769},{"_id":"source/.git/objects/64/7eac0ed9583b6f65f14455e009d07e1d98e5e1","hash":"0da402c97f69ded47ff3417d8a0396dfa153aeac","modified":1594626893187},{"_id":"source/.git/objects/62/ba368bf6ac7eeac8ee899341a49443772c66b1","hash":"f63c8003f61a6f67526a4fe4f96afc4e64a5e68d","modified":1575596588000},{"_id":"source/.git/objects/63/adfecea07cb35f9ad92c1353ac372a6353213a","hash":"0526b6b91d07680bb0892651b934bb4cce8092cb","modified":1594626879000},{"_id":"source/.git/objects/67/de651da0fbc72e2af033fe846627b9331b723d","hash":"b437132820e15e75eff595dc237aa3d5fcc09c2f","modified":1600347009687},{"_id":"source/.git/objects/67/facad929ed5bb5b9b2b7a1479f7c2bf360040b","hash":"ca9f8af6778647a296af2b070c259390f6620dd9","modified":1603684112580},{"_id":"source/.git/objects/66/3ad4d11af01f11454d921a751ac440e74ccc62","hash":"d52686c455fd8e89f26a16d6d4328114482c4ba1","modified":1594626879915},{"_id":"source/.git/objects/6a/b6a5c3c1acce6552db92eb93a7384bb946d9d2","hash":"63941025769addee7bb4005e993266fd9e8ac83b","modified":1604478406812},{"_id":"source/.git/objects/6e/2e04597c6907dc0c7fab962b61eaf6137a2b5d","hash":"41243787544740df8de09ea6ca6fa43973a96760","modified":1603684112587},{"_id":"source/.git/objects/6d/71d68258da9cbbfc4fd769d3d20a16b1f21ab6","hash":"63ca721a04efddc41d1bc85f3e5a39359fc24bdf","modified":1575596560000},{"_id":"source/.git/objects/70/9a03f98dbed31b4b23a505b4c02318e2279d5d","hash":"9ab9c4ae87ba854d2b8cd3aef39469414bcb2e9e","modified":1594626879930},{"_id":"source/.git/objects/70/d7b00caab0fe83700d7ffc155095397d9ec68f","hash":"b0a8f8f2742f357eb68b61fd7a4ac5634f750386","modified":1577092149518},{"_id":"source/.git/objects/76/35e3d19d9c42ae4ee978c9b88fd0c5ea032415","hash":"2a638dd016630e202ffbbca2fe6cb6d862348391","modified":1577092071759},{"_id":"source/.git/objects/76/ddbc5ed5a33b468db5c1d7a93b6ba8a93c4046","hash":"33199afe17c950598366f79d7069a985d6ab2984","modified":1575596560000},{"_id":"source/.git/objects/75/b5b61e5a03072f6831952e6fb7f2914ee3fe0b","hash":"6cfca44d43d93451cc1e8097a495d85dae10ad47","modified":1575596560000},{"_id":"source/.git/objects/7a/a26c3c407c8d262e193d69fc96591de56166f3","hash":"528f9c9ed010e1b619eb00fad348d9d56a3f700e","modified":1604478428181},{"_id":"source/.git/objects/77/9f182847bb3b354b1924e3762358a433c76021","hash":"98ac74fd0deeac2e86693aef55ec745d97cb52dc","modified":1575596560000},{"_id":"source/.git/objects/5d/7ef02acab7207ee3a97fa744d04f670ce7ed9a","hash":"d6c273af00343d169561499f966ad367a6befcca","modified":1575596588924},{"_id":"source/.git/objects/7d/909a3c4241a1a85945a80f050d31b492983d22","hash":"3e9e5b7a997bcc0604e2db42fd28bfc0771b26a9","modified":1575596560000},{"_id":"source/.git/objects/83/7a14c55c87c1a63602210c413da3c8f77f7a6b","hash":"8e0fb9ae43e88476b6996965b589ac7f41736953","modified":1575596560000},{"_id":"source/.git/objects/83/5ea70ff4dd4f7b6c29276fe58820199b5e901d","hash":"91d902f76bc6a337b3f9231c67b29eba0b94243e","modified":1575596560000},{"_id":"source/.git/objects/7e/f0c1549b525a758183de5293c658a787bfe837","hash":"eb1f8b03926ec244a6cfdcd00fe559816c077350","modified":1594626879914},{"_id":"source/.git/objects/86/62e06de18f227568cf3a807ca7177e35ed39e0","hash":"9c0a0b05212c3ef20be0605bb6a74d6a41f79e8c","modified":1594626879916},{"_id":"source/.git/objects/86/9012080cc51b7453a547117148905aece33ec2","hash":"74dadcc7abede8b17b4b4b2ed48f4d623b4be02d","modified":1575596588916},{"_id":"source/.git/objects/81/bee53a1bef3c99b432446b2bae0f89d05ba4a5","hash":"c295a328ebb509a7dcdf65b54bb27a2d78520ce7","modified":1594626893189},{"_id":"source/.git/objects/89/0dcdffc3435ff886481897f116cedccd1e8584","hash":"e503fc0073b87a62fd6a83fa8307eba879437cab","modified":1603684112592},{"_id":"source/.git/objects/89/2bfc4a6101e74af812792f2f3e8278a44183f6","hash":"662edaf8d71f1ba87847876fdfa801ecadf0d13e","modified":1575596560000},{"_id":"source/.git/objects/8b/d3588c7ec7da6011d6265147579120a949d233","hash":"7d24242366137f4f792f26ed553ee6f66aaf2ad5","modified":1596717054703},{"_id":"source/.git/objects/85/0ec4510b65759eb63ffca5e592793dab996cb8","hash":"10c990ed38ece1ef32e4a85321ed2cdaf1694726","modified":1575596560000},{"_id":"source/.git/objects/8a/49b8007480d70bf757232e35cd6d95d8ff26de","hash":"70c8f148071fc8fe3971e2450ed11e04eb902fee","modified":1575596560320},{"_id":"source/.git/objects/8f/031b41cafe5c71af64eb7150b41eabce4f8663","hash":"c78d8a9c7fd46380d2f46e7ef38825324060a748","modified":1575596560303},{"_id":"source/.git/objects/99/02b9b4be32cf4e39fa41e37d077c2de265da04","hash":"62f52d2606a6237315c8ff4e18a70dbdda816dca","modified":1603684112593},{"_id":"source/.git/objects/94/1eb4da8585ce4b53233ba8a450e59107f78f0e","hash":"3c7194cf2f400b9c6421e826c089dac991d6635c","modified":1594626893190},{"_id":"source/.git/objects/94/56cd3447bb186bd9d1871f56977cab0a121ba8","hash":"f470624b04357b9cf4cf6cf4c5eadd97e2e17ef2","modified":1577092071771},{"_id":"source/.git/objects/8f/83e917a56a0062141624fe65903ca44bf16714","hash":"8a2f8e551cee24d7299bb4b6dfd04cd50f676643","modified":1594626879922},{"_id":"source/.git/objects/97/1101abe16a1a2c3c92731d5ec2f408bef54491","hash":"3f8555c1e8bab15b3081027c50ab3d0be6c1b235","modified":1575596560000},{"_id":"source/.git/objects/9d/c2eaa911b4778daf07166aacbc71c2b2f8fa47","hash":"168c8bc2ee523a1c9a4edd7413619bd0ee80843d","modified":1604478406807},{"_id":"source/.git/objects/97/386cdd7a6e6ae9dba6545da8a39d83c58197d0","hash":"8ecd522144d1bb675ad85f3dc48299b2fbf03a1f","modified":1600347009697},{"_id":"source/.git/objects/9c/7ba25691d125593a07d8830b933c32ebb61c01","hash":"daf4171829461a13a6e1264c7cde2e7fd123ddcc","modified":1600347009690},{"_id":"source/.git/objects/a2/e75893089862302e28a4f49d2384e0f016998e","hash":"8b37ef93eabecc7ef823ceff86e3fcfca5b7e1b5","modified":1594626893194},{"_id":"source/.git/objects/9e/3b4c38b7c564c3848f3e5a9743c2753e75e1ae","hash":"9f01077242086ee9e504f0b3debf55e1445fec4a","modified":1600346961692},{"_id":"source/.git/objects/a0/89024448ebce42969d71962ea0853475746379","hash":"b1d8488390dd78baa719523626128cba3dbcdb10","modified":1594626879924},{"_id":"source/.git/objects/a6/2142cf7cf8e793348bc9da37c6cb837633999a","hash":"f5401a24170ed2a61218bccd1d09c14dcd521022","modified":1575596560000},{"_id":"source/.git/objects/a6/05461d6064910977fb8b590b06db6a2660b024","hash":"e27bab80ed9c3471866fd23da7b80d0d0c874f8c","modified":1596717035809},{"_id":"source/.git/objects/a7/e1fae3550d3eeedefdb08960b8a0d21560e9b4","hash":"0bc3c6020694ac68c81ccfff7278bbecc6cd4971","modified":1575596560000},{"_id":"source/.git/objects/ac/50a2ed622d439c974cec78f80119f714f58543","hash":"d7d65cf44617a4fadd9978221e791fb17d7fc668","modified":1604478406814},{"_id":"source/.git/objects/a8/2383a3f99cf64b14737f76fdcc3d1b77a77a49","hash":"2a4725a81196174f1eeb66d6f6d8a1cf8dce8e9f","modified":1575596560000},{"_id":"source/.git/objects/a5/a419ad66b66fa470ed65418e2195967546d449","hash":"47f4b0d27c7cedfaac0a60f448d96c8488c3f81c","modified":1575596588920},{"_id":"source/.git/objects/b0/523c6035a0fd71c8999f0b6a0100045d4259e9","hash":"318490a16c882df603a20abb99758bec358c95d9","modified":1603684146431},{"_id":"source/.git/objects/b0/b37981c1d9facdfb249a5b10eca13f9f0931d7","hash":"028ccb594e9c04f814be53e4fe4b2fd632dbfc29","modified":1575596560000},{"_id":"source/.git/objects/b2/3021dcb7e67535e70bfa833d22442672763f68","hash":"40db867912937143f7e5ea17f9f102cdd3fc9524","modified":1603684112000},{"_id":"source/.git/objects/b2/a3101eaa07322fd1ee8ac6920fd0e73eb25ba5","hash":"e218bd35dc2c5bf76b77a0f7b5a70293e0c454ee","modified":1575596560321},{"_id":"source/.git/objects/b6/d0ccf1efd3dba186ab64feeaf62a1ef234942e","hash":"4f1366bdc28ba46fed44ef279cc68ffdc2453bf5","modified":1577092071764},{"_id":"source/.git/objects/c2/5ca7fe9afa05830f70a20b85281aca91bb23c5","hash":"7149b5dcffce5cdba1b728af9eca90c71a934ddf","modified":1603684146426},{"_id":"source/.git/objects/b5/246d90f3409cfb03bfc15202875cb65d62ddd3","hash":"55327f0757542296991be77115b0c2ab45b7ae01","modified":1575596560000},{"_id":"source/.git/objects/b7/cb344bd7da023f195b35567b9678833c367377","hash":"4efa9238089874ac83153f806e7122fa02996385","modified":1575596560000},{"_id":"source/.git/objects/b7/6c1d0be283b6d3b775f1494d8d6c27247fe62c","hash":"3543e2ebf8b6af278dde31b004ce02f46fa2c0a5","modified":1575960519724},{"_id":"source/.git/objects/c7/6c98b178563334e3ab96818a12b2491c860fe1","hash":"3e9b2dcfb18049f32b87a699868df32d4817634d","modified":1575596560000},{"_id":"source/.git/objects/cd/44ce67f47d916f86d7ca173f16ad2616fecd29","hash":"b0182d324cc1f12beeac228515e00c87b76c2196","modified":1594626879932},{"_id":"source/.git/objects/ca/a9e854fd70a25dfd78ed3d3631606aa62e7928","hash":"5d91f5b77603f75bac5d2475efcc1b89613065a5","modified":1594626879942},{"_id":"source/.git/objects/ca/be52f3fb7ff3b86661fbc00fc7b4d87a1e443c","hash":"0b2c30c97293377992170edb8a260f0598bcbc46","modified":1575596560000},{"_id":"source/.git/objects/cd/be5d1cb3aed8d61cd2fd512edc996205a68033","hash":"f4a66ac493faa373b6851defccc743203a7a368f","modified":1577092071757},{"_id":"source/.git/objects/cd/f18a491de5dd8565ca2186769cd0fa5d2d080f","hash":"cf013eb313cdb64c2a8277781215c21efce473c1","modified":1575596588918},{"_id":"source/.git/objects/cc/3f1af9b08319d444e3020922e40f8edfd9db58","hash":"661186895c0d852e97d554f6baa04c4ad8d85fc4","modified":1575596560322},{"_id":"source/.git/objects/d3/41404a078658a212d39e47853202e11b9ddabf","hash":"e896b128a3e42c5719d5d672d5e897daa96d2ac6","modified":1577092071765},{"_id":"source/.git/objects/cc/a1347f3da301a4eefcaf81d3cbdc25a2b4837b","hash":"ae612d9d94b3ecac3c8913e8708c2c8f56aaf519","modified":1575596482682},{"_id":"source/.git/objects/d9/937d322c9b9478e42f6198897ebf7ec232f361","hash":"7fea9334d99e7fbe7f4398e2cfb06dda6d3f15c7","modified":1594626893188},{"_id":"source/.git/objects/d6/657619218207048f2a548c97188cbd0e401423","hash":"18a40ca03f8f4021e56be999ee3b0066acb24cfe","modified":1575596560000},{"_id":"source/.git/objects/dd/9922645023d6571a3846fc343ccfeec2cb1905","hash":"717c5c12d731948529ffe1efc76a02d6d8f0fbdf","modified":1594626879923},{"_id":"source/.git/objects/dd/c42da4c078f24f94681dca31b8c26748da0c0e","hash":"53660a5f6402c660eb55822a8f1a96719644a4f2","modified":1594626879938},{"_id":"source/.git/objects/db/c46ccba47beba442a2ea5c207b2b3966a7acc9","hash":"e244dbacdc3663da8bfa93a6d421f4418e191ec6","modified":1600346961690},{"_id":"source/.git/objects/e2/35b3281cf82d67e5b630c7be834f5fa8f21af9","hash":"e8ec08b25ebc3aa5fe588a6adf963106ffc76888","modified":1603684112585},{"_id":"source/.git/objects/e1/10ee695a3f727dad94767396cf830bae601c66","hash":"f6c8036cce3e46a798004dbe787125c9eeaefa3b","modified":1575596588920},{"_id":"source/.git/objects/e3/2f640361f0127d4d06a94d6992d6620a9a930a","hash":"bc7a6d48b63bce7aea1f814e4c205fcf2625b642","modified":1575960531926},{"_id":"source/.git/objects/e3/ab29c171e286f60a3c23257c5359bde1530f26","hash":"f313d02ccd2e8826c8bdc917b2f50b476d754998","modified":1575596560304},{"_id":"source/.git/objects/eb/bfe1b685096c0f1b3f3984779769f3b516adda","hash":"2c73d652628faa83d367f437ed458a4000b43489","modified":1596717035808},{"_id":"source/.git/objects/e5/cf7865159a31f6b273280c0fa67c05e694c142","hash":"21910781cda5ee64f6a33f8d3a6cd833f7fc4721","modified":1575596560000},{"_id":"source/.git/objects/e5/24080a8be29ef33a0e7fb6c1e58ac8f56e5658","hash":"a9a6508728ad02051fd9ffb0430ec419e2f104c4","modified":1577092071763},{"_id":"source/.git/objects/f4/3ae719b5069591c2f30e8468d363d1a52afb14","hash":"5b98fbfa43e77a8b113777b220107c5ae977ad16","modified":1575596560000},{"_id":"source/.git/objects/f4/98e2cde39d8c603061a47f366b29617cff88f2","hash":"a6a0f071c21aaf06934f30f21e3f0c8b7215bf8c","modified":1596717035810},{"_id":"source/.git/objects/ef/f9131c8f4bb46cc96936e94f2cabfad75ab7c0","hash":"e398a50b5f9a5e1b058b087ad7d8e8d29f739b5e","modified":1575596560318},{"_id":"source/.git/objects/f4/22e66c055fd642485196649c2bff537defe118","hash":"21b6236fe5343b15c5723f2dbcfb3c1490f8c4f1","modified":1575596560000},{"_id":"source/.git/objects/f5/56d236fbc4396782156394a2937b1677479008","hash":"12fe161610fdab5ee7fab1746656be7a986248db","modified":1594626879000},{"_id":"source/.git/objects/e8/e92f73986dafdf966a15a04c1f8c642683fc96","hash":"dbf01bf9da91dd9360388787c0b7444714a37728","modified":1575960531922},{"_id":"source/.git/objects/fd/54473bf1dd41fb74a8a5051022e31e1c7e2438","hash":"a6f260b26fd8ff1964f4ac228b6652fd6dbf0cc7","modified":1575596560000},{"_id":"source/.git/objects/fd/6561a1dd53d5424e113926d856eb866cc37206","hash":"9d0baef7db18d35e407d85a8fa1fd18aed696a2d","modified":1594626879928},{"_id":"source/.git/objects/fa/aa8a477675d34acfed87a28f929281ae2235fe","hash":"1d0ed2c1b772c99935bee4d78cc810f914d415c7","modified":1575596560000},{"_id":"source/.git/objects/fa/9a642d849cc8520e9f586636b961f0f8a7d459","hash":"eb9f6b088ce3999782a2d4f9e05c3c57b8890815","modified":1577092149512},{"_id":"source/.git/objects/fa/5b317beaf76e49672eee4caf8da67479819299","hash":"52c8ce26ae7fb0425c25fa454eb9ff9a78152a55","modified":1575596560000},{"_id":"source/.git/objects/fc/1b5b6ffe37fb2d531e81779d3d61745537bc6b","hash":"3e904abfd387f0b244efc1f75b854a11748126ab","modified":1575596560000},{"_id":"source/.git/objects/fe/12e0e2d657bfc0d6094c3443f2ca55fe21d1d0","hash":"a3f77b144c7bc8d97dcdd370ff66823122bdfe49","modified":1575960519723},{"_id":"source/.git/objects/ff/8284bb353abaf09eb226285b3346dfa8512ede","hash":"90d9d720395da55d8fb84cbbad38cf5f8d9f2628","modified":1596717054698},{"_id":"themes/matery/source/libs/animate/animate.min.css","hash":"97afa151569f046b2e01f27c1871646e9cd87caf","modified":1575005960000},{"_id":"themes/matery/source/libs/aos/aos.css","hash":"191a3705a8f63e589a50a0ff2f2c5559f1a1b6b2","modified":1575005960000},{"_id":"themes/matery/source/libs/aos/aos.js","hash":"02bfb40b0c4b6e9b0b4081218357145cbb327d74","modified":1575005960000},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1575005960000},{"_id":"themes/matery/source/libs/background/canvas-nest.js","hash":"65333d0dbb9c1173a1b13031b230161fc42c8b2f","modified":1575005960000},{"_id":"themes/matery/source/libs/background/ribbon.min.js","hash":"fa679c94df8fdd2bfe183b2496410afede480f38","modified":1575005960000},{"_id":"themes/matery/source/libs/background/ribbon-dynamic.js","hash":"052b80c29e6bc585aa28d4504b743bdbac220a88","modified":1575005960000},{"_id":"themes/matery/source/libs/gitalk/gitalk.css","hash":"3aac1db83b0135c521187254ff302d125cc30706","modified":1575005960000},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.css","hash":"f7d19655f873b813ffba5d1a17145c91f82631b8","modified":1575005960000},{"_id":"themes/matery/source/libs/codeBlock/codeCopy.js","hash":"6d39a766af62e625f177c4d5cf3adc35eed71e61","modified":1575005960000},{"_id":"themes/matery/source/libs/codeBlock/codeBlockFuction.js","hash":"c7ab06d27a525b15b1eb69027135269e9b9132fb","modified":1575005960000},{"_id":"themes/matery/source/libs/codeBlock/codeLang.js","hash":"bac88b4d4e3679732d29bd037c34f089cf27cf05","modified":1575005960000},{"_id":"themes/matery/source/libs/codeBlock/codeShrink.js","hash":"201e8cd761b4be557247bdaf1ebc7c11c83194f6","modified":1575005960000},{"_id":"themes/matery/source/libs/gitment/gitment-default.css.bk","hash":"2903c59ee06b965bef32e937bd69f5b0b2190717","modified":1575005960000},{"_id":"themes/matery/source/libs/instantpage/instantpage.js","hash":"83ce8919b1a69b2f1809ffaf99b52a8627e650e9","modified":1575005960000},{"_id":"themes/matery/source/libs/jqcloud/jqcloud-1.0.4.min.js","hash":"257eaae3020599e4939f50d5008a743827f25b8c","modified":1575005960000},{"_id":"themes/matery/source/libs/gitment/gitment-default.css","hash":"7fbb18b73b44ed11193739c55fce53a6f173cf68","modified":1575279792290},{"_id":"themes/matery/source/libs/jqcloud/jqcloud.css","hash":"20d9f11a19d95c70e27cb922e0d6dccbec4eae89","modified":1575005960000},{"_id":"themes/matery/source/libs/scrollprogress/scrollProgress.min.js","hash":"777ffe5d07e85a14fbe97d846f45ffc0087251cc","modified":1575005960000},{"_id":"themes/matery/source/libs/others/clicklove.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1575005960000},{"_id":"themes/matery/source/libs/tocbot/tocbot.css","hash":"15601837bf8557c2fd111e4450ed4c8495fd11a0","modified":1575005960000},{"_id":"themes/matery/source/libs/tocbot/tocbot.min.js","hash":"5ec27317f0270b8cf6b884c6f12025700b9a565c","modified":1575005960000},{"_id":"themes/matery/source/libs/masonry/masonry.pkgd.min.js","hash":"ff940b4ea68368ca0e4d5560cbb79fb147dfc3c5","modified":1575005960000},{"_id":"themes/matery/source/libs/others/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1575005960000},{"_id":"themes/matery/source/libs/cryptojs/crypto-js.min.js","hash":"5989527a378b55011a59522f41eeb3981518325c","modified":1575005960000},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1575005960000},{"_id":"themes/matery/source/libs/gitment/gitment.js.bk","hash":"28c02c45ce568e084cd1041dc493f83f9c6c88c6","modified":1575005960000},{"_id":"themes/matery/source/libs/jquery/jquery.min.js","hash":"2115753ca5fb7032aec498db7bb5dca624dbe6be","modified":1575005960000},{"_id":"themes/matery/source/libs/valine/Valine.min.js","hash":"6cbdbf91e1f046dd41267a5ff0691a1fccba99df","modified":1575005960000},{"_id":"source/.git/logs/refs/heads/master","hash":"d6a887105476a7fbadb486030cb5ba6caf661984","modified":1604478428185},{"_id":"source/.git/refs/remotes/origin/master","hash":"8d4998bbd82b5aad703ceea157c6e5dd77c30f0f","modified":1604478436209},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-regular-400.ttf","hash":"0f4bd02942a54a6b3200d9078adff88c2812e751","modified":1575005960000},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-regular-400.woff","hash":"59439d3ad31d856d78ec3e2bd9f1eafa2c7a581c","modified":1575005960000},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-regular-400.woff2","hash":"f6f653b4ea8fc487bdb590d39d5a726258a55f40","modified":1575005960000},{"_id":"themes/matery/source/libs/gitalk/gitalk.min.js","hash":"734f56442e62fe55f677e8ccae7f175445667767","modified":1575005960000},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.js","hash":"c3bad7b265574fab0ae4d45867422ea1cb9d6599","modified":1575005960000},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1575005960000},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1575005960000},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1575005960000},{"_id":"themes/matery/source/libs/lightGallery/css/lightgallery.min.css","hash":"1b7227237f9785c66062a4811508916518e4132c","modified":1575005960000},{"_id":"themes/matery/source/libs/lightGallery/img/loading.gif","hash":"15a76af2739482d8de7354abc6d8dc4fca8d145e","modified":1575005960000},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.svg","hash":"9a732790adc004b22022cc60fd5f77ec4c8e3e5a","modified":1575005960000},{"_id":"themes/matery/source/libs/lightGallery/img/vimeo-play.png","hash":"1142b47de219dddfba2e712cd3189dec0c8b7bee","modified":1575005960000},{"_id":"themes/matery/source/libs/lightGallery/img/video-play.png","hash":"fbfdbe06aebf7d0c00da175a4810cf888d128f11","modified":1575005960000},{"_id":"themes/matery/source/libs/lightGallery/img/youtube-play.png","hash":"39150b45ec5fc03155b7ebeaa44f1829281788e2","modified":1575005960000},{"_id":"themes/matery/source/libs/gitment/gitment.js","hash":"433e24cd7627204b7c3b4c278a421c95e15a9d21","modified":1575279781394},{"_id":"themes/matery/source/libs/share/css/share.min.css","hash":"8a778a86f3ce9a042df6be63a9f1039631e351a5","modified":1575005960000},{"_id":"themes/matery/source/libs/share/fonts/iconfont.svg","hash":"f0a1b849868a6bf351ff98dc3924a4e7254eb88b","modified":1575005960000},{"_id":"themes/matery/source/libs/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1575005960000},{"_id":"themes/matery/source/libs/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1575005960000},{"_id":"themes/matery/source/libs/share/js/jquery.share.min.js","hash":"41367dcb857e02e3c417ebe68a554ce1d4430806","modified":1575005960000},{"_id":"themes/matery/source/libs/share/js/social-share.min.js","hash":"a3090a02786dcd4efc6355c1c1dc978add8d6827","modified":1575005960000},{"_id":"themes/matery/source/libs/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1575005960000},{"_id":"themes/matery/source/libs/materialize/materialize.min.css","hash":"80ae4aa0dba3634dd9bf59586d541d2dd8d8191c","modified":1575005960000},{"_id":"themes/matery/source/libs/awesome/css/all.css","hash":"ecc41e32ad2696877a1656749841f3b5543bbe3d","modified":1575005960000},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-brands-400.woff","hash":"18838f5260317da3c5ed29bf844ac8a4f7ad0529","modified":1575005960000},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-regular-400.eot","hash":"439c8afd3373acb4a73135a34e220464a89cd5e2","modified":1575005960000},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-solid-900.woff2","hash":"9c081b88b106c6c04ecb895ba7ba7d3dcb3b55ac","modified":1575005960000},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-solid-900.woff","hash":"92803b8753ceda573c6906774677c5a7081d2fbb","modified":1575005960000},{"_id":"themes/matery/source/libs/lightGallery/js/lightgallery-all.min.js","hash":"9f5ef4bc8a0a3c746ca4f3c3e6d64493b1a977d8","modified":1575005960000},{"_id":"themes/matery/source/libs/valine/av-min.js","hash":"541efb9edc1ce425cbe3897cfc25803211fe6a05","modified":1575005960000},{"_id":"source/.git/logs/refs/remotes/origin/master","hash":"9db42b55446454e55c53129b0fdc26949573d475","modified":1604478436211},{"_id":"themes/matery/source/libs/materialize/materialize.min.js","hash":"c8b4c65651921d888cf5f27430dfe2ad190d35bf","modified":1575005960000},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-brands-400.eot","hash":"22f9e7d5226408eb2d0a11e118257a3ca22b8670","modified":1575005960000},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-brands-400.ttf","hash":"91cbeeaceb644a971241c08362898599d6d968ce","modified":1575005960000},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-brands-400.woff2","hash":"a46bd47ff0a90b812aafafda587d095cdb844271","modified":1575005960000},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-regular-400.svg","hash":"229afff648cbd17de80176e0feb969c7f514be7e","modified":1575005960000},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-solid-900.eot","hash":"cab8e84ae5682d1d556e234df9c790985888def8","modified":1575005960000},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-solid-900.ttf","hash":"9521ed12274c2cbc910cea77657116fcf6545da3","modified":1575005960000},{"_id":"themes/matery/source/libs/echarts/echarts.min.js","hash":"9496f386a0da4601cad22c479cc5543913a4d67f","modified":1575005960000},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-brands-400.svg","hash":"25612c76ded31c497effe46454d8d2bb36fb99d6","modified":1575005960000},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-solid-900.svg","hash":"2c026711e4dd6b6d805cc19c0e4a572e6239a05b","modified":1575005960000},{"_id":"public/baidusitemap.xml","hash":"24ee2178b9d93d486de1369d1c7d8ff57ac48fdd","modified":1604478440787},{"_id":"public/atom.xml","hash":"2e8be4faf91567aaa1af5bd042e700a5beabe754","modified":1604478440787},{"_id":"public/sitemap.xml","hash":"bbbdeb186ede3093c8788d1214406da990a88fc1","modified":1604478440787},{"_id":"public/search.xml","hash":"083ad872fc53d16ac25f23c24b102d17976806fa","modified":1604478440787},{"_id":"public/contact/index.html","hash":"446abc284528d8a4a886da93fa5f310dbb66c090","modified":1604478440787},{"_id":"public/404.html","hash":"48f8ab56b451203a0b6dd6ff095dddbba3ec8f4e","modified":1604478440787},{"_id":"public/about/index.html","hash":"24394adc9c30777ac6d8fd95a24a882841a0037f","modified":1604478440787},{"_id":"public/categories/index.html","hash":"26509bd791708c5bb2d6c3bd64fb2cc3feaf1e6e","modified":1604478440787},{"_id":"public/friends/index.html","hash":"a127dc64d141590c8471bb5bd23ec228b6dde9dd","modified":1604478440787},{"_id":"public/tags/index.html","hash":"8909e82b59fcd7c5c9a9c886bfcf36b4360db95c","modified":1604478440787},{"_id":"public/golang/golang-mpg-you-xian-zhuang-tai-ji.html","hash":"525b1c4778b69811fb08f409ffe8141715007e4a","modified":1604478440787},{"_id":"public/golang/golang-mpg-chang-jing-yuan-ma-pou-xi.html","hash":"135dd55014c8496b7dfde0434d1304ff24bb9397","modified":1604478440787},{"_id":"public/linux/linux-sed-ming-ling.html","hash":"275e2013026178341c0176207c5791415071425f","modified":1604478440787},{"_id":"public/linux/linux-find-ming-ling.html","hash":"0467377ae8f04931b518cc99d182c768b5040e5d","modified":1604478440787},{"_id":"public/golang/golang-xie-cheng-diao-du-guan-li-yuan-ma-fen-xi.html","hash":"8b9d6c2a7ac647d72127b4dd40b5808208b237ac","modified":1604478440787},{"_id":"public/linux/linux-sar-ming-ling.html","hash":"514d32f082020e0ec10ef5a28390ce6866ce8c09","modified":1604478440787},{"_id":"public/golang/golang-xie-cheng-zhan.html","hash":"d38f8a0011d0feafdc5352f5fa4fc6a8e46b0b57","modified":1604478440787},{"_id":"public/golang/golang-mpg-diao-du.html","hash":"db1e5e86ca8c3a5e17ada0795c0cb570b53767b8","modified":1604478440787},{"_id":"public/wireshark/wireshark-jie-xi-zi-ding-yi-xie-yi.html","hash":"632933818a270824f70a09fc481f3f29b3e8a844","modified":1604478440787},{"_id":"public/golang/golang-diao-yong-syscall.html","hash":"2e5c6f6e39b505d9d4ab4903919395f64a7b2336","modified":1604478440787},{"_id":"public/golang/golang-diao-yong-ipc.html","hash":"20e6fc324a21840ccbc6dc265fe3b918b6129a8e","modified":1604478440787},{"_id":"public/golang/golang-nei-cun-guan-li.html","hash":"7ed3a8ce189a7425e11671f42a743d48cc86efe9","modified":1604478440787},{"_id":"public/protobuf/protocol-buffer.html","hash":"2ecf7141f0f046278b5f50443a9eeb63e0db00af","modified":1604478440787},{"_id":"public/golang/golang-de-tcpsocket-bian-cheng.html","hash":"7445b0f8daaa0fd2cefbe18c399bd7201e5b5e85","modified":1604478440787},{"_id":"public/linux/linux-ruan-lian-jie-he-ying-lian-jie.html","hash":"64c5b531d99664455dd8b673011159b697d17e43","modified":1604478440787},{"_id":"public/service-discovery/fu-wu-zhu-ce-yu-fa-xian.html","hash":"5b7a7272a9a549bd5f165283a907f8fe937f01d2","modified":1604478440787},{"_id":"public/linux/linux-watch-ming-ling.html","hash":"6cb1e305f359944573e496017bb74d82f9442ae0","modified":1604478440787},{"_id":"public/golang/golang-bian-yi-zhi-shi.html","hash":"f92624081d2fa1cd9f7a1d9511d7f0ac10bbd307","modified":1604478440787},{"_id":"public/golang/sync-bao.html","hash":"58ab22677a018a5a89984096c90ea1a6341b4c89","modified":1604478440787},{"_id":"public/linux/linux-sort-ming-ling.html","hash":"c5991b3d31a71460405235794bc6056ae605f083","modified":1604478440787},{"_id":"public/article/ji-zhu-wen-zhang.html","hash":"c9ded779313d420281a00fbc3fa8badd6f9b3f88","modified":1604478440787},{"_id":"public/linux/linux-cut-ming-ling.html","hash":"0aee4120bddcd13c5457ba35b0663dc165b572e7","modified":1604478440787},{"_id":"public/linux/linux-awk-ming-ling.html","hash":"3b2f163a34b79cc37a8580f3de8ecc6d3df0a48b","modified":1604478440787},{"_id":"public/net/ip-xie-yi.html","hash":"b81d93306432c0b126b6b34ec72f1e510e9c4b7f","modified":1604478440787},{"_id":"public/git/git-stash.html","hash":"d3b870cc311c1427725c461da5993f29d2159ada","modified":1604478440787},{"_id":"public/redis/redis-pei-zhi-wen-jian.html","hash":"caae06f5807d80ce154ce41b5518085b38845f9e","modified":1604478440787},{"_id":"public/redis/redis-da-key-chu-li.html","hash":"75f47c09339aea1f0e31f1b2d71b097735cb32bf","modified":1604478440787},{"_id":"public/etcd/etcdctl-ming-ling-xing-jiao-hu.html","hash":"a0dfdf7fbda709a190631d2c3bb9d2b9fbc3ae24","modified":1604478440787},{"_id":"public/program/chang-jian-fu-zai-jun-heng-suan-fa.html","hash":"2915671e16994821aa7e9b3af7ae30e2a3fca8b3","modified":1604478440787},{"_id":"public/docker/chuang-jian-si-you-docker-image-fu-wu-qi.html","hash":"5ee29be3186960513491354df0ac9c4cc646bb50","modified":1604478440787},{"_id":"public/net/tcp-xie-yi.html","hash":"41976aa7dfee144619e7fb39f5e863011848d776","modified":1604478440787},{"_id":"public/archives/index.html","hash":"497b43719d09164012233a6c0bb43890150b1697","modified":1604478440787},{"_id":"public/archives/2018/index.html","hash":"baec96fdfdb0ced774e91e2fe92689c1a96c6047","modified":1604478440787},{"_id":"public/archives/page/3/index.html","hash":"08cfe1d7c64d85cdc86becf684af390b5ef1d4ba","modified":1604478440787},{"_id":"public/program/bi-bao-wen-ti.html","hash":"98080cc135352d27c2097cb27a9adc81f8c12715","modified":1604478440787},{"_id":"public/archives/2018/08/index.html","hash":"dcde61efca0114c84609a448d6c254709f8fd2e6","modified":1604478440787},{"_id":"public/archives/page/2/index.html","hash":"77af6c3459a7d1c4164625599954bac63a651091","modified":1604478440787},{"_id":"public/archives/2019/index.html","hash":"aef4078b2c0da7ba2523030bc879acb0209c8b8c","modified":1604478440787},{"_id":"public/archives/2019/12/index.html","hash":"903ae38eb7ce5b5064aa0fdb7984111f1dd40651","modified":1604478440787},{"_id":"public/archives/2019/10/index.html","hash":"027af51b906a61afdc726bab4cb260842514c91a","modified":1604478440787},{"_id":"public/archives/2020/01/index.html","hash":"f7d0d2251c389dd33bcf4e33dbd5e1fec9fb274f","modified":1604478440787},{"_id":"public/archives/2020/index.html","hash":"964df1cb6615e9eb06c728156c5bfc56ce7773ba","modified":1604478440787},{"_id":"public/archives/2020/03/index.html","hash":"0090be767377314f72b2b7a9900c53610a1dc5a1","modified":1604478440787},{"_id":"public/archives/2020/04/index.html","hash":"62937a57967a637f972b5896de3864e78bb2e4dc","modified":1604478440787},{"_id":"public/archives/2020/07/index.html","hash":"db486a8d58a78d12e794df41d1f967cdfcacadf9","modified":1604478440787},{"_id":"public/archives/2020/08/index.html","hash":"8ec9f43070f29e819d2938f051db15042e969359","modified":1604478440787},{"_id":"public/archives/2020/09/index.html","hash":"3bc1f91c1d40ceb868b8d927c9feb98d34d89fd1","modified":1604478440787},{"_id":"public/categories/redis/index.html","hash":"7b258a11bd358e84c268196b3116f20b5aad8d9d","modified":1604478440787},{"_id":"public/categories/git/index.html","hash":"59c91b7cb5c60dae200d1d79ee19241681ff9ba6","modified":1604478440787},{"_id":"public/categories/golang/index.html","hash":"4ff8c3c9dca4ae12197476f03862c89b0c33d358","modified":1604478440787},{"_id":"public/archives/2020/page/2/index.html","hash":"07499af1b3a40a2bb03b917319f812bf87ba81da","modified":1604478440787},{"_id":"public/archives/2020/10/index.html","hash":"14a471e06bc1b4ec8c12c66f5ab7a53d576add9f","modified":1604478440787},{"_id":"public/categories/etcd/index.html","hash":"40920cd102a863632b6d7bb5ccb6fcebe6b72a5c","modified":1604478440787},{"_id":"public/categories/linux/index.html","hash":"e25a8d59af9028db6d411acac136add5c332f900","modified":1604478440787},{"_id":"public/categories/protobuf/index.html","hash":"756aee0df05ad95ddf307dfe89e71d3a56d6e4d8","modified":1604478440787},{"_id":"public/categories/wireshark/index.html","hash":"0ac5dee266e88fe3225ccc3f982ea7a16190915b","modified":1604478440787},{"_id":"public/categories/program/index.html","hash":"5cd38ec0b402c09444f5cbf18067b6c938c7f6aa","modified":1604478440787},{"_id":"public/categories/docker/index.html","hash":"ca6625d4bf77704ff4390b368c22913d220ccdf9","modified":1604478440787},{"_id":"public/categories/article/index.html","hash":"98d07e2edf10c348f3f604c3a4a1e0f6aeb32550","modified":1604478440787},{"_id":"public/index.html","hash":"91d96268badfbe98b0c99030e177ec35f24366a0","modified":1604478440787},{"_id":"public/categories/net/index.html","hash":"5827aa210169edcc0a6f2fa8fc2b6e2904e32896","modified":1604478440787},{"_id":"public/categories/service-discovery/index.html","hash":"d847456b27585aba70e46171afdd62e705040875","modified":1604478440787},{"_id":"public/page/2/index.html","hash":"60a9cc05a70dd8744605d09cd5a84dff7808c5b6","modified":1604478440787},{"_id":"public/page/3/index.html","hash":"27d0cddf09df2befba26f169c665e2dc8192b46b","modified":1604478440787},{"_id":"public/tags/git/index.html","hash":"5c054bcef78f90221d463ecf7cacf9f608e1959f","modified":1604478440787},{"_id":"public/tags/cmd/index.html","hash":"da0dc9510397262bcc3493f3ab13f9f2e46c30c8","modified":1604478440787},{"_id":"public/tags/redis/index.html","hash":"15e2393c4e193434c8a909a71beaf68a2651c674","modified":1604478440787},{"_id":"public/tags/tcp/index.html","hash":"006ed1eaab579e6139d4460a21136d81267651f3","modified":1604478440787},{"_id":"public/tags/config/index.html","hash":"cbca727155629a1ed06d823c2793ba3ee3f99c0d","modified":1604478440787},{"_id":"public/tags/compile/index.html","hash":"23a132b2dd798a22d794ce1de444a309139f6e44","modified":1604478440787},{"_id":"public/tags/etcd/index.html","hash":"87115c89a2f843b7510b1832d1faece6f3c9c7fb","modified":1604478440787},{"_id":"public/tags/mpg/index.html","hash":"46e465e6bc72e07184f7d808cc297b9eeeb442c8","modified":1604478440787},{"_id":"public/tags/infra/index.html","hash":"ca22a7557e64d5eb6e4ccd6034e1a774c78ab647","modified":1604478440787},{"_id":"public/tags/IP/index.html","hash":"7e8c2a36b093fca406ce1528f80797f57e027f8c","modified":1604478440787},{"_id":"public/tags/IPv4/index.html","hash":"876c75b0ab03761b14c50b3dfdbbd94ced919aaf","modified":1604478440787},{"_id":"public/tags/IPv6/index.html","hash":"fae2be1fddaeb34236141342db398b7a4f701568","modified":1604478440787},{"_id":"public/tags/runtime/index.html","hash":"370db9f7ca6a138757a3417f71198023a2c33b09","modified":1604478440787},{"_id":"public/tags/memory/index.html","hash":"0b4a5d68bded01c9471ba71cf10a24bea4785b51","modified":1604478440787},{"_id":"public/tags/ipc/index.html","hash":"e46868c37bf2035bbc7696ae93f6d37bf5309de3","modified":1604478440787},{"_id":"public/tags/etcdctl/index.html","hash":"49416c87dd9f8d16301414605cc219f3e15fb1dc","modified":1604478440787},{"_id":"public/tags/shmems/index.html","hash":"63f25f391b0a54a6a8d6fe91126bd8ff0360d8eb","modified":1604478440787},{"_id":"public/tags/queues/index.html","hash":"8b650fc35f8954d2114ee1227f497768e86bd1c3","modified":1604478440787},{"_id":"public/tags/syscall/index.html","hash":"841b873ec004c54c95e36a49a10741869fe5f3bc","modified":1604478440787},{"_id":"public/tags/semaphores/index.html","hash":"8ea7032e02c61b36791f5f381f389991ff0ff2d5","modified":1604478440787},{"_id":"public/tags/linux/index.html","hash":"ba0eb958e82d3a2592dfbff2617a2cba6a0170a9","modified":1604478440787},{"_id":"public/tags/syscall6/index.html","hash":"1452a3d04c682845ef29b656dd75201c47c18de4","modified":1604478440787},{"_id":"public/tags/command/index.html","hash":"a628d771ad2ee748c5148daf15dc2071fe711e38","modified":1604478440787},{"_id":"public/tags/rawsyscall/index.html","hash":"e20cd07f676e8d81748db766b6dc4f015324015a","modified":1604478440787},{"_id":"public/tags/net/index.html","hash":"f31f9afc92ed40dd6383ba2a85cf0ee4cbadca97","modified":1604478440787},{"_id":"public/tags/link/index.html","hash":"1f1f55a03ab703763b7fbe2378c4a2aa28d6e828","modified":1604478440787},{"_id":"public/tags/protobuf/index.html","hash":"cd489d123879957e0db3c43af8a18fcacb7ea1c5","modified":1604478440787},{"_id":"public/tags/rawsyscall6/index.html","hash":"ae839cccbc59f377ec3b5ffe56cce5e75c0bd7cc","modified":1604478440787},{"_id":"public/tags/key/index.html","hash":"09eaba977e5d91adf39777ac0cbd4aea935d4940","modified":1604478440787},{"_id":"public/tags/proto3/index.html","hash":"ef8e59aa080c782ccb7a24be3d3b9b901d35d1d8","modified":1604478440787},{"_id":"public/tags/condition-variable/index.html","hash":"9e6f173651e7155fb05a3cc230a1f01766cdc6b5","modified":1604478440787},{"_id":"public/tags/atomic/index.html","hash":"1caac84ccde0e15ec9bd17144eebe5910ff8c4c2","modified":1604478440787},{"_id":"public/tags/lua/index.html","hash":"6270393fd9028ad3a403a75d5b4e084c645a5840","modified":1604478440787},{"_id":"public/tags/image/index.html","hash":"0ef7875111c46ce3a46931d59aec9c0d92617c9c","modified":1604478440787},{"_id":"public/tags/load-balance/index.html","hash":"d62f44010912ebc1a94c616da51f5df382b8a325","modified":1604478440787},{"_id":"public/tags/sync/index.html","hash":"9b85a43cc52ea74523d39beda4e1c49480b7e20e","modified":1604478440787},{"_id":"public/tags/registry/index.html","hash":"12a58829fccbd15b18644954b63d698c684742ef","modified":1604478440787},{"_id":"public/tags/blog/index.html","hash":"15dbded5c3f9a281b8dc13b042f034b5cd384f64","modified":1604478440787},{"_id":"public/tags/explain/index.html","hash":"0657eb9be17372f795ce6d7b6c8f8331fc67ddc9","modified":1604478440787},{"_id":"public/tags/comment/index.html","hash":"63a10054ca8b0e421b089dd9e257efdd25be457d","modified":1604478440787},{"_id":"public/tags/zk/index.html","hash":"96864c59730910110bb009fd7667de0f612f84c2","modified":1604478440787},{"_id":"public/tags/zookeeper/index.html","hash":"a44c69b624f4994c0e48c127f8d02d5e2c0559d7","modified":1604478440787},{"_id":"public/tags/consul/index.html","hash":"cc7d80f97670c45d554fb90ebdff6d74eaeddee2","modified":1604478440787},{"_id":"public/tags/confd/index.html","hash":"a974f0b47eb3ae39304af1c050235ce74be35723","modified":1604478440787},{"_id":"public/tags/eureka/index.html","hash":"cfe4310021fdd909556d64f875b3caeeebbc03ef","modified":1604478440787},{"_id":"public/tags/mutex/index.html","hash":"2c780675c3c9e51e9b16f9e6fc72710f13831ab7","modified":1604478440787},{"_id":"public/tags/server/index.html","hash":"e61435a32ac5836bcfed088928027e7d93bf7118","modified":1604478440787},{"_id":"public/tags/closure/index.html","hash":"29f9c7723ec26e3c874542ecb680767de32cae53","modified":1604478440787},{"_id":"public/icon.png","hash":"0796e93ed5031a6e3a48af143c39d5906fb76120","modified":1604478440787},{"_id":"public/medias/icp.png","hash":"5d1a1f3051c8a4ad70afa0a5488dfa7f0bb27bd5","modified":1604478440787},{"_id":"public/favicon.png","hash":"20674c497b75fc889194b47fd18ecea12303d8ec","modified":1604478440787},{"_id":"public/libs/gitment/gitment-default.css.bk","hash":"2903c59ee06b965bef32e937bd69f5b0b2190717","modified":1604478440787},{"_id":"public/libs/awesome/webfonts/fa-regular-400.woff","hash":"59439d3ad31d856d78ec3e2bd9f1eafa2c7a581c","modified":1604478440787},{"_id":"public/libs/awesome/webfonts/fa-regular-400.ttf","hash":"0f4bd02942a54a6b3200d9078adff88c2812e751","modified":1604478440787},{"_id":"public/libs/lightGallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1604478440787},{"_id":"public/libs/awesome/webfonts/fa-regular-400.woff2","hash":"f6f653b4ea8fc487bdb590d39d5a726258a55f40","modified":1604478440787},{"_id":"public/libs/lightGallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1604478440787},{"_id":"public/libs/lightGallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1604478440787},{"_id":"public/libs/lightGallery/img/loading.gif","hash":"15a76af2739482d8de7354abc6d8dc4fca8d145e","modified":1604478440787},{"_id":"public/libs/lightGallery/fonts/lg.svg","hash":"9a732790adc004b22022cc60fd5f77ec4c8e3e5a","modified":1604478440787},{"_id":"public/libs/lightGallery/img/video-play.png","hash":"fbfdbe06aebf7d0c00da175a4810cf888d128f11","modified":1604478440787},{"_id":"public/libs/lightGallery/img/vimeo-play.png","hash":"1142b47de219dddfba2e712cd3189dec0c8b7bee","modified":1604478440787},{"_id":"public/libs/share/fonts/iconfont.svg","hash":"f0a1b849868a6bf351ff98dc3924a4e7254eb88b","modified":1604478440787},{"_id":"public/libs/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1604478440787},{"_id":"public/libs/lightGallery/img/youtube-play.png","hash":"39150b45ec5fc03155b7ebeaa44f1829281788e2","modified":1604478440787},{"_id":"public/libs/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1604478440787},{"_id":"public/libs/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1604478440787},{"_id":"public/libs/awesome/webfonts/fa-regular-400.eot","hash":"439c8afd3373acb4a73135a34e220464a89cd5e2","modified":1604478440787},{"_id":"public/css/prism-duotone-light.css","hash":"25796d986ecad1dc1b009cda6c05ab062bb78f92","modified":1604478440787},{"_id":"public/js/prism.js","hash":"12d3529ee0e9d5d8c12609fe65b3b11fe5a89e6d","modified":1604478440787},{"_id":"public/libs/gitment/gitment.js.bk","hash":"28c02c45ce568e084cd1041dc493f83f9c6c88c6","modified":1604478440787},{"_id":"public/libs/awesome/webfonts/fa-brands-400.woff","hash":"18838f5260317da3c5ed29bf844ac8a4f7ad0529","modified":1604478440787},{"_id":"public/libs/awesome/webfonts/fa-solid-900.woff","hash":"92803b8753ceda573c6906774677c5a7081d2fbb","modified":1604478440787},{"_id":"public/libs/awesome/webfonts/fa-brands-400.woff2","hash":"a46bd47ff0a90b812aafafda587d095cdb844271","modified":1604478440787},{"_id":"public/libs/awesome/webfonts/fa-solid-900.woff2","hash":"9c081b88b106c6c04ecb895ba7ba7d3dcb3b55ac","modified":1604478440787},{"_id":"public/css/my-gitalk.css","hash":"eeda46a83d0db1cc239a9cd27d544faf663f9883","modified":1604478440787},{"_id":"public/css/my.css","hash":"10577fbc30f241b126d1b51b1f56136ecba86b19","modified":1604478440787},{"_id":"public/css/gitment.css","hash":"2bd15cc17dca35ac3ecc0acf167a23a1dd362acd","modified":1604478440787},{"_id":"public/libs/aos/aos.js","hash":"02bfb40b0c4b6e9b0b4081218357145cbb327d74","modified":1604478440787},{"_id":"public/libs/aplayer/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1604478440787},{"_id":"public/libs/background/canvas-nest.js","hash":"65333d0dbb9c1173a1b13031b230161fc42c8b2f","modified":1604478440787},{"_id":"public/libs/background/ribbon-dynamic.js","hash":"052b80c29e6bc585aa28d4504b743bdbac220a88","modified":1604478440787},{"_id":"public/libs/background/ribbon.min.js","hash":"fa679c94df8fdd2bfe183b2496410afede480f38","modified":1604478440787},{"_id":"public/libs/codeBlock/codeBlockFuction.js","hash":"c7ab06d27a525b15b1eb69027135269e9b9132fb","modified":1604478440787},{"_id":"public/libs/codeBlock/codeCopy.js","hash":"6d39a766af62e625f177c4d5cf3adc35eed71e61","modified":1604478440787},{"_id":"public/libs/codeBlock/codeShrink.js","hash":"201e8cd761b4be557247bdaf1ebc7c11c83194f6","modified":1604478440787},{"_id":"public/libs/codeBlock/codeLang.js","hash":"bac88b4d4e3679732d29bd037c34f089cf27cf05","modified":1604478440787},{"_id":"public/libs/jqcloud/jqcloud-1.0.4.min.js","hash":"257eaae3020599e4939f50d5008a743827f25b8c","modified":1604478440787},{"_id":"public/libs/jqcloud/jqcloud.css","hash":"20d9f11a19d95c70e27cb922e0d6dccbec4eae89","modified":1604478440787},{"_id":"public/libs/instantpage/instantpage.js","hash":"83ce8919b1a69b2f1809ffaf99b52a8627e650e9","modified":1604478440787},{"_id":"public/libs/others/clicklove.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1604478440787},{"_id":"public/libs/scrollprogress/scrollProgress.min.js","hash":"777ffe5d07e85a14fbe97d846f45ffc0087251cc","modified":1604478440787},{"_id":"public/libs/tocbot/tocbot.css","hash":"15601837bf8557c2fd111e4450ed4c8495fd11a0","modified":1604478440787},{"_id":"public/libs/others/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1604478440787},{"_id":"public/libs/tocbot/tocbot.min.js","hash":"5ec27317f0270b8cf6b884c6f12025700b9a565c","modified":1604478440787},{"_id":"public/js/search.js","hash":"499e11786efbb04815b54a1de317cc8606a37555","modified":1604478440787},{"_id":"public/js/matery.js","hash":"07ed4f743a497d7850b3fdda2a5d9beccc5a8fb5","modified":1604478440787},{"_id":"public/libs/share/css/share.min.css","hash":"8a778a86f3ce9a042df6be63a9f1039631e351a5","modified":1604478440787},{"_id":"public/css/matery.css","hash":"43c651b783e768dc62c242bf09648fcde6ad5f88","modified":1604478440787},{"_id":"public/libs/aos/aos.css","hash":"191a3705a8f63e589a50a0ff2f2c5559f1a1b6b2","modified":1604478440787},{"_id":"public/libs/animate/animate.min.css","hash":"97afa151569f046b2e01f27c1871646e9cd87caf","modified":1604478440787},{"_id":"public/libs/gitalk/gitalk.css","hash":"3aac1db83b0135c521187254ff302d125cc30706","modified":1604478440787},{"_id":"public/libs/dplayer/DPlayer.min.css","hash":"f7d19655f873b813ffba5d1a17145c91f82631b8","modified":1604478440787},{"_id":"public/libs/cryptojs/crypto-js.min.js","hash":"5989527a378b55011a59522f41eeb3981518325c","modified":1604478440787},{"_id":"public/libs/masonry/masonry.pkgd.min.js","hash":"ff940b4ea68368ca0e4d5560cbb79fb147dfc3c5","modified":1604478440787},{"_id":"public/libs/aplayer/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1604478440787},{"_id":"public/libs/jquery/jquery.min.js","hash":"2115753ca5fb7032aec498db7bb5dca624dbe6be","modified":1604478440787},{"_id":"public/libs/valine/Valine.min.js","hash":"6cbdbf91e1f046dd41267a5ff0691a1fccba99df","modified":1604478440787},{"_id":"public/libs/gitment/gitment-default.css","hash":"7fbb18b73b44ed11193739c55fce53a6f173cf68","modified":1604478440787},{"_id":"public/libs/gitalk/gitalk.min.js","hash":"734f56442e62fe55f677e8ccae7f175445667767","modified":1604478440787},{"_id":"public/libs/dplayer/DPlayer.min.js","hash":"c3bad7b265574fab0ae4d45867422ea1cb9d6599","modified":1604478440787},{"_id":"public/libs/lightGallery/css/lightgallery.min.css","hash":"1b7227237f9785c66062a4811508916518e4132c","modified":1604478440787},{"_id":"public/libs/gitment/gitment.js","hash":"433e24cd7627204b7c3b4c278a421c95e15a9d21","modified":1604478440787},{"_id":"public/libs/share/js/jquery.share.min.js","hash":"41367dcb857e02e3c417ebe68a554ce1d4430806","modified":1604478440787},{"_id":"public/libs/share/js/social-share.min.js","hash":"a3090a02786dcd4efc6355c1c1dc978add8d6827","modified":1604478440787},{"_id":"public/libs/materialize/materialize.min.css","hash":"580459a012f556fba86438953062013a94b201af","modified":1604478440787},{"_id":"public/libs/lightGallery/js/lightgallery-all.min.js","hash":"9f5ef4bc8a0a3c746ca4f3c3e6d64493b1a977d8","modified":1604478440787},{"_id":"public/libs/valine/av-min.js","hash":"541efb9edc1ce425cbe3897cfc25803211fe6a05","modified":1604478440787},{"_id":"public/libs/materialize/materialize.min.js","hash":"c8b4c65651921d888cf5f27430dfe2ad190d35bf","modified":1604478440787},{"_id":"public/libs/awesome/css/all.css","hash":"ecc41e32ad2696877a1656749841f3b5543bbe3d","modified":1604478440787},{"_id":"public/libs/awesome/webfonts/fa-brands-400.eot","hash":"22f9e7d5226408eb2d0a11e118257a3ca22b8670","modified":1604478440787},{"_id":"public/libs/awesome/webfonts/fa-regular-400.svg","hash":"229afff648cbd17de80176e0feb969c7f514be7e","modified":1604478440787},{"_id":"public/libs/awesome/webfonts/fa-brands-400.ttf","hash":"91cbeeaceb644a971241c08362898599d6d968ce","modified":1604478440787},{"_id":"public/libs/echarts/echarts.min.js","hash":"9496f386a0da4601cad22c479cc5543913a4d67f","modified":1604478440787},{"_id":"public/libs/awesome/webfonts/fa-solid-900.eot","hash":"cab8e84ae5682d1d556e234df9c790985888def8","modified":1604478440787},{"_id":"public/libs/awesome/webfonts/fa-solid-900.ttf","hash":"9521ed12274c2cbc910cea77657116fcf6545da3","modified":1604478440787},{"_id":"public/libs/awesome/webfonts/fa-brands-400.svg","hash":"25612c76ded31c497effe46454d8d2bb36fb99d6","modified":1604478440787},{"_id":"public/libs/awesome/webfonts/fa-solid-900.svg","hash":"2c026711e4dd6b6d805cc19c0e4a572e6239a05b","modified":1604478440787}],"Category":[{"name":"redis","_id":"ckh351dtt000419z45z8hbfbw"},{"name":"git","_id":"ckh351du1000b19z49o0l8344"},{"name":"golang","_id":"ckh351du8000i19z43plu3cg5"},{"name":"net","_id":"ckh351duc000p19z43nsx2n2j"},{"name":"etcd","_id":"ckh351due000v19z4841x79jz"},{"name":"linux","_id":"ckh351duw001p19z48whxgf07"},{"name":"protobuf","_id":"ckh351dv9002f19z4crgge859"},{"name":"wireshark","_id":"ckh351dve002q19z42q8taz7a"},{"name":"program","_id":"ckh351dvi002x19z4c162g9qs"},{"name":"docker","_id":"ckh351dvk003519z4c1om1men"},{"name":"article","_id":"ckh351dvl003819z4djgr9gvi"},{"name":"service discovery","_id":"ckh351dvl003c19z44fys0i6u"}],"Data":[{"_id":"friends","data":[{"avatar":"https://img-1251474779.cos.ap-beijing.myqcloud.com/icon.png","name":"djaigo","introduction":"好好学习，天天向上","url":"/","title":"前去学习"},{"avatar":"https://awps-assets.meituan.net/mit/blog/v20190629/asset/icon/favicon.ico?v=Whistle&t=20181017-1r","name":"美团技术团队","introduction":"一行代码，亿万生活。","url":"https://tech.meituan.com/","title":"点个外卖-->"},{"avatar":"","name":"鸟窝","introduction":"rpcx作者","url":"https://colobu.com/","title":"进个鸟窝-->"},{"avatar":"https://d1j8pt39hxlh3d.cloudfront.net/emoji/emojione/5.0/png/unicode/32/1f92a.png","name":"labuladong的算法小抄","introduction":"算法大神","url":"https://labuladong.gitbook.io/algo/","title":"学个算法-->"}]}],"Page":[{"title":"404","date":"2019-12-03T02:08:13.000Z","type":"404","layout":"404","comments":0,"_content":"## ヽ(；´Д｀)ﾉ  404啦\n😔很抱歉，数据走丢了\n点击此处回到[首页](/)\n\n❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️\n如果你有什么疑问请评论\n(～￣▽￣)～\n(～￣▽￣)～\n(～￣▽￣)～\n","source":"404/index.md","raw":"---\ntitle: 404\ndate: 2019-12-03 10:08:13\npermalink: /404\ntype: \"404\"\nlayout: \"404\"\ncomments: false\n---\n## ヽ(；´Д｀)ﾉ  404啦\n😔很抱歉，数据走丢了\n点击此处回到[首页](/)\n\n❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️\n如果你有什么疑问请评论\n(～￣▽￣)～\n(～￣▽￣)～\n(～￣▽￣)～\n","updated":"2019-12-03T02:08:13.000Z","path":"/404.html","_id":"ckh351dtp000119z4aguldxx2","content":"<h2 id=\"ヽ-；´Д｀-ﾉ-404啦\"><a href=\"#ヽ-；´Д｀-ﾉ-404啦\" class=\"headerlink\" title=\"ヽ(；´Д｀)ﾉ  404啦\"></a>ヽ(；´Д｀)ﾉ  404啦</h2><p>😔很抱歉，数据走丢了<br>点击此处回到<a href=\"/\">首页</a></p>\n<p>❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️<br>如果你有什么疑问请评论<br>(～￣▽￣)～<br>(～￣▽￣)～<br>(～￣▽￣)～</p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"friends":[{"avatar":"https://img-1251474779.cos.ap-beijing.myqcloud.com/icon.png","name":"djaigo","introduction":"好好学习，天天向上","url":"/","title":"前去学习"},{"avatar":"https://awps-assets.meituan.net/mit/blog/v20190629/asset/icon/favicon.ico?v=Whistle&t=20181017-1r","name":"美团技术团队","introduction":"一行代码，亿万生活。","url":"https://tech.meituan.com/","title":"点个外卖-->"},{"avatar":"","name":"鸟窝","introduction":"rpcx作者","url":"https://colobu.com/","title":"进个鸟窝-->"},{"avatar":"https://d1j8pt39hxlh3d.cloudfront.net/emoji/emojione/5.0/png/unicode/32/1f92a.png","name":"labuladong的算法小抄","introduction":"算法大神","url":"https://labuladong.gitbook.io/algo/","title":"学个算法-->"}]}},"excerpt":"","more":"<h2 id=\"ヽ-；´Д｀-ﾉ-404啦\"><a href=\"#ヽ-；´Д｀-ﾉ-404啦\" class=\"headerlink\" title=\"ヽ(；´Д｀)ﾉ  404啦\"></a>ヽ(；´Д｀)ﾉ  404啦</h2><p>😔很抱歉，数据走丢了<br>点击此处回到<a href=\"/\">首页</a></p>\n<p>❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️<br>如果你有什么疑问请评论<br>(～￣▽￣)～<br>(～￣▽￣)～<br>(～￣▽￣)～</p>\n"},{"title":"about","date":"2019-12-02T07:57:22.000Z","type":"about","layout":"about","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2019-12-02 15:57:22\ntype: \"about\"\nlayout: \"about\"\n---\n","updated":"2019-12-02T07:57:22.000Z","path":"about/index.html","comments":1,"_id":"ckh351dts000319z4giocf87i","content":"<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"friends":[{"avatar":"https://img-1251474779.cos.ap-beijing.myqcloud.com/icon.png","name":"djaigo","introduction":"好好学习，天天向上","url":"/","title":"前去学习"},{"avatar":"https://awps-assets.meituan.net/mit/blog/v20190629/asset/icon/favicon.ico?v=Whistle&t=20181017-1r","name":"美团技术团队","introduction":"一行代码，亿万生活。","url":"https://tech.meituan.com/","title":"点个外卖-->"},{"avatar":"","name":"鸟窝","introduction":"rpcx作者","url":"https://colobu.com/","title":"进个鸟窝-->"},{"avatar":"https://d1j8pt39hxlh3d.cloudfront.net/emoji/emojione/5.0/png/unicode/32/1f92a.png","name":"labuladong的算法小抄","introduction":"算法大神","url":"https://labuladong.gitbook.io/algo/","title":"学个算法-->"}]}},"excerpt":"","more":""},{"title":"categories","date":"2019-12-02T07:54:28.000Z","type":"categories","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2019-12-02 15:54:28\ntype: \"categories\"\nlayout: \"categories\"\n---\n","updated":"2019-12-02T07:54:28.000Z","path":"categories/index.html","comments":1,"_id":"ckh351dtv000719z4crpg78t9","content":"<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"friends":[{"avatar":"https://img-1251474779.cos.ap-beijing.myqcloud.com/icon.png","name":"djaigo","introduction":"好好学习，天天向上","url":"/","title":"前去学习"},{"avatar":"https://awps-assets.meituan.net/mit/blog/v20190629/asset/icon/favicon.ico?v=Whistle&t=20181017-1r","name":"美团技术团队","introduction":"一行代码，亿万生活。","url":"https://tech.meituan.com/","title":"点个外卖-->"},{"avatar":"","name":"鸟窝","introduction":"rpcx作者","url":"https://colobu.com/","title":"进个鸟窝-->"},{"avatar":"https://d1j8pt39hxlh3d.cloudfront.net/emoji/emojione/5.0/png/unicode/32/1f92a.png","name":"labuladong的算法小抄","introduction":"算法大神","url":"https://labuladong.gitbook.io/algo/","title":"学个算法-->"}]}},"excerpt":"","more":""},{"title":"contact","date":"2019-12-02T07:57:44.000Z","type":"contact","layout":"contact","_content":"","source":"contact/index.md","raw":"---\ntitle: contact\ndate: 2019-12-02 15:57:44\ntype: \"contact\"\nlayout: \"contact\"\n---\n","updated":"2019-12-02T07:57:44.000Z","path":"contact/index.html","comments":1,"_id":"ckh351dty000919z44wsca50y","content":"<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"friends":[{"avatar":"https://img-1251474779.cos.ap-beijing.myqcloud.com/icon.png","name":"djaigo","introduction":"好好学习，天天向上","url":"/","title":"前去学习"},{"avatar":"https://awps-assets.meituan.net/mit/blog/v20190629/asset/icon/favicon.ico?v=Whistle&t=20181017-1r","name":"美团技术团队","introduction":"一行代码，亿万生活。","url":"https://tech.meituan.com/","title":"点个外卖-->"},{"avatar":"","name":"鸟窝","introduction":"rpcx作者","url":"https://colobu.com/","title":"进个鸟窝-->"},{"avatar":"https://d1j8pt39hxlh3d.cloudfront.net/emoji/emojione/5.0/png/unicode/32/1f92a.png","name":"labuladong的算法小抄","introduction":"算法大神","url":"https://labuladong.gitbook.io/algo/","title":"学个算法-->"}]}},"excerpt":"","more":""},{"title":"friends","date":"2019-12-02T07:58:13.000Z","type":"friends","layout":"friends","_content":"","source":"friends/index.md","raw":"---\ntitle: friends\ndate: 2019-12-02 15:58:13\ntype: \"friends\"\nlayout: \"friends\"\n---\n","updated":"2019-12-02T07:58:13.000Z","path":"friends/index.html","comments":1,"_id":"ckh351du2000d19z45wl9gg1y","content":"<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"friends":[{"avatar":"https://img-1251474779.cos.ap-beijing.myqcloud.com/icon.png","name":"djaigo","introduction":"好好学习，天天向上","url":"/","title":"前去学习"},{"avatar":"https://awps-assets.meituan.net/mit/blog/v20190629/asset/icon/favicon.ico?v=Whistle&t=20181017-1r","name":"美团技术团队","introduction":"一行代码，亿万生活。","url":"https://tech.meituan.com/","title":"点个外卖-->"},{"avatar":"","name":"鸟窝","introduction":"rpcx作者","url":"https://colobu.com/","title":"进个鸟窝-->"},{"avatar":"https://d1j8pt39hxlh3d.cloudfront.net/emoji/emojione/5.0/png/unicode/32/1f92a.png","name":"labuladong的算法小抄","introduction":"算法大神","url":"https://labuladong.gitbook.io/algo/","title":"学个算法-->"}]}},"excerpt":"","more":""},{"title":"tags","date":"2019-12-02T07:56:42.000Z","type":"tags","layout":"tags","_content":"\n","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2019-12-02 15:56:42\ntype: \"tags\"\nlayout: \"tags\"\n---\n\n","updated":"2019-12-02T07:56:42.000Z","path":"tags/index.html","comments":1,"_id":"ckh351du4000f19z40nc8gih2","content":"<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"friends":[{"avatar":"https://img-1251474779.cos.ap-beijing.myqcloud.com/icon.png","name":"djaigo","introduction":"好好学习，天天向上","url":"/","title":"前去学习"},{"avatar":"https://awps-assets.meituan.net/mit/blog/v20190629/asset/icon/favicon.ico?v=Whistle&t=20181017-1r","name":"美团技术团队","introduction":"一行代码，亿万生活。","url":"https://tech.meituan.com/","title":"点个外卖-->"},{"avatar":"","name":"鸟窝","introduction":"rpcx作者","url":"https://colobu.com/","title":"进个鸟窝-->"},{"avatar":"https://d1j8pt39hxlh3d.cloudfront.net/emoji/emojione/5.0/png/unicode/32/1f92a.png","name":"labuladong的算法小抄","introduction":"算法大神","url":"https://labuladong.gitbook.io/algo/","title":"学个算法-->"}]}},"excerpt":"","more":""}],"Post":[{"author":"djaigo","title":"redis集群策略方案","img":"https://img-1251474779.cos.ap-beijing.myqcloud.com/golang.png","date":"2020-09-16T02:43:50.000Z","updated":"2020-09-16T02:43:50.000Z","_content":"\n# master-slave\n依赖redis自带的主从复制，实现读写分离\n# sentinel\n# cluster\n# codis","source":"_drafts/redis集群方案.md","raw":"---\nauthor: djaigo\ntitle: redis集群策略方案\nimg: 'https://img-1251474779.cos.ap-beijing.myqcloud.com/golang.png'\ncategories:\n  - redis\ntags:\n  - redis\n  - cluster\ndate: 2020-09-16 10:43:50\nupdated: 2020-09-16 10:43:50\n---\n\n# master-slave\n依赖redis自带的主从复制，实现读写分离\n# sentinel\n# cluster\n# codis","slug":"redis集群方案","published":0,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckh351dtk000019z4gbbbahmp","content":"<h1 id=\"master-slave\"><a href=\"#master-slave\" class=\"headerlink\" title=\"master-slave\"></a>master-slave</h1><p>依赖redis自带的主从复制，实现读写分离</p>\n<h1 id=\"sentinel\"><a href=\"#sentinel\" class=\"headerlink\" title=\"sentinel\"></a>sentinel</h1><h1 id=\"cluster\"><a href=\"#cluster\" class=\"headerlink\" title=\"cluster\"></a>cluster</h1><h1 id=\"codis\"><a href=\"#codis\" class=\"headerlink\" title=\"codis\"></a>codis</h1><script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"friends":[{"avatar":"https://img-1251474779.cos.ap-beijing.myqcloud.com/icon.png","name":"djaigo","introduction":"好好学习，天天向上","url":"/","title":"前去学习"},{"avatar":"https://awps-assets.meituan.net/mit/blog/v20190629/asset/icon/favicon.ico?v=Whistle&t=20181017-1r","name":"美团技术团队","introduction":"一行代码，亿万生活。","url":"https://tech.meituan.com/","title":"点个外卖-->"},{"avatar":"","name":"鸟窝","introduction":"rpcx作者","url":"https://colobu.com/","title":"进个鸟窝-->"},{"avatar":"https://d1j8pt39hxlh3d.cloudfront.net/emoji/emojione/5.0/png/unicode/32/1f92a.png","name":"labuladong的算法小抄","introduction":"算法大神","url":"https://labuladong.gitbook.io/algo/","title":"学个算法-->"}]}},"excerpt":"","more":"<h1 id=\"master-slave\"><a href=\"#master-slave\" class=\"headerlink\" title=\"master-slave\"></a>master-slave</h1><p>依赖redis自带的主从复制，实现读写分离</p>\n<h1 id=\"sentinel\"><a href=\"#sentinel\" class=\"headerlink\" title=\"sentinel\"></a>sentinel</h1><h1 id=\"cluster\"><a href=\"#cluster\" class=\"headerlink\" title=\"cluster\"></a>cluster</h1><h1 id=\"codis\"><a href=\"#codis\" class=\"headerlink\" title=\"codis\"></a>codis</h1>"},{"author":"djaigo","title":"ss运行原理","img":"https://img-1251474779.cos.ap-beijing.myqcloud.com/golang.png","date":"2020-03-11T07:51:22.000Z","updated":"2020-03-11T07:51:22.000Z","_content":"\n\n解析一下ss的运行机制\n\n```mermaid\nsequenceDiagram\n    participant Alice\n    participant Bob\n    Alice->>John: Hello John, how are you?\n    loop Healthcheck\n        John->>John: Fight against hypochondria\n    end\n    Note right of John: Rational thoughts <br/>prevail!\n    John-->>Alice: Great!\n    John->>Bob: How about you?\n    Bob-->>John: Jolly good!\n```\n\n下面是程序的源代码\n```text\nsequenceDiagram\n    participant Alice\n    participant Bob\n    Alice->>John: Hello John, how are you?\n    loop Healthcheck\n        John->>John: Fight against hypochondria\n    end\n    Note right of John: Rational thoughts <br/>prevail!\n    John-->>Alice: Great!\n    John->>Bob: How about you?\n    Bob-->>John: Jolly good!\n```\n\n通过上图可以知道ss是通过本地和远端分别部署两个程序进行加密通信。\n\n\n\n","source":"_drafts/ss运行原理.md","raw":"---\nauthor: djaigo\ntitle: ss运行原理\nimg: 'https://img-1251474779.cos.ap-beijing.myqcloud.com/golang.png'\ncategories:\n  - null\ntags:\n  - null\ndate: 2020-03-11 15:51:22\nupdated: 2020-03-11 15:51:22\n---\n\n\n解析一下ss的运行机制\n\n```mermaid\nsequenceDiagram\n    participant Alice\n    participant Bob\n    Alice->>John: Hello John, how are you?\n    loop Healthcheck\n        John->>John: Fight against hypochondria\n    end\n    Note right of John: Rational thoughts <br/>prevail!\n    John-->>Alice: Great!\n    John->>Bob: How about you?\n    Bob-->>John: Jolly good!\n```\n\n下面是程序的源代码\n```text\nsequenceDiagram\n    participant Alice\n    participant Bob\n    Alice->>John: Hello John, how are you?\n    loop Healthcheck\n        John->>John: Fight against hypochondria\n    end\n    Note right of John: Rational thoughts <br/>prevail!\n    John-->>Alice: Great!\n    John->>Bob: How about you?\n    Bob-->>John: Jolly good!\n```\n\n通过上图可以知道ss是通过本地和远端分别部署两个程序进行加密通信。\n\n\n\n","slug":"ss运行原理","published":0,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckh351dtq000219z4764y9era","content":"<p>解析一下ss的运行机制</p>\n<pre class=\"mermaid\">sequenceDiagram\n    participant Alice\n    participant Bob\n    Alice-&gt;&gt;John: Hello John, how are you?\n    loop Healthcheck\n        John-&gt;&gt;John: Fight against hypochondria\n    end\n    Note right of John: Rational thoughts <br>prevail!\n    John--&gt;&gt;Alice: Great!\n    John-&gt;&gt;Bob: How about you?\n    Bob--&gt;&gt;John: Jolly good!</pre>\n\n<p>下面是程序的源代码</p>\n<pre class=\" language-text\"><code class=\"language-text\">sequenceDiagram\n    participant Alice\n    participant Bob\n    Alice->>John: Hello John, how are you?\n    loop Healthcheck\n        John->>John: Fight against hypochondria\n    end\n    Note right of John: Rational thoughts <br/>prevail!\n    John-->>Alice: Great!\n    John->>Bob: How about you?\n    Bob-->>John: Jolly good!</code></pre>\n<p>通过上图可以知道ss是通过本地和远端分别部署两个程序进行加密通信。</p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"friends":[{"avatar":"https://img-1251474779.cos.ap-beijing.myqcloud.com/icon.png","name":"djaigo","introduction":"好好学习，天天向上","url":"/","title":"前去学习"},{"avatar":"https://awps-assets.meituan.net/mit/blog/v20190629/asset/icon/favicon.ico?v=Whistle&t=20181017-1r","name":"美团技术团队","introduction":"一行代码，亿万生活。","url":"https://tech.meituan.com/","title":"点个外卖-->"},{"avatar":"","name":"鸟窝","introduction":"rpcx作者","url":"https://colobu.com/","title":"进个鸟窝-->"},{"avatar":"https://d1j8pt39hxlh3d.cloudfront.net/emoji/emojione/5.0/png/unicode/32/1f92a.png","name":"labuladong的算法小抄","introduction":"算法大神","url":"https://labuladong.gitbook.io/algo/","title":"学个算法-->"}]}},"excerpt":"","more":"<p>解析一下ss的运行机制</p>\n<pre class=\"mermaid\">sequenceDiagram\n    participant Alice\n    participant Bob\n    Alice->>John: Hello John, how are you?\n    loop Healthcheck\n        John->>John: Fight against hypochondria\n    end\n    Note right of John: Rational thoughts <br/>prevail!\n    John-->>Alice: Great!\n    John->>Bob: How about you?\n    Bob-->>John: Jolly good!</pre>\n\n<p>下面是程序的源代码</p>\n<pre><code class=\"text\">sequenceDiagram\n    participant Alice\n    participant Bob\n    Alice-&gt;&gt;John: Hello John, how are you?\n    loop Healthcheck\n        John-&gt;&gt;John: Fight against hypochondria\n    end\n    Note right of John: Rational thoughts &lt;br/&gt;prevail!\n    John--&gt;&gt;Alice: Great!\n    John-&gt;&gt;Bob: How about you?\n    Bob--&gt;&gt;John: Jolly good!</code></pre>\n<p>通过上图可以知道ss是通过本地和远端分别部署两个程序进行加密通信。</p>\n"},{"author":"djaigo","title":"git stash","date":"2019-12-10T06:43:35.000Z","update":null,"img":"https://img-1251474779.cos.ap-beijing.myqcloud.com/golang.png","_content":"\n# git stash\n将当前所有更改记录存放于栈区，可以在必要时将当前的更改恢复\n应用场景：\n* 需要切换分支，但是不想commit目前的文件更改\n* 用于临时切换分支\n\n## 命令\ngit stash\n将当前更改存储到栈区，当前文件目录就会回退到最近分支commit的状态\n\napply   -- 应用stash中的更改记录，调回指定的存储，如果不指明则默认最新存储。如果应用存储是会发生冲突的，所以应用后需要合并冲突\nbranch  -- 在最初创建存储的提交处分支，如果你存储一份修改，暂时不去理会，然后继续在你存储的分支上工作，你在重新应用工作时可能会碰到一些问题合并冲突的问题\n这个命令会创建一个新的分支，检查你存储的提交，重新应用分支，如果成功，将会丢弃储藏\nclear   -- 删除所有stash\ncreate  -- 创建一个存储而不将其存储在ref命名空间中\ndrop    -- 从list中删除一个stash\nlist    -- 列出所有的stash\npop     -- 从stash列表中删除并应用最近的stash\nsave    -- 将您的本地修改保存到新的stash中\nshow    -- 展示在stash中的修改记录的差异\n\n## 与commit的区别\ncommit会记录在历史记录中，而stash不会\n\n实体包：数据传输结构体定义\n工具包：功能函数实现\n错误包：产生错误定义\n模拟包：mock数据定义，函数实现\n部署包：部署远端服务器实现\n数据层：远端数据层实现\n服务层：本地功能实现\n路由层：分配路由，指定处理服务handle","source":"_posts/Git stash.md","raw":"---\nauthor: djaigo\ntitle: git stash\ndate: 2019-12-10 14:43:35\nupdate: \nimg: https://img-1251474779.cos.ap-beijing.myqcloud.com/golang.png\ncategories: \n  - git\ntags: \n  - git\n  - cmd\n---\n\n# git stash\n将当前所有更改记录存放于栈区，可以在必要时将当前的更改恢复\n应用场景：\n* 需要切换分支，但是不想commit目前的文件更改\n* 用于临时切换分支\n\n## 命令\ngit stash\n将当前更改存储到栈区，当前文件目录就会回退到最近分支commit的状态\n\napply   -- 应用stash中的更改记录，调回指定的存储，如果不指明则默认最新存储。如果应用存储是会发生冲突的，所以应用后需要合并冲突\nbranch  -- 在最初创建存储的提交处分支，如果你存储一份修改，暂时不去理会，然后继续在你存储的分支上工作，你在重新应用工作时可能会碰到一些问题合并冲突的问题\n这个命令会创建一个新的分支，检查你存储的提交，重新应用分支，如果成功，将会丢弃储藏\nclear   -- 删除所有stash\ncreate  -- 创建一个存储而不将其存储在ref命名空间中\ndrop    -- 从list中删除一个stash\nlist    -- 列出所有的stash\npop     -- 从stash列表中删除并应用最近的stash\nsave    -- 将您的本地修改保存到新的stash中\nshow    -- 展示在stash中的修改记录的差异\n\n## 与commit的区别\ncommit会记录在历史记录中，而stash不会\n\n实体包：数据传输结构体定义\n工具包：功能函数实现\n错误包：产生错误定义\n模拟包：mock数据定义，函数实现\n部署包：部署远端服务器实现\n数据层：远端数据层实现\n服务层：本地功能实现\n路由层：分配路由，指定处理服务handle","slug":"Git stash","published":1,"updated":"2019-12-10T06:43:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh351dtu000619z408g09ht9","content":"<h1 id=\"git-stash\"><a href=\"#git-stash\" class=\"headerlink\" title=\"git stash\"></a>git stash</h1><p>将当前所有更改记录存放于栈区，可以在必要时将当前的更改恢复<br>应用场景：</p>\n<ul>\n<li>需要切换分支，但是不想commit目前的文件更改</li>\n<li>用于临时切换分支</li>\n</ul>\n<h2 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h2><p>git stash<br>将当前更改存储到栈区，当前文件目录就会回退到最近分支commit的状态</p>\n<p>apply   – 应用stash中的更改记录，调回指定的存储，如果不指明则默认最新存储。如果应用存储是会发生冲突的，所以应用后需要合并冲突<br>branch  – 在最初创建存储的提交处分支，如果你存储一份修改，暂时不去理会，然后继续在你存储的分支上工作，你在重新应用工作时可能会碰到一些问题合并冲突的问题<br>这个命令会创建一个新的分支，检查你存储的提交，重新应用分支，如果成功，将会丢弃储藏<br>clear   – 删除所有stash<br>create  – 创建一个存储而不将其存储在ref命名空间中<br>drop    – 从list中删除一个stash<br>list    – 列出所有的stash<br>pop     – 从stash列表中删除并应用最近的stash<br>save    – 将您的本地修改保存到新的stash中<br>show    – 展示在stash中的修改记录的差异</p>\n<h2 id=\"与commit的区别\"><a href=\"#与commit的区别\" class=\"headerlink\" title=\"与commit的区别\"></a>与commit的区别</h2><p>commit会记录在历史记录中，而stash不会</p>\n<p>实体包：数据传输结构体定义<br>工具包：功能函数实现<br>错误包：产生错误定义<br>模拟包：mock数据定义，函数实现<br>部署包：部署远端服务器实现<br>数据层：远端数据层实现<br>服务层：本地功能实现<br>路由层：分配路由，指定处理服务handle</p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"friends":[{"avatar":"https://img-1251474779.cos.ap-beijing.myqcloud.com/icon.png","name":"djaigo","introduction":"好好学习，天天向上","url":"/","title":"前去学习"},{"avatar":"https://awps-assets.meituan.net/mit/blog/v20190629/asset/icon/favicon.ico?v=Whistle&t=20181017-1r","name":"美团技术团队","introduction":"一行代码，亿万生活。","url":"https://tech.meituan.com/","title":"点个外卖-->"},{"avatar":"","name":"鸟窝","introduction":"rpcx作者","url":"https://colobu.com/","title":"进个鸟窝-->"},{"avatar":"https://d1j8pt39hxlh3d.cloudfront.net/emoji/emojione/5.0/png/unicode/32/1f92a.png","name":"labuladong的算法小抄","introduction":"算法大神","url":"https://labuladong.gitbook.io/algo/","title":"学个算法-->"}]}},"excerpt":"","more":"<h1 id=\"git-stash\"><a href=\"#git-stash\" class=\"headerlink\" title=\"git stash\"></a>git stash</h1><p>将当前所有更改记录存放于栈区，可以在必要时将当前的更改恢复<br>应用场景：</p>\n<ul>\n<li>需要切换分支，但是不想commit目前的文件更改</li>\n<li>用于临时切换分支</li>\n</ul>\n<h2 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h2><p>git stash<br>将当前更改存储到栈区，当前文件目录就会回退到最近分支commit的状态</p>\n<p>apply   – 应用stash中的更改记录，调回指定的存储，如果不指明则默认最新存储。如果应用存储是会发生冲突的，所以应用后需要合并冲突<br>branch  – 在最初创建存储的提交处分支，如果你存储一份修改，暂时不去理会，然后继续在你存储的分支上工作，你在重新应用工作时可能会碰到一些问题合并冲突的问题<br>这个命令会创建一个新的分支，检查你存储的提交，重新应用分支，如果成功，将会丢弃储藏<br>clear   – 删除所有stash<br>create  – 创建一个存储而不将其存储在ref命名空间中<br>drop    – 从list中删除一个stash<br>list    – 列出所有的stash<br>pop     – 从stash列表中删除并应用最近的stash<br>save    – 将您的本地修改保存到新的stash中<br>show    – 展示在stash中的修改记录的差异</p>\n<h2 id=\"与commit的区别\"><a href=\"#与commit的区别\" class=\"headerlink\" title=\"与commit的区别\"></a>与commit的区别</h2><p>commit会记录在历史记录中，而stash不会</p>\n<p>实体包：数据传输结构体定义<br>工具包：功能函数实现<br>错误包：产生错误定义<br>模拟包：mock数据定义，函数实现<br>部署包：部署远端服务器实现<br>数据层：远端数据层实现<br>服务层：本地功能实现<br>路由层：分配路由，指定处理服务handle</p>\n"},{"author":"djaigo","title":"golang 编译指示","date":"2019-12-10T06:43:35.000Z","update":null,"img":"https://img-1251474779.cos.ap-beijing.myqcloud.com/golang.png","enable html":true,"_content":"# 编译指示\n函数声明前一行写上`//go:`后面跟上编译指示，在编译的时候，go编译器会进行指定的操作。\n\n源码中包含了所有的编译指示\n\n```go\nconst (\n\t// Func pragmas.\n\tNointerface    syntax.Pragma = 1 << iota\n\tNoescape                     // func parameters don't escape\n\tNorace                       // func must not have race detector annotations\n\tNosplit                      // func should not execute on separate stack\n\tNoinline                     // func should not be inlined\n\tCgoUnsafeArgs                // treat a pointer to one arg as a pointer to them all\n\tUintptrEscapes               // pointers converted to uintptr escape\n\n\t// Runtime-only func pragmas.\n\t// See ../../../../runtime/README.md for detailed descriptions.\n\tSystemstack        // func must run on system stack\n\tNowritebarrier     // emit compiler error instead of write barrier\n\tNowritebarrierrec  // error on write barrier in this or recursive callees\n\tYeswritebarrierrec // cancels Nowritebarrierrec in this function and callees\n\n\t// Runtime-only type pragmas\n\tNotInHeap // values of this type must not be heap allocated\n)\n\nfunc pragmaValue(verb string) syntax.Pragma {\n\tswitch verb {\n\tcase \"go:nointerface\":\n\t\tif objabi.Fieldtrack_enabled != 0 {\n\t\t\treturn Nointerface\n\t\t}\n\tcase \"go:noescape\":\n\t\treturn Noescape\n\tcase \"go:norace\":\n\t\treturn Norace\n\tcase \"go:nosplit\":\n\t\treturn Nosplit\n\tcase \"go:noinline\":\n\t\treturn Noinline\n\tcase \"go:systemstack\":\n\t\treturn Systemstack\n\tcase \"go:nowritebarrier\":\n\t\treturn Nowritebarrier\n\tcase \"go:nowritebarrierrec\":\n\t\treturn Nowritebarrierrec | Nowritebarrier // implies Nowritebarrier\n\tcase \"go:yeswritebarrierrec\":\n\t\treturn Yeswritebarrierrec\n\tcase \"go:cgo_unsafe_args\":\n\t\treturn CgoUnsafeArgs\n\tcase \"go:uintptrescapes\":\n\t\t// For the next function declared in the file\n\t\t// any uintptr arguments may be pointer values\n\t\t// converted to uintptr. This directive\n\t\t// ensures that the referenced allocated\n\t\t// object, if any, is retained and not moved\n\t\t// until the call completes, even though from\n\t\t// the types alone it would appear that the\n\t\t// object is no longer needed during the\n\t\t// call. The conversion to uintptr must appear\n\t\t// in the argument list.\n\t\t// Used in syscall/dll_windows.go.\n\t\treturn UintptrEscapes\n\tcase \"go:notinheap\":\n\t\treturn NotInHeap\n\t}\n\treturn 0\n}\n```\n\n## nointerface\n\n## noescape\n\n禁止逃逸，而且它必须指示一个只有声明没有主体的函数。\n最显而易见的好处是，GC 压力变小了。\n因为它已经告诉编译器，下面的函数无论如何都不会逃逸，那么当函数返回时，其中的资源也会一并都被销毁。\n不过，这么做代表会绕过编译器的逃逸检查，一旦进入运行时，就有可能导致严重的错误及后果。\n\n## norace\n\n跳过竞态检测\n\n## nosplit\n\n跳过栈溢出检测，正是因为一个 Goroutine 的起始栈大小是有限制的，且比较小的，才可以做到支持并发很多 Goroutine，并高效调度。\n[stack.go](https://github.com/golang/go/blob/master/src/runtime/stack.go#L71) 源码中可以看到，`_StackMin` 是 2048 字节，也就是 2k，它不是一成不变的，当不够用时，它会动态地增长。\n那么，必然有一个检测的机制，来保证可以及时地知道栈不够用了，然后再去增长。\n回到话题，`nosplit` 就是将这个跳过这个机制。\n\n## noinline\n\n标记编译的时候不用内联\n\n## systemstack\n\n## nowritebarrier\n## nowritebarrierrec\n## yeswritebarrierrec\n## cgo_unsafe_args\n## uintptrescapes\n\n## notinheap\n\n\n\n## linkname\n\n示例：`//go:linkname localname importpath.name`\n\n编译器指令的使用linkname instructs”importpath.name”为对象的文件的符号名的变量或函数被作为“localname”代码。因为本指令的类型系统和CAN subvert包装modularity只读文件，它是在一个“功能”不安全”。\n\n# 参考文献\n\n1. [Go 语言编译器的 \"//go:\" 详解](https://segmentfault.com/a/1190000016743220)\n2. [Command compile](https://golang.org/cmd/compile/)","source":"_drafts/编译指示.md","raw":"---\nauthor: djaigo\ntitle: golang 编译指示\ndate: 2019-12-10 14:43:35\nupdate: \nimg: https://img-1251474779.cos.ap-beijing.myqcloud.com/golang.png\ncategories: \n  - golang\ntags: \n  - compile\nenable html: true\n---\n# 编译指示\n函数声明前一行写上`//go:`后面跟上编译指示，在编译的时候，go编译器会进行指定的操作。\n\n源码中包含了所有的编译指示\n\n```go\nconst (\n\t// Func pragmas.\n\tNointerface    syntax.Pragma = 1 << iota\n\tNoescape                     // func parameters don't escape\n\tNorace                       // func must not have race detector annotations\n\tNosplit                      // func should not execute on separate stack\n\tNoinline                     // func should not be inlined\n\tCgoUnsafeArgs                // treat a pointer to one arg as a pointer to them all\n\tUintptrEscapes               // pointers converted to uintptr escape\n\n\t// Runtime-only func pragmas.\n\t// See ../../../../runtime/README.md for detailed descriptions.\n\tSystemstack        // func must run on system stack\n\tNowritebarrier     // emit compiler error instead of write barrier\n\tNowritebarrierrec  // error on write barrier in this or recursive callees\n\tYeswritebarrierrec // cancels Nowritebarrierrec in this function and callees\n\n\t// Runtime-only type pragmas\n\tNotInHeap // values of this type must not be heap allocated\n)\n\nfunc pragmaValue(verb string) syntax.Pragma {\n\tswitch verb {\n\tcase \"go:nointerface\":\n\t\tif objabi.Fieldtrack_enabled != 0 {\n\t\t\treturn Nointerface\n\t\t}\n\tcase \"go:noescape\":\n\t\treturn Noescape\n\tcase \"go:norace\":\n\t\treturn Norace\n\tcase \"go:nosplit\":\n\t\treturn Nosplit\n\tcase \"go:noinline\":\n\t\treturn Noinline\n\tcase \"go:systemstack\":\n\t\treturn Systemstack\n\tcase \"go:nowritebarrier\":\n\t\treturn Nowritebarrier\n\tcase \"go:nowritebarrierrec\":\n\t\treturn Nowritebarrierrec | Nowritebarrier // implies Nowritebarrier\n\tcase \"go:yeswritebarrierrec\":\n\t\treturn Yeswritebarrierrec\n\tcase \"go:cgo_unsafe_args\":\n\t\treturn CgoUnsafeArgs\n\tcase \"go:uintptrescapes\":\n\t\t// For the next function declared in the file\n\t\t// any uintptr arguments may be pointer values\n\t\t// converted to uintptr. This directive\n\t\t// ensures that the referenced allocated\n\t\t// object, if any, is retained and not moved\n\t\t// until the call completes, even though from\n\t\t// the types alone it would appear that the\n\t\t// object is no longer needed during the\n\t\t// call. The conversion to uintptr must appear\n\t\t// in the argument list.\n\t\t// Used in syscall/dll_windows.go.\n\t\treturn UintptrEscapes\n\tcase \"go:notinheap\":\n\t\treturn NotInHeap\n\t}\n\treturn 0\n}\n```\n\n## nointerface\n\n## noescape\n\n禁止逃逸，而且它必须指示一个只有声明没有主体的函数。\n最显而易见的好处是，GC 压力变小了。\n因为它已经告诉编译器，下面的函数无论如何都不会逃逸，那么当函数返回时，其中的资源也会一并都被销毁。\n不过，这么做代表会绕过编译器的逃逸检查，一旦进入运行时，就有可能导致严重的错误及后果。\n\n## norace\n\n跳过竞态检测\n\n## nosplit\n\n跳过栈溢出检测，正是因为一个 Goroutine 的起始栈大小是有限制的，且比较小的，才可以做到支持并发很多 Goroutine，并高效调度。\n[stack.go](https://github.com/golang/go/blob/master/src/runtime/stack.go#L71) 源码中可以看到，`_StackMin` 是 2048 字节，也就是 2k，它不是一成不变的，当不够用时，它会动态地增长。\n那么，必然有一个检测的机制，来保证可以及时地知道栈不够用了，然后再去增长。\n回到话题，`nosplit` 就是将这个跳过这个机制。\n\n## noinline\n\n标记编译的时候不用内联\n\n## systemstack\n\n## nowritebarrier\n## nowritebarrierrec\n## yeswritebarrierrec\n## cgo_unsafe_args\n## uintptrescapes\n\n## notinheap\n\n\n\n## linkname\n\n示例：`//go:linkname localname importpath.name`\n\n编译器指令的使用linkname instructs”importpath.name”为对象的文件的符号名的变量或函数被作为“localname”代码。因为本指令的类型系统和CAN subvert包装modularity只读文件，它是在一个“功能”不安全”。\n\n# 参考文献\n\n1. [Go 语言编译器的 \"//go:\" 详解](https://segmentfault.com/a/1190000016743220)\n2. [Command compile](https://golang.org/cmd/compile/)","slug":"编译指示","published":0,"updated":"2019-12-10T06:43:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh351dtx000819z49rk0575z","content":"<h1 id=\"编译指示\"><a href=\"#编译指示\" class=\"headerlink\" title=\"编译指示\"></a>编译指示</h1><p>函数声明前一行写上<code>//go:</code>后面跟上编译指示，在编译的时候，go编译器会进行指定的操作。</p>\n<p>源码中包含了所有的编译指示</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">const</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Func pragmas.</span>\n    Nointerface    syntax<span class=\"token punctuation\">.</span>Pragma <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token boolean\">iota</span>\n    Noescape                     <span class=\"token comment\" spellcheck=\"true\">// func parameters don't escape</span>\n    Norace                       <span class=\"token comment\" spellcheck=\"true\">// func must not have race detector annotations</span>\n    Nosplit                      <span class=\"token comment\" spellcheck=\"true\">// func should not execute on separate stack</span>\n    Noinline                     <span class=\"token comment\" spellcheck=\"true\">// func should not be inlined</span>\n    CgoUnsafeArgs                <span class=\"token comment\" spellcheck=\"true\">// treat a pointer to one arg as a pointer to them all</span>\n    UintptrEscapes               <span class=\"token comment\" spellcheck=\"true\">// pointers converted to uintptr escape</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Runtime-only func pragmas.</span>\n    <span class=\"token comment\" spellcheck=\"true\">// See ../../../../runtime/README.md for detailed descriptions.</span>\n    Systemstack        <span class=\"token comment\" spellcheck=\"true\">// func must run on system stack</span>\n    Nowritebarrier     <span class=\"token comment\" spellcheck=\"true\">// emit compiler error instead of write barrier</span>\n    Nowritebarrierrec  <span class=\"token comment\" spellcheck=\"true\">// error on write barrier in this or recursive callees</span>\n    Yeswritebarrierrec <span class=\"token comment\" spellcheck=\"true\">// cancels Nowritebarrierrec in this function and callees</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Runtime-only type pragmas</span>\n    NotInHeap <span class=\"token comment\" spellcheck=\"true\">// values of this type must not be heap allocated</span>\n<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">pragmaValue</span><span class=\"token punctuation\">(</span>verb <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> syntax<span class=\"token punctuation\">.</span>Pragma <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">switch</span> verb <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">case</span> <span class=\"token string\">\"go:nointerface\"</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> objabi<span class=\"token punctuation\">.</span>Fieldtrack_enabled <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> Nointerface\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">case</span> <span class=\"token string\">\"go:noescape\"</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> Noescape\n    <span class=\"token keyword\">case</span> <span class=\"token string\">\"go:norace\"</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> Norace\n    <span class=\"token keyword\">case</span> <span class=\"token string\">\"go:nosplit\"</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> Nosplit\n    <span class=\"token keyword\">case</span> <span class=\"token string\">\"go:noinline\"</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> Noinline\n    <span class=\"token keyword\">case</span> <span class=\"token string\">\"go:systemstack\"</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> Systemstack\n    <span class=\"token keyword\">case</span> <span class=\"token string\">\"go:nowritebarrier\"</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> Nowritebarrier\n    <span class=\"token keyword\">case</span> <span class=\"token string\">\"go:nowritebarrierrec\"</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> Nowritebarrierrec <span class=\"token operator\">|</span> Nowritebarrier <span class=\"token comment\" spellcheck=\"true\">// implies Nowritebarrier</span>\n    <span class=\"token keyword\">case</span> <span class=\"token string\">\"go:yeswritebarrierrec\"</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> Yeswritebarrierrec\n    <span class=\"token keyword\">case</span> <span class=\"token string\">\"go:cgo_unsafe_args\"</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> CgoUnsafeArgs\n    <span class=\"token keyword\">case</span> <span class=\"token string\">\"go:uintptrescapes\"</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\" spellcheck=\"true\">// For the next function declared in the file</span>\n        <span class=\"token comment\" spellcheck=\"true\">// any uintptr arguments may be pointer values</span>\n        <span class=\"token comment\" spellcheck=\"true\">// converted to uintptr. This directive</span>\n        <span class=\"token comment\" spellcheck=\"true\">// ensures that the referenced allocated</span>\n        <span class=\"token comment\" spellcheck=\"true\">// object, if any, is retained and not moved</span>\n        <span class=\"token comment\" spellcheck=\"true\">// until the call completes, even though from</span>\n        <span class=\"token comment\" spellcheck=\"true\">// the types alone it would appear that the</span>\n        <span class=\"token comment\" spellcheck=\"true\">// object is no longer needed during the</span>\n        <span class=\"token comment\" spellcheck=\"true\">// call. The conversion to uintptr must appear</span>\n        <span class=\"token comment\" spellcheck=\"true\">// in the argument list.</span>\n        <span class=\"token comment\" spellcheck=\"true\">// Used in syscall/dll_windows.go.</span>\n        <span class=\"token keyword\">return</span> UintptrEscapes\n    <span class=\"token keyword\">case</span> <span class=\"token string\">\"go:notinheap\"</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> NotInHeap\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"nointerface\"><a href=\"#nointerface\" class=\"headerlink\" title=\"nointerface\"></a>nointerface</h2><h2 id=\"noescape\"><a href=\"#noescape\" class=\"headerlink\" title=\"noescape\"></a>noescape</h2><p>禁止逃逸，而且它必须指示一个只有声明没有主体的函数。<br>最显而易见的好处是，GC 压力变小了。<br>因为它已经告诉编译器，下面的函数无论如何都不会逃逸，那么当函数返回时，其中的资源也会一并都被销毁。<br>不过，这么做代表会绕过编译器的逃逸检查，一旦进入运行时，就有可能导致严重的错误及后果。</p>\n<h2 id=\"norace\"><a href=\"#norace\" class=\"headerlink\" title=\"norace\"></a>norace</h2><p>跳过竞态检测</p>\n<h2 id=\"nosplit\"><a href=\"#nosplit\" class=\"headerlink\" title=\"nosplit\"></a>nosplit</h2><p>跳过栈溢出检测，正是因为一个 Goroutine 的起始栈大小是有限制的，且比较小的，才可以做到支持并发很多 Goroutine，并高效调度。<br><a href=\"https://github.com/golang/go/blob/master/src/runtime/stack.go#L71\" target=\"_blank\" rel=\"noopener\">stack.go</a> 源码中可以看到，<code>_StackMin</code> 是 2048 字节，也就是 2k，它不是一成不变的，当不够用时，它会动态地增长。<br>那么，必然有一个检测的机制，来保证可以及时地知道栈不够用了，然后再去增长。<br>回到话题，<code>nosplit</code> 就是将这个跳过这个机制。</p>\n<h2 id=\"noinline\"><a href=\"#noinline\" class=\"headerlink\" title=\"noinline\"></a>noinline</h2><p>标记编译的时候不用内联</p>\n<h2 id=\"systemstack\"><a href=\"#systemstack\" class=\"headerlink\" title=\"systemstack\"></a>systemstack</h2><h2 id=\"nowritebarrier\"><a href=\"#nowritebarrier\" class=\"headerlink\" title=\"nowritebarrier\"></a>nowritebarrier</h2><h2 id=\"nowritebarrierrec\"><a href=\"#nowritebarrierrec\" class=\"headerlink\" title=\"nowritebarrierrec\"></a>nowritebarrierrec</h2><h2 id=\"yeswritebarrierrec\"><a href=\"#yeswritebarrierrec\" class=\"headerlink\" title=\"yeswritebarrierrec\"></a>yeswritebarrierrec</h2><h2 id=\"cgo-unsafe-args\"><a href=\"#cgo-unsafe-args\" class=\"headerlink\" title=\"cgo_unsafe_args\"></a>cgo_unsafe_args</h2><h2 id=\"uintptrescapes\"><a href=\"#uintptrescapes\" class=\"headerlink\" title=\"uintptrescapes\"></a>uintptrescapes</h2><h2 id=\"notinheap\"><a href=\"#notinheap\" class=\"headerlink\" title=\"notinheap\"></a>notinheap</h2><h2 id=\"linkname\"><a href=\"#linkname\" class=\"headerlink\" title=\"linkname\"></a>linkname</h2><p>示例：<code>//go:linkname localname importpath.name</code></p>\n<p>编译器指令的使用linkname instructs”importpath.name”为对象的文件的符号名的变量或函数被作为“localname”代码。因为本指令的类型系统和CAN subvert包装modularity只读文件，它是在一个“功能”不安全”。</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ol>\n<li><a href=\"https://segmentfault.com/a/1190000016743220\" target=\"_blank\" rel=\"noopener\">Go 语言编译器的 “//go:” 详解</a></li>\n<li><a href=\"https://golang.org/cmd/compile/\" target=\"_blank\" rel=\"noopener\">Command compile</a></li>\n</ol>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"friends":[{"avatar":"https://img-1251474779.cos.ap-beijing.myqcloud.com/icon.png","name":"djaigo","introduction":"好好学习，天天向上","url":"/","title":"前去学习"},{"avatar":"https://awps-assets.meituan.net/mit/blog/v20190629/asset/icon/favicon.ico?v=Whistle&t=20181017-1r","name":"美团技术团队","introduction":"一行代码，亿万生活。","url":"https://tech.meituan.com/","title":"点个外卖-->"},{"avatar":"","name":"鸟窝","introduction":"rpcx作者","url":"https://colobu.com/","title":"进个鸟窝-->"},{"avatar":"https://d1j8pt39hxlh3d.cloudfront.net/emoji/emojione/5.0/png/unicode/32/1f92a.png","name":"labuladong的算法小抄","introduction":"算法大神","url":"https://labuladong.gitbook.io/algo/","title":"学个算法-->"}]}},"excerpt":"","more":"<h1 id=\"编译指示\"><a href=\"#编译指示\" class=\"headerlink\" title=\"编译指示\"></a>编译指示</h1><p>函数声明前一行写上<code>//go:</code>后面跟上编译指示，在编译的时候，go编译器会进行指定的操作。</p>\n<p>源码中包含了所有的编译指示</p>\n<pre><code class=\"go\">const (\n    // Func pragmas.\n    Nointerface    syntax.Pragma = 1 &lt;&lt; iota\n    Noescape                     // func parameters don&#39;t escape\n    Norace                       // func must not have race detector annotations\n    Nosplit                      // func should not execute on separate stack\n    Noinline                     // func should not be inlined\n    CgoUnsafeArgs                // treat a pointer to one arg as a pointer to them all\n    UintptrEscapes               // pointers converted to uintptr escape\n\n    // Runtime-only func pragmas.\n    // See ../../../../runtime/README.md for detailed descriptions.\n    Systemstack        // func must run on system stack\n    Nowritebarrier     // emit compiler error instead of write barrier\n    Nowritebarrierrec  // error on write barrier in this or recursive callees\n    Yeswritebarrierrec // cancels Nowritebarrierrec in this function and callees\n\n    // Runtime-only type pragmas\n    NotInHeap // values of this type must not be heap allocated\n)\n\nfunc pragmaValue(verb string) syntax.Pragma {\n    switch verb {\n    case &quot;go:nointerface&quot;:\n        if objabi.Fieldtrack_enabled != 0 {\n            return Nointerface\n        }\n    case &quot;go:noescape&quot;:\n        return Noescape\n    case &quot;go:norace&quot;:\n        return Norace\n    case &quot;go:nosplit&quot;:\n        return Nosplit\n    case &quot;go:noinline&quot;:\n        return Noinline\n    case &quot;go:systemstack&quot;:\n        return Systemstack\n    case &quot;go:nowritebarrier&quot;:\n        return Nowritebarrier\n    case &quot;go:nowritebarrierrec&quot;:\n        return Nowritebarrierrec | Nowritebarrier // implies Nowritebarrier\n    case &quot;go:yeswritebarrierrec&quot;:\n        return Yeswritebarrierrec\n    case &quot;go:cgo_unsafe_args&quot;:\n        return CgoUnsafeArgs\n    case &quot;go:uintptrescapes&quot;:\n        // For the next function declared in the file\n        // any uintptr arguments may be pointer values\n        // converted to uintptr. This directive\n        // ensures that the referenced allocated\n        // object, if any, is retained and not moved\n        // until the call completes, even though from\n        // the types alone it would appear that the\n        // object is no longer needed during the\n        // call. The conversion to uintptr must appear\n        // in the argument list.\n        // Used in syscall/dll_windows.go.\n        return UintptrEscapes\n    case &quot;go:notinheap&quot;:\n        return NotInHeap\n    }\n    return 0\n}</code></pre>\n<h2 id=\"nointerface\"><a href=\"#nointerface\" class=\"headerlink\" title=\"nointerface\"></a>nointerface</h2><h2 id=\"noescape\"><a href=\"#noescape\" class=\"headerlink\" title=\"noescape\"></a>noescape</h2><p>禁止逃逸，而且它必须指示一个只有声明没有主体的函数。<br>最显而易见的好处是，GC 压力变小了。<br>因为它已经告诉编译器，下面的函数无论如何都不会逃逸，那么当函数返回时，其中的资源也会一并都被销毁。<br>不过，这么做代表会绕过编译器的逃逸检查，一旦进入运行时，就有可能导致严重的错误及后果。</p>\n<h2 id=\"norace\"><a href=\"#norace\" class=\"headerlink\" title=\"norace\"></a>norace</h2><p>跳过竞态检测</p>\n<h2 id=\"nosplit\"><a href=\"#nosplit\" class=\"headerlink\" title=\"nosplit\"></a>nosplit</h2><p>跳过栈溢出检测，正是因为一个 Goroutine 的起始栈大小是有限制的，且比较小的，才可以做到支持并发很多 Goroutine，并高效调度。<br><a href=\"https://github.com/golang/go/blob/master/src/runtime/stack.go#L71\" target=\"_blank\" rel=\"noopener\">stack.go</a> 源码中可以看到，<code>_StackMin</code> 是 2048 字节，也就是 2k，它不是一成不变的，当不够用时，它会动态地增长。<br>那么，必然有一个检测的机制，来保证可以及时地知道栈不够用了，然后再去增长。<br>回到话题，<code>nosplit</code> 就是将这个跳过这个机制。</p>\n<h2 id=\"noinline\"><a href=\"#noinline\" class=\"headerlink\" title=\"noinline\"></a>noinline</h2><p>标记编译的时候不用内联</p>\n<h2 id=\"systemstack\"><a href=\"#systemstack\" class=\"headerlink\" title=\"systemstack\"></a>systemstack</h2><h2 id=\"nowritebarrier\"><a href=\"#nowritebarrier\" class=\"headerlink\" title=\"nowritebarrier\"></a>nowritebarrier</h2><h2 id=\"nowritebarrierrec\"><a href=\"#nowritebarrierrec\" class=\"headerlink\" title=\"nowritebarrierrec\"></a>nowritebarrierrec</h2><h2 id=\"yeswritebarrierrec\"><a href=\"#yeswritebarrierrec\" class=\"headerlink\" title=\"yeswritebarrierrec\"></a>yeswritebarrierrec</h2><h2 id=\"cgo-unsafe-args\"><a href=\"#cgo-unsafe-args\" class=\"headerlink\" title=\"cgo_unsafe_args\"></a>cgo_unsafe_args</h2><h2 id=\"uintptrescapes\"><a href=\"#uintptrescapes\" class=\"headerlink\" title=\"uintptrescapes\"></a>uintptrescapes</h2><h2 id=\"notinheap\"><a href=\"#notinheap\" class=\"headerlink\" title=\"notinheap\"></a>notinheap</h2><h2 id=\"linkname\"><a href=\"#linkname\" class=\"headerlink\" title=\"linkname\"></a>linkname</h2><p>示例：<code>//go:linkname localname importpath.name</code></p>\n<p>编译器指令的使用linkname instructs”importpath.name”为对象的文件的符号名的变量或函数被作为“localname”代码。因为本指令的类型系统和CAN subvert包装modularity只读文件，它是在一个“功能”不安全”。</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ol>\n<li><a href=\"https://segmentfault.com/a/1190000016743220\" target=\"_blank\" rel=\"noopener\">Go 语言编译器的 “//go:” 详解</a></li>\n<li><a href=\"https://golang.org/cmd/compile/\" target=\"_blank\" rel=\"noopener\">Command compile</a></li>\n</ol>\n"},{"author":"djaigo","title":"TCP协议","img":"https://img-1251474779.cos.ap-beijing.myqcloud.com/net.png","date":"2019-12-20T09:32:14.000Z","_content":"\n# 简介\nTCP协议是传输层重要的协议，TCP是面向连接、字节流和提供可靠传输。要使用TCP连接的双方必须先建立连接，然后才能开始数据的读写。TCP是全双工的，所以双发的内核都需要一定的资源保存TCP连接的状态和连接上的数据。在完成数据交换之后，通信双方都必须断开连接已释放系统资源。\n# 头部结构\n头部结构字段：\n```text\n0                   1                   2                   3 \n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 \n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Source Port          |       Destination Port        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Sequence Number                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    Acknowledgment Number                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Data |           |U|A|P|R|S|F|                               |\n| Offset| Reserved  |R|C|S|S|Y|I|            Window             |\n|       |           |G|K|H|T|N|N|                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|           Checksum            |         Urgent Pointer        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    Options                    |    Padding    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                             data                              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n```\n\n* Source Port:  16 bits\n* Destination Port:  16 bits\n* Sequence Number:  32 bits\n* Acknowledgment Number:  32 bits\n* Data Offset:  4 bits\n* Reserved:  6 bits\n* Control Bits:  6 bits\n* Window:  16 bits\n* Checksum:  16 bits\n* Urgent Pointer:  16 bits\n* Options:  variable\n* Padding:  variable\n\n## Sequence Number\n## Acknowledgment Number\n## Data Offset\n## Control Bits\n## Window\n## Checksum\n检验和是填充一个伪包头加上TCP报文求和算出。\n伪包头结构字段：\n```text\n+--------+--------+--------+--------+\n|           Source Address          |\n+--------+--------+--------+--------+\n|         Destination Address       |\n+--------+--------+--------+--------+\n|  zero  |  PTCL  |    TCP Length   |\n+--------+--------+--------+--------+\n```\n  - Source Address: 32 bits\n  - Destination Address: 32 bits\n  - zero: 8 bits\n  - PTCL: 8 bits\n  - TCP Length: 16 bits\n\n## Urgent Pointer\n## Options\n  当前定义的选项字段\n  \n| Kind | Length | Meaning |\n| ---- | ------ | ------- |\n|  0   |   -  |   End of option list. |\n|  1   |   -  |   No-Operation. |\n|  2   |   4  |  Maximum Segment Size. |\n\n\n\n# 连接\n## TCP 连接状态机\n```text\n                              +---------+ ---------\\      active OPEN\n                              |  CLOSED |            \\    -----------\n                              +---------+<---------\\   \\   create TCB\n                                |     ^              \\   \\  snd SYN\n                   passive OPEN |     |   CLOSE        \\   \\\n                   ------------ |     | ----------       \\   \\\n                    create TCB  |     | delete TCB         \\   \\\n                                V     |                      \\   \\\n                              +---------+            CLOSE    |    \\\n                              |  LISTEN |          ---------- |     |\n                              +---------+          delete TCB |     |\n                   rcv SYN      |     |     SEND              |     |\n                  -----------   |     |    -------            |     V\n +---------+      snd SYN,ACK  /       \\   snd SYN          +---------+\n |         |<-----------------           ------------------>|         |\n |   SYN   |                    rcv SYN                     |   SYN   |\n |   RCVD  |<-----------------------------------------------|   SENT  |\n |         |                    snd ACK                     |         |\n |         |------------------           -------------------|         |\n +---------+   rcv ACK of SYN  \\       /  rcv SYN,ACK       +---------+\n   |           --------------   |     |   -----------\n   |                  x         |     |     snd ACK\n   |                            V     V\n   |  CLOSE                   +---------+\n   | -------                  |  ESTAB  |\n   | snd FIN                  +---------+\n   |                   CLOSE    |     |    rcv FIN\n   V                  -------   |     |    -------\n +---------+          snd FIN  /       \\   snd ACK          +---------+\n |  FIN    |<-----------------           ------------------>|  CLOSE  |\n | WAIT-1  |------------------                              |   WAIT  |\n +---------+          rcv FIN  \\                            +---------+\n   | rcv ACK of FIN   -------   |                            CLOSE  |\n   | --------------   snd ACK   |                           ------- |\n   V        x                   V                           snd FIN V\n +---------+                  +---------+                   +---------+\n |FINWAIT-2|                  | CLOSING |                   | LAST-ACK|\n +---------+                  +---------+                   +---------+\n   |                rcv ACK of FIN |                 rcv ACK of FIN |\n   |  rcv FIN       -------------- |    Timeout=2MSL -------------- |\n   |  -------              x       V    ------------        x       V\n    \\ snd ACK                 +---------+delete TCB         +---------+\n     ------------------------>|TIME WAIT|------------------>| CLOSED  |\n                              +---------+                   +---------+\n```\n\n### 各个状态意义\n* LISTEN - represents waiting for a connection request from any remote\n    TCP and port.\n* SYN-SENT - represents waiting for a matching connection request\n    after having sent a connection request.\n* SYN-RECEIVED - represents waiting for a confirming connection\n    request acknowledgment after having both received and sent a\n    connection request.\n* ESTABLISHED - represents an open connection, data received can be\n    delivered to the user.  The normal state for the data transfer phase\n    of the connection.\n* FIN-WAIT-1 - represents waiting for a connection termination request\n    from the remote TCP, or an acknowledgment of the connection\n    termination request previously sent.\n* FIN-WAIT-2 - represents waiting for a connection termination request\n    from the remote TCP.\n* CLOSE-WAIT - represents waiting for a connection termination request\n    from the local user.\n* CLOSING - represents waiting for a connection termination request\n    acknowledgment from the remote TCP.\n* LAST-ACK - represents waiting for an acknowledgment of the\n    connection termination request previously sent to the remote TCP\n    (which includes an acknowledgment of its connection termination\n    request).\n* TIME-WAIT - represents waiting for enough time to pass to be sure\n    the remote TCP received the acknowledgment of its connection\n    termination request.\n* CLOSED - represents no connection state at all.\n\n## 建立连接\n## Establishing\n## 断开连接\n# 超时重传\n# 拥塞控制\n\n# 参考文献\n* [TRANSMISSION CONTROL PROTOCOL](https://tools.ietf.org/html/rfc793)\n* [Requirements for Internet Hosts -- Communication Layers](https://tools.ietf.org/html/rfc1122)\n* 《Linux高性能服务器编程》\n* [传输控制协议](https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE)\n","source":"_posts/TCP协议.md","raw":"---\nauthor: djaigo\ntitle: TCP协议\nimg: 'https://img-1251474779.cos.ap-beijing.myqcloud.com/net.png'\ncategories:\n  - net\ntags:\n  - tcp\ndate: 2019-12-20 17:32:14\n---\n\n# 简介\nTCP协议是传输层重要的协议，TCP是面向连接、字节流和提供可靠传输。要使用TCP连接的双方必须先建立连接，然后才能开始数据的读写。TCP是全双工的，所以双发的内核都需要一定的资源保存TCP连接的状态和连接上的数据。在完成数据交换之后，通信双方都必须断开连接已释放系统资源。\n# 头部结构\n头部结构字段：\n```text\n0                   1                   2                   3 \n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 \n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Source Port          |       Destination Port        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Sequence Number                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    Acknowledgment Number                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Data |           |U|A|P|R|S|F|                               |\n| Offset| Reserved  |R|C|S|S|Y|I|            Window             |\n|       |           |G|K|H|T|N|N|                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|           Checksum            |         Urgent Pointer        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    Options                    |    Padding    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                             data                              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n```\n\n* Source Port:  16 bits\n* Destination Port:  16 bits\n* Sequence Number:  32 bits\n* Acknowledgment Number:  32 bits\n* Data Offset:  4 bits\n* Reserved:  6 bits\n* Control Bits:  6 bits\n* Window:  16 bits\n* Checksum:  16 bits\n* Urgent Pointer:  16 bits\n* Options:  variable\n* Padding:  variable\n\n## Sequence Number\n## Acknowledgment Number\n## Data Offset\n## Control Bits\n## Window\n## Checksum\n检验和是填充一个伪包头加上TCP报文求和算出。\n伪包头结构字段：\n```text\n+--------+--------+--------+--------+\n|           Source Address          |\n+--------+--------+--------+--------+\n|         Destination Address       |\n+--------+--------+--------+--------+\n|  zero  |  PTCL  |    TCP Length   |\n+--------+--------+--------+--------+\n```\n  - Source Address: 32 bits\n  - Destination Address: 32 bits\n  - zero: 8 bits\n  - PTCL: 8 bits\n  - TCP Length: 16 bits\n\n## Urgent Pointer\n## Options\n  当前定义的选项字段\n  \n| Kind | Length | Meaning |\n| ---- | ------ | ------- |\n|  0   |   -  |   End of option list. |\n|  1   |   -  |   No-Operation. |\n|  2   |   4  |  Maximum Segment Size. |\n\n\n\n# 连接\n## TCP 连接状态机\n```text\n                              +---------+ ---------\\      active OPEN\n                              |  CLOSED |            \\    -----------\n                              +---------+<---------\\   \\   create TCB\n                                |     ^              \\   \\  snd SYN\n                   passive OPEN |     |   CLOSE        \\   \\\n                   ------------ |     | ----------       \\   \\\n                    create TCB  |     | delete TCB         \\   \\\n                                V     |                      \\   \\\n                              +---------+            CLOSE    |    \\\n                              |  LISTEN |          ---------- |     |\n                              +---------+          delete TCB |     |\n                   rcv SYN      |     |     SEND              |     |\n                  -----------   |     |    -------            |     V\n +---------+      snd SYN,ACK  /       \\   snd SYN          +---------+\n |         |<-----------------           ------------------>|         |\n |   SYN   |                    rcv SYN                     |   SYN   |\n |   RCVD  |<-----------------------------------------------|   SENT  |\n |         |                    snd ACK                     |         |\n |         |------------------           -------------------|         |\n +---------+   rcv ACK of SYN  \\       /  rcv SYN,ACK       +---------+\n   |           --------------   |     |   -----------\n   |                  x         |     |     snd ACK\n   |                            V     V\n   |  CLOSE                   +---------+\n   | -------                  |  ESTAB  |\n   | snd FIN                  +---------+\n   |                   CLOSE    |     |    rcv FIN\n   V                  -------   |     |    -------\n +---------+          snd FIN  /       \\   snd ACK          +---------+\n |  FIN    |<-----------------           ------------------>|  CLOSE  |\n | WAIT-1  |------------------                              |   WAIT  |\n +---------+          rcv FIN  \\                            +---------+\n   | rcv ACK of FIN   -------   |                            CLOSE  |\n   | --------------   snd ACK   |                           ------- |\n   V        x                   V                           snd FIN V\n +---------+                  +---------+                   +---------+\n |FINWAIT-2|                  | CLOSING |                   | LAST-ACK|\n +---------+                  +---------+                   +---------+\n   |                rcv ACK of FIN |                 rcv ACK of FIN |\n   |  rcv FIN       -------------- |    Timeout=2MSL -------------- |\n   |  -------              x       V    ------------        x       V\n    \\ snd ACK                 +---------+delete TCB         +---------+\n     ------------------------>|TIME WAIT|------------------>| CLOSED  |\n                              +---------+                   +---------+\n```\n\n### 各个状态意义\n* LISTEN - represents waiting for a connection request from any remote\n    TCP and port.\n* SYN-SENT - represents waiting for a matching connection request\n    after having sent a connection request.\n* SYN-RECEIVED - represents waiting for a confirming connection\n    request acknowledgment after having both received and sent a\n    connection request.\n* ESTABLISHED - represents an open connection, data received can be\n    delivered to the user.  The normal state for the data transfer phase\n    of the connection.\n* FIN-WAIT-1 - represents waiting for a connection termination request\n    from the remote TCP, or an acknowledgment of the connection\n    termination request previously sent.\n* FIN-WAIT-2 - represents waiting for a connection termination request\n    from the remote TCP.\n* CLOSE-WAIT - represents waiting for a connection termination request\n    from the local user.\n* CLOSING - represents waiting for a connection termination request\n    acknowledgment from the remote TCP.\n* LAST-ACK - represents waiting for an acknowledgment of the\n    connection termination request previously sent to the remote TCP\n    (which includes an acknowledgment of its connection termination\n    request).\n* TIME-WAIT - represents waiting for enough time to pass to be sure\n    the remote TCP received the acknowledgment of its connection\n    termination request.\n* CLOSED - represents no connection state at all.\n\n## 建立连接\n## Establishing\n## 断开连接\n# 超时重传\n# 拥塞控制\n\n# 参考文献\n* [TRANSMISSION CONTROL PROTOCOL](https://tools.ietf.org/html/rfc793)\n* [Requirements for Internet Hosts -- Communication Layers](https://tools.ietf.org/html/rfc1122)\n* 《Linux高性能服务器编程》\n* [传输控制协议](https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE)\n","slug":"TCP协议","published":1,"updated":"2019-12-20T09:32:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh351du0000a19z4d0tk2cbq","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>TCP协议是传输层重要的协议，TCP是面向连接、字节流和提供可靠传输。要使用TCP连接的双方必须先建立连接，然后才能开始数据的读写。TCP是全双工的，所以双发的内核都需要一定的资源保存TCP连接的状态和连接上的数据。在完成数据交换之后，通信双方都必须断开连接已释放系统资源。</p>\n<h1 id=\"头部结构\"><a href=\"#头部结构\" class=\"headerlink\" title=\"头部结构\"></a>头部结构</h1><p>头部结构字段：</p>\n<pre class=\" language-text\"><code class=\"language-text\">0                   1                   2                   3 \n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 \n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Source Port          |       Destination Port        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Sequence Number                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    Acknowledgment Number                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Data |           |U|A|P|R|S|F|                               |\n| Offset| Reserved  |R|C|S|S|Y|I|            Window             |\n|       |           |G|K|H|T|N|N|                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|           Checksum            |         Urgent Pointer        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    Options                    |    Padding    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                             data                              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre>\n<ul>\n<li>Source Port:  16 bits</li>\n<li>Destination Port:  16 bits</li>\n<li>Sequence Number:  32 bits</li>\n<li>Acknowledgment Number:  32 bits</li>\n<li>Data Offset:  4 bits</li>\n<li>Reserved:  6 bits</li>\n<li>Control Bits:  6 bits</li>\n<li>Window:  16 bits</li>\n<li>Checksum:  16 bits</li>\n<li>Urgent Pointer:  16 bits</li>\n<li>Options:  variable</li>\n<li>Padding:  variable</li>\n</ul>\n<h2 id=\"Sequence-Number\"><a href=\"#Sequence-Number\" class=\"headerlink\" title=\"Sequence Number\"></a>Sequence Number</h2><h2 id=\"Acknowledgment-Number\"><a href=\"#Acknowledgment-Number\" class=\"headerlink\" title=\"Acknowledgment Number\"></a>Acknowledgment Number</h2><h2 id=\"Data-Offset\"><a href=\"#Data-Offset\" class=\"headerlink\" title=\"Data Offset\"></a>Data Offset</h2><h2 id=\"Control-Bits\"><a href=\"#Control-Bits\" class=\"headerlink\" title=\"Control Bits\"></a>Control Bits</h2><h2 id=\"Window\"><a href=\"#Window\" class=\"headerlink\" title=\"Window\"></a>Window</h2><h2 id=\"Checksum\"><a href=\"#Checksum\" class=\"headerlink\" title=\"Checksum\"></a>Checksum</h2><p>检验和是填充一个伪包头加上TCP报文求和算出。<br>伪包头结构字段：</p>\n<pre class=\" language-text\"><code class=\"language-text\">+--------+--------+--------+--------+\n|           Source Address          |\n+--------+--------+--------+--------+\n|         Destination Address       |\n+--------+--------+--------+--------+\n|  zero  |  PTCL  |    TCP Length   |\n+--------+--------+--------+--------+</code></pre>\n<ul>\n<li>Source Address: 32 bits</li>\n<li>Destination Address: 32 bits</li>\n<li>zero: 8 bits</li>\n<li>PTCL: 8 bits</li>\n<li>TCP Length: 16 bits</li>\n</ul>\n<h2 id=\"Urgent-Pointer\"><a href=\"#Urgent-Pointer\" class=\"headerlink\" title=\"Urgent Pointer\"></a>Urgent Pointer</h2><h2 id=\"Options\"><a href=\"#Options\" class=\"headerlink\" title=\"Options\"></a>Options</h2><p>  当前定义的选项字段</p>\n<table>\n<thead>\n<tr>\n<th>Kind</th>\n<th>Length</th>\n<th>Meaning</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>-</td>\n<td>End of option list.</td>\n</tr>\n<tr>\n<td>1</td>\n<td>-</td>\n<td>No-Operation.</td>\n</tr>\n<tr>\n<td>2</td>\n<td>4</td>\n<td>Maximum Segment Size.</td>\n</tr>\n</tbody></table>\n<h1 id=\"连接\"><a href=\"#连接\" class=\"headerlink\" title=\"连接\"></a>连接</h1><h2 id=\"TCP-连接状态机\"><a href=\"#TCP-连接状态机\" class=\"headerlink\" title=\"TCP 连接状态机\"></a>TCP 连接状态机</h2><pre class=\" language-text\"><code class=\"language-text\">                              +---------+ ---------\\      active OPEN\n                              |  CLOSED |            \\    -----------\n                              +---------+<---------\\   \\   create TCB\n                                |     ^              \\   \\  snd SYN\n                   passive OPEN |     |   CLOSE        \\   \\\n                   ------------ |     | ----------       \\   \\\n                    create TCB  |     | delete TCB         \\   \\\n                                V     |                      \\   \\\n                              +---------+            CLOSE    |    \\\n                              |  LISTEN |          ---------- |     |\n                              +---------+          delete TCB |     |\n                   rcv SYN      |     |     SEND              |     |\n                  -----------   |     |    -------            |     V\n +---------+      snd SYN,ACK  /       \\   snd SYN          +---------+\n |         |<-----------------           ------------------>|         |\n |   SYN   |                    rcv SYN                     |   SYN   |\n |   RCVD  |<-----------------------------------------------|   SENT  |\n |         |                    snd ACK                     |         |\n |         |------------------           -------------------|         |\n +---------+   rcv ACK of SYN  \\       /  rcv SYN,ACK       +---------+\n   |           --------------   |     |   -----------\n   |                  x         |     |     snd ACK\n   |                            V     V\n   |  CLOSE                   +---------+\n   | -------                  |  ESTAB  |\n   | snd FIN                  +---------+\n   |                   CLOSE    |     |    rcv FIN\n   V                  -------   |     |    -------\n +---------+          snd FIN  /       \\   snd ACK          +---------+\n |  FIN    |<-----------------           ------------------>|  CLOSE  |\n | WAIT-1  |------------------                              |   WAIT  |\n +---------+          rcv FIN  \\                            +---------+\n   | rcv ACK of FIN   -------   |                            CLOSE  |\n   | --------------   snd ACK   |                           ------- |\n   V        x                   V                           snd FIN V\n +---------+                  +---------+                   +---------+\n |FINWAIT-2|                  | CLOSING |                   | LAST-ACK|\n +---------+                  +---------+                   +---------+\n   |                rcv ACK of FIN |                 rcv ACK of FIN |\n   |  rcv FIN       -------------- |    Timeout=2MSL -------------- |\n   |  -------              x       V    ------------        x       V\n    \\ snd ACK                 +---------+delete TCB         +---------+\n     ------------------------>|TIME WAIT|------------------>| CLOSED  |\n                              +---------+                   +---------+</code></pre>\n<h3 id=\"各个状态意义\"><a href=\"#各个状态意义\" class=\"headerlink\" title=\"各个状态意义\"></a>各个状态意义</h3><ul>\n<li>LISTEN - represents waiting for a connection request from any remote<br>  TCP and port.</li>\n<li>SYN-SENT - represents waiting for a matching connection request<br>  after having sent a connection request.</li>\n<li>SYN-RECEIVED - represents waiting for a confirming connection<br>  request acknowledgment after having both received and sent a<br>  connection request.</li>\n<li>ESTABLISHED - represents an open connection, data received can be<br>  delivered to the user.  The normal state for the data transfer phase<br>  of the connection.</li>\n<li>FIN-WAIT-1 - represents waiting for a connection termination request<br>  from the remote TCP, or an acknowledgment of the connection<br>  termination request previously sent.</li>\n<li>FIN-WAIT-2 - represents waiting for a connection termination request<br>  from the remote TCP.</li>\n<li>CLOSE-WAIT - represents waiting for a connection termination request<br>  from the local user.</li>\n<li>CLOSING - represents waiting for a connection termination request<br>  acknowledgment from the remote TCP.</li>\n<li>LAST-ACK - represents waiting for an acknowledgment of the<br>  connection termination request previously sent to the remote TCP<br>  (which includes an acknowledgment of its connection termination<br>  request).</li>\n<li>TIME-WAIT - represents waiting for enough time to pass to be sure<br>  the remote TCP received the acknowledgment of its connection<br>  termination request.</li>\n<li>CLOSED - represents no connection state at all.</li>\n</ul>\n<h2 id=\"建立连接\"><a href=\"#建立连接\" class=\"headerlink\" title=\"建立连接\"></a>建立连接</h2><h2 id=\"Establishing\"><a href=\"#Establishing\" class=\"headerlink\" title=\"Establishing\"></a>Establishing</h2><h2 id=\"断开连接\"><a href=\"#断开连接\" class=\"headerlink\" title=\"断开连接\"></a>断开连接</h2><h1 id=\"超时重传\"><a href=\"#超时重传\" class=\"headerlink\" title=\"超时重传\"></a>超时重传</h1><h1 id=\"拥塞控制\"><a href=\"#拥塞控制\" class=\"headerlink\" title=\"拥塞控制\"></a>拥塞控制</h1><h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ul>\n<li><a href=\"https://tools.ietf.org/html/rfc793\" target=\"_blank\" rel=\"noopener\">TRANSMISSION CONTROL PROTOCOL</a></li>\n<li><a href=\"https://tools.ietf.org/html/rfc1122\" target=\"_blank\" rel=\"noopener\">Requirements for Internet Hosts – Communication Layers</a></li>\n<li>《Linux高性能服务器编程》</li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE\" target=\"_blank\" rel=\"noopener\">传输控制协议</a></li>\n</ul>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"friends":[{"avatar":"https://img-1251474779.cos.ap-beijing.myqcloud.com/icon.png","name":"djaigo","introduction":"好好学习，天天向上","url":"/","title":"前去学习"},{"avatar":"https://awps-assets.meituan.net/mit/blog/v20190629/asset/icon/favicon.ico?v=Whistle&t=20181017-1r","name":"美团技术团队","introduction":"一行代码，亿万生活。","url":"https://tech.meituan.com/","title":"点个外卖-->"},{"avatar":"","name":"鸟窝","introduction":"rpcx作者","url":"https://colobu.com/","title":"进个鸟窝-->"},{"avatar":"https://d1j8pt39hxlh3d.cloudfront.net/emoji/emojione/5.0/png/unicode/32/1f92a.png","name":"labuladong的算法小抄","introduction":"算法大神","url":"https://labuladong.gitbook.io/algo/","title":"学个算法-->"}]}},"excerpt":"","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>TCP协议是传输层重要的协议，TCP是面向连接、字节流和提供可靠传输。要使用TCP连接的双方必须先建立连接，然后才能开始数据的读写。TCP是全双工的，所以双发的内核都需要一定的资源保存TCP连接的状态和连接上的数据。在完成数据交换之后，通信双方都必须断开连接已释放系统资源。</p>\n<h1 id=\"头部结构\"><a href=\"#头部结构\" class=\"headerlink\" title=\"头部结构\"></a>头部结构</h1><p>头部结构字段：</p>\n<pre><code class=\"text\">0                   1                   2                   3 \n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 \n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Source Port          |       Destination Port        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Sequence Number                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    Acknowledgment Number                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Data |           |U|A|P|R|S|F|                               |\n| Offset| Reserved  |R|C|S|S|Y|I|            Window             |\n|       |           |G|K|H|T|N|N|                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|           Checksum            |         Urgent Pointer        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    Options                    |    Padding    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                             data                              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre>\n<ul>\n<li>Source Port:  16 bits</li>\n<li>Destination Port:  16 bits</li>\n<li>Sequence Number:  32 bits</li>\n<li>Acknowledgment Number:  32 bits</li>\n<li>Data Offset:  4 bits</li>\n<li>Reserved:  6 bits</li>\n<li>Control Bits:  6 bits</li>\n<li>Window:  16 bits</li>\n<li>Checksum:  16 bits</li>\n<li>Urgent Pointer:  16 bits</li>\n<li>Options:  variable</li>\n<li>Padding:  variable</li>\n</ul>\n<h2 id=\"Sequence-Number\"><a href=\"#Sequence-Number\" class=\"headerlink\" title=\"Sequence Number\"></a>Sequence Number</h2><h2 id=\"Acknowledgment-Number\"><a href=\"#Acknowledgment-Number\" class=\"headerlink\" title=\"Acknowledgment Number\"></a>Acknowledgment Number</h2><h2 id=\"Data-Offset\"><a href=\"#Data-Offset\" class=\"headerlink\" title=\"Data Offset\"></a>Data Offset</h2><h2 id=\"Control-Bits\"><a href=\"#Control-Bits\" class=\"headerlink\" title=\"Control Bits\"></a>Control Bits</h2><h2 id=\"Window\"><a href=\"#Window\" class=\"headerlink\" title=\"Window\"></a>Window</h2><h2 id=\"Checksum\"><a href=\"#Checksum\" class=\"headerlink\" title=\"Checksum\"></a>Checksum</h2><p>检验和是填充一个伪包头加上TCP报文求和算出。<br>伪包头结构字段：</p>\n<pre><code class=\"text\">+--------+--------+--------+--------+\n|           Source Address          |\n+--------+--------+--------+--------+\n|         Destination Address       |\n+--------+--------+--------+--------+\n|  zero  |  PTCL  |    TCP Length   |\n+--------+--------+--------+--------+</code></pre>\n<ul>\n<li>Source Address: 32 bits</li>\n<li>Destination Address: 32 bits</li>\n<li>zero: 8 bits</li>\n<li>PTCL: 8 bits</li>\n<li>TCP Length: 16 bits</li>\n</ul>\n<h2 id=\"Urgent-Pointer\"><a href=\"#Urgent-Pointer\" class=\"headerlink\" title=\"Urgent Pointer\"></a>Urgent Pointer</h2><h2 id=\"Options\"><a href=\"#Options\" class=\"headerlink\" title=\"Options\"></a>Options</h2><p>  当前定义的选项字段</p>\n<table>\n<thead>\n<tr>\n<th>Kind</th>\n<th>Length</th>\n<th>Meaning</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>-</td>\n<td>End of option list.</td>\n</tr>\n<tr>\n<td>1</td>\n<td>-</td>\n<td>No-Operation.</td>\n</tr>\n<tr>\n<td>2</td>\n<td>4</td>\n<td>Maximum Segment Size.</td>\n</tr>\n</tbody></table>\n<h1 id=\"连接\"><a href=\"#连接\" class=\"headerlink\" title=\"连接\"></a>连接</h1><h2 id=\"TCP-连接状态机\"><a href=\"#TCP-连接状态机\" class=\"headerlink\" title=\"TCP 连接状态机\"></a>TCP 连接状态机</h2><pre><code class=\"text\">                              +---------+ ---------\\      active OPEN\n                              |  CLOSED |            \\    -----------\n                              +---------+&lt;---------\\   \\   create TCB\n                                |     ^              \\   \\  snd SYN\n                   passive OPEN |     |   CLOSE        \\   \\\n                   ------------ |     | ----------       \\   \\\n                    create TCB  |     | delete TCB         \\   \\\n                                V     |                      \\   \\\n                              +---------+            CLOSE    |    \\\n                              |  LISTEN |          ---------- |     |\n                              +---------+          delete TCB |     |\n                   rcv SYN      |     |     SEND              |     |\n                  -----------   |     |    -------            |     V\n +---------+      snd SYN,ACK  /       \\   snd SYN          +---------+\n |         |&lt;-----------------           ------------------&gt;|         |\n |   SYN   |                    rcv SYN                     |   SYN   |\n |   RCVD  |&lt;-----------------------------------------------|   SENT  |\n |         |                    snd ACK                     |         |\n |         |------------------           -------------------|         |\n +---------+   rcv ACK of SYN  \\       /  rcv SYN,ACK       +---------+\n   |           --------------   |     |   -----------\n   |                  x         |     |     snd ACK\n   |                            V     V\n   |  CLOSE                   +---------+\n   | -------                  |  ESTAB  |\n   | snd FIN                  +---------+\n   |                   CLOSE    |     |    rcv FIN\n   V                  -------   |     |    -------\n +---------+          snd FIN  /       \\   snd ACK          +---------+\n |  FIN    |&lt;-----------------           ------------------&gt;|  CLOSE  |\n | WAIT-1  |------------------                              |   WAIT  |\n +---------+          rcv FIN  \\                            +---------+\n   | rcv ACK of FIN   -------   |                            CLOSE  |\n   | --------------   snd ACK   |                           ------- |\n   V        x                   V                           snd FIN V\n +---------+                  +---------+                   +---------+\n |FINWAIT-2|                  | CLOSING |                   | LAST-ACK|\n +---------+                  +---------+                   +---------+\n   |                rcv ACK of FIN |                 rcv ACK of FIN |\n   |  rcv FIN       -------------- |    Timeout=2MSL -------------- |\n   |  -------              x       V    ------------        x       V\n    \\ snd ACK                 +---------+delete TCB         +---------+\n     ------------------------&gt;|TIME WAIT|------------------&gt;| CLOSED  |\n                              +---------+                   +---------+</code></pre>\n<h3 id=\"各个状态意义\"><a href=\"#各个状态意义\" class=\"headerlink\" title=\"各个状态意义\"></a>各个状态意义</h3><ul>\n<li>LISTEN - represents waiting for a connection request from any remote<br>  TCP and port.</li>\n<li>SYN-SENT - represents waiting for a matching connection request<br>  after having sent a connection request.</li>\n<li>SYN-RECEIVED - represents waiting for a confirming connection<br>  request acknowledgment after having both received and sent a<br>  connection request.</li>\n<li>ESTABLISHED - represents an open connection, data received can be<br>  delivered to the user.  The normal state for the data transfer phase<br>  of the connection.</li>\n<li>FIN-WAIT-1 - represents waiting for a connection termination request<br>  from the remote TCP, or an acknowledgment of the connection<br>  termination request previously sent.</li>\n<li>FIN-WAIT-2 - represents waiting for a connection termination request<br>  from the remote TCP.</li>\n<li>CLOSE-WAIT - represents waiting for a connection termination request<br>  from the local user.</li>\n<li>CLOSING - represents waiting for a connection termination request<br>  acknowledgment from the remote TCP.</li>\n<li>LAST-ACK - represents waiting for an acknowledgment of the<br>  connection termination request previously sent to the remote TCP<br>  (which includes an acknowledgment of its connection termination<br>  request).</li>\n<li>TIME-WAIT - represents waiting for enough time to pass to be sure<br>  the remote TCP received the acknowledgment of its connection<br>  termination request.</li>\n<li>CLOSED - represents no connection state at all.</li>\n</ul>\n<h2 id=\"建立连接\"><a href=\"#建立连接\" class=\"headerlink\" title=\"建立连接\"></a>建立连接</h2><h2 id=\"Establishing\"><a href=\"#Establishing\" class=\"headerlink\" title=\"Establishing\"></a>Establishing</h2><h2 id=\"断开连接\"><a href=\"#断开连接\" class=\"headerlink\" title=\"断开连接\"></a>断开连接</h2><h1 id=\"超时重传\"><a href=\"#超时重传\" class=\"headerlink\" title=\"超时重传\"></a>超时重传</h1><h1 id=\"拥塞控制\"><a href=\"#拥塞控制\" class=\"headerlink\" title=\"拥塞控制\"></a>拥塞控制</h1><h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ul>\n<li><a href=\"https://tools.ietf.org/html/rfc793\" target=\"_blank\" rel=\"noopener\">TRANSMISSION CONTROL PROTOCOL</a></li>\n<li><a href=\"https://tools.ietf.org/html/rfc1122\" target=\"_blank\" rel=\"noopener\">Requirements for Internet Hosts – Communication Layers</a></li>\n<li>《Linux高性能服务器编程》</li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE\" target=\"_blank\" rel=\"noopener\">传输控制协议</a></li>\n</ul>\n"},{"author":"djaigo","title":"redis conf 说明","date":"2019-12-10T06:43:35.000Z","update":null,"img":"https://img-1251474779.cos.ap-beijing.myqcloud.com/redis.png","enable html":true,"_content":"\n最新Redis配置文件获取[redis.conf](http://download.redis.io/redis-stable/redis.conf)\n\n# start\n启动Redis启动。\n```sh\n$ ./redis-server /path/to/redis.conf\n```\n\n配置文件单位说明，单位不区分大小写。\n```sh\n# 1k => 1000 bytes\n# 1kb => 1024 bytes\n# 1m => 1000000 bytes\n# 1mb => 1024 * 1024 bytes\n# 1g => 1000000000 bytes\n# 1gb => 1024 * 1024 * 1024 bytes\n```\n\n# include\n`include`可以引入其他的配置文件，且不会被`CONFIG REWRITE`命令复写。Redis总是使用最后处理的行作为配置指令的值，最好在文件开始的时候`include`，避免运行时复写配置。如果想用`include`覆盖之前的配置可以放在文件末尾。\n```sh\n# include /path/to/local.conf\n# include /path/to/other.conf\n```\n\n# module\n在启动时加载模块，如果无法加载，Redis会`abort`，可以同时加载多个模块。\n```sh\n# loadmodule /path/to/my_module.so\n# loadmodule /path/to/other_module.so\n```\n\n# network\n## bind\n默认地，如果没有指定`bind`指令，Redis监听监听服务器上所有可用网络接口的连接。可以使用`bind`配置指令只侦听一个或多个选定的网卡接口，后跟一个或多个IP地址。\n如果不指定bind指定是一件很危险的事，所以Redis默认指定本地的环回地址。\n```sh\n# bind 192.168.1.100 10.0.0.1\nbind 127.0.0.1 ::1\n```\n\n## protected-mode\n保护模式是一层安全保护，以避免Redis实例在Internet上保持打开状态被访问和利用。\n当保护模式打开，并且：\n* Redis未`bind`到一组地址\n* 没有配置密码\n\nRedis只能接受来自IPv4和IPv6环回地址（127.0.0.1和::1）、Unix域套接字的连接。\n保护模式默认是打开的。如果想其他地址访问Redis没有使用密码，或没有使用bind指定网络接口可以关闭保护模式。\n```sh\nprotected-mode yes\n```\n\n## port\n接受指定端口的连接。如果指定为0，Redis不会监听TCP socket。\n```sh\nport 6379\n```\n\n## tcp-backlog\nTCP listen()函数的backlog参数，挂起连接队列的最大长度。\n```sh\ntcp-backlog 511\n```\n\n## Unix socket\n指定`Unix socket`的路径，Redis默认不监听`Unix socket`。\n```sh\n# unixsocket /tmp/redis.sock\n# unixsocketperm 700\n```\n\n## timeout\n设置连接多少秒没有使用后断开连接，0表示不启用。\n```sh\ntimeout 0\n```\n\n## TCP keepalive\n如果非零，使用SO_KEEPALIVE发送TCP ACK，来保活连接。\n这样做有两个理由：\n* 检测对端状态\n* \n\n在Linux上，每隔指定的值（单位秒）都会发送TCP ACK，如果需要关闭连接则需要两倍这个时间。\n其他内核取决于内核配置。\nRedis默认300秒。\n```sh\ntcp-keepalive 300\n```\n\n# general\n## daemonize\nRedis默认是不作为`daemon`运行，可以使用`yes`启动该选项。\nRedis在启用指令后会在`/var/run/redis.pid`产生`pid`文件。\n```sh\ndaemonize no\n```\n\n## supervised\n如果使用upstart或者systemd启动Redis，可以使用supervised指令进行交互。\n选项：\n* no - 不使用supervision交互\n* upstart - 让Redis进入`SIGSTOP`模式\n* systemd - 向`$NOTIFY_SOCKET`写入`READY=1`\n* auto - 基于环境变量`UPSTART_JOB`或 `NOTIFY_SOCKET`来设置upstart还是systemd模式\n\nsupervised只表示进程已经就绪，并不持续supervisor。\n```sh\nsupervised no\n```\n\n## pidfile\n如果指定了pidfile，那么Redis将会在启动的时候写入，退出的时候删除。\n当Redis启动是使用非daemonized，配置中没有指定pidfile，则不会有pidfile创建；当Redis使用daemonized启动时，即使没有指定pidfile，也会创建，默认是`/var/run/redis.pid`。\n如果Redis无法创建pidfile，也不会产生任何影响，Redis依旧可以正常启动和运行。\n```sh\npidfile /var/run/redis_6379.pid\n```\n\n## loglevel\n设置日志等级：\n* debug，对开发测试有用\n* verbose，一些有用的信息，不像debug那么杂乱\n* notice，一般生产日志\n* warning，记录关键信息\n\n```sh\nloglevel notice\n```\n\n## logfile\n指定日志文件名，空字符串表示Redis日志强制输出到标准输出。如果使用daemonized并且把日志输出到标准输出，则日志会被发送到`/dev/null`。\n```sh\nlogfile \"\"\n```\n\n## syslog\n### enabled\n将日志输出到system logger，指定`syslog-enabled`为`yes`，可以按照需求添加其他参数。\n```sh\n# syslog-enabled no\n```\n\n### ident\n指定syslog标识。\n```sh\n# syslog-ident redis\n```\n\n### facility\n指定syslog的`facility`，必须是`USER`或介于`LOCAL0-LOCAL7`。\n```sh\n# syslog-facility local0\n```\n\n## databases\n设置Redis数据库的数量，默认`DB`是0，可以使用`SELECT`选择`dbid`介于`0-databases-1`。\n```sh\ndatabases 16\n```\n\n## show logo\n默认在Redis启动的时候打印`ASCII logo`，仅在log输出在标准输出或标准输出是TTY的时候。只有在交互式的时候才显示`logo`。\n```sh\nalways-show-logo yes\n```\n\n# snapshotting\n## save\n数据库快照，将Redis数据保存到disk，命令`save second changes`。\n当指定秒和写操作次数同时满足的时候写入disk。\n可以通过注释掉save来禁用快照，也可以使用`save \"\"`来禁用已经设置的快照选项。\n示例表示：\n* 900秒（15分钟）至少有一个键改动\n* 300秒（5分钟）至少有10个键改动\n* 60秒（1分钟）至少有10000个键改动\n```sh\nsave 900 1\nsave 300 10\nsave 60 10000\n```\n\n## stop-writes-on-bgsave-error\n当启动RDB快照时，Redis会停止写入，并且最后一次后台保存会失败。\n```sh\nstop-writes-on-bgsave-error yes\n```\n\n## rdbcompression\n当使用dump .rdb数据库时，是否使用LZF压缩字符串对象\n```sh\nrdbcompression yes\n```\n\n## rdbchecksum\nCRC64校验和存放于RDB文件的末尾，这可以抵抗损坏，但是有性能问题，可以禁用。\n```sh\nrdbchecksum yes\n```\n\n## dbfilename\n指定dump文件\n```sh\ndbfilename dump.rdb\n```\n\n## dir\n指定工作目录，`dbfilename`指定的文件将会在`dir`中创建，只追加的文件也在此目录中创建。\n`dir`必须指定一个目录，非文件路径。\n```sh\ndir ./\n```\n\n\n# replication\n## replicaof\n`Master-Replica`拷贝，使用replicaof让一个Redis实例复制另一个Redis实例。\n相关概念：\n* Redis复制是异步的，如果一个主Redis实例没有与给定数量的副本连接，那么可以配置他停止接收写操作\n* 如果复制链接丢失的时间相对较少，Redis副本可以与主服务器执行部分重新同步。根据需要，您可能需要使用合理的值配置复制积压工作的大小（请参阅此文件的下一节）。\n* 复制是一个自动的过程，网络分区副本自动尝试重新连接到主服务器，并与它们重新同步。\n\n```sh\n# replicaof masterip masterport\n```\n\n## masterauth\n如果master有密码（使用requirepass配置），副本在复制的之前必须要验证密码，否则将拒绝复制。\n```sh\n# masterauth <master-password>\n```\n\n## replica-serve-stale-data\n当副本与master断开连接，或当复制正在进行时，副本可以以两种不同的方式发挥做用：\n* 如果将`replica-serve-stale-data`设置成`yes`，副本将仍然回复客户端的请求，可能数据已过期，或者为空\n* 如果将`replica-serve-stale-data`设置成`no`，副本将用`SYNC with master in progress`回复所有请求，除了`INFO`，`replicaOF`，`AUTH`，`PING`，`SHUTDOWN`，`REPLCONF`，`ROLE`，`CONFIG`，`SUBSCRIBE`，`UNSUBSCRIBE`，`PSUBSCRIBE`，`PUNSUBSCRIBE`，`PUBLISH`，`PUBSUB`，`COMMAND`，`POST`，`HOST:`，`LATENCY`\n\n```sh\nreplica-serve-stale-data yes\n```\n\n## replica-read-only\n设置副本实例是否可以写，默认副本是只读的。副本仍可以执行所有管理命令，可以使用`rename-command`遮蔽这些管理命令。\n```sh\nreplica-read-only yes\n```\n\n## repl-diskless-sync\n新的复制副本和重新连接的复制副本无法继续仅接收差异的复制过程，需要执行所谓的“完全同步”。RDB文件从主服务器传输到副本服务器。\n传输可以通过两种不同的方式进行：\n* 磁盘支持，Redis主服务器创建一个新进程，将RDB文件写入磁盘，稍后，父进程将文件以递增方式传输到副本。\n* 无磁盘，Redis主服务器创建一个新进程，将RDB文件写入副本套接字，不通过磁盘。\n\n使用磁盘备份复制，在生成RDB文件的同时，可以在生成RDB文件的当前子级完成工作后，将更多的副本排队并与RDB文件一起提供服务。\n在无盘复制中，一旦传输开始，到达的新副本将排队，当当前副本终止时，将开始新的传输。`master`实例机会在开始传输之前等待一段可配置的时间（以秒为单位），以希望多个副本能够到达，并且可以并行传输。\n使用低速磁盘和快速（大带宽）网络，无盘复制工作得更好。\n```sh\nrepl-diskless-sync no\n```\n\n## repl-diskless-sync-delay\n启动无盘复制时，可以配置服务器的等待延迟，这一点很重要，因为一旦传输开始，就不可能为到达的新副本提供服务，这些副本将排队等待下一次RDB传输，因此服务器将等待一段延迟，以便让更多副本到达。\n默认5秒，设置为0表示禁用\n```sh\nrepl-diskless-sync-delay 5\n```\n\n## repl-ping-replica-period\n副本以预先定义的间隔向服务器发送ping。可以使用`repl-ping-replica-period`选项更改此间隔。默认值为10秒。\n```sh\n# repl-ping-replica-period 10\n```\n\n## repl-timeout\n以下情况会复制超时：\n* 从副本角度看，同步期间的批量传输I/O。\n* 从副本角度看，master实例超时。\n* 从master实例看，复制超时。\n\n确保`repl-timeout`比`repl-ping-replica-period`大，否则每次主服务器和副本之间的通信量低时都会检测到超时。\n```sh\n# repl-timeout 60\n```\n\n## repl-disable-tcp-nodelay\n在副本发送`SYNC`后禁用`TCP_NODELAY`？\n如果选择`yes`，Redis会占用少量带宽发送少量TCP包给副本，但这可能会增加副本同步延迟，使用Linux内核默认配置最多可延迟40毫秒。\n如果选择`no`，延迟会减少，但是会占用更多带宽用于复制。\n默认选择`no`，但是在非常高流量下或者master和副本之间有多跳时，`yes`也是不错的选择。\n```sh\nrepl-disable-tcp-nodelay no\n```\n\n## repl-backlog-size\n设置副本`backlog`大小，`backlog`是一个缓冲区，当副本断开连接一段时间后，它会累积副本数据，因此当副本希望再次重新连接时，通常不需要完全重新同步，部分重新同步就足够了，只需传递断开连接时副本丢失的数据部分。只有在至少连接了一个副本后，才会分配积压工作。\n```sh\n#repl-backlog-size 1mb\n```\n\n## repl-backlog-ttl\n当master不在连接副本一段时间后释放backlog，该选项设置最后一个断开连接的副本后多久释放backlog，单位秒。如果为0，则永不释放。副本不会释放backlog，所以总是积压。\n```sh\n# repl-backlog-ttl 3600\n```\n\n## replica-priority\n副本优先级，当master不在工作时，升级优先级编号低的成为master。当设置成0时，表示无法变成master。默认情况下优先级为100。\n```sh\nreplica-priority 100\n```\n\n## min-replicas-to-write\n如果小于指定副本数量，并且通信小于指定时间，master会停止写入操作。副本必须都处于在线状态。其中一个选项为0表示禁用。默认禁用。\n示例表示，3个副本并且滞后10秒。\n```sh\n# min-replicas-to-write 3\n# min-replicas-max-lag 10\n```\n\n## replica-announce-ip\nRedis master可以通过指定副本地址连接副本，Redis Sentinel可以发现副本实例。\n复制副本通常报告的列出的IP和地址是通过以下方式获得的：\n* IP，通过检查复制副本用于与主服务器连接的套接字的对等地址，可以自动检测该地址。\n* port，在复制握手期间，该端口由副本通信，通常是副本用来侦听连接的端口。\n\n但是，当使用端口转发或网络地址转换（NAT）时，复制副本实际上可以通过不同的IP和端口对访问。副本可以使用以下两个选项向其主服务器报告一组特定的IP和端口，以便信息和角色都报告这些值。\n```sh\n# replica-announce-ip 5.5.5.5\n# replica-announce-port 1234\n```\n\n# security\n## requirepass\n设置密码，客户端在使用的时候需要使用`AUTH`鉴权。\n```sh\n# requirepass foobared\n```\n\n## rename-command\n重命名命令。如果设置为空表示禁用命令。修改命令可能会在AOF模式或传输到副本中引发问题。\n```sh\n# rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52\n# rename-command CONFIG \"\"\n```\n\n# client\n## maxclient\n设置客户端最大连接数，如果不指定则是当前文件系统最大值减32，达到限制后新的连接会收到`max number of clients reached`错误。\n```sh\n# maxclients 10000\n```\n\n# memory management\n## maxmemory\n设置占用内存最大值字节数，达到内存限制时，会采用所选的策略删除键。\n如果Redis无法根据策略删除密钥，或者策略设置为`noeviction`。如果命令将使用更多内存，如SET，LPUSH等时，Redis将开始回复错误。只读命令正常回复。\n当将Redis用作LRU或LFU缓存，或为实例设置硬内存限制（使用`noevection`策略）时，此选项通常很有用。\n如果将副本附加到一个启用了`maxmemory`的实例上，则会从已用的内存计数中减去提供副本所需的输出缓冲区的大小，这样网络问题或重新同步就不会触发一个循环，在该循环中取出键，而反过来，输出缓冲区的复制副本中充满了被收回的键的del，从而导致删除更多的键，等等，直到数据库完全清空。\n简而言之，如果您附加了副本，建议您为`maxmemory`设置一个较低的限制，以便系统上有一些用于副本输出缓冲区的可用RAM（但如果策略为`noevicetion`，则不需要这样做）。\n```sh\n# maxmemory <bytes>\n```\n\n## maxmemory-policy\n当内存到达maxmemory的限制时，可以采用以下选项清理内存：\n* volatile-lru，在具有过期集的密钥中使用近似的LRU逐出。\n* allkeys-lru，使用近似的LRU逐出任何密钥。\n* volatile-lfu，在具有过期集的键中使用近似的逐出。\n* allkeys-lfu，使用近似的LFU逐出任何键。\n* volatile-random，在有过期集的密钥中删除一个随机密钥。\n* allkeys-random，随机删除任意键。\n* volatile-ttl，删除最接近过期时间的密钥（次要TTL）。\n* noeviction，不要逐出任何内容，只返回写操作错误。\n\nLRU指`Least Recently Used`，LFU指`Least Frequently Used`。\n当操作命令是`set` `setnx` `setex` `append` `incr` `decr` `rpush` `lpush` `rpushx` `lpushx` `linsert` `lset` `rpoplpush` `sadd` `sinter` `sinterstore` `sunion` `sunionstore` `sdiff` `sdiffstore` `zadd` `zincrby` `zunionstore` `zinterstore` `hset` `hsetnx` `hmset` `hincrby` `incrby` `decrby` `getset` `mset` `msetnx` `exec` `sort`时，如果没有合适的键删除时返回错误。\n默认`noeviction`。\n```sh\n# maxmemory-policy noeviction\n```\n\n## maxmemory-samples\nLRU，LFU和最小的TTL算法是不准确的算法，可以通过设置改选项提高精确度。\n默认值为5会产生足够好的结果。10近似非常接近但成本更高的CPU，3更快但不是很准确。\n```sh\n# maxmemory-samples 5\n```\n\n## replica-ignore-maxmemory\n副本会忽略`maxmemory`指令，当master剔除键会发送DEL进行同步。但是如果副本可写，或者希望与master内存设置不一样，并且确定写入是幂等的，可以设置此值。\n```sh\n# replica-ignore-maxmemory yes\n```\n\n# lazy freeing\nRedis有两种方法删除键。一种是通过DEL阻塞的删除对象，删除时间与键关联的内存大小有关，如果是大key则可能会阻塞服务器很久。所以Redis提供异步删除。例如：`UNLINK`，`FLUSHALL`，`FLUSHDB`，会以恒定的时间，后台逐步释放。\n这些命令是用户主动调用的，在某些情况下，Redis会主动的删除键：\n* 到达内存限制的时候，会主动调用剔除策略进行删除键；\n* 键到达了过期时间；\n* 修改键值可能会删除原有内容，例如`RENAME`，`SET`等；\n* 在复制过程中，当一个副本与其主服务器执行完全重新同步时，将删除整个数据库的内容，以便加载刚刚传输的RDB文件。\n\n在上述所有情况下，默认情况是以阻塞方式删除对象，就像调用`DEL`一样。但是，您可以具体配置每种情况，以便以非阻塞方式释放内存，就像调用`UNLINK`时一样，使用以下配置指令：\n```sh\nlazyfree-lazy-eviction no\nlazyfree-lazy-expire no\nlazyfree-lazy-server-del no\nreplica-lazy-flush no\n```\n\n# append only mode\n## appendonly no\n默认情况，Redis采用异步的方式转储磁盘，但有可能丢失数据，取决于保存点。\nRedis提供追加模式，一种更好的持久性。例如使用fsync policy，Redis仅会丢失1秒的写入或Redis进程本身发生什么错误丢失写入数据，但是系统仍能正常运行。\n`AOF`和`RDB`持久性可以同时启用而不会出现问题。如果在启动时启用`AOF`，Redis将加载`AOF`。\n```sh\nappendonly no\n```\n\n## appendfilename\n指定追加文件\n```sh\nappendfilename \"appendonly.aof\"\n```\n\n## appendfsync\n`fsync()`调用告诉操作系统在磁盘上实际写入数据，而不是在输出缓冲区中等待更多数据。有些操作系统将真正刷新磁盘上的数据，而另一些操作系统则会尽快进行刷新。\nRedis支持三种模式：\n* `no`，不调用`fsync()`，仅让操作系统管理刷新数据，快速；\n* `always`，每次写入数据的时候添加文件，慢，安全；\n* `everysec`，每秒添加一次，折中。\n\n默认采用`everysec`。\n```sh\n# appendfsync always\nappendfsync everysec\n# appendfsync no\n```\n\n## no-appendfsync-on-rewrite\n当`AOF`的同步策略设置为`always`或`everysec`时，后台保存数据，这会有大量`IO`操作，在某些平台下，调用`fsync()`会阻塞很长时间。\n为了缓解这个问题，可以使用`BGSAVE`或`BGREWRITEAOF`止主进程调用`fsync()`阻塞。\n这意味着当另一个子进程正在保存时，redis的耐久性与`appendfsync none`相同。实际上，这意味着在最坏的情况下（使用默认的Linux设置），可能会丢失长达30秒的日志。\n如果遇到延迟问题，请将其转为`yes`。否则 ，从耐久性的角度来看，`no`，这是最安全的选择。\n```sh\nno-appendfsync-on-rewrite no\n```\n\n## auto-aof-rewrite-percentage\n自动重写仅附加文件。 当`AOF`日志大小增长指定的百分比时， Redis能够自动重写日志文件，隐式调用`BGREWRITEAOF`。\n工作方式：Redis会记录最后一次复写时`AOF`文件大小，如果复写发生在重启时，这个大小是`AOF`在启动的时使用。\n将此基本大小与当前大小进行比较。如果当前大小大于指定的百分比，则会触发重写。另外需要为要重写的`AOF`文件指定最小大小，这对于避免重写`AOF`文件很有用，即使达到了增加的百分比，但仍然很小。\n指定零的百分比以禁用自动AOF重写功能。\n```sh\nauto-aof-rewrite-percentage 100\nauto-aof-rewrite-min-size 64mb\n```\n\n## aof-load-truncated\n在Redis启动过程中，当`AOF`数据被加载回内存时，可能会发现`AOF`文件在末尾被截断。当运行Redis的系统崩溃时可能会发生这种情况，尤其是当安装`ext4`文件系统时，如果没有`data=ordered`选项（但是，当Redis本身崩溃或中止，但操作系统仍然正常工作时，则不会发生这种情况）。\n当发生这种情况时，Redis退出并报错，也可以加载尽可能多的数据（现在是默认值），如果在末尾发现`AOF`文件被截断，则可以启动它。以下选项控制此行为。\n如果设置为`yes`，则会加载一个已截断的`AOF`文件，并且Redis服务器开始发出日志，通知用户事件。否则，如果该选项设置为`no`，则服务器将以错误中止并拒绝启动。\n当选项设置为否时，用户需要在重新启动服务器之前使用`redis-check-aof`修复`aof`文件。如果在中间发现AOF文件已损坏，服务器仍将退出并出现错误。此选项仅适用于Redis尝试从AOF文件读取更多数据但未找到足够字节的情况。\n```sh\naof-load-truncated yes\n```\n\n## aof-use-rdb-preamble\n在重写`AOF`文件时，Redis可以使用AOF文件中的RDB前导码来更快地重写和恢复。启用此选项时，重写的`AOF`文件由两个不同的节`[RDB file][AOF tail]`组成。\nRedis加载时，会识别出`AOF`文件以`REDIS`字符串开始并加载前缀`RDB`文件，然后继续加载`AOF`尾部。\n```sh\naof-use-rdb-preamble yes\n```\n\n# LUA scripting\nLua脚本的最大执行时间（以毫秒为单位）。\n如果达到最大执行时间，redis将记录脚本在最大允许时间之后仍在执行中，并开始对出现错误的查询进行回复。\n当长时间运行的脚本超过最大执行时间时，只有`SCRIPT KILL`和`SHUTDOWN NOSAVE`命令可用。第一个可以用于停止尚未调用写入命令的脚本。第二种方法是在脚本已经发出写命令但用户不希望等待脚本自然终止的情况下关闭服务器。\n将其设置为0或负值，以便无警告地无限执行。\n```sh\nlua-time-limit 5000\n```\n\n# Redis cluster\n## cluster-enabled\n普通的redis实例不能是redis集群的一部分；只有作为集群节点启动的节点才能。为了启动Redis实例作为群集节点，解注释并设置成`yes`即可。\n```sh\n# cluster-enabled yes\n```\n\n## cluster-config-file\n每个集群节点都有一个集群配置文件，此文件不需要手动编辑。它创建和更新都有Redis节点进行。每个Redis集群节点都需要不同的集群配置文件。确保在同一系统中运行的实例没有重叠的群集配置文件名。\n```sh\n# cluster-config-file nodes-6379.conf\n```\n\n## cluster-node-timeout\n集群节点超时，单位毫秒。\n```sh\n# cluster-node-timeout 15000\n```\n\n## cluster-replica-validity-factor\n如果故障主机的数据看起来太旧，那么它的副本将避免启动故障转移。\n对于副本来说没法验证数据的是否太旧，所以需要执行两项检查：\n* 如果有多个副本能够进行故障转移，它们会交换消息，以尽量利用具有最佳复制偏移量的副本（从主处理的更多数据）。副本将尝试按偏移量获取它们的列组，并将与列组成比例的延迟应用于故障转移的开始。\n* 每个副本都计算与主副本的最后一次交互的时间。这可以是接收到的最后一个ping或命令（如果主服务器仍然处于“已连接”状态），也可以是断开与主服务器的连接后经过的时间（如果复制链接当前已关闭）。如果上一次交互太旧，则复制副本将不会尝试进行故障转移。\n\n第二点可以由用户进行调整，即，如果副本上次与主服务器交互时间超过时间大于：`(node-timeout * replica-validity-factor) + repl-ping-replica-period`。\n因此，例如，如果节点超时为30秒，副本有效性系数为10，并且假设默认的复制副本周期为10秒，那么如果副本无法与主副本进行超过310秒的对话，则不会尝试进行故障转移。\n较大的副本有效性系数可能允许具有太旧数据的副本故障转移到主服务器，而太小的值可能会阻止群集根本无法选择副本。\n为了获得最大的可用性，可以将副本有效性系数设置为0，这意味着，无论副本上次与主服务器交互的时间如何，它们都将始终尝试对主服务器进行故障转移。（然而，他们总是尝试应用与他们的偏移等级成比例的延迟）。\n零是唯一能够保证当所有分区恢复时群集始终能够继续运行的值。\n```sh\n# cluster-replica-validity-factor 10\n```\n\n## cluster-migration-barrier\n群集副本能够迁移到孤立的主服务器，即没有工作副本的主服务器。这提高了集群抵御故障的能力，否则，如果一个孤立的主机没有工作的副本，它就不能在发生故障的情况下进行故障转移。\n只有在至少有一个给定数量的旧主控形状的其他工作副本的情况下，副本才会迁移到孤立的主控形状。这个数字是“移民壁垒”。迁移屏障为1意味着只有在主副本至少有一个其他工作副本的情况下，副本才会迁移，以此类推。它通常反映出集群中每个主服务器所需的副本数量。\n默认值为1（仅当主副本至少保留一个副本时才迁移副本）。要禁用迁移，只需将其设置为非常大的值。#可以设置值0，但仅对调试和生产中的危险有用。\n```sh\n# cluster-migration-barrier 1\n```\n\n## cluster-require-full-coverage\n默认情况下，如果Redis群集节点检测到至少有一个散列槽未被发现（没有可用节点提供服务），则它们将停止接受查询。这样，如果集群部分关闭（例如一系列散列槽不再被覆盖），所有集群最终都将不可用。一旦所有插槽再次被覆盖，它就会自动返回可用状态。\n然而，有时您希望集群的子集工作，继续接受对仍然被覆盖的密钥空间部分的查询。为此，只需将`cluster-require-full-coverage`选项设置为no。\n```sh\n# cluster-require-full-coverage yes\n```\n\n## cluster-replica-no-failover\n当设置为“是”时，此选项可防止副本在主服务器故障时尝试故障转移其主服务器。但是，如果强制的话，主服务器仍然可以执行手动故障转移。\n这在不同的情况下很有用，特别是在多个数据中心操作的情况下，如果不升级，我们希望一方永远不会升级；如果发生完全的DC故障。\n```sh\n# cluster-replica-no-failover no\n```\n\n# CLUSTER DOCKER/NAT support\n在某些部署中，Redis群集节点地址发现失败，原因是地址是NAT，或者端口是转发的（典型情况是Docker和其他容器）。\n为了使redis集群在这样的环境中工作，需要一个静态配置，其中每个节点都知道其公共地址。以下两个选项用于此范围，分别是：\n* cluster-announce-ip\n* cluster-announce-port\n* cluster-announce-bus-port\n\n每个节点都指示其地址、客户机端口和集群消息总线端口。然后将信息发布到总线数据包的头部，以便其他节点能够正确映射发布信息的节点的地址。\n如果不使用上述选项，则将使用普通的Redis群集自动检测。\n请注意，重新映射时，总线端口可能不在客户机端口+10000的固定偏移量处，因此您可以根据重新映射的方式指定任何端口和总线端口。如果未设置总线端口，则通常使用固定偏移量10000。\n例如：\n```sh\n# cluster-announce-ip 10.1.1.5\n# cluster-announce-port 6379\n# cluster-announce-bus-port 6380\n```\n\n# slow log\nRedis slow log是一个系统日志查询，它超过了指定的执行时间。执行时间不包括I/O操作，如与客户机交谈、发送回复等，而只包括实际执行命令所需的时间（这是命令执行的唯一阶段，线程被阻塞，无法以平均值服务其他请求时间）。\n您可以用两个参数配置慢日志：一个参数告诉redis命令要记录的执行时间（以微秒计），另一个参数是慢日志的长度。当记录新命令时，最旧的命令将从记录的命令队列中删除。\n## slowlog-slower-than\n以下时间以微秒表示，因此1000000等于一秒。注意，负数会禁用慢速日志，而零值会强制记录每个命令。\n```sh\nslowlog-log-slower-than 10000\n```\n\n## slowlog-max-len\n这个长度没有限制。只是要知道它会消耗内存。可以使用`SLOWLOG RESET`来回收慢速日志使用的内存。\n```sh\nslowlog-max-len 128\n```\n\n# latency monitor\nRedis延迟监控子系统在运行时对不同的操作进行采样，以便收集与Redis实例的可能延迟源相关的数据。\n通过`LATENCY`命令，用户可以使用这些信息来打印图形和获取报告。\n系统只记录在时间等于或大于通过延迟监视器阈值配置指令指定的毫秒数内执行的操作。当其值设置为零时，延迟监视器将关闭。\n默认情况下，延迟监控是禁用的，因为如果您没有延迟问题，则通常不需要它，并且收集数据会对性能产生影响，尽管这一影响很小，但可以在大负载下进行测量。如果需要，可以使用命令`CONFIG SET latency-monitor-threshold <milliseconds>`在运行时轻松启用延迟监控。\n```sh\nlatency-monitor-threshold 0\n```\n\n# event notification\n例如，如果启用了keyspace事件通知，并且客户机对存储在数据库0中的密钥`foo`执行`DEL`操作，则将通过pub/sub发布两条消息：\n```sh\nPUBLISH __keyspace@0__:foo del\nPUBLISH __keyevent@0__:del foo\n```\n\n可以在一组类中选择Redis将通知的事件。每个类都由单个字符标识：\n```sh\n#  K     Keyspace events, published with __keyspace@<db>__ prefix.\n#  E     Keyevent events, published with __keyevent@<db>__ prefix.\n#  g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...\n#  $     String commands\n#  l     List commands\n#  s     Set commands\n#  h     Hash commands\n#  z     Sorted set commands\n#  x     Expired events (events generated every time a key expires)\n#  e     Evicted events (events generated when a key is evicted for maxmemory)\n#  A     Alias for g$lshzxe, so that the \"AKE\" string means all the events.\n```\n\n`notify-keyspace-events`将一个由零个或多个字符组成的字符串作为参数。空字符串表示通知被禁用。\n\n默认情况下，所有通知都被禁用，因为大多数用户不需要此功能，而且此功能有一些开销。请注意，如果不指定`K`或`E`中的至少一个，则不会传递任何事件。\n```sh\nnotify-keyspace-events \"\"\n```\n\n# advanced config\n ","source":"_posts/Redis配置文件.md","raw":"---\nauthor: djaigo\ntitle: redis conf 说明\ndate: 2019-12-10 14:43:35\nupdate: \nimg: https://img-1251474779.cos.ap-beijing.myqcloud.com/redis.png\ncategories: \n  - redis\ntags: \n  - redis\n  - config\nenable html: true\n---\n\n最新Redis配置文件获取[redis.conf](http://download.redis.io/redis-stable/redis.conf)\n\n# start\n启动Redis启动。\n```sh\n$ ./redis-server /path/to/redis.conf\n```\n\n配置文件单位说明，单位不区分大小写。\n```sh\n# 1k => 1000 bytes\n# 1kb => 1024 bytes\n# 1m => 1000000 bytes\n# 1mb => 1024 * 1024 bytes\n# 1g => 1000000000 bytes\n# 1gb => 1024 * 1024 * 1024 bytes\n```\n\n# include\n`include`可以引入其他的配置文件，且不会被`CONFIG REWRITE`命令复写。Redis总是使用最后处理的行作为配置指令的值，最好在文件开始的时候`include`，避免运行时复写配置。如果想用`include`覆盖之前的配置可以放在文件末尾。\n```sh\n# include /path/to/local.conf\n# include /path/to/other.conf\n```\n\n# module\n在启动时加载模块，如果无法加载，Redis会`abort`，可以同时加载多个模块。\n```sh\n# loadmodule /path/to/my_module.so\n# loadmodule /path/to/other_module.so\n```\n\n# network\n## bind\n默认地，如果没有指定`bind`指令，Redis监听监听服务器上所有可用网络接口的连接。可以使用`bind`配置指令只侦听一个或多个选定的网卡接口，后跟一个或多个IP地址。\n如果不指定bind指定是一件很危险的事，所以Redis默认指定本地的环回地址。\n```sh\n# bind 192.168.1.100 10.0.0.1\nbind 127.0.0.1 ::1\n```\n\n## protected-mode\n保护模式是一层安全保护，以避免Redis实例在Internet上保持打开状态被访问和利用。\n当保护模式打开，并且：\n* Redis未`bind`到一组地址\n* 没有配置密码\n\nRedis只能接受来自IPv4和IPv6环回地址（127.0.0.1和::1）、Unix域套接字的连接。\n保护模式默认是打开的。如果想其他地址访问Redis没有使用密码，或没有使用bind指定网络接口可以关闭保护模式。\n```sh\nprotected-mode yes\n```\n\n## port\n接受指定端口的连接。如果指定为0，Redis不会监听TCP socket。\n```sh\nport 6379\n```\n\n## tcp-backlog\nTCP listen()函数的backlog参数，挂起连接队列的最大长度。\n```sh\ntcp-backlog 511\n```\n\n## Unix socket\n指定`Unix socket`的路径，Redis默认不监听`Unix socket`。\n```sh\n# unixsocket /tmp/redis.sock\n# unixsocketperm 700\n```\n\n## timeout\n设置连接多少秒没有使用后断开连接，0表示不启用。\n```sh\ntimeout 0\n```\n\n## TCP keepalive\n如果非零，使用SO_KEEPALIVE发送TCP ACK，来保活连接。\n这样做有两个理由：\n* 检测对端状态\n* \n\n在Linux上，每隔指定的值（单位秒）都会发送TCP ACK，如果需要关闭连接则需要两倍这个时间。\n其他内核取决于内核配置。\nRedis默认300秒。\n```sh\ntcp-keepalive 300\n```\n\n# general\n## daemonize\nRedis默认是不作为`daemon`运行，可以使用`yes`启动该选项。\nRedis在启用指令后会在`/var/run/redis.pid`产生`pid`文件。\n```sh\ndaemonize no\n```\n\n## supervised\n如果使用upstart或者systemd启动Redis，可以使用supervised指令进行交互。\n选项：\n* no - 不使用supervision交互\n* upstart - 让Redis进入`SIGSTOP`模式\n* systemd - 向`$NOTIFY_SOCKET`写入`READY=1`\n* auto - 基于环境变量`UPSTART_JOB`或 `NOTIFY_SOCKET`来设置upstart还是systemd模式\n\nsupervised只表示进程已经就绪，并不持续supervisor。\n```sh\nsupervised no\n```\n\n## pidfile\n如果指定了pidfile，那么Redis将会在启动的时候写入，退出的时候删除。\n当Redis启动是使用非daemonized，配置中没有指定pidfile，则不会有pidfile创建；当Redis使用daemonized启动时，即使没有指定pidfile，也会创建，默认是`/var/run/redis.pid`。\n如果Redis无法创建pidfile，也不会产生任何影响，Redis依旧可以正常启动和运行。\n```sh\npidfile /var/run/redis_6379.pid\n```\n\n## loglevel\n设置日志等级：\n* debug，对开发测试有用\n* verbose，一些有用的信息，不像debug那么杂乱\n* notice，一般生产日志\n* warning，记录关键信息\n\n```sh\nloglevel notice\n```\n\n## logfile\n指定日志文件名，空字符串表示Redis日志强制输出到标准输出。如果使用daemonized并且把日志输出到标准输出，则日志会被发送到`/dev/null`。\n```sh\nlogfile \"\"\n```\n\n## syslog\n### enabled\n将日志输出到system logger，指定`syslog-enabled`为`yes`，可以按照需求添加其他参数。\n```sh\n# syslog-enabled no\n```\n\n### ident\n指定syslog标识。\n```sh\n# syslog-ident redis\n```\n\n### facility\n指定syslog的`facility`，必须是`USER`或介于`LOCAL0-LOCAL7`。\n```sh\n# syslog-facility local0\n```\n\n## databases\n设置Redis数据库的数量，默认`DB`是0，可以使用`SELECT`选择`dbid`介于`0-databases-1`。\n```sh\ndatabases 16\n```\n\n## show logo\n默认在Redis启动的时候打印`ASCII logo`，仅在log输出在标准输出或标准输出是TTY的时候。只有在交互式的时候才显示`logo`。\n```sh\nalways-show-logo yes\n```\n\n# snapshotting\n## save\n数据库快照，将Redis数据保存到disk，命令`save second changes`。\n当指定秒和写操作次数同时满足的时候写入disk。\n可以通过注释掉save来禁用快照，也可以使用`save \"\"`来禁用已经设置的快照选项。\n示例表示：\n* 900秒（15分钟）至少有一个键改动\n* 300秒（5分钟）至少有10个键改动\n* 60秒（1分钟）至少有10000个键改动\n```sh\nsave 900 1\nsave 300 10\nsave 60 10000\n```\n\n## stop-writes-on-bgsave-error\n当启动RDB快照时，Redis会停止写入，并且最后一次后台保存会失败。\n```sh\nstop-writes-on-bgsave-error yes\n```\n\n## rdbcompression\n当使用dump .rdb数据库时，是否使用LZF压缩字符串对象\n```sh\nrdbcompression yes\n```\n\n## rdbchecksum\nCRC64校验和存放于RDB文件的末尾，这可以抵抗损坏，但是有性能问题，可以禁用。\n```sh\nrdbchecksum yes\n```\n\n## dbfilename\n指定dump文件\n```sh\ndbfilename dump.rdb\n```\n\n## dir\n指定工作目录，`dbfilename`指定的文件将会在`dir`中创建，只追加的文件也在此目录中创建。\n`dir`必须指定一个目录，非文件路径。\n```sh\ndir ./\n```\n\n\n# replication\n## replicaof\n`Master-Replica`拷贝，使用replicaof让一个Redis实例复制另一个Redis实例。\n相关概念：\n* Redis复制是异步的，如果一个主Redis实例没有与给定数量的副本连接，那么可以配置他停止接收写操作\n* 如果复制链接丢失的时间相对较少，Redis副本可以与主服务器执行部分重新同步。根据需要，您可能需要使用合理的值配置复制积压工作的大小（请参阅此文件的下一节）。\n* 复制是一个自动的过程，网络分区副本自动尝试重新连接到主服务器，并与它们重新同步。\n\n```sh\n# replicaof masterip masterport\n```\n\n## masterauth\n如果master有密码（使用requirepass配置），副本在复制的之前必须要验证密码，否则将拒绝复制。\n```sh\n# masterauth <master-password>\n```\n\n## replica-serve-stale-data\n当副本与master断开连接，或当复制正在进行时，副本可以以两种不同的方式发挥做用：\n* 如果将`replica-serve-stale-data`设置成`yes`，副本将仍然回复客户端的请求，可能数据已过期，或者为空\n* 如果将`replica-serve-stale-data`设置成`no`，副本将用`SYNC with master in progress`回复所有请求，除了`INFO`，`replicaOF`，`AUTH`，`PING`，`SHUTDOWN`，`REPLCONF`，`ROLE`，`CONFIG`，`SUBSCRIBE`，`UNSUBSCRIBE`，`PSUBSCRIBE`，`PUNSUBSCRIBE`，`PUBLISH`，`PUBSUB`，`COMMAND`，`POST`，`HOST:`，`LATENCY`\n\n```sh\nreplica-serve-stale-data yes\n```\n\n## replica-read-only\n设置副本实例是否可以写，默认副本是只读的。副本仍可以执行所有管理命令，可以使用`rename-command`遮蔽这些管理命令。\n```sh\nreplica-read-only yes\n```\n\n## repl-diskless-sync\n新的复制副本和重新连接的复制副本无法继续仅接收差异的复制过程，需要执行所谓的“完全同步”。RDB文件从主服务器传输到副本服务器。\n传输可以通过两种不同的方式进行：\n* 磁盘支持，Redis主服务器创建一个新进程，将RDB文件写入磁盘，稍后，父进程将文件以递增方式传输到副本。\n* 无磁盘，Redis主服务器创建一个新进程，将RDB文件写入副本套接字，不通过磁盘。\n\n使用磁盘备份复制，在生成RDB文件的同时，可以在生成RDB文件的当前子级完成工作后，将更多的副本排队并与RDB文件一起提供服务。\n在无盘复制中，一旦传输开始，到达的新副本将排队，当当前副本终止时，将开始新的传输。`master`实例机会在开始传输之前等待一段可配置的时间（以秒为单位），以希望多个副本能够到达，并且可以并行传输。\n使用低速磁盘和快速（大带宽）网络，无盘复制工作得更好。\n```sh\nrepl-diskless-sync no\n```\n\n## repl-diskless-sync-delay\n启动无盘复制时，可以配置服务器的等待延迟，这一点很重要，因为一旦传输开始，就不可能为到达的新副本提供服务，这些副本将排队等待下一次RDB传输，因此服务器将等待一段延迟，以便让更多副本到达。\n默认5秒，设置为0表示禁用\n```sh\nrepl-diskless-sync-delay 5\n```\n\n## repl-ping-replica-period\n副本以预先定义的间隔向服务器发送ping。可以使用`repl-ping-replica-period`选项更改此间隔。默认值为10秒。\n```sh\n# repl-ping-replica-period 10\n```\n\n## repl-timeout\n以下情况会复制超时：\n* 从副本角度看，同步期间的批量传输I/O。\n* 从副本角度看，master实例超时。\n* 从master实例看，复制超时。\n\n确保`repl-timeout`比`repl-ping-replica-period`大，否则每次主服务器和副本之间的通信量低时都会检测到超时。\n```sh\n# repl-timeout 60\n```\n\n## repl-disable-tcp-nodelay\n在副本发送`SYNC`后禁用`TCP_NODELAY`？\n如果选择`yes`，Redis会占用少量带宽发送少量TCP包给副本，但这可能会增加副本同步延迟，使用Linux内核默认配置最多可延迟40毫秒。\n如果选择`no`，延迟会减少，但是会占用更多带宽用于复制。\n默认选择`no`，但是在非常高流量下或者master和副本之间有多跳时，`yes`也是不错的选择。\n```sh\nrepl-disable-tcp-nodelay no\n```\n\n## repl-backlog-size\n设置副本`backlog`大小，`backlog`是一个缓冲区，当副本断开连接一段时间后，它会累积副本数据，因此当副本希望再次重新连接时，通常不需要完全重新同步，部分重新同步就足够了，只需传递断开连接时副本丢失的数据部分。只有在至少连接了一个副本后，才会分配积压工作。\n```sh\n#repl-backlog-size 1mb\n```\n\n## repl-backlog-ttl\n当master不在连接副本一段时间后释放backlog，该选项设置最后一个断开连接的副本后多久释放backlog，单位秒。如果为0，则永不释放。副本不会释放backlog，所以总是积压。\n```sh\n# repl-backlog-ttl 3600\n```\n\n## replica-priority\n副本优先级，当master不在工作时，升级优先级编号低的成为master。当设置成0时，表示无法变成master。默认情况下优先级为100。\n```sh\nreplica-priority 100\n```\n\n## min-replicas-to-write\n如果小于指定副本数量，并且通信小于指定时间，master会停止写入操作。副本必须都处于在线状态。其中一个选项为0表示禁用。默认禁用。\n示例表示，3个副本并且滞后10秒。\n```sh\n# min-replicas-to-write 3\n# min-replicas-max-lag 10\n```\n\n## replica-announce-ip\nRedis master可以通过指定副本地址连接副本，Redis Sentinel可以发现副本实例。\n复制副本通常报告的列出的IP和地址是通过以下方式获得的：\n* IP，通过检查复制副本用于与主服务器连接的套接字的对等地址，可以自动检测该地址。\n* port，在复制握手期间，该端口由副本通信，通常是副本用来侦听连接的端口。\n\n但是，当使用端口转发或网络地址转换（NAT）时，复制副本实际上可以通过不同的IP和端口对访问。副本可以使用以下两个选项向其主服务器报告一组特定的IP和端口，以便信息和角色都报告这些值。\n```sh\n# replica-announce-ip 5.5.5.5\n# replica-announce-port 1234\n```\n\n# security\n## requirepass\n设置密码，客户端在使用的时候需要使用`AUTH`鉴权。\n```sh\n# requirepass foobared\n```\n\n## rename-command\n重命名命令。如果设置为空表示禁用命令。修改命令可能会在AOF模式或传输到副本中引发问题。\n```sh\n# rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52\n# rename-command CONFIG \"\"\n```\n\n# client\n## maxclient\n设置客户端最大连接数，如果不指定则是当前文件系统最大值减32，达到限制后新的连接会收到`max number of clients reached`错误。\n```sh\n# maxclients 10000\n```\n\n# memory management\n## maxmemory\n设置占用内存最大值字节数，达到内存限制时，会采用所选的策略删除键。\n如果Redis无法根据策略删除密钥，或者策略设置为`noeviction`。如果命令将使用更多内存，如SET，LPUSH等时，Redis将开始回复错误。只读命令正常回复。\n当将Redis用作LRU或LFU缓存，或为实例设置硬内存限制（使用`noevection`策略）时，此选项通常很有用。\n如果将副本附加到一个启用了`maxmemory`的实例上，则会从已用的内存计数中减去提供副本所需的输出缓冲区的大小，这样网络问题或重新同步就不会触发一个循环，在该循环中取出键，而反过来，输出缓冲区的复制副本中充满了被收回的键的del，从而导致删除更多的键，等等，直到数据库完全清空。\n简而言之，如果您附加了副本，建议您为`maxmemory`设置一个较低的限制，以便系统上有一些用于副本输出缓冲区的可用RAM（但如果策略为`noevicetion`，则不需要这样做）。\n```sh\n# maxmemory <bytes>\n```\n\n## maxmemory-policy\n当内存到达maxmemory的限制时，可以采用以下选项清理内存：\n* volatile-lru，在具有过期集的密钥中使用近似的LRU逐出。\n* allkeys-lru，使用近似的LRU逐出任何密钥。\n* volatile-lfu，在具有过期集的键中使用近似的逐出。\n* allkeys-lfu，使用近似的LFU逐出任何键。\n* volatile-random，在有过期集的密钥中删除一个随机密钥。\n* allkeys-random，随机删除任意键。\n* volatile-ttl，删除最接近过期时间的密钥（次要TTL）。\n* noeviction，不要逐出任何内容，只返回写操作错误。\n\nLRU指`Least Recently Used`，LFU指`Least Frequently Used`。\n当操作命令是`set` `setnx` `setex` `append` `incr` `decr` `rpush` `lpush` `rpushx` `lpushx` `linsert` `lset` `rpoplpush` `sadd` `sinter` `sinterstore` `sunion` `sunionstore` `sdiff` `sdiffstore` `zadd` `zincrby` `zunionstore` `zinterstore` `hset` `hsetnx` `hmset` `hincrby` `incrby` `decrby` `getset` `mset` `msetnx` `exec` `sort`时，如果没有合适的键删除时返回错误。\n默认`noeviction`。\n```sh\n# maxmemory-policy noeviction\n```\n\n## maxmemory-samples\nLRU，LFU和最小的TTL算法是不准确的算法，可以通过设置改选项提高精确度。\n默认值为5会产生足够好的结果。10近似非常接近但成本更高的CPU，3更快但不是很准确。\n```sh\n# maxmemory-samples 5\n```\n\n## replica-ignore-maxmemory\n副本会忽略`maxmemory`指令，当master剔除键会发送DEL进行同步。但是如果副本可写，或者希望与master内存设置不一样，并且确定写入是幂等的，可以设置此值。\n```sh\n# replica-ignore-maxmemory yes\n```\n\n# lazy freeing\nRedis有两种方法删除键。一种是通过DEL阻塞的删除对象，删除时间与键关联的内存大小有关，如果是大key则可能会阻塞服务器很久。所以Redis提供异步删除。例如：`UNLINK`，`FLUSHALL`，`FLUSHDB`，会以恒定的时间，后台逐步释放。\n这些命令是用户主动调用的，在某些情况下，Redis会主动的删除键：\n* 到达内存限制的时候，会主动调用剔除策略进行删除键；\n* 键到达了过期时间；\n* 修改键值可能会删除原有内容，例如`RENAME`，`SET`等；\n* 在复制过程中，当一个副本与其主服务器执行完全重新同步时，将删除整个数据库的内容，以便加载刚刚传输的RDB文件。\n\n在上述所有情况下，默认情况是以阻塞方式删除对象，就像调用`DEL`一样。但是，您可以具体配置每种情况，以便以非阻塞方式释放内存，就像调用`UNLINK`时一样，使用以下配置指令：\n```sh\nlazyfree-lazy-eviction no\nlazyfree-lazy-expire no\nlazyfree-lazy-server-del no\nreplica-lazy-flush no\n```\n\n# append only mode\n## appendonly no\n默认情况，Redis采用异步的方式转储磁盘，但有可能丢失数据，取决于保存点。\nRedis提供追加模式，一种更好的持久性。例如使用fsync policy，Redis仅会丢失1秒的写入或Redis进程本身发生什么错误丢失写入数据，但是系统仍能正常运行。\n`AOF`和`RDB`持久性可以同时启用而不会出现问题。如果在启动时启用`AOF`，Redis将加载`AOF`。\n```sh\nappendonly no\n```\n\n## appendfilename\n指定追加文件\n```sh\nappendfilename \"appendonly.aof\"\n```\n\n## appendfsync\n`fsync()`调用告诉操作系统在磁盘上实际写入数据，而不是在输出缓冲区中等待更多数据。有些操作系统将真正刷新磁盘上的数据，而另一些操作系统则会尽快进行刷新。\nRedis支持三种模式：\n* `no`，不调用`fsync()`，仅让操作系统管理刷新数据，快速；\n* `always`，每次写入数据的时候添加文件，慢，安全；\n* `everysec`，每秒添加一次，折中。\n\n默认采用`everysec`。\n```sh\n# appendfsync always\nappendfsync everysec\n# appendfsync no\n```\n\n## no-appendfsync-on-rewrite\n当`AOF`的同步策略设置为`always`或`everysec`时，后台保存数据，这会有大量`IO`操作，在某些平台下，调用`fsync()`会阻塞很长时间。\n为了缓解这个问题，可以使用`BGSAVE`或`BGREWRITEAOF`止主进程调用`fsync()`阻塞。\n这意味着当另一个子进程正在保存时，redis的耐久性与`appendfsync none`相同。实际上，这意味着在最坏的情况下（使用默认的Linux设置），可能会丢失长达30秒的日志。\n如果遇到延迟问题，请将其转为`yes`。否则 ，从耐久性的角度来看，`no`，这是最安全的选择。\n```sh\nno-appendfsync-on-rewrite no\n```\n\n## auto-aof-rewrite-percentage\n自动重写仅附加文件。 当`AOF`日志大小增长指定的百分比时， Redis能够自动重写日志文件，隐式调用`BGREWRITEAOF`。\n工作方式：Redis会记录最后一次复写时`AOF`文件大小，如果复写发生在重启时，这个大小是`AOF`在启动的时使用。\n将此基本大小与当前大小进行比较。如果当前大小大于指定的百分比，则会触发重写。另外需要为要重写的`AOF`文件指定最小大小，这对于避免重写`AOF`文件很有用，即使达到了增加的百分比，但仍然很小。\n指定零的百分比以禁用自动AOF重写功能。\n```sh\nauto-aof-rewrite-percentage 100\nauto-aof-rewrite-min-size 64mb\n```\n\n## aof-load-truncated\n在Redis启动过程中，当`AOF`数据被加载回内存时，可能会发现`AOF`文件在末尾被截断。当运行Redis的系统崩溃时可能会发生这种情况，尤其是当安装`ext4`文件系统时，如果没有`data=ordered`选项（但是，当Redis本身崩溃或中止，但操作系统仍然正常工作时，则不会发生这种情况）。\n当发生这种情况时，Redis退出并报错，也可以加载尽可能多的数据（现在是默认值），如果在末尾发现`AOF`文件被截断，则可以启动它。以下选项控制此行为。\n如果设置为`yes`，则会加载一个已截断的`AOF`文件，并且Redis服务器开始发出日志，通知用户事件。否则，如果该选项设置为`no`，则服务器将以错误中止并拒绝启动。\n当选项设置为否时，用户需要在重新启动服务器之前使用`redis-check-aof`修复`aof`文件。如果在中间发现AOF文件已损坏，服务器仍将退出并出现错误。此选项仅适用于Redis尝试从AOF文件读取更多数据但未找到足够字节的情况。\n```sh\naof-load-truncated yes\n```\n\n## aof-use-rdb-preamble\n在重写`AOF`文件时，Redis可以使用AOF文件中的RDB前导码来更快地重写和恢复。启用此选项时，重写的`AOF`文件由两个不同的节`[RDB file][AOF tail]`组成。\nRedis加载时，会识别出`AOF`文件以`REDIS`字符串开始并加载前缀`RDB`文件，然后继续加载`AOF`尾部。\n```sh\naof-use-rdb-preamble yes\n```\n\n# LUA scripting\nLua脚本的最大执行时间（以毫秒为单位）。\n如果达到最大执行时间，redis将记录脚本在最大允许时间之后仍在执行中，并开始对出现错误的查询进行回复。\n当长时间运行的脚本超过最大执行时间时，只有`SCRIPT KILL`和`SHUTDOWN NOSAVE`命令可用。第一个可以用于停止尚未调用写入命令的脚本。第二种方法是在脚本已经发出写命令但用户不希望等待脚本自然终止的情况下关闭服务器。\n将其设置为0或负值，以便无警告地无限执行。\n```sh\nlua-time-limit 5000\n```\n\n# Redis cluster\n## cluster-enabled\n普通的redis实例不能是redis集群的一部分；只有作为集群节点启动的节点才能。为了启动Redis实例作为群集节点，解注释并设置成`yes`即可。\n```sh\n# cluster-enabled yes\n```\n\n## cluster-config-file\n每个集群节点都有一个集群配置文件，此文件不需要手动编辑。它创建和更新都有Redis节点进行。每个Redis集群节点都需要不同的集群配置文件。确保在同一系统中运行的实例没有重叠的群集配置文件名。\n```sh\n# cluster-config-file nodes-6379.conf\n```\n\n## cluster-node-timeout\n集群节点超时，单位毫秒。\n```sh\n# cluster-node-timeout 15000\n```\n\n## cluster-replica-validity-factor\n如果故障主机的数据看起来太旧，那么它的副本将避免启动故障转移。\n对于副本来说没法验证数据的是否太旧，所以需要执行两项检查：\n* 如果有多个副本能够进行故障转移，它们会交换消息，以尽量利用具有最佳复制偏移量的副本（从主处理的更多数据）。副本将尝试按偏移量获取它们的列组，并将与列组成比例的延迟应用于故障转移的开始。\n* 每个副本都计算与主副本的最后一次交互的时间。这可以是接收到的最后一个ping或命令（如果主服务器仍然处于“已连接”状态），也可以是断开与主服务器的连接后经过的时间（如果复制链接当前已关闭）。如果上一次交互太旧，则复制副本将不会尝试进行故障转移。\n\n第二点可以由用户进行调整，即，如果副本上次与主服务器交互时间超过时间大于：`(node-timeout * replica-validity-factor) + repl-ping-replica-period`。\n因此，例如，如果节点超时为30秒，副本有效性系数为10，并且假设默认的复制副本周期为10秒，那么如果副本无法与主副本进行超过310秒的对话，则不会尝试进行故障转移。\n较大的副本有效性系数可能允许具有太旧数据的副本故障转移到主服务器，而太小的值可能会阻止群集根本无法选择副本。\n为了获得最大的可用性，可以将副本有效性系数设置为0，这意味着，无论副本上次与主服务器交互的时间如何，它们都将始终尝试对主服务器进行故障转移。（然而，他们总是尝试应用与他们的偏移等级成比例的延迟）。\n零是唯一能够保证当所有分区恢复时群集始终能够继续运行的值。\n```sh\n# cluster-replica-validity-factor 10\n```\n\n## cluster-migration-barrier\n群集副本能够迁移到孤立的主服务器，即没有工作副本的主服务器。这提高了集群抵御故障的能力，否则，如果一个孤立的主机没有工作的副本，它就不能在发生故障的情况下进行故障转移。\n只有在至少有一个给定数量的旧主控形状的其他工作副本的情况下，副本才会迁移到孤立的主控形状。这个数字是“移民壁垒”。迁移屏障为1意味着只有在主副本至少有一个其他工作副本的情况下，副本才会迁移，以此类推。它通常反映出集群中每个主服务器所需的副本数量。\n默认值为1（仅当主副本至少保留一个副本时才迁移副本）。要禁用迁移，只需将其设置为非常大的值。#可以设置值0，但仅对调试和生产中的危险有用。\n```sh\n# cluster-migration-barrier 1\n```\n\n## cluster-require-full-coverage\n默认情况下，如果Redis群集节点检测到至少有一个散列槽未被发现（没有可用节点提供服务），则它们将停止接受查询。这样，如果集群部分关闭（例如一系列散列槽不再被覆盖），所有集群最终都将不可用。一旦所有插槽再次被覆盖，它就会自动返回可用状态。\n然而，有时您希望集群的子集工作，继续接受对仍然被覆盖的密钥空间部分的查询。为此，只需将`cluster-require-full-coverage`选项设置为no。\n```sh\n# cluster-require-full-coverage yes\n```\n\n## cluster-replica-no-failover\n当设置为“是”时，此选项可防止副本在主服务器故障时尝试故障转移其主服务器。但是，如果强制的话，主服务器仍然可以执行手动故障转移。\n这在不同的情况下很有用，特别是在多个数据中心操作的情况下，如果不升级，我们希望一方永远不会升级；如果发生完全的DC故障。\n```sh\n# cluster-replica-no-failover no\n```\n\n# CLUSTER DOCKER/NAT support\n在某些部署中，Redis群集节点地址发现失败，原因是地址是NAT，或者端口是转发的（典型情况是Docker和其他容器）。\n为了使redis集群在这样的环境中工作，需要一个静态配置，其中每个节点都知道其公共地址。以下两个选项用于此范围，分别是：\n* cluster-announce-ip\n* cluster-announce-port\n* cluster-announce-bus-port\n\n每个节点都指示其地址、客户机端口和集群消息总线端口。然后将信息发布到总线数据包的头部，以便其他节点能够正确映射发布信息的节点的地址。\n如果不使用上述选项，则将使用普通的Redis群集自动检测。\n请注意，重新映射时，总线端口可能不在客户机端口+10000的固定偏移量处，因此您可以根据重新映射的方式指定任何端口和总线端口。如果未设置总线端口，则通常使用固定偏移量10000。\n例如：\n```sh\n# cluster-announce-ip 10.1.1.5\n# cluster-announce-port 6379\n# cluster-announce-bus-port 6380\n```\n\n# slow log\nRedis slow log是一个系统日志查询，它超过了指定的执行时间。执行时间不包括I/O操作，如与客户机交谈、发送回复等，而只包括实际执行命令所需的时间（这是命令执行的唯一阶段，线程被阻塞，无法以平均值服务其他请求时间）。\n您可以用两个参数配置慢日志：一个参数告诉redis命令要记录的执行时间（以微秒计），另一个参数是慢日志的长度。当记录新命令时，最旧的命令将从记录的命令队列中删除。\n## slowlog-slower-than\n以下时间以微秒表示，因此1000000等于一秒。注意，负数会禁用慢速日志，而零值会强制记录每个命令。\n```sh\nslowlog-log-slower-than 10000\n```\n\n## slowlog-max-len\n这个长度没有限制。只是要知道它会消耗内存。可以使用`SLOWLOG RESET`来回收慢速日志使用的内存。\n```sh\nslowlog-max-len 128\n```\n\n# latency monitor\nRedis延迟监控子系统在运行时对不同的操作进行采样，以便收集与Redis实例的可能延迟源相关的数据。\n通过`LATENCY`命令，用户可以使用这些信息来打印图形和获取报告。\n系统只记录在时间等于或大于通过延迟监视器阈值配置指令指定的毫秒数内执行的操作。当其值设置为零时，延迟监视器将关闭。\n默认情况下，延迟监控是禁用的，因为如果您没有延迟问题，则通常不需要它，并且收集数据会对性能产生影响，尽管这一影响很小，但可以在大负载下进行测量。如果需要，可以使用命令`CONFIG SET latency-monitor-threshold <milliseconds>`在运行时轻松启用延迟监控。\n```sh\nlatency-monitor-threshold 0\n```\n\n# event notification\n例如，如果启用了keyspace事件通知，并且客户机对存储在数据库0中的密钥`foo`执行`DEL`操作，则将通过pub/sub发布两条消息：\n```sh\nPUBLISH __keyspace@0__:foo del\nPUBLISH __keyevent@0__:del foo\n```\n\n可以在一组类中选择Redis将通知的事件。每个类都由单个字符标识：\n```sh\n#  K     Keyspace events, published with __keyspace@<db>__ prefix.\n#  E     Keyevent events, published with __keyevent@<db>__ prefix.\n#  g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...\n#  $     String commands\n#  l     List commands\n#  s     Set commands\n#  h     Hash commands\n#  z     Sorted set commands\n#  x     Expired events (events generated every time a key expires)\n#  e     Evicted events (events generated when a key is evicted for maxmemory)\n#  A     Alias for g$lshzxe, so that the \"AKE\" string means all the events.\n```\n\n`notify-keyspace-events`将一个由零个或多个字符组成的字符串作为参数。空字符串表示通知被禁用。\n\n默认情况下，所有通知都被禁用，因为大多数用户不需要此功能，而且此功能有一些开销。请注意，如果不指定`K`或`E`中的至少一个，则不会传递任何事件。\n```sh\nnotify-keyspace-events \"\"\n```\n\n# advanced config\n ","slug":"Redis配置文件","published":1,"updated":"2019-12-10T06:43:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh351du3000e19z44s7paukj","content":"<p>最新Redis配置文件获取<a href=\"http://download.redis.io/redis-stable/redis.conf\" target=\"_blank\" rel=\"noopener\">redis.conf</a></p>\n<h1 id=\"start\"><a href=\"#start\" class=\"headerlink\" title=\"start\"></a>start</h1><p>启动Redis启动。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">$ ./redis-server /path/to/redis.conf</code></pre>\n<p>配置文件单位说明，单位不区分大小写。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\"># 1k => 1000 bytes\n# 1kb => 1024 bytes\n# 1m => 1000000 bytes\n# 1mb => 1024 * 1024 bytes\n# 1g => 1000000000 bytes\n# 1gb => 1024 * 1024 * 1024 bytes</code></pre>\n<h1 id=\"include\"><a href=\"#include\" class=\"headerlink\" title=\"include\"></a>include</h1><p><code>include</code>可以引入其他的配置文件，且不会被<code>CONFIG REWRITE</code>命令复写。Redis总是使用最后处理的行作为配置指令的值，最好在文件开始的时候<code>include</code>，避免运行时复写配置。如果想用<code>include</code>覆盖之前的配置可以放在文件末尾。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\"># include /path/to/local.conf\n# include /path/to/other.conf</code></pre>\n<h1 id=\"module\"><a href=\"#module\" class=\"headerlink\" title=\"module\"></a>module</h1><p>在启动时加载模块，如果无法加载，Redis会<code>abort</code>，可以同时加载多个模块。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\"># loadmodule /path/to/my_module.so\n# loadmodule /path/to/other_module.so</code></pre>\n<h1 id=\"network\"><a href=\"#network\" class=\"headerlink\" title=\"network\"></a>network</h1><h2 id=\"bind\"><a href=\"#bind\" class=\"headerlink\" title=\"bind\"></a>bind</h2><p>默认地，如果没有指定<code>bind</code>指令，Redis监听监听服务器上所有可用网络接口的连接。可以使用<code>bind</code>配置指令只侦听一个或多个选定的网卡接口，后跟一个或多个IP地址。<br>如果不指定bind指定是一件很危险的事，所以Redis默认指定本地的环回地址。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\"># bind 192.168.1.100 10.0.0.1\nbind 127.0.0.1 ::1</code></pre>\n<h2 id=\"protected-mode\"><a href=\"#protected-mode\" class=\"headerlink\" title=\"protected-mode\"></a>protected-mode</h2><p>保护模式是一层安全保护，以避免Redis实例在Internet上保持打开状态被访问和利用。<br>当保护模式打开，并且：</p>\n<ul>\n<li>Redis未<code>bind</code>到一组地址</li>\n<li>没有配置密码</li>\n</ul>\n<p>Redis只能接受来自IPv4和IPv6环回地址（127.0.0.1和::1）、Unix域套接字的连接。<br>保护模式默认是打开的。如果想其他地址访问Redis没有使用密码，或没有使用bind指定网络接口可以关闭保护模式。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">protected-mode yes</code></pre>\n<h2 id=\"port\"><a href=\"#port\" class=\"headerlink\" title=\"port\"></a>port</h2><p>接受指定端口的连接。如果指定为0，Redis不会监听TCP socket。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">port 6379</code></pre>\n<h2 id=\"tcp-backlog\"><a href=\"#tcp-backlog\" class=\"headerlink\" title=\"tcp-backlog\"></a>tcp-backlog</h2><p>TCP listen()函数的backlog参数，挂起连接队列的最大长度。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">tcp-backlog 511</code></pre>\n<h2 id=\"Unix-socket\"><a href=\"#Unix-socket\" class=\"headerlink\" title=\"Unix socket\"></a>Unix socket</h2><p>指定<code>Unix socket</code>的路径，Redis默认不监听<code>Unix socket</code>。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\"># unixsocket /tmp/redis.sock\n# unixsocketperm 700</code></pre>\n<h2 id=\"timeout\"><a href=\"#timeout\" class=\"headerlink\" title=\"timeout\"></a>timeout</h2><p>设置连接多少秒没有使用后断开连接，0表示不启用。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">timeout 0</code></pre>\n<h2 id=\"TCP-keepalive\"><a href=\"#TCP-keepalive\" class=\"headerlink\" title=\"TCP keepalive\"></a>TCP keepalive</h2><p>如果非零，使用SO_KEEPALIVE发送TCP ACK，来保活连接。<br>这样做有两个理由：</p>\n<ul>\n<li>检测对端状态</li>\n<li></li>\n</ul>\n<p>在Linux上，每隔指定的值（单位秒）都会发送TCP ACK，如果需要关闭连接则需要两倍这个时间。<br>其他内核取决于内核配置。<br>Redis默认300秒。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">tcp-keepalive 300</code></pre>\n<h1 id=\"general\"><a href=\"#general\" class=\"headerlink\" title=\"general\"></a>general</h1><h2 id=\"daemonize\"><a href=\"#daemonize\" class=\"headerlink\" title=\"daemonize\"></a>daemonize</h2><p>Redis默认是不作为<code>daemon</code>运行，可以使用<code>yes</code>启动该选项。<br>Redis在启用指令后会在<code>/var/run/redis.pid</code>产生<code>pid</code>文件。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">daemonize no</code></pre>\n<h2 id=\"supervised\"><a href=\"#supervised\" class=\"headerlink\" title=\"supervised\"></a>supervised</h2><p>如果使用upstart或者systemd启动Redis，可以使用supervised指令进行交互。<br>选项：</p>\n<ul>\n<li>no - 不使用supervision交互</li>\n<li>upstart - 让Redis进入<code>SIGSTOP</code>模式</li>\n<li>systemd - 向<code>$NOTIFY_SOCKET</code>写入<code>READY=1</code></li>\n<li>auto - 基于环境变量<code>UPSTART_JOB</code>或 <code>NOTIFY_SOCKET</code>来设置upstart还是systemd模式</li>\n</ul>\n<p>supervised只表示进程已经就绪，并不持续supervisor。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">supervised no</code></pre>\n<h2 id=\"pidfile\"><a href=\"#pidfile\" class=\"headerlink\" title=\"pidfile\"></a>pidfile</h2><p>如果指定了pidfile，那么Redis将会在启动的时候写入，退出的时候删除。<br>当Redis启动是使用非daemonized，配置中没有指定pidfile，则不会有pidfile创建；当Redis使用daemonized启动时，即使没有指定pidfile，也会创建，默认是<code>/var/run/redis.pid</code>。<br>如果Redis无法创建pidfile，也不会产生任何影响，Redis依旧可以正常启动和运行。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">pidfile /var/run/redis_6379.pid</code></pre>\n<h2 id=\"loglevel\"><a href=\"#loglevel\" class=\"headerlink\" title=\"loglevel\"></a>loglevel</h2><p>设置日志等级：</p>\n<ul>\n<li>debug，对开发测试有用</li>\n<li>verbose，一些有用的信息，不像debug那么杂乱</li>\n<li>notice，一般生产日志</li>\n<li>warning，记录关键信息</li>\n</ul>\n<pre class=\" language-sh\"><code class=\"language-sh\">loglevel notice</code></pre>\n<h2 id=\"logfile\"><a href=\"#logfile\" class=\"headerlink\" title=\"logfile\"></a>logfile</h2><p>指定日志文件名，空字符串表示Redis日志强制输出到标准输出。如果使用daemonized并且把日志输出到标准输出，则日志会被发送到<code>/dev/null</code>。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">logfile \"\"</code></pre>\n<h2 id=\"syslog\"><a href=\"#syslog\" class=\"headerlink\" title=\"syslog\"></a>syslog</h2><h3 id=\"enabled\"><a href=\"#enabled\" class=\"headerlink\" title=\"enabled\"></a>enabled</h3><p>将日志输出到system logger，指定<code>syslog-enabled</code>为<code>yes</code>，可以按照需求添加其他参数。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\"># syslog-enabled no</code></pre>\n<h3 id=\"ident\"><a href=\"#ident\" class=\"headerlink\" title=\"ident\"></a>ident</h3><p>指定syslog标识。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\"># syslog-ident redis</code></pre>\n<h3 id=\"facility\"><a href=\"#facility\" class=\"headerlink\" title=\"facility\"></a>facility</h3><p>指定syslog的<code>facility</code>，必须是<code>USER</code>或介于<code>LOCAL0-LOCAL7</code>。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\"># syslog-facility local0</code></pre>\n<h2 id=\"databases\"><a href=\"#databases\" class=\"headerlink\" title=\"databases\"></a>databases</h2><p>设置Redis数据库的数量，默认<code>DB</code>是0，可以使用<code>SELECT</code>选择<code>dbid</code>介于<code>0-databases-1</code>。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">databases 16</code></pre>\n<h2 id=\"show-logo\"><a href=\"#show-logo\" class=\"headerlink\" title=\"show logo\"></a>show logo</h2><p>默认在Redis启动的时候打印<code>ASCII logo</code>，仅在log输出在标准输出或标准输出是TTY的时候。只有在交互式的时候才显示<code>logo</code>。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">always-show-logo yes</code></pre>\n<h1 id=\"snapshotting\"><a href=\"#snapshotting\" class=\"headerlink\" title=\"snapshotting\"></a>snapshotting</h1><h2 id=\"save\"><a href=\"#save\" class=\"headerlink\" title=\"save\"></a>save</h2><p>数据库快照，将Redis数据保存到disk，命令<code>save second changes</code>。<br>当指定秒和写操作次数同时满足的时候写入disk。<br>可以通过注释掉save来禁用快照，也可以使用<code>save \"\"</code>来禁用已经设置的快照选项。<br>示例表示：</p>\n<ul>\n<li>900秒（15分钟）至少有一个键改动</li>\n<li>300秒（5分钟）至少有10个键改动</li>\n<li>60秒（1分钟）至少有10000个键改动<pre class=\" language-sh\"><code class=\"language-sh\">save 900 1\nsave 300 10\nsave 60 10000</code></pre>\n</li>\n</ul>\n<h2 id=\"stop-writes-on-bgsave-error\"><a href=\"#stop-writes-on-bgsave-error\" class=\"headerlink\" title=\"stop-writes-on-bgsave-error\"></a>stop-writes-on-bgsave-error</h2><p>当启动RDB快照时，Redis会停止写入，并且最后一次后台保存会失败。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">stop-writes-on-bgsave-error yes</code></pre>\n<h2 id=\"rdbcompression\"><a href=\"#rdbcompression\" class=\"headerlink\" title=\"rdbcompression\"></a>rdbcompression</h2><p>当使用dump .rdb数据库时，是否使用LZF压缩字符串对象</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">rdbcompression yes</code></pre>\n<h2 id=\"rdbchecksum\"><a href=\"#rdbchecksum\" class=\"headerlink\" title=\"rdbchecksum\"></a>rdbchecksum</h2><p>CRC64校验和存放于RDB文件的末尾，这可以抵抗损坏，但是有性能问题，可以禁用。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">rdbchecksum yes</code></pre>\n<h2 id=\"dbfilename\"><a href=\"#dbfilename\" class=\"headerlink\" title=\"dbfilename\"></a>dbfilename</h2><p>指定dump文件</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">dbfilename dump.rdb</code></pre>\n<h2 id=\"dir\"><a href=\"#dir\" class=\"headerlink\" title=\"dir\"></a>dir</h2><p>指定工作目录，<code>dbfilename</code>指定的文件将会在<code>dir</code>中创建，只追加的文件也在此目录中创建。<br><code>dir</code>必须指定一个目录，非文件路径。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">dir ./</code></pre>\n<h1 id=\"replication\"><a href=\"#replication\" class=\"headerlink\" title=\"replication\"></a>replication</h1><h2 id=\"replicaof\"><a href=\"#replicaof\" class=\"headerlink\" title=\"replicaof\"></a>replicaof</h2><p><code>Master-Replica</code>拷贝，使用replicaof让一个Redis实例复制另一个Redis实例。<br>相关概念：</p>\n<ul>\n<li>Redis复制是异步的，如果一个主Redis实例没有与给定数量的副本连接，那么可以配置他停止接收写操作</li>\n<li>如果复制链接丢失的时间相对较少，Redis副本可以与主服务器执行部分重新同步。根据需要，您可能需要使用合理的值配置复制积压工作的大小（请参阅此文件的下一节）。</li>\n<li>复制是一个自动的过程，网络分区副本自动尝试重新连接到主服务器，并与它们重新同步。</li>\n</ul>\n<pre class=\" language-sh\"><code class=\"language-sh\"># replicaof masterip masterport</code></pre>\n<h2 id=\"masterauth\"><a href=\"#masterauth\" class=\"headerlink\" title=\"masterauth\"></a>masterauth</h2><p>如果master有密码（使用requirepass配置），副本在复制的之前必须要验证密码，否则将拒绝复制。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\"># masterauth <master-password></code></pre>\n<h2 id=\"replica-serve-stale-data\"><a href=\"#replica-serve-stale-data\" class=\"headerlink\" title=\"replica-serve-stale-data\"></a>replica-serve-stale-data</h2><p>当副本与master断开连接，或当复制正在进行时，副本可以以两种不同的方式发挥做用：</p>\n<ul>\n<li>如果将<code>replica-serve-stale-data</code>设置成<code>yes</code>，副本将仍然回复客户端的请求，可能数据已过期，或者为空</li>\n<li>如果将<code>replica-serve-stale-data</code>设置成<code>no</code>，副本将用<code>SYNC with master in progress</code>回复所有请求，除了<code>INFO</code>，<code>replicaOF</code>，<code>AUTH</code>，<code>PING</code>，<code>SHUTDOWN</code>，<code>REPLCONF</code>，<code>ROLE</code>，<code>CONFIG</code>，<code>SUBSCRIBE</code>，<code>UNSUBSCRIBE</code>，<code>PSUBSCRIBE</code>，<code>PUNSUBSCRIBE</code>，<code>PUBLISH</code>，<code>PUBSUB</code>，<code>COMMAND</code>，<code>POST</code>，<code>HOST:</code>，<code>LATENCY</code></li>\n</ul>\n<pre class=\" language-sh\"><code class=\"language-sh\">replica-serve-stale-data yes</code></pre>\n<h2 id=\"replica-read-only\"><a href=\"#replica-read-only\" class=\"headerlink\" title=\"replica-read-only\"></a>replica-read-only</h2><p>设置副本实例是否可以写，默认副本是只读的。副本仍可以执行所有管理命令，可以使用<code>rename-command</code>遮蔽这些管理命令。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">replica-read-only yes</code></pre>\n<h2 id=\"repl-diskless-sync\"><a href=\"#repl-diskless-sync\" class=\"headerlink\" title=\"repl-diskless-sync\"></a>repl-diskless-sync</h2><p>新的复制副本和重新连接的复制副本无法继续仅接收差异的复制过程，需要执行所谓的“完全同步”。RDB文件从主服务器传输到副本服务器。<br>传输可以通过两种不同的方式进行：</p>\n<ul>\n<li>磁盘支持，Redis主服务器创建一个新进程，将RDB文件写入磁盘，稍后，父进程将文件以递增方式传输到副本。</li>\n<li>无磁盘，Redis主服务器创建一个新进程，将RDB文件写入副本套接字，不通过磁盘。</li>\n</ul>\n<p>使用磁盘备份复制，在生成RDB文件的同时，可以在生成RDB文件的当前子级完成工作后，将更多的副本排队并与RDB文件一起提供服务。<br>在无盘复制中，一旦传输开始，到达的新副本将排队，当当前副本终止时，将开始新的传输。<code>master</code>实例机会在开始传输之前等待一段可配置的时间（以秒为单位），以希望多个副本能够到达，并且可以并行传输。<br>使用低速磁盘和快速（大带宽）网络，无盘复制工作得更好。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">repl-diskless-sync no</code></pre>\n<h2 id=\"repl-diskless-sync-delay\"><a href=\"#repl-diskless-sync-delay\" class=\"headerlink\" title=\"repl-diskless-sync-delay\"></a>repl-diskless-sync-delay</h2><p>启动无盘复制时，可以配置服务器的等待延迟，这一点很重要，因为一旦传输开始，就不可能为到达的新副本提供服务，这些副本将排队等待下一次RDB传输，因此服务器将等待一段延迟，以便让更多副本到达。<br>默认5秒，设置为0表示禁用</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">repl-diskless-sync-delay 5</code></pre>\n<h2 id=\"repl-ping-replica-period\"><a href=\"#repl-ping-replica-period\" class=\"headerlink\" title=\"repl-ping-replica-period\"></a>repl-ping-replica-period</h2><p>副本以预先定义的间隔向服务器发送ping。可以使用<code>repl-ping-replica-period</code>选项更改此间隔。默认值为10秒。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\"># repl-ping-replica-period 10</code></pre>\n<h2 id=\"repl-timeout\"><a href=\"#repl-timeout\" class=\"headerlink\" title=\"repl-timeout\"></a>repl-timeout</h2><p>以下情况会复制超时：</p>\n<ul>\n<li>从副本角度看，同步期间的批量传输I/O。</li>\n<li>从副本角度看，master实例超时。</li>\n<li>从master实例看，复制超时。</li>\n</ul>\n<p>确保<code>repl-timeout</code>比<code>repl-ping-replica-period</code>大，否则每次主服务器和副本之间的通信量低时都会检测到超时。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\"># repl-timeout 60</code></pre>\n<h2 id=\"repl-disable-tcp-nodelay\"><a href=\"#repl-disable-tcp-nodelay\" class=\"headerlink\" title=\"repl-disable-tcp-nodelay\"></a>repl-disable-tcp-nodelay</h2><p>在副本发送<code>SYNC</code>后禁用<code>TCP_NODELAY</code>？<br>如果选择<code>yes</code>，Redis会占用少量带宽发送少量TCP包给副本，但这可能会增加副本同步延迟，使用Linux内核默认配置最多可延迟40毫秒。<br>如果选择<code>no</code>，延迟会减少，但是会占用更多带宽用于复制。<br>默认选择<code>no</code>，但是在非常高流量下或者master和副本之间有多跳时，<code>yes</code>也是不错的选择。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">repl-disable-tcp-nodelay no</code></pre>\n<h2 id=\"repl-backlog-size\"><a href=\"#repl-backlog-size\" class=\"headerlink\" title=\"repl-backlog-size\"></a>repl-backlog-size</h2><p>设置副本<code>backlog</code>大小，<code>backlog</code>是一个缓冲区，当副本断开连接一段时间后，它会累积副本数据，因此当副本希望再次重新连接时，通常不需要完全重新同步，部分重新同步就足够了，只需传递断开连接时副本丢失的数据部分。只有在至少连接了一个副本后，才会分配积压工作。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">#repl-backlog-size 1mb</code></pre>\n<h2 id=\"repl-backlog-ttl\"><a href=\"#repl-backlog-ttl\" class=\"headerlink\" title=\"repl-backlog-ttl\"></a>repl-backlog-ttl</h2><p>当master不在连接副本一段时间后释放backlog，该选项设置最后一个断开连接的副本后多久释放backlog，单位秒。如果为0，则永不释放。副本不会释放backlog，所以总是积压。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\"># repl-backlog-ttl 3600</code></pre>\n<h2 id=\"replica-priority\"><a href=\"#replica-priority\" class=\"headerlink\" title=\"replica-priority\"></a>replica-priority</h2><p>副本优先级，当master不在工作时，升级优先级编号低的成为master。当设置成0时，表示无法变成master。默认情况下优先级为100。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">replica-priority 100</code></pre>\n<h2 id=\"min-replicas-to-write\"><a href=\"#min-replicas-to-write\" class=\"headerlink\" title=\"min-replicas-to-write\"></a>min-replicas-to-write</h2><p>如果小于指定副本数量，并且通信小于指定时间，master会停止写入操作。副本必须都处于在线状态。其中一个选项为0表示禁用。默认禁用。<br>示例表示，3个副本并且滞后10秒。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\"># min-replicas-to-write 3\n# min-replicas-max-lag 10</code></pre>\n<h2 id=\"replica-announce-ip\"><a href=\"#replica-announce-ip\" class=\"headerlink\" title=\"replica-announce-ip\"></a>replica-announce-ip</h2><p>Redis master可以通过指定副本地址连接副本，Redis Sentinel可以发现副本实例。<br>复制副本通常报告的列出的IP和地址是通过以下方式获得的：</p>\n<ul>\n<li>IP，通过检查复制副本用于与主服务器连接的套接字的对等地址，可以自动检测该地址。</li>\n<li>port，在复制握手期间，该端口由副本通信，通常是副本用来侦听连接的端口。</li>\n</ul>\n<p>但是，当使用端口转发或网络地址转换（NAT）时，复制副本实际上可以通过不同的IP和端口对访问。副本可以使用以下两个选项向其主服务器报告一组特定的IP和端口，以便信息和角色都报告这些值。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\"># replica-announce-ip 5.5.5.5\n# replica-announce-port 1234</code></pre>\n<h1 id=\"security\"><a href=\"#security\" class=\"headerlink\" title=\"security\"></a>security</h1><h2 id=\"requirepass\"><a href=\"#requirepass\" class=\"headerlink\" title=\"requirepass\"></a>requirepass</h2><p>设置密码，客户端在使用的时候需要使用<code>AUTH</code>鉴权。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\"># requirepass foobared</code></pre>\n<h2 id=\"rename-command\"><a href=\"#rename-command\" class=\"headerlink\" title=\"rename-command\"></a>rename-command</h2><p>重命名命令。如果设置为空表示禁用命令。修改命令可能会在AOF模式或传输到副本中引发问题。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\"># rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52\n# rename-command CONFIG \"\"</code></pre>\n<h1 id=\"client\"><a href=\"#client\" class=\"headerlink\" title=\"client\"></a>client</h1><h2 id=\"maxclient\"><a href=\"#maxclient\" class=\"headerlink\" title=\"maxclient\"></a>maxclient</h2><p>设置客户端最大连接数，如果不指定则是当前文件系统最大值减32，达到限制后新的连接会收到<code>max number of clients reached</code>错误。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\"># maxclients 10000</code></pre>\n<h1 id=\"memory-management\"><a href=\"#memory-management\" class=\"headerlink\" title=\"memory management\"></a>memory management</h1><h2 id=\"maxmemory\"><a href=\"#maxmemory\" class=\"headerlink\" title=\"maxmemory\"></a>maxmemory</h2><p>设置占用内存最大值字节数，达到内存限制时，会采用所选的策略删除键。<br>如果Redis无法根据策略删除密钥，或者策略设置为<code>noeviction</code>。如果命令将使用更多内存，如SET，LPUSH等时，Redis将开始回复错误。只读命令正常回复。<br>当将Redis用作LRU或LFU缓存，或为实例设置硬内存限制（使用<code>noevection</code>策略）时，此选项通常很有用。<br>如果将副本附加到一个启用了<code>maxmemory</code>的实例上，则会从已用的内存计数中减去提供副本所需的输出缓冲区的大小，这样网络问题或重新同步就不会触发一个循环，在该循环中取出键，而反过来，输出缓冲区的复制副本中充满了被收回的键的del，从而导致删除更多的键，等等，直到数据库完全清空。<br>简而言之，如果您附加了副本，建议您为<code>maxmemory</code>设置一个较低的限制，以便系统上有一些用于副本输出缓冲区的可用RAM（但如果策略为<code>noevicetion</code>，则不需要这样做）。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\"># maxmemory <bytes></code></pre>\n<h2 id=\"maxmemory-policy\"><a href=\"#maxmemory-policy\" class=\"headerlink\" title=\"maxmemory-policy\"></a>maxmemory-policy</h2><p>当内存到达maxmemory的限制时，可以采用以下选项清理内存：</p>\n<ul>\n<li>volatile-lru，在具有过期集的密钥中使用近似的LRU逐出。</li>\n<li>allkeys-lru，使用近似的LRU逐出任何密钥。</li>\n<li>volatile-lfu，在具有过期集的键中使用近似的逐出。</li>\n<li>allkeys-lfu，使用近似的LFU逐出任何键。</li>\n<li>volatile-random，在有过期集的密钥中删除一个随机密钥。</li>\n<li>allkeys-random，随机删除任意键。</li>\n<li>volatile-ttl，删除最接近过期时间的密钥（次要TTL）。</li>\n<li>noeviction，不要逐出任何内容，只返回写操作错误。</li>\n</ul>\n<p>LRU指<code>Least Recently Used</code>，LFU指<code>Least Frequently Used</code>。<br>当操作命令是<code>set</code> <code>setnx</code> <code>setex</code> <code>append</code> <code>incr</code> <code>decr</code> <code>rpush</code> <code>lpush</code> <code>rpushx</code> <code>lpushx</code> <code>linsert</code> <code>lset</code> <code>rpoplpush</code> <code>sadd</code> <code>sinter</code> <code>sinterstore</code> <code>sunion</code> <code>sunionstore</code> <code>sdiff</code> <code>sdiffstore</code> <code>zadd</code> <code>zincrby</code> <code>zunionstore</code> <code>zinterstore</code> <code>hset</code> <code>hsetnx</code> <code>hmset</code> <code>hincrby</code> <code>incrby</code> <code>decrby</code> <code>getset</code> <code>mset</code> <code>msetnx</code> <code>exec</code> <code>sort</code>时，如果没有合适的键删除时返回错误。<br>默认<code>noeviction</code>。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\"># maxmemory-policy noeviction</code></pre>\n<h2 id=\"maxmemory-samples\"><a href=\"#maxmemory-samples\" class=\"headerlink\" title=\"maxmemory-samples\"></a>maxmemory-samples</h2><p>LRU，LFU和最小的TTL算法是不准确的算法，可以通过设置改选项提高精确度。<br>默认值为5会产生足够好的结果。10近似非常接近但成本更高的CPU，3更快但不是很准确。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\"># maxmemory-samples 5</code></pre>\n<h2 id=\"replica-ignore-maxmemory\"><a href=\"#replica-ignore-maxmemory\" class=\"headerlink\" title=\"replica-ignore-maxmemory\"></a>replica-ignore-maxmemory</h2><p>副本会忽略<code>maxmemory</code>指令，当master剔除键会发送DEL进行同步。但是如果副本可写，或者希望与master内存设置不一样，并且确定写入是幂等的，可以设置此值。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\"># replica-ignore-maxmemory yes</code></pre>\n<h1 id=\"lazy-freeing\"><a href=\"#lazy-freeing\" class=\"headerlink\" title=\"lazy freeing\"></a>lazy freeing</h1><p>Redis有两种方法删除键。一种是通过DEL阻塞的删除对象，删除时间与键关联的内存大小有关，如果是大key则可能会阻塞服务器很久。所以Redis提供异步删除。例如：<code>UNLINK</code>，<code>FLUSHALL</code>，<code>FLUSHDB</code>，会以恒定的时间，后台逐步释放。<br>这些命令是用户主动调用的，在某些情况下，Redis会主动的删除键：</p>\n<ul>\n<li>到达内存限制的时候，会主动调用剔除策略进行删除键；</li>\n<li>键到达了过期时间；</li>\n<li>修改键值可能会删除原有内容，例如<code>RENAME</code>，<code>SET</code>等；</li>\n<li>在复制过程中，当一个副本与其主服务器执行完全重新同步时，将删除整个数据库的内容，以便加载刚刚传输的RDB文件。</li>\n</ul>\n<p>在上述所有情况下，默认情况是以阻塞方式删除对象，就像调用<code>DEL</code>一样。但是，您可以具体配置每种情况，以便以非阻塞方式释放内存，就像调用<code>UNLINK</code>时一样，使用以下配置指令：</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">lazyfree-lazy-eviction no\nlazyfree-lazy-expire no\nlazyfree-lazy-server-del no\nreplica-lazy-flush no</code></pre>\n<h1 id=\"append-only-mode\"><a href=\"#append-only-mode\" class=\"headerlink\" title=\"append only mode\"></a>append only mode</h1><h2 id=\"appendonly-no\"><a href=\"#appendonly-no\" class=\"headerlink\" title=\"appendonly no\"></a>appendonly no</h2><p>默认情况，Redis采用异步的方式转储磁盘，但有可能丢失数据，取决于保存点。<br>Redis提供追加模式，一种更好的持久性。例如使用fsync policy，Redis仅会丢失1秒的写入或Redis进程本身发生什么错误丢失写入数据，但是系统仍能正常运行。<br><code>AOF</code>和<code>RDB</code>持久性可以同时启用而不会出现问题。如果在启动时启用<code>AOF</code>，Redis将加载<code>AOF</code>。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">appendonly no</code></pre>\n<h2 id=\"appendfilename\"><a href=\"#appendfilename\" class=\"headerlink\" title=\"appendfilename\"></a>appendfilename</h2><p>指定追加文件</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">appendfilename \"appendonly.aof\"</code></pre>\n<h2 id=\"appendfsync\"><a href=\"#appendfsync\" class=\"headerlink\" title=\"appendfsync\"></a>appendfsync</h2><p><code>fsync()</code>调用告诉操作系统在磁盘上实际写入数据，而不是在输出缓冲区中等待更多数据。有些操作系统将真正刷新磁盘上的数据，而另一些操作系统则会尽快进行刷新。<br>Redis支持三种模式：</p>\n<ul>\n<li><code>no</code>，不调用<code>fsync()</code>，仅让操作系统管理刷新数据，快速；</li>\n<li><code>always</code>，每次写入数据的时候添加文件，慢，安全；</li>\n<li><code>everysec</code>，每秒添加一次，折中。</li>\n</ul>\n<p>默认采用<code>everysec</code>。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\"># appendfsync always\nappendfsync everysec\n# appendfsync no</code></pre>\n<h2 id=\"no-appendfsync-on-rewrite\"><a href=\"#no-appendfsync-on-rewrite\" class=\"headerlink\" title=\"no-appendfsync-on-rewrite\"></a>no-appendfsync-on-rewrite</h2><p>当<code>AOF</code>的同步策略设置为<code>always</code>或<code>everysec</code>时，后台保存数据，这会有大量<code>IO</code>操作，在某些平台下，调用<code>fsync()</code>会阻塞很长时间。<br>为了缓解这个问题，可以使用<code>BGSAVE</code>或<code>BGREWRITEAOF</code>止主进程调用<code>fsync()</code>阻塞。<br>这意味着当另一个子进程正在保存时，redis的耐久性与<code>appendfsync none</code>相同。实际上，这意味着在最坏的情况下（使用默认的Linux设置），可能会丢失长达30秒的日志。<br>如果遇到延迟问题，请将其转为<code>yes</code>。否则 ，从耐久性的角度来看，<code>no</code>，这是最安全的选择。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">no-appendfsync-on-rewrite no</code></pre>\n<h2 id=\"auto-aof-rewrite-percentage\"><a href=\"#auto-aof-rewrite-percentage\" class=\"headerlink\" title=\"auto-aof-rewrite-percentage\"></a>auto-aof-rewrite-percentage</h2><p>自动重写仅附加文件。 当<code>AOF</code>日志大小增长指定的百分比时， Redis能够自动重写日志文件，隐式调用<code>BGREWRITEAOF</code>。<br>工作方式：Redis会记录最后一次复写时<code>AOF</code>文件大小，如果复写发生在重启时，这个大小是<code>AOF</code>在启动的时使用。<br>将此基本大小与当前大小进行比较。如果当前大小大于指定的百分比，则会触发重写。另外需要为要重写的<code>AOF</code>文件指定最小大小，这对于避免重写<code>AOF</code>文件很有用，即使达到了增加的百分比，但仍然很小。<br>指定零的百分比以禁用自动AOF重写功能。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">auto-aof-rewrite-percentage 100\nauto-aof-rewrite-min-size 64mb</code></pre>\n<h2 id=\"aof-load-truncated\"><a href=\"#aof-load-truncated\" class=\"headerlink\" title=\"aof-load-truncated\"></a>aof-load-truncated</h2><p>在Redis启动过程中，当<code>AOF</code>数据被加载回内存时，可能会发现<code>AOF</code>文件在末尾被截断。当运行Redis的系统崩溃时可能会发生这种情况，尤其是当安装<code>ext4</code>文件系统时，如果没有<code>data=ordered</code>选项（但是，当Redis本身崩溃或中止，但操作系统仍然正常工作时，则不会发生这种情况）。<br>当发生这种情况时，Redis退出并报错，也可以加载尽可能多的数据（现在是默认值），如果在末尾发现<code>AOF</code>文件被截断，则可以启动它。以下选项控制此行为。<br>如果设置为<code>yes</code>，则会加载一个已截断的<code>AOF</code>文件，并且Redis服务器开始发出日志，通知用户事件。否则，如果该选项设置为<code>no</code>，则服务器将以错误中止并拒绝启动。<br>当选项设置为否时，用户需要在重新启动服务器之前使用<code>redis-check-aof</code>修复<code>aof</code>文件。如果在中间发现AOF文件已损坏，服务器仍将退出并出现错误。此选项仅适用于Redis尝试从AOF文件读取更多数据但未找到足够字节的情况。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">aof-load-truncated yes</code></pre>\n<h2 id=\"aof-use-rdb-preamble\"><a href=\"#aof-use-rdb-preamble\" class=\"headerlink\" title=\"aof-use-rdb-preamble\"></a>aof-use-rdb-preamble</h2><p>在重写<code>AOF</code>文件时，Redis可以使用AOF文件中的RDB前导码来更快地重写和恢复。启用此选项时，重写的<code>AOF</code>文件由两个不同的节<code>[RDB file][AOF tail]</code>组成。<br>Redis加载时，会识别出<code>AOF</code>文件以<code>REDIS</code>字符串开始并加载前缀<code>RDB</code>文件，然后继续加载<code>AOF</code>尾部。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">aof-use-rdb-preamble yes</code></pre>\n<h1 id=\"LUA-scripting\"><a href=\"#LUA-scripting\" class=\"headerlink\" title=\"LUA scripting\"></a>LUA scripting</h1><p>Lua脚本的最大执行时间（以毫秒为单位）。<br>如果达到最大执行时间，redis将记录脚本在最大允许时间之后仍在执行中，并开始对出现错误的查询进行回复。<br>当长时间运行的脚本超过最大执行时间时，只有<code>SCRIPT KILL</code>和<code>SHUTDOWN NOSAVE</code>命令可用。第一个可以用于停止尚未调用写入命令的脚本。第二种方法是在脚本已经发出写命令但用户不希望等待脚本自然终止的情况下关闭服务器。<br>将其设置为0或负值，以便无警告地无限执行。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">lua-time-limit 5000</code></pre>\n<h1 id=\"Redis-cluster\"><a href=\"#Redis-cluster\" class=\"headerlink\" title=\"Redis cluster\"></a>Redis cluster</h1><h2 id=\"cluster-enabled\"><a href=\"#cluster-enabled\" class=\"headerlink\" title=\"cluster-enabled\"></a>cluster-enabled</h2><p>普通的redis实例不能是redis集群的一部分；只有作为集群节点启动的节点才能。为了启动Redis实例作为群集节点，解注释并设置成<code>yes</code>即可。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\"># cluster-enabled yes</code></pre>\n<h2 id=\"cluster-config-file\"><a href=\"#cluster-config-file\" class=\"headerlink\" title=\"cluster-config-file\"></a>cluster-config-file</h2><p>每个集群节点都有一个集群配置文件，此文件不需要手动编辑。它创建和更新都有Redis节点进行。每个Redis集群节点都需要不同的集群配置文件。确保在同一系统中运行的实例没有重叠的群集配置文件名。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\"># cluster-config-file nodes-6379.conf</code></pre>\n<h2 id=\"cluster-node-timeout\"><a href=\"#cluster-node-timeout\" class=\"headerlink\" title=\"cluster-node-timeout\"></a>cluster-node-timeout</h2><p>集群节点超时，单位毫秒。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\"># cluster-node-timeout 15000</code></pre>\n<h2 id=\"cluster-replica-validity-factor\"><a href=\"#cluster-replica-validity-factor\" class=\"headerlink\" title=\"cluster-replica-validity-factor\"></a>cluster-replica-validity-factor</h2><p>如果故障主机的数据看起来太旧，那么它的副本将避免启动故障转移。<br>对于副本来说没法验证数据的是否太旧，所以需要执行两项检查：</p>\n<ul>\n<li>如果有多个副本能够进行故障转移，它们会交换消息，以尽量利用具有最佳复制偏移量的副本（从主处理的更多数据）。副本将尝试按偏移量获取它们的列组，并将与列组成比例的延迟应用于故障转移的开始。</li>\n<li>每个副本都计算与主副本的最后一次交互的时间。这可以是接收到的最后一个ping或命令（如果主服务器仍然处于“已连接”状态），也可以是断开与主服务器的连接后经过的时间（如果复制链接当前已关闭）。如果上一次交互太旧，则复制副本将不会尝试进行故障转移。</li>\n</ul>\n<p>第二点可以由用户进行调整，即，如果副本上次与主服务器交互时间超过时间大于：<code>(node-timeout * replica-validity-factor) + repl-ping-replica-period</code>。<br>因此，例如，如果节点超时为30秒，副本有效性系数为10，并且假设默认的复制副本周期为10秒，那么如果副本无法与主副本进行超过310秒的对话，则不会尝试进行故障转移。<br>较大的副本有效性系数可能允许具有太旧数据的副本故障转移到主服务器，而太小的值可能会阻止群集根本无法选择副本。<br>为了获得最大的可用性，可以将副本有效性系数设置为0，这意味着，无论副本上次与主服务器交互的时间如何，它们都将始终尝试对主服务器进行故障转移。（然而，他们总是尝试应用与他们的偏移等级成比例的延迟）。<br>零是唯一能够保证当所有分区恢复时群集始终能够继续运行的值。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\"># cluster-replica-validity-factor 10</code></pre>\n<h2 id=\"cluster-migration-barrier\"><a href=\"#cluster-migration-barrier\" class=\"headerlink\" title=\"cluster-migration-barrier\"></a>cluster-migration-barrier</h2><p>群集副本能够迁移到孤立的主服务器，即没有工作副本的主服务器。这提高了集群抵御故障的能力，否则，如果一个孤立的主机没有工作的副本，它就不能在发生故障的情况下进行故障转移。<br>只有在至少有一个给定数量的旧主控形状的其他工作副本的情况下，副本才会迁移到孤立的主控形状。这个数字是“移民壁垒”。迁移屏障为1意味着只有在主副本至少有一个其他工作副本的情况下，副本才会迁移，以此类推。它通常反映出集群中每个主服务器所需的副本数量。<br>默认值为1（仅当主副本至少保留一个副本时才迁移副本）。要禁用迁移，只需将其设置为非常大的值。#可以设置值0，但仅对调试和生产中的危险有用。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\"># cluster-migration-barrier 1</code></pre>\n<h2 id=\"cluster-require-full-coverage\"><a href=\"#cluster-require-full-coverage\" class=\"headerlink\" title=\"cluster-require-full-coverage\"></a>cluster-require-full-coverage</h2><p>默认情况下，如果Redis群集节点检测到至少有一个散列槽未被发现（没有可用节点提供服务），则它们将停止接受查询。这样，如果集群部分关闭（例如一系列散列槽不再被覆盖），所有集群最终都将不可用。一旦所有插槽再次被覆盖，它就会自动返回可用状态。<br>然而，有时您希望集群的子集工作，继续接受对仍然被覆盖的密钥空间部分的查询。为此，只需将<code>cluster-require-full-coverage</code>选项设置为no。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\"># cluster-require-full-coverage yes</code></pre>\n<h2 id=\"cluster-replica-no-failover\"><a href=\"#cluster-replica-no-failover\" class=\"headerlink\" title=\"cluster-replica-no-failover\"></a>cluster-replica-no-failover</h2><p>当设置为“是”时，此选项可防止副本在主服务器故障时尝试故障转移其主服务器。但是，如果强制的话，主服务器仍然可以执行手动故障转移。<br>这在不同的情况下很有用，特别是在多个数据中心操作的情况下，如果不升级，我们希望一方永远不会升级；如果发生完全的DC故障。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\"># cluster-replica-no-failover no</code></pre>\n<h1 id=\"CLUSTER-DOCKER-NAT-support\"><a href=\"#CLUSTER-DOCKER-NAT-support\" class=\"headerlink\" title=\"CLUSTER DOCKER/NAT support\"></a>CLUSTER DOCKER/NAT support</h1><p>在某些部署中，Redis群集节点地址发现失败，原因是地址是NAT，或者端口是转发的（典型情况是Docker和其他容器）。<br>为了使redis集群在这样的环境中工作，需要一个静态配置，其中每个节点都知道其公共地址。以下两个选项用于此范围，分别是：</p>\n<ul>\n<li>cluster-announce-ip</li>\n<li>cluster-announce-port</li>\n<li>cluster-announce-bus-port</li>\n</ul>\n<p>每个节点都指示其地址、客户机端口和集群消息总线端口。然后将信息发布到总线数据包的头部，以便其他节点能够正确映射发布信息的节点的地址。<br>如果不使用上述选项，则将使用普通的Redis群集自动检测。<br>请注意，重新映射时，总线端口可能不在客户机端口+10000的固定偏移量处，因此您可以根据重新映射的方式指定任何端口和总线端口。如果未设置总线端口，则通常使用固定偏移量10000。<br>例如：</p>\n<pre class=\" language-sh\"><code class=\"language-sh\"># cluster-announce-ip 10.1.1.5\n# cluster-announce-port 6379\n# cluster-announce-bus-port 6380</code></pre>\n<h1 id=\"slow-log\"><a href=\"#slow-log\" class=\"headerlink\" title=\"slow log\"></a>slow log</h1><p>Redis slow log是一个系统日志查询，它超过了指定的执行时间。执行时间不包括I/O操作，如与客户机交谈、发送回复等，而只包括实际执行命令所需的时间（这是命令执行的唯一阶段，线程被阻塞，无法以平均值服务其他请求时间）。<br>您可以用两个参数配置慢日志：一个参数告诉redis命令要记录的执行时间（以微秒计），另一个参数是慢日志的长度。当记录新命令时，最旧的命令将从记录的命令队列中删除。</p>\n<h2 id=\"slowlog-slower-than\"><a href=\"#slowlog-slower-than\" class=\"headerlink\" title=\"slowlog-slower-than\"></a>slowlog-slower-than</h2><p>以下时间以微秒表示，因此1000000等于一秒。注意，负数会禁用慢速日志，而零值会强制记录每个命令。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">slowlog-log-slower-than 10000</code></pre>\n<h2 id=\"slowlog-max-len\"><a href=\"#slowlog-max-len\" class=\"headerlink\" title=\"slowlog-max-len\"></a>slowlog-max-len</h2><p>这个长度没有限制。只是要知道它会消耗内存。可以使用<code>SLOWLOG RESET</code>来回收慢速日志使用的内存。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">slowlog-max-len 128</code></pre>\n<h1 id=\"latency-monitor\"><a href=\"#latency-monitor\" class=\"headerlink\" title=\"latency monitor\"></a>latency monitor</h1><p>Redis延迟监控子系统在运行时对不同的操作进行采样，以便收集与Redis实例的可能延迟源相关的数据。<br>通过<code>LATENCY</code>命令，用户可以使用这些信息来打印图形和获取报告。<br>系统只记录在时间等于或大于通过延迟监视器阈值配置指令指定的毫秒数内执行的操作。当其值设置为零时，延迟监视器将关闭。<br>默认情况下，延迟监控是禁用的，因为如果您没有延迟问题，则通常不需要它，并且收集数据会对性能产生影响，尽管这一影响很小，但可以在大负载下进行测量。如果需要，可以使用命令<code>CONFIG SET latency-monitor-threshold &lt;milliseconds&gt;</code>在运行时轻松启用延迟监控。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">latency-monitor-threshold 0</code></pre>\n<h1 id=\"event-notification\"><a href=\"#event-notification\" class=\"headerlink\" title=\"event notification\"></a>event notification</h1><p>例如，如果启用了keyspace事件通知，并且客户机对存储在数据库0中的密钥<code>foo</code>执行<code>DEL</code>操作，则将通过pub/sub发布两条消息：</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">PUBLISH __keyspace@0__:foo del\nPUBLISH __keyevent@0__:del foo</code></pre>\n<p>可以在一组类中选择Redis将通知的事件。每个类都由单个字符标识：</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">#  K     Keyspace events, published with __keyspace@<db>__ prefix.\n#  E     Keyevent events, published with __keyevent@<db>__ prefix.\n#  g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...\n#  $     String commands\n#  l     List commands\n#  s     Set commands\n#  h     Hash commands\n#  z     Sorted set commands\n#  x     Expired events (events generated every time a key expires)\n#  e     Evicted events (events generated when a key is evicted for maxmemory)\n#  A     Alias for g$lshzxe, so that the \"AKE\" string means all the events.</code></pre>\n<p><code>notify-keyspace-events</code>将一个由零个或多个字符组成的字符串作为参数。空字符串表示通知被禁用。</p>\n<p>默认情况下，所有通知都被禁用，因为大多数用户不需要此功能，而且此功能有一些开销。请注意，如果不指定<code>K</code>或<code>E</code>中的至少一个，则不会传递任何事件。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">notify-keyspace-events \"\"</code></pre>\n<h1 id=\"advanced-config\"><a href=\"#advanced-config\" class=\"headerlink\" title=\"advanced config\"></a>advanced config</h1><script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"friends":[{"avatar":"https://img-1251474779.cos.ap-beijing.myqcloud.com/icon.png","name":"djaigo","introduction":"好好学习，天天向上","url":"/","title":"前去学习"},{"avatar":"https://awps-assets.meituan.net/mit/blog/v20190629/asset/icon/favicon.ico?v=Whistle&t=20181017-1r","name":"美团技术团队","introduction":"一行代码，亿万生活。","url":"https://tech.meituan.com/","title":"点个外卖-->"},{"avatar":"","name":"鸟窝","introduction":"rpcx作者","url":"https://colobu.com/","title":"进个鸟窝-->"},{"avatar":"https://d1j8pt39hxlh3d.cloudfront.net/emoji/emojione/5.0/png/unicode/32/1f92a.png","name":"labuladong的算法小抄","introduction":"算法大神","url":"https://labuladong.gitbook.io/algo/","title":"学个算法-->"}]}},"excerpt":"","more":"<p>最新Redis配置文件获取<a href=\"http://download.redis.io/redis-stable/redis.conf\" target=\"_blank\" rel=\"noopener\">redis.conf</a></p>\n<h1 id=\"start\"><a href=\"#start\" class=\"headerlink\" title=\"start\"></a>start</h1><p>启动Redis启动。</p>\n<pre><code class=\"sh\">$ ./redis-server /path/to/redis.conf</code></pre>\n<p>配置文件单位说明，单位不区分大小写。</p>\n<pre><code class=\"sh\"># 1k =&gt; 1000 bytes\n# 1kb =&gt; 1024 bytes\n# 1m =&gt; 1000000 bytes\n# 1mb =&gt; 1024 * 1024 bytes\n# 1g =&gt; 1000000000 bytes\n# 1gb =&gt; 1024 * 1024 * 1024 bytes</code></pre>\n<h1 id=\"include\"><a href=\"#include\" class=\"headerlink\" title=\"include\"></a>include</h1><p><code>include</code>可以引入其他的配置文件，且不会被<code>CONFIG REWRITE</code>命令复写。Redis总是使用最后处理的行作为配置指令的值，最好在文件开始的时候<code>include</code>，避免运行时复写配置。如果想用<code>include</code>覆盖之前的配置可以放在文件末尾。</p>\n<pre><code class=\"sh\"># include /path/to/local.conf\n# include /path/to/other.conf</code></pre>\n<h1 id=\"module\"><a href=\"#module\" class=\"headerlink\" title=\"module\"></a>module</h1><p>在启动时加载模块，如果无法加载，Redis会<code>abort</code>，可以同时加载多个模块。</p>\n<pre><code class=\"sh\"># loadmodule /path/to/my_module.so\n# loadmodule /path/to/other_module.so</code></pre>\n<h1 id=\"network\"><a href=\"#network\" class=\"headerlink\" title=\"network\"></a>network</h1><h2 id=\"bind\"><a href=\"#bind\" class=\"headerlink\" title=\"bind\"></a>bind</h2><p>默认地，如果没有指定<code>bind</code>指令，Redis监听监听服务器上所有可用网络接口的连接。可以使用<code>bind</code>配置指令只侦听一个或多个选定的网卡接口，后跟一个或多个IP地址。<br>如果不指定bind指定是一件很危险的事，所以Redis默认指定本地的环回地址。</p>\n<pre><code class=\"sh\"># bind 192.168.1.100 10.0.0.1\nbind 127.0.0.1 ::1</code></pre>\n<h2 id=\"protected-mode\"><a href=\"#protected-mode\" class=\"headerlink\" title=\"protected-mode\"></a>protected-mode</h2><p>保护模式是一层安全保护，以避免Redis实例在Internet上保持打开状态被访问和利用。<br>当保护模式打开，并且：</p>\n<ul>\n<li>Redis未<code>bind</code>到一组地址</li>\n<li>没有配置密码</li>\n</ul>\n<p>Redis只能接受来自IPv4和IPv6环回地址（127.0.0.1和::1）、Unix域套接字的连接。<br>保护模式默认是打开的。如果想其他地址访问Redis没有使用密码，或没有使用bind指定网络接口可以关闭保护模式。</p>\n<pre><code class=\"sh\">protected-mode yes</code></pre>\n<h2 id=\"port\"><a href=\"#port\" class=\"headerlink\" title=\"port\"></a>port</h2><p>接受指定端口的连接。如果指定为0，Redis不会监听TCP socket。</p>\n<pre><code class=\"sh\">port 6379</code></pre>\n<h2 id=\"tcp-backlog\"><a href=\"#tcp-backlog\" class=\"headerlink\" title=\"tcp-backlog\"></a>tcp-backlog</h2><p>TCP listen()函数的backlog参数，挂起连接队列的最大长度。</p>\n<pre><code class=\"sh\">tcp-backlog 511</code></pre>\n<h2 id=\"Unix-socket\"><a href=\"#Unix-socket\" class=\"headerlink\" title=\"Unix socket\"></a>Unix socket</h2><p>指定<code>Unix socket</code>的路径，Redis默认不监听<code>Unix socket</code>。</p>\n<pre><code class=\"sh\"># unixsocket /tmp/redis.sock\n# unixsocketperm 700</code></pre>\n<h2 id=\"timeout\"><a href=\"#timeout\" class=\"headerlink\" title=\"timeout\"></a>timeout</h2><p>设置连接多少秒没有使用后断开连接，0表示不启用。</p>\n<pre><code class=\"sh\">timeout 0</code></pre>\n<h2 id=\"TCP-keepalive\"><a href=\"#TCP-keepalive\" class=\"headerlink\" title=\"TCP keepalive\"></a>TCP keepalive</h2><p>如果非零，使用SO_KEEPALIVE发送TCP ACK，来保活连接。<br>这样做有两个理由：</p>\n<ul>\n<li>检测对端状态</li>\n<li></li>\n</ul>\n<p>在Linux上，每隔指定的值（单位秒）都会发送TCP ACK，如果需要关闭连接则需要两倍这个时间。<br>其他内核取决于内核配置。<br>Redis默认300秒。</p>\n<pre><code class=\"sh\">tcp-keepalive 300</code></pre>\n<h1 id=\"general\"><a href=\"#general\" class=\"headerlink\" title=\"general\"></a>general</h1><h2 id=\"daemonize\"><a href=\"#daemonize\" class=\"headerlink\" title=\"daemonize\"></a>daemonize</h2><p>Redis默认是不作为<code>daemon</code>运行，可以使用<code>yes</code>启动该选项。<br>Redis在启用指令后会在<code>/var/run/redis.pid</code>产生<code>pid</code>文件。</p>\n<pre><code class=\"sh\">daemonize no</code></pre>\n<h2 id=\"supervised\"><a href=\"#supervised\" class=\"headerlink\" title=\"supervised\"></a>supervised</h2><p>如果使用upstart或者systemd启动Redis，可以使用supervised指令进行交互。<br>选项：</p>\n<ul>\n<li>no - 不使用supervision交互</li>\n<li>upstart - 让Redis进入<code>SIGSTOP</code>模式</li>\n<li>systemd - 向<code>$NOTIFY_SOCKET</code>写入<code>READY=1</code></li>\n<li>auto - 基于环境变量<code>UPSTART_JOB</code>或 <code>NOTIFY_SOCKET</code>来设置upstart还是systemd模式</li>\n</ul>\n<p>supervised只表示进程已经就绪，并不持续supervisor。</p>\n<pre><code class=\"sh\">supervised no</code></pre>\n<h2 id=\"pidfile\"><a href=\"#pidfile\" class=\"headerlink\" title=\"pidfile\"></a>pidfile</h2><p>如果指定了pidfile，那么Redis将会在启动的时候写入，退出的时候删除。<br>当Redis启动是使用非daemonized，配置中没有指定pidfile，则不会有pidfile创建；当Redis使用daemonized启动时，即使没有指定pidfile，也会创建，默认是<code>/var/run/redis.pid</code>。<br>如果Redis无法创建pidfile，也不会产生任何影响，Redis依旧可以正常启动和运行。</p>\n<pre><code class=\"sh\">pidfile /var/run/redis_6379.pid</code></pre>\n<h2 id=\"loglevel\"><a href=\"#loglevel\" class=\"headerlink\" title=\"loglevel\"></a>loglevel</h2><p>设置日志等级：</p>\n<ul>\n<li>debug，对开发测试有用</li>\n<li>verbose，一些有用的信息，不像debug那么杂乱</li>\n<li>notice，一般生产日志</li>\n<li>warning，记录关键信息</li>\n</ul>\n<pre><code class=\"sh\">loglevel notice</code></pre>\n<h2 id=\"logfile\"><a href=\"#logfile\" class=\"headerlink\" title=\"logfile\"></a>logfile</h2><p>指定日志文件名，空字符串表示Redis日志强制输出到标准输出。如果使用daemonized并且把日志输出到标准输出，则日志会被发送到<code>/dev/null</code>。</p>\n<pre><code class=\"sh\">logfile &quot;&quot;</code></pre>\n<h2 id=\"syslog\"><a href=\"#syslog\" class=\"headerlink\" title=\"syslog\"></a>syslog</h2><h3 id=\"enabled\"><a href=\"#enabled\" class=\"headerlink\" title=\"enabled\"></a>enabled</h3><p>将日志输出到system logger，指定<code>syslog-enabled</code>为<code>yes</code>，可以按照需求添加其他参数。</p>\n<pre><code class=\"sh\"># syslog-enabled no</code></pre>\n<h3 id=\"ident\"><a href=\"#ident\" class=\"headerlink\" title=\"ident\"></a>ident</h3><p>指定syslog标识。</p>\n<pre><code class=\"sh\"># syslog-ident redis</code></pre>\n<h3 id=\"facility\"><a href=\"#facility\" class=\"headerlink\" title=\"facility\"></a>facility</h3><p>指定syslog的<code>facility</code>，必须是<code>USER</code>或介于<code>LOCAL0-LOCAL7</code>。</p>\n<pre><code class=\"sh\"># syslog-facility local0</code></pre>\n<h2 id=\"databases\"><a href=\"#databases\" class=\"headerlink\" title=\"databases\"></a>databases</h2><p>设置Redis数据库的数量，默认<code>DB</code>是0，可以使用<code>SELECT</code>选择<code>dbid</code>介于<code>0-databases-1</code>。</p>\n<pre><code class=\"sh\">databases 16</code></pre>\n<h2 id=\"show-logo\"><a href=\"#show-logo\" class=\"headerlink\" title=\"show logo\"></a>show logo</h2><p>默认在Redis启动的时候打印<code>ASCII logo</code>，仅在log输出在标准输出或标准输出是TTY的时候。只有在交互式的时候才显示<code>logo</code>。</p>\n<pre><code class=\"sh\">always-show-logo yes</code></pre>\n<h1 id=\"snapshotting\"><a href=\"#snapshotting\" class=\"headerlink\" title=\"snapshotting\"></a>snapshotting</h1><h2 id=\"save\"><a href=\"#save\" class=\"headerlink\" title=\"save\"></a>save</h2><p>数据库快照，将Redis数据保存到disk，命令<code>save second changes</code>。<br>当指定秒和写操作次数同时满足的时候写入disk。<br>可以通过注释掉save来禁用快照，也可以使用<code>save &quot;&quot;</code>来禁用已经设置的快照选项。<br>示例表示：</p>\n<ul>\n<li>900秒（15分钟）至少有一个键改动</li>\n<li>300秒（5分钟）至少有10个键改动</li>\n<li>60秒（1分钟）至少有10000个键改动<pre><code class=\"sh\">save 900 1\nsave 300 10\nsave 60 10000</code></pre>\n</li>\n</ul>\n<h2 id=\"stop-writes-on-bgsave-error\"><a href=\"#stop-writes-on-bgsave-error\" class=\"headerlink\" title=\"stop-writes-on-bgsave-error\"></a>stop-writes-on-bgsave-error</h2><p>当启动RDB快照时，Redis会停止写入，并且最后一次后台保存会失败。</p>\n<pre><code class=\"sh\">stop-writes-on-bgsave-error yes</code></pre>\n<h2 id=\"rdbcompression\"><a href=\"#rdbcompression\" class=\"headerlink\" title=\"rdbcompression\"></a>rdbcompression</h2><p>当使用dump .rdb数据库时，是否使用LZF压缩字符串对象</p>\n<pre><code class=\"sh\">rdbcompression yes</code></pre>\n<h2 id=\"rdbchecksum\"><a href=\"#rdbchecksum\" class=\"headerlink\" title=\"rdbchecksum\"></a>rdbchecksum</h2><p>CRC64校验和存放于RDB文件的末尾，这可以抵抗损坏，但是有性能问题，可以禁用。</p>\n<pre><code class=\"sh\">rdbchecksum yes</code></pre>\n<h2 id=\"dbfilename\"><a href=\"#dbfilename\" class=\"headerlink\" title=\"dbfilename\"></a>dbfilename</h2><p>指定dump文件</p>\n<pre><code class=\"sh\">dbfilename dump.rdb</code></pre>\n<h2 id=\"dir\"><a href=\"#dir\" class=\"headerlink\" title=\"dir\"></a>dir</h2><p>指定工作目录，<code>dbfilename</code>指定的文件将会在<code>dir</code>中创建，只追加的文件也在此目录中创建。<br><code>dir</code>必须指定一个目录，非文件路径。</p>\n<pre><code class=\"sh\">dir ./</code></pre>\n<h1 id=\"replication\"><a href=\"#replication\" class=\"headerlink\" title=\"replication\"></a>replication</h1><h2 id=\"replicaof\"><a href=\"#replicaof\" class=\"headerlink\" title=\"replicaof\"></a>replicaof</h2><p><code>Master-Replica</code>拷贝，使用replicaof让一个Redis实例复制另一个Redis实例。<br>相关概念：</p>\n<ul>\n<li>Redis复制是异步的，如果一个主Redis实例没有与给定数量的副本连接，那么可以配置他停止接收写操作</li>\n<li>如果复制链接丢失的时间相对较少，Redis副本可以与主服务器执行部分重新同步。根据需要，您可能需要使用合理的值配置复制积压工作的大小（请参阅此文件的下一节）。</li>\n<li>复制是一个自动的过程，网络分区副本自动尝试重新连接到主服务器，并与它们重新同步。</li>\n</ul>\n<pre><code class=\"sh\"># replicaof masterip masterport</code></pre>\n<h2 id=\"masterauth\"><a href=\"#masterauth\" class=\"headerlink\" title=\"masterauth\"></a>masterauth</h2><p>如果master有密码（使用requirepass配置），副本在复制的之前必须要验证密码，否则将拒绝复制。</p>\n<pre><code class=\"sh\"># masterauth &lt;master-password&gt;</code></pre>\n<h2 id=\"replica-serve-stale-data\"><a href=\"#replica-serve-stale-data\" class=\"headerlink\" title=\"replica-serve-stale-data\"></a>replica-serve-stale-data</h2><p>当副本与master断开连接，或当复制正在进行时，副本可以以两种不同的方式发挥做用：</p>\n<ul>\n<li>如果将<code>replica-serve-stale-data</code>设置成<code>yes</code>，副本将仍然回复客户端的请求，可能数据已过期，或者为空</li>\n<li>如果将<code>replica-serve-stale-data</code>设置成<code>no</code>，副本将用<code>SYNC with master in progress</code>回复所有请求，除了<code>INFO</code>，<code>replicaOF</code>，<code>AUTH</code>，<code>PING</code>，<code>SHUTDOWN</code>，<code>REPLCONF</code>，<code>ROLE</code>，<code>CONFIG</code>，<code>SUBSCRIBE</code>，<code>UNSUBSCRIBE</code>，<code>PSUBSCRIBE</code>，<code>PUNSUBSCRIBE</code>，<code>PUBLISH</code>，<code>PUBSUB</code>，<code>COMMAND</code>，<code>POST</code>，<code>HOST:</code>，<code>LATENCY</code></li>\n</ul>\n<pre><code class=\"sh\">replica-serve-stale-data yes</code></pre>\n<h2 id=\"replica-read-only\"><a href=\"#replica-read-only\" class=\"headerlink\" title=\"replica-read-only\"></a>replica-read-only</h2><p>设置副本实例是否可以写，默认副本是只读的。副本仍可以执行所有管理命令，可以使用<code>rename-command</code>遮蔽这些管理命令。</p>\n<pre><code class=\"sh\">replica-read-only yes</code></pre>\n<h2 id=\"repl-diskless-sync\"><a href=\"#repl-diskless-sync\" class=\"headerlink\" title=\"repl-diskless-sync\"></a>repl-diskless-sync</h2><p>新的复制副本和重新连接的复制副本无法继续仅接收差异的复制过程，需要执行所谓的“完全同步”。RDB文件从主服务器传输到副本服务器。<br>传输可以通过两种不同的方式进行：</p>\n<ul>\n<li>磁盘支持，Redis主服务器创建一个新进程，将RDB文件写入磁盘，稍后，父进程将文件以递增方式传输到副本。</li>\n<li>无磁盘，Redis主服务器创建一个新进程，将RDB文件写入副本套接字，不通过磁盘。</li>\n</ul>\n<p>使用磁盘备份复制，在生成RDB文件的同时，可以在生成RDB文件的当前子级完成工作后，将更多的副本排队并与RDB文件一起提供服务。<br>在无盘复制中，一旦传输开始，到达的新副本将排队，当当前副本终止时，将开始新的传输。<code>master</code>实例机会在开始传输之前等待一段可配置的时间（以秒为单位），以希望多个副本能够到达，并且可以并行传输。<br>使用低速磁盘和快速（大带宽）网络，无盘复制工作得更好。</p>\n<pre><code class=\"sh\">repl-diskless-sync no</code></pre>\n<h2 id=\"repl-diskless-sync-delay\"><a href=\"#repl-diskless-sync-delay\" class=\"headerlink\" title=\"repl-diskless-sync-delay\"></a>repl-diskless-sync-delay</h2><p>启动无盘复制时，可以配置服务器的等待延迟，这一点很重要，因为一旦传输开始，就不可能为到达的新副本提供服务，这些副本将排队等待下一次RDB传输，因此服务器将等待一段延迟，以便让更多副本到达。<br>默认5秒，设置为0表示禁用</p>\n<pre><code class=\"sh\">repl-diskless-sync-delay 5</code></pre>\n<h2 id=\"repl-ping-replica-period\"><a href=\"#repl-ping-replica-period\" class=\"headerlink\" title=\"repl-ping-replica-period\"></a>repl-ping-replica-period</h2><p>副本以预先定义的间隔向服务器发送ping。可以使用<code>repl-ping-replica-period</code>选项更改此间隔。默认值为10秒。</p>\n<pre><code class=\"sh\"># repl-ping-replica-period 10</code></pre>\n<h2 id=\"repl-timeout\"><a href=\"#repl-timeout\" class=\"headerlink\" title=\"repl-timeout\"></a>repl-timeout</h2><p>以下情况会复制超时：</p>\n<ul>\n<li>从副本角度看，同步期间的批量传输I/O。</li>\n<li>从副本角度看，master实例超时。</li>\n<li>从master实例看，复制超时。</li>\n</ul>\n<p>确保<code>repl-timeout</code>比<code>repl-ping-replica-period</code>大，否则每次主服务器和副本之间的通信量低时都会检测到超时。</p>\n<pre><code class=\"sh\"># repl-timeout 60</code></pre>\n<h2 id=\"repl-disable-tcp-nodelay\"><a href=\"#repl-disable-tcp-nodelay\" class=\"headerlink\" title=\"repl-disable-tcp-nodelay\"></a>repl-disable-tcp-nodelay</h2><p>在副本发送<code>SYNC</code>后禁用<code>TCP_NODELAY</code>？<br>如果选择<code>yes</code>，Redis会占用少量带宽发送少量TCP包给副本，但这可能会增加副本同步延迟，使用Linux内核默认配置最多可延迟40毫秒。<br>如果选择<code>no</code>，延迟会减少，但是会占用更多带宽用于复制。<br>默认选择<code>no</code>，但是在非常高流量下或者master和副本之间有多跳时，<code>yes</code>也是不错的选择。</p>\n<pre><code class=\"sh\">repl-disable-tcp-nodelay no</code></pre>\n<h2 id=\"repl-backlog-size\"><a href=\"#repl-backlog-size\" class=\"headerlink\" title=\"repl-backlog-size\"></a>repl-backlog-size</h2><p>设置副本<code>backlog</code>大小，<code>backlog</code>是一个缓冲区，当副本断开连接一段时间后，它会累积副本数据，因此当副本希望再次重新连接时，通常不需要完全重新同步，部分重新同步就足够了，只需传递断开连接时副本丢失的数据部分。只有在至少连接了一个副本后，才会分配积压工作。</p>\n<pre><code class=\"sh\">#repl-backlog-size 1mb</code></pre>\n<h2 id=\"repl-backlog-ttl\"><a href=\"#repl-backlog-ttl\" class=\"headerlink\" title=\"repl-backlog-ttl\"></a>repl-backlog-ttl</h2><p>当master不在连接副本一段时间后释放backlog，该选项设置最后一个断开连接的副本后多久释放backlog，单位秒。如果为0，则永不释放。副本不会释放backlog，所以总是积压。</p>\n<pre><code class=\"sh\"># repl-backlog-ttl 3600</code></pre>\n<h2 id=\"replica-priority\"><a href=\"#replica-priority\" class=\"headerlink\" title=\"replica-priority\"></a>replica-priority</h2><p>副本优先级，当master不在工作时，升级优先级编号低的成为master。当设置成0时，表示无法变成master。默认情况下优先级为100。</p>\n<pre><code class=\"sh\">replica-priority 100</code></pre>\n<h2 id=\"min-replicas-to-write\"><a href=\"#min-replicas-to-write\" class=\"headerlink\" title=\"min-replicas-to-write\"></a>min-replicas-to-write</h2><p>如果小于指定副本数量，并且通信小于指定时间，master会停止写入操作。副本必须都处于在线状态。其中一个选项为0表示禁用。默认禁用。<br>示例表示，3个副本并且滞后10秒。</p>\n<pre><code class=\"sh\"># min-replicas-to-write 3\n# min-replicas-max-lag 10</code></pre>\n<h2 id=\"replica-announce-ip\"><a href=\"#replica-announce-ip\" class=\"headerlink\" title=\"replica-announce-ip\"></a>replica-announce-ip</h2><p>Redis master可以通过指定副本地址连接副本，Redis Sentinel可以发现副本实例。<br>复制副本通常报告的列出的IP和地址是通过以下方式获得的：</p>\n<ul>\n<li>IP，通过检查复制副本用于与主服务器连接的套接字的对等地址，可以自动检测该地址。</li>\n<li>port，在复制握手期间，该端口由副本通信，通常是副本用来侦听连接的端口。</li>\n</ul>\n<p>但是，当使用端口转发或网络地址转换（NAT）时，复制副本实际上可以通过不同的IP和端口对访问。副本可以使用以下两个选项向其主服务器报告一组特定的IP和端口，以便信息和角色都报告这些值。</p>\n<pre><code class=\"sh\"># replica-announce-ip 5.5.5.5\n# replica-announce-port 1234</code></pre>\n<h1 id=\"security\"><a href=\"#security\" class=\"headerlink\" title=\"security\"></a>security</h1><h2 id=\"requirepass\"><a href=\"#requirepass\" class=\"headerlink\" title=\"requirepass\"></a>requirepass</h2><p>设置密码，客户端在使用的时候需要使用<code>AUTH</code>鉴权。</p>\n<pre><code class=\"sh\"># requirepass foobared</code></pre>\n<h2 id=\"rename-command\"><a href=\"#rename-command\" class=\"headerlink\" title=\"rename-command\"></a>rename-command</h2><p>重命名命令。如果设置为空表示禁用命令。修改命令可能会在AOF模式或传输到副本中引发问题。</p>\n<pre><code class=\"sh\"># rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52\n# rename-command CONFIG &quot;&quot;</code></pre>\n<h1 id=\"client\"><a href=\"#client\" class=\"headerlink\" title=\"client\"></a>client</h1><h2 id=\"maxclient\"><a href=\"#maxclient\" class=\"headerlink\" title=\"maxclient\"></a>maxclient</h2><p>设置客户端最大连接数，如果不指定则是当前文件系统最大值减32，达到限制后新的连接会收到<code>max number of clients reached</code>错误。</p>\n<pre><code class=\"sh\"># maxclients 10000</code></pre>\n<h1 id=\"memory-management\"><a href=\"#memory-management\" class=\"headerlink\" title=\"memory management\"></a>memory management</h1><h2 id=\"maxmemory\"><a href=\"#maxmemory\" class=\"headerlink\" title=\"maxmemory\"></a>maxmemory</h2><p>设置占用内存最大值字节数，达到内存限制时，会采用所选的策略删除键。<br>如果Redis无法根据策略删除密钥，或者策略设置为<code>noeviction</code>。如果命令将使用更多内存，如SET，LPUSH等时，Redis将开始回复错误。只读命令正常回复。<br>当将Redis用作LRU或LFU缓存，或为实例设置硬内存限制（使用<code>noevection</code>策略）时，此选项通常很有用。<br>如果将副本附加到一个启用了<code>maxmemory</code>的实例上，则会从已用的内存计数中减去提供副本所需的输出缓冲区的大小，这样网络问题或重新同步就不会触发一个循环，在该循环中取出键，而反过来，输出缓冲区的复制副本中充满了被收回的键的del，从而导致删除更多的键，等等，直到数据库完全清空。<br>简而言之，如果您附加了副本，建议您为<code>maxmemory</code>设置一个较低的限制，以便系统上有一些用于副本输出缓冲区的可用RAM（但如果策略为<code>noevicetion</code>，则不需要这样做）。</p>\n<pre><code class=\"sh\"># maxmemory &lt;bytes&gt;</code></pre>\n<h2 id=\"maxmemory-policy\"><a href=\"#maxmemory-policy\" class=\"headerlink\" title=\"maxmemory-policy\"></a>maxmemory-policy</h2><p>当内存到达maxmemory的限制时，可以采用以下选项清理内存：</p>\n<ul>\n<li>volatile-lru，在具有过期集的密钥中使用近似的LRU逐出。</li>\n<li>allkeys-lru，使用近似的LRU逐出任何密钥。</li>\n<li>volatile-lfu，在具有过期集的键中使用近似的逐出。</li>\n<li>allkeys-lfu，使用近似的LFU逐出任何键。</li>\n<li>volatile-random，在有过期集的密钥中删除一个随机密钥。</li>\n<li>allkeys-random，随机删除任意键。</li>\n<li>volatile-ttl，删除最接近过期时间的密钥（次要TTL）。</li>\n<li>noeviction，不要逐出任何内容，只返回写操作错误。</li>\n</ul>\n<p>LRU指<code>Least Recently Used</code>，LFU指<code>Least Frequently Used</code>。<br>当操作命令是<code>set</code> <code>setnx</code> <code>setex</code> <code>append</code> <code>incr</code> <code>decr</code> <code>rpush</code> <code>lpush</code> <code>rpushx</code> <code>lpushx</code> <code>linsert</code> <code>lset</code> <code>rpoplpush</code> <code>sadd</code> <code>sinter</code> <code>sinterstore</code> <code>sunion</code> <code>sunionstore</code> <code>sdiff</code> <code>sdiffstore</code> <code>zadd</code> <code>zincrby</code> <code>zunionstore</code> <code>zinterstore</code> <code>hset</code> <code>hsetnx</code> <code>hmset</code> <code>hincrby</code> <code>incrby</code> <code>decrby</code> <code>getset</code> <code>mset</code> <code>msetnx</code> <code>exec</code> <code>sort</code>时，如果没有合适的键删除时返回错误。<br>默认<code>noeviction</code>。</p>\n<pre><code class=\"sh\"># maxmemory-policy noeviction</code></pre>\n<h2 id=\"maxmemory-samples\"><a href=\"#maxmemory-samples\" class=\"headerlink\" title=\"maxmemory-samples\"></a>maxmemory-samples</h2><p>LRU，LFU和最小的TTL算法是不准确的算法，可以通过设置改选项提高精确度。<br>默认值为5会产生足够好的结果。10近似非常接近但成本更高的CPU，3更快但不是很准确。</p>\n<pre><code class=\"sh\"># maxmemory-samples 5</code></pre>\n<h2 id=\"replica-ignore-maxmemory\"><a href=\"#replica-ignore-maxmemory\" class=\"headerlink\" title=\"replica-ignore-maxmemory\"></a>replica-ignore-maxmemory</h2><p>副本会忽略<code>maxmemory</code>指令，当master剔除键会发送DEL进行同步。但是如果副本可写，或者希望与master内存设置不一样，并且确定写入是幂等的，可以设置此值。</p>\n<pre><code class=\"sh\"># replica-ignore-maxmemory yes</code></pre>\n<h1 id=\"lazy-freeing\"><a href=\"#lazy-freeing\" class=\"headerlink\" title=\"lazy freeing\"></a>lazy freeing</h1><p>Redis有两种方法删除键。一种是通过DEL阻塞的删除对象，删除时间与键关联的内存大小有关，如果是大key则可能会阻塞服务器很久。所以Redis提供异步删除。例如：<code>UNLINK</code>，<code>FLUSHALL</code>，<code>FLUSHDB</code>，会以恒定的时间，后台逐步释放。<br>这些命令是用户主动调用的，在某些情况下，Redis会主动的删除键：</p>\n<ul>\n<li>到达内存限制的时候，会主动调用剔除策略进行删除键；</li>\n<li>键到达了过期时间；</li>\n<li>修改键值可能会删除原有内容，例如<code>RENAME</code>，<code>SET</code>等；</li>\n<li>在复制过程中，当一个副本与其主服务器执行完全重新同步时，将删除整个数据库的内容，以便加载刚刚传输的RDB文件。</li>\n</ul>\n<p>在上述所有情况下，默认情况是以阻塞方式删除对象，就像调用<code>DEL</code>一样。但是，您可以具体配置每种情况，以便以非阻塞方式释放内存，就像调用<code>UNLINK</code>时一样，使用以下配置指令：</p>\n<pre><code class=\"sh\">lazyfree-lazy-eviction no\nlazyfree-lazy-expire no\nlazyfree-lazy-server-del no\nreplica-lazy-flush no</code></pre>\n<h1 id=\"append-only-mode\"><a href=\"#append-only-mode\" class=\"headerlink\" title=\"append only mode\"></a>append only mode</h1><h2 id=\"appendonly-no\"><a href=\"#appendonly-no\" class=\"headerlink\" title=\"appendonly no\"></a>appendonly no</h2><p>默认情况，Redis采用异步的方式转储磁盘，但有可能丢失数据，取决于保存点。<br>Redis提供追加模式，一种更好的持久性。例如使用fsync policy，Redis仅会丢失1秒的写入或Redis进程本身发生什么错误丢失写入数据，但是系统仍能正常运行。<br><code>AOF</code>和<code>RDB</code>持久性可以同时启用而不会出现问题。如果在启动时启用<code>AOF</code>，Redis将加载<code>AOF</code>。</p>\n<pre><code class=\"sh\">appendonly no</code></pre>\n<h2 id=\"appendfilename\"><a href=\"#appendfilename\" class=\"headerlink\" title=\"appendfilename\"></a>appendfilename</h2><p>指定追加文件</p>\n<pre><code class=\"sh\">appendfilename &quot;appendonly.aof&quot;</code></pre>\n<h2 id=\"appendfsync\"><a href=\"#appendfsync\" class=\"headerlink\" title=\"appendfsync\"></a>appendfsync</h2><p><code>fsync()</code>调用告诉操作系统在磁盘上实际写入数据，而不是在输出缓冲区中等待更多数据。有些操作系统将真正刷新磁盘上的数据，而另一些操作系统则会尽快进行刷新。<br>Redis支持三种模式：</p>\n<ul>\n<li><code>no</code>，不调用<code>fsync()</code>，仅让操作系统管理刷新数据，快速；</li>\n<li><code>always</code>，每次写入数据的时候添加文件，慢，安全；</li>\n<li><code>everysec</code>，每秒添加一次，折中。</li>\n</ul>\n<p>默认采用<code>everysec</code>。</p>\n<pre><code class=\"sh\"># appendfsync always\nappendfsync everysec\n# appendfsync no</code></pre>\n<h2 id=\"no-appendfsync-on-rewrite\"><a href=\"#no-appendfsync-on-rewrite\" class=\"headerlink\" title=\"no-appendfsync-on-rewrite\"></a>no-appendfsync-on-rewrite</h2><p>当<code>AOF</code>的同步策略设置为<code>always</code>或<code>everysec</code>时，后台保存数据，这会有大量<code>IO</code>操作，在某些平台下，调用<code>fsync()</code>会阻塞很长时间。<br>为了缓解这个问题，可以使用<code>BGSAVE</code>或<code>BGREWRITEAOF</code>止主进程调用<code>fsync()</code>阻塞。<br>这意味着当另一个子进程正在保存时，redis的耐久性与<code>appendfsync none</code>相同。实际上，这意味着在最坏的情况下（使用默认的Linux设置），可能会丢失长达30秒的日志。<br>如果遇到延迟问题，请将其转为<code>yes</code>。否则 ，从耐久性的角度来看，<code>no</code>，这是最安全的选择。</p>\n<pre><code class=\"sh\">no-appendfsync-on-rewrite no</code></pre>\n<h2 id=\"auto-aof-rewrite-percentage\"><a href=\"#auto-aof-rewrite-percentage\" class=\"headerlink\" title=\"auto-aof-rewrite-percentage\"></a>auto-aof-rewrite-percentage</h2><p>自动重写仅附加文件。 当<code>AOF</code>日志大小增长指定的百分比时， Redis能够自动重写日志文件，隐式调用<code>BGREWRITEAOF</code>。<br>工作方式：Redis会记录最后一次复写时<code>AOF</code>文件大小，如果复写发生在重启时，这个大小是<code>AOF</code>在启动的时使用。<br>将此基本大小与当前大小进行比较。如果当前大小大于指定的百分比，则会触发重写。另外需要为要重写的<code>AOF</code>文件指定最小大小，这对于避免重写<code>AOF</code>文件很有用，即使达到了增加的百分比，但仍然很小。<br>指定零的百分比以禁用自动AOF重写功能。</p>\n<pre><code class=\"sh\">auto-aof-rewrite-percentage 100\nauto-aof-rewrite-min-size 64mb</code></pre>\n<h2 id=\"aof-load-truncated\"><a href=\"#aof-load-truncated\" class=\"headerlink\" title=\"aof-load-truncated\"></a>aof-load-truncated</h2><p>在Redis启动过程中，当<code>AOF</code>数据被加载回内存时，可能会发现<code>AOF</code>文件在末尾被截断。当运行Redis的系统崩溃时可能会发生这种情况，尤其是当安装<code>ext4</code>文件系统时，如果没有<code>data=ordered</code>选项（但是，当Redis本身崩溃或中止，但操作系统仍然正常工作时，则不会发生这种情况）。<br>当发生这种情况时，Redis退出并报错，也可以加载尽可能多的数据（现在是默认值），如果在末尾发现<code>AOF</code>文件被截断，则可以启动它。以下选项控制此行为。<br>如果设置为<code>yes</code>，则会加载一个已截断的<code>AOF</code>文件，并且Redis服务器开始发出日志，通知用户事件。否则，如果该选项设置为<code>no</code>，则服务器将以错误中止并拒绝启动。<br>当选项设置为否时，用户需要在重新启动服务器之前使用<code>redis-check-aof</code>修复<code>aof</code>文件。如果在中间发现AOF文件已损坏，服务器仍将退出并出现错误。此选项仅适用于Redis尝试从AOF文件读取更多数据但未找到足够字节的情况。</p>\n<pre><code class=\"sh\">aof-load-truncated yes</code></pre>\n<h2 id=\"aof-use-rdb-preamble\"><a href=\"#aof-use-rdb-preamble\" class=\"headerlink\" title=\"aof-use-rdb-preamble\"></a>aof-use-rdb-preamble</h2><p>在重写<code>AOF</code>文件时，Redis可以使用AOF文件中的RDB前导码来更快地重写和恢复。启用此选项时，重写的<code>AOF</code>文件由两个不同的节<code>[RDB file][AOF tail]</code>组成。<br>Redis加载时，会识别出<code>AOF</code>文件以<code>REDIS</code>字符串开始并加载前缀<code>RDB</code>文件，然后继续加载<code>AOF</code>尾部。</p>\n<pre><code class=\"sh\">aof-use-rdb-preamble yes</code></pre>\n<h1 id=\"LUA-scripting\"><a href=\"#LUA-scripting\" class=\"headerlink\" title=\"LUA scripting\"></a>LUA scripting</h1><p>Lua脚本的最大执行时间（以毫秒为单位）。<br>如果达到最大执行时间，redis将记录脚本在最大允许时间之后仍在执行中，并开始对出现错误的查询进行回复。<br>当长时间运行的脚本超过最大执行时间时，只有<code>SCRIPT KILL</code>和<code>SHUTDOWN NOSAVE</code>命令可用。第一个可以用于停止尚未调用写入命令的脚本。第二种方法是在脚本已经发出写命令但用户不希望等待脚本自然终止的情况下关闭服务器。<br>将其设置为0或负值，以便无警告地无限执行。</p>\n<pre><code class=\"sh\">lua-time-limit 5000</code></pre>\n<h1 id=\"Redis-cluster\"><a href=\"#Redis-cluster\" class=\"headerlink\" title=\"Redis cluster\"></a>Redis cluster</h1><h2 id=\"cluster-enabled\"><a href=\"#cluster-enabled\" class=\"headerlink\" title=\"cluster-enabled\"></a>cluster-enabled</h2><p>普通的redis实例不能是redis集群的一部分；只有作为集群节点启动的节点才能。为了启动Redis实例作为群集节点，解注释并设置成<code>yes</code>即可。</p>\n<pre><code class=\"sh\"># cluster-enabled yes</code></pre>\n<h2 id=\"cluster-config-file\"><a href=\"#cluster-config-file\" class=\"headerlink\" title=\"cluster-config-file\"></a>cluster-config-file</h2><p>每个集群节点都有一个集群配置文件，此文件不需要手动编辑。它创建和更新都有Redis节点进行。每个Redis集群节点都需要不同的集群配置文件。确保在同一系统中运行的实例没有重叠的群集配置文件名。</p>\n<pre><code class=\"sh\"># cluster-config-file nodes-6379.conf</code></pre>\n<h2 id=\"cluster-node-timeout\"><a href=\"#cluster-node-timeout\" class=\"headerlink\" title=\"cluster-node-timeout\"></a>cluster-node-timeout</h2><p>集群节点超时，单位毫秒。</p>\n<pre><code class=\"sh\"># cluster-node-timeout 15000</code></pre>\n<h2 id=\"cluster-replica-validity-factor\"><a href=\"#cluster-replica-validity-factor\" class=\"headerlink\" title=\"cluster-replica-validity-factor\"></a>cluster-replica-validity-factor</h2><p>如果故障主机的数据看起来太旧，那么它的副本将避免启动故障转移。<br>对于副本来说没法验证数据的是否太旧，所以需要执行两项检查：</p>\n<ul>\n<li>如果有多个副本能够进行故障转移，它们会交换消息，以尽量利用具有最佳复制偏移量的副本（从主处理的更多数据）。副本将尝试按偏移量获取它们的列组，并将与列组成比例的延迟应用于故障转移的开始。</li>\n<li>每个副本都计算与主副本的最后一次交互的时间。这可以是接收到的最后一个ping或命令（如果主服务器仍然处于“已连接”状态），也可以是断开与主服务器的连接后经过的时间（如果复制链接当前已关闭）。如果上一次交互太旧，则复制副本将不会尝试进行故障转移。</li>\n</ul>\n<p>第二点可以由用户进行调整，即，如果副本上次与主服务器交互时间超过时间大于：<code>(node-timeout * replica-validity-factor) + repl-ping-replica-period</code>。<br>因此，例如，如果节点超时为30秒，副本有效性系数为10，并且假设默认的复制副本周期为10秒，那么如果副本无法与主副本进行超过310秒的对话，则不会尝试进行故障转移。<br>较大的副本有效性系数可能允许具有太旧数据的副本故障转移到主服务器，而太小的值可能会阻止群集根本无法选择副本。<br>为了获得最大的可用性，可以将副本有效性系数设置为0，这意味着，无论副本上次与主服务器交互的时间如何，它们都将始终尝试对主服务器进行故障转移。（然而，他们总是尝试应用与他们的偏移等级成比例的延迟）。<br>零是唯一能够保证当所有分区恢复时群集始终能够继续运行的值。</p>\n<pre><code class=\"sh\"># cluster-replica-validity-factor 10</code></pre>\n<h2 id=\"cluster-migration-barrier\"><a href=\"#cluster-migration-barrier\" class=\"headerlink\" title=\"cluster-migration-barrier\"></a>cluster-migration-barrier</h2><p>群集副本能够迁移到孤立的主服务器，即没有工作副本的主服务器。这提高了集群抵御故障的能力，否则，如果一个孤立的主机没有工作的副本，它就不能在发生故障的情况下进行故障转移。<br>只有在至少有一个给定数量的旧主控形状的其他工作副本的情况下，副本才会迁移到孤立的主控形状。这个数字是“移民壁垒”。迁移屏障为1意味着只有在主副本至少有一个其他工作副本的情况下，副本才会迁移，以此类推。它通常反映出集群中每个主服务器所需的副本数量。<br>默认值为1（仅当主副本至少保留一个副本时才迁移副本）。要禁用迁移，只需将其设置为非常大的值。#可以设置值0，但仅对调试和生产中的危险有用。</p>\n<pre><code class=\"sh\"># cluster-migration-barrier 1</code></pre>\n<h2 id=\"cluster-require-full-coverage\"><a href=\"#cluster-require-full-coverage\" class=\"headerlink\" title=\"cluster-require-full-coverage\"></a>cluster-require-full-coverage</h2><p>默认情况下，如果Redis群集节点检测到至少有一个散列槽未被发现（没有可用节点提供服务），则它们将停止接受查询。这样，如果集群部分关闭（例如一系列散列槽不再被覆盖），所有集群最终都将不可用。一旦所有插槽再次被覆盖，它就会自动返回可用状态。<br>然而，有时您希望集群的子集工作，继续接受对仍然被覆盖的密钥空间部分的查询。为此，只需将<code>cluster-require-full-coverage</code>选项设置为no。</p>\n<pre><code class=\"sh\"># cluster-require-full-coverage yes</code></pre>\n<h2 id=\"cluster-replica-no-failover\"><a href=\"#cluster-replica-no-failover\" class=\"headerlink\" title=\"cluster-replica-no-failover\"></a>cluster-replica-no-failover</h2><p>当设置为“是”时，此选项可防止副本在主服务器故障时尝试故障转移其主服务器。但是，如果强制的话，主服务器仍然可以执行手动故障转移。<br>这在不同的情况下很有用，特别是在多个数据中心操作的情况下，如果不升级，我们希望一方永远不会升级；如果发生完全的DC故障。</p>\n<pre><code class=\"sh\"># cluster-replica-no-failover no</code></pre>\n<h1 id=\"CLUSTER-DOCKER-NAT-support\"><a href=\"#CLUSTER-DOCKER-NAT-support\" class=\"headerlink\" title=\"CLUSTER DOCKER/NAT support\"></a>CLUSTER DOCKER/NAT support</h1><p>在某些部署中，Redis群集节点地址发现失败，原因是地址是NAT，或者端口是转发的（典型情况是Docker和其他容器）。<br>为了使redis集群在这样的环境中工作，需要一个静态配置，其中每个节点都知道其公共地址。以下两个选项用于此范围，分别是：</p>\n<ul>\n<li>cluster-announce-ip</li>\n<li>cluster-announce-port</li>\n<li>cluster-announce-bus-port</li>\n</ul>\n<p>每个节点都指示其地址、客户机端口和集群消息总线端口。然后将信息发布到总线数据包的头部，以便其他节点能够正确映射发布信息的节点的地址。<br>如果不使用上述选项，则将使用普通的Redis群集自动检测。<br>请注意，重新映射时，总线端口可能不在客户机端口+10000的固定偏移量处，因此您可以根据重新映射的方式指定任何端口和总线端口。如果未设置总线端口，则通常使用固定偏移量10000。<br>例如：</p>\n<pre><code class=\"sh\"># cluster-announce-ip 10.1.1.5\n# cluster-announce-port 6379\n# cluster-announce-bus-port 6380</code></pre>\n<h1 id=\"slow-log\"><a href=\"#slow-log\" class=\"headerlink\" title=\"slow log\"></a>slow log</h1><p>Redis slow log是一个系统日志查询，它超过了指定的执行时间。执行时间不包括I/O操作，如与客户机交谈、发送回复等，而只包括实际执行命令所需的时间（这是命令执行的唯一阶段，线程被阻塞，无法以平均值服务其他请求时间）。<br>您可以用两个参数配置慢日志：一个参数告诉redis命令要记录的执行时间（以微秒计），另一个参数是慢日志的长度。当记录新命令时，最旧的命令将从记录的命令队列中删除。</p>\n<h2 id=\"slowlog-slower-than\"><a href=\"#slowlog-slower-than\" class=\"headerlink\" title=\"slowlog-slower-than\"></a>slowlog-slower-than</h2><p>以下时间以微秒表示，因此1000000等于一秒。注意，负数会禁用慢速日志，而零值会强制记录每个命令。</p>\n<pre><code class=\"sh\">slowlog-log-slower-than 10000</code></pre>\n<h2 id=\"slowlog-max-len\"><a href=\"#slowlog-max-len\" class=\"headerlink\" title=\"slowlog-max-len\"></a>slowlog-max-len</h2><p>这个长度没有限制。只是要知道它会消耗内存。可以使用<code>SLOWLOG RESET</code>来回收慢速日志使用的内存。</p>\n<pre><code class=\"sh\">slowlog-max-len 128</code></pre>\n<h1 id=\"latency-monitor\"><a href=\"#latency-monitor\" class=\"headerlink\" title=\"latency monitor\"></a>latency monitor</h1><p>Redis延迟监控子系统在运行时对不同的操作进行采样，以便收集与Redis实例的可能延迟源相关的数据。<br>通过<code>LATENCY</code>命令，用户可以使用这些信息来打印图形和获取报告。<br>系统只记录在时间等于或大于通过延迟监视器阈值配置指令指定的毫秒数内执行的操作。当其值设置为零时，延迟监视器将关闭。<br>默认情况下，延迟监控是禁用的，因为如果您没有延迟问题，则通常不需要它，并且收集数据会对性能产生影响，尽管这一影响很小，但可以在大负载下进行测量。如果需要，可以使用命令<code>CONFIG SET latency-monitor-threshold &lt;milliseconds&gt;</code>在运行时轻松启用延迟监控。</p>\n<pre><code class=\"sh\">latency-monitor-threshold 0</code></pre>\n<h1 id=\"event-notification\"><a href=\"#event-notification\" class=\"headerlink\" title=\"event notification\"></a>event notification</h1><p>例如，如果启用了keyspace事件通知，并且客户机对存储在数据库0中的密钥<code>foo</code>执行<code>DEL</code>操作，则将通过pub/sub发布两条消息：</p>\n<pre><code class=\"sh\">PUBLISH __keyspace@0__:foo del\nPUBLISH __keyevent@0__:del foo</code></pre>\n<p>可以在一组类中选择Redis将通知的事件。每个类都由单个字符标识：</p>\n<pre><code class=\"sh\">#  K     Keyspace events, published with __keyspace@&lt;db&gt;__ prefix.\n#  E     Keyevent events, published with __keyevent@&lt;db&gt;__ prefix.\n#  g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...\n#  $     String commands\n#  l     List commands\n#  s     Set commands\n#  h     Hash commands\n#  z     Sorted set commands\n#  x     Expired events (events generated every time a key expires)\n#  e     Evicted events (events generated when a key is evicted for maxmemory)\n#  A     Alias for g$lshzxe, so that the &quot;AKE&quot; string means all the events.</code></pre>\n<p><code>notify-keyspace-events</code>将一个由零个或多个字符组成的字符串作为参数。空字符串表示通知被禁用。</p>\n<p>默认情况下，所有通知都被禁用，因为大多数用户不需要此功能，而且此功能有一些开销。请注意，如果不指定<code>K</code>或<code>E</code>中的至少一个，则不会传递任何事件。</p>\n<pre><code class=\"sh\">notify-keyspace-events &quot;&quot;</code></pre>\n<h1 id=\"advanced-config\"><a href=\"#advanced-config\" class=\"headerlink\" title=\"advanced config\"></a>advanced config</h1>"},{"author":"djaigo","title":"etcdctl命令行交互","img":"https://img-1251474779.cos.ap-beijing.myqcloud.com/etcd.png","date":"2020-03-24T01:39:09.000Z","updated":"2020-03-24T01:39:09.000Z","_content":"\n# 简介\netcd 是一个分布式一致性键值存储，用于共享配置和服务发现，专注于：\n*   简单：良好定义的，面向用户的API (gRPC)\n*   安全：带有可选客户端证书认证的自动 TLS\n*   快速：测试验证，每秒 10000 写入\n*   可靠：使用Raft适当分布\n\netcd是Go编写，并使用 Raft 一致性算法来管理高可用复制日志。\n\n用户通常通过设置或者获取 key 的值来和 etcd 交互。本文描述如何使用 etcdctl 来操作， etcdctl 是一个和 etcd 服务器交互的命令行工具。这里描述的概念也适用于 gRPC API 或者客户端类库 API。\n\n默认，为了向后兼容 etcdctl 使用 v2 API 来和 etcd 服务器通讯。为了让 etcdctl 使用 v3 API 来和etcd通讯，API 版本必须通过环境变量 `ETCDCTL_API` 设置为版本3。\n\n```bash\nexport ETCDCTL_API=3\n```\n\n# 写入key\n\n应用通过写入 key 来储存 key 到 etcd 中。每个存储的 key 被通过 Raft 协议复制到所有 etcd 集群成员来达到一致性和可靠性。\n\n这是设置 key `foo` 的值为 `bar` 的命令:\n\n```\n$ etcdctl put foo bar\nOK\n\n```\n\netcdctl默认操作的etcd是`--endpoints=[127.0.0.1:2379]\t\tgRPC endpoints`，下同。\n\n# 读取 key\n\n应用可以从 etcd 集群中读取 key 的值。查询可以读取单个 key，或者某个范围的 key。\n\n假设 etcd 集群存储有下面的 key：\n\n```\nfoo = bar\nfoo1 = bar1\nfoo2 = bar2\nfoo4 = bar4\nfoo5 = bar5\n```\n\n这是读取 key `foo` 的值的命令：\n\n```\n$ etcdctl get foo\nfoo\nbar\n\n```\n\n这是覆盖从 `foo` to `foo5` 的 key 的命令：\n\n```\n$ etcdctl get foo foo5\nfoo\nbar\nfoo1\nbar1\nfoo2\nbar2\nfoo4\nbar4\n\n```\n\n> 注： 这里是按照左闭右开的区间进行获取。\n\n## 读取 key 过往版本的值\n\n应用可能想读取 key 的被替代的值。例如，应用可能想通过访问 key 的过往版本来回滚到旧的配置。或者，应用可能想通过访问 key 历史记录的多个请求来得到一个覆盖多个 key 上的统一视图。\n\n因为 etcd 集群上键值存储的每个修改都会增加 etcd 集群的全局修订版本（所有的key共有一个版本），应用可以通过提供旧有的 etcd 版本来读取被替代的 key。\n\n假设 etcd 集群已经有下列 key：\n\n```\n$ etcdctl put foo bar         # revision = 2\n$ etcdctl put foo1 bar1       # revision = 3\n$ etcdctl put foo bar_new     # revision = 4\n$ etcdctl put foo1 bar1_new   # revision = 5\n\n```\n\n这里是访问 key 的过往版本的例子：\n\n```\n$ etcdctl get foo foo9 # 访问 key 的最新版本\nfoo\nbar_new\nfoo1\nbar1_new\n\n$ etcdctl get --rev=4 foo foo9 # 访问 key 的修订版本4\nfoo\nbar_new\nfoo1\nbar1\n\n$ etcdctl get --rev=3 foo foo9 # 访问 key 的修订版本3\nfoo\nbar\nfoo1\nbar1\n\n$ etcdctl get --rev=2 foo foo9 # 访问 key 的修订版本2\nfoo\nbar\n\n$ etcdctl get --rev=1 foo foo9 # 访问 key 的修订版本1\n\n```\n\n# 删除 key\n\n应用可以从 etcd 集群中删除一个 key 或者特定范围的 key。\n\n下面是删除 key `foo` 的命令：\n\n```\n$ etcdctl del foo\n1 # 删除了一个key\n\n```\n\n这是删除从 `foo` to `foo9` 范围的 key 的命令：\n\n```\n$ etcdctl del foo foo9\n5 # 删除了5个key\n\n```\n\n# 前缀匹配\n## 获取指定前缀所有key\n通过设置`--prefix`调用对象是拥有指定前缀的key，设置`--keys-only`只显示key的名字，设置`--from-key`获取所有的键值。\n```bash\n$ etcdctl --prefix --keys-only=true get foo\nfoo\n\nfoo1\n\nfoo2\n\nfoo4\n\nfoo5\n\n```\n\n如果把前缀变成空字符就是获取当前etcd中所有的key。\n```bash\n$ etcdctl --prefix --keys-only=true get \"\"\nfoo\n\nfoo1\n\nfoo2\n\nfoo4\n\nfoo5\n```\n\n`--from-key`和`--prefix`不能同时使用。\n```bash\n$ etcdctl get \"\" --from-key --prefix\nError: `--prefix` and `--from-key` cannot be set at the same time, choose one\n```\n\n且`--from-key`必须写在get之后，不然会报错找不到flag。\n```\n$ etcdctl --from-key get \"\"\nError: unknown flag: --from-key\n```\n\n\n# 观察 key 的变化\n\n应用可以观察一个 key 或者特定范围内的 key 来监控任何更新。\n\n这是在 key `foo` 上进行观察的命令：\n\n```\n$ etcdctl watch foo\nfoo\nbar\n```\n\n```sh\n$ etcdctl put foo bar\nOK\n```\n这是观察从 `foo` to `foo9` 范围key的命令：\n```bash\n$ etcdctl watch foo foo9\n# 在另外一个终端: etcdctl put foo bar\nfoo\nbar\n# 在另外一个终端: etcdctl put foo1 bar1\nfoo1\nbar1\n\n```\n\n## 观察 key 的历史改动\n\n应用可能想观察 etcd 中 key 的历史改动。例如，应用想接收到某个 key 的所有修改。如果应用一直连接到etcd，那么 `watch` 就足够好了。但是，如果应用或者 etcd 出错，改动可能发生在出错期间，这样应用就没能实时接收到这个更新。为了保证更新被接收，应用必须能够观察到 key 的历史变动。为了做到这点，应用可以在观察时指定一个历史修订版本，就像读取 key 的过往版本一样。\n\n假设我们完成了下列操作序列：\n\n```\netcdctl put foo bar         # revision = 2\netcdctl put foo1 bar1       # revision = 3\netcdctl put foo bar_new     # revision = 4\netcdctl put foo1 bar1_new   # revision = 5\n\n```\n\n这是观察历史改动的例子：\n\n```\n# 从修订版本 2 开始观察key `foo` 的改动\n$ etcdctl watch --rev=2 foo\nPUT\nfoo\nbar\nPUT\nfoo\nbar_new\n\n# 从修订版本 3 开始观察key `foo` 的改动\n$ etcdctl watch --rev=3 foo\nPUT\nfoo\nbar_new\n\n```\n\n# 压缩修订版本\n\n如我们提到的，etcd 保存修订版本以便应用可以读取 key 的过往版本。但是，为了避免积累无限数量的历史数据，压缩过往的修订版本就变得很重要。压缩之后，etcd 删除历史修订版本，释放资源来提供未来使用。所有修订版本在压缩修订版本之前的被替代的数据将不可访问。\n\n这是压缩修订版本的命令：\n\n```\n$ etcdctl compact 5\ncompacted revision 5\n\n# 在压缩修订版本之前的任何修订版本都不可访问\n$ etcdctl get --rev=4 foo\n{\"level\":\"warn\",\"ts\":\"2020-03-24T10:25:00.189+0800\",\"caller\":\"clientv3/retry_interceptor.go:62\",\"msg\":\"retrying of unary invoker failed\",\"target\":\"endpoint://client-d0dbfe68-878e-4b3f-8bc9-8c1c8fad1a10/127.0.0.1:2379\",\"attempt\":0,\"error\":\"rpc error: code = OutOfRange desc = etcdserver: mvcc: required revision has been compacted\"}\n\n```\n\n# 租约\n## 授予租约\n\n应用可以为 etcd 集群里面的 key 授予租约。当 key 被附加到租约时，它的生存时间被绑定到租约的生存时间，而租约的生存时间相应的被 `time-to-live` (TTL)管理。租约的实际 TTL 值是不低于最小 TTL，由 etcd 集群选择。一旦租约的 TTL 到期，租约就过期并且所有附带的 key 都将被删除。\n\n这是授予租约的命令：\n\n```\n# 授予租约，TTL为100秒\n$ etcdctl lease grant 100\nlease 00d4710a3e7c7539 granted with TTL(100s)\n\n# 附加key foo到租约32695410dcc0ca06\n$ etcdctl put --lease=00d4710a3e7c7539 foo bar\nOK\n\n```\n\n## 撤销租约\n\n应用通过租约 id 可以撤销租约。撤销租约将删除所有它附带的 key。\n\n假设我们完成了下列的操作：\n\n```\n$ etcdctl lease grant 10\nlease 32695410dcc0ca06 granted with TTL(10s)\n$ etcdctl put --lease=32695410dcc0ca06 foo bar\nOK\n\n```\n\n这是撤销同一个租约的命令：\n\n```\n$ etcdctl lease revoke 32695410dcc0ca06\nlease 32695410dcc0ca06 revoked\n\n$ etcdctl get foo\n# 空应答，因为租约撤销导致foo被删除\n\n```\n\n## 维持租约\n\n应用可以通过刷新 key 的 TTL 来维持租约，以便租约不过期。\n\n假设我们完成了下列操作：\n\n```\n$ etcdctl lease grant 10\nlease 32695410dcc0ca06 granted with TTL(10s)\n\n```\n\n这是维持同一个租约的命令：\n\n```\n$ etcdctl lease keep-alive 32695410dcc0ca0\nlease 32695410dcc0ca0 keepalived with TTL(100)\nlease 32695410dcc0ca0 keepalived with TTL(100)\nlease 32695410dcc0ca0 keepalived with TTL(100)\n...\n\n```\n\n> 注： 上面的这个命令中，etcdctl 不是单次续约，而是 etcdctl 会一直不断的发送请求来维持这个租约。\n\n [](https://skyao.gitbooks.io/learning-etcd3/content/documentation/dev-guide/local_cluster.html)\n\n\n# 参考文献\n1. [etcd3介绍](https://skyao.gitbooks.io/learning-etcd3/content/introduction/)\n2. [和etcd交互](https://skyao.gitbooks.io/learning-etcd3/content/documentation/dev-guide/interacting_v3.html)\n","source":"_posts/etcdctl命令行交互.md","raw":"---\nauthor: djaigo\ntitle: etcdctl命令行交互\nimg: 'https://img-1251474779.cos.ap-beijing.myqcloud.com/etcd.png'\ncategories:\n  - etcd\ntags:\n  - etcd\n  - etcdctl\n  - cmd\ndate: 2020-03-24 09:39:09\nupdated: 2020-03-24 09:39:09\n---\n\n# 简介\netcd 是一个分布式一致性键值存储，用于共享配置和服务发现，专注于：\n*   简单：良好定义的，面向用户的API (gRPC)\n*   安全：带有可选客户端证书认证的自动 TLS\n*   快速：测试验证，每秒 10000 写入\n*   可靠：使用Raft适当分布\n\netcd是Go编写，并使用 Raft 一致性算法来管理高可用复制日志。\n\n用户通常通过设置或者获取 key 的值来和 etcd 交互。本文描述如何使用 etcdctl 来操作， etcdctl 是一个和 etcd 服务器交互的命令行工具。这里描述的概念也适用于 gRPC API 或者客户端类库 API。\n\n默认，为了向后兼容 etcdctl 使用 v2 API 来和 etcd 服务器通讯。为了让 etcdctl 使用 v3 API 来和etcd通讯，API 版本必须通过环境变量 `ETCDCTL_API` 设置为版本3。\n\n```bash\nexport ETCDCTL_API=3\n```\n\n# 写入key\n\n应用通过写入 key 来储存 key 到 etcd 中。每个存储的 key 被通过 Raft 协议复制到所有 etcd 集群成员来达到一致性和可靠性。\n\n这是设置 key `foo` 的值为 `bar` 的命令:\n\n```\n$ etcdctl put foo bar\nOK\n\n```\n\netcdctl默认操作的etcd是`--endpoints=[127.0.0.1:2379]\t\tgRPC endpoints`，下同。\n\n# 读取 key\n\n应用可以从 etcd 集群中读取 key 的值。查询可以读取单个 key，或者某个范围的 key。\n\n假设 etcd 集群存储有下面的 key：\n\n```\nfoo = bar\nfoo1 = bar1\nfoo2 = bar2\nfoo4 = bar4\nfoo5 = bar5\n```\n\n这是读取 key `foo` 的值的命令：\n\n```\n$ etcdctl get foo\nfoo\nbar\n\n```\n\n这是覆盖从 `foo` to `foo5` 的 key 的命令：\n\n```\n$ etcdctl get foo foo5\nfoo\nbar\nfoo1\nbar1\nfoo2\nbar2\nfoo4\nbar4\n\n```\n\n> 注： 这里是按照左闭右开的区间进行获取。\n\n## 读取 key 过往版本的值\n\n应用可能想读取 key 的被替代的值。例如，应用可能想通过访问 key 的过往版本来回滚到旧的配置。或者，应用可能想通过访问 key 历史记录的多个请求来得到一个覆盖多个 key 上的统一视图。\n\n因为 etcd 集群上键值存储的每个修改都会增加 etcd 集群的全局修订版本（所有的key共有一个版本），应用可以通过提供旧有的 etcd 版本来读取被替代的 key。\n\n假设 etcd 集群已经有下列 key：\n\n```\n$ etcdctl put foo bar         # revision = 2\n$ etcdctl put foo1 bar1       # revision = 3\n$ etcdctl put foo bar_new     # revision = 4\n$ etcdctl put foo1 bar1_new   # revision = 5\n\n```\n\n这里是访问 key 的过往版本的例子：\n\n```\n$ etcdctl get foo foo9 # 访问 key 的最新版本\nfoo\nbar_new\nfoo1\nbar1_new\n\n$ etcdctl get --rev=4 foo foo9 # 访问 key 的修订版本4\nfoo\nbar_new\nfoo1\nbar1\n\n$ etcdctl get --rev=3 foo foo9 # 访问 key 的修订版本3\nfoo\nbar\nfoo1\nbar1\n\n$ etcdctl get --rev=2 foo foo9 # 访问 key 的修订版本2\nfoo\nbar\n\n$ etcdctl get --rev=1 foo foo9 # 访问 key 的修订版本1\n\n```\n\n# 删除 key\n\n应用可以从 etcd 集群中删除一个 key 或者特定范围的 key。\n\n下面是删除 key `foo` 的命令：\n\n```\n$ etcdctl del foo\n1 # 删除了一个key\n\n```\n\n这是删除从 `foo` to `foo9` 范围的 key 的命令：\n\n```\n$ etcdctl del foo foo9\n5 # 删除了5个key\n\n```\n\n# 前缀匹配\n## 获取指定前缀所有key\n通过设置`--prefix`调用对象是拥有指定前缀的key，设置`--keys-only`只显示key的名字，设置`--from-key`获取所有的键值。\n```bash\n$ etcdctl --prefix --keys-only=true get foo\nfoo\n\nfoo1\n\nfoo2\n\nfoo4\n\nfoo5\n\n```\n\n如果把前缀变成空字符就是获取当前etcd中所有的key。\n```bash\n$ etcdctl --prefix --keys-only=true get \"\"\nfoo\n\nfoo1\n\nfoo2\n\nfoo4\n\nfoo5\n```\n\n`--from-key`和`--prefix`不能同时使用。\n```bash\n$ etcdctl get \"\" --from-key --prefix\nError: `--prefix` and `--from-key` cannot be set at the same time, choose one\n```\n\n且`--from-key`必须写在get之后，不然会报错找不到flag。\n```\n$ etcdctl --from-key get \"\"\nError: unknown flag: --from-key\n```\n\n\n# 观察 key 的变化\n\n应用可以观察一个 key 或者特定范围内的 key 来监控任何更新。\n\n这是在 key `foo` 上进行观察的命令：\n\n```\n$ etcdctl watch foo\nfoo\nbar\n```\n\n```sh\n$ etcdctl put foo bar\nOK\n```\n这是观察从 `foo` to `foo9` 范围key的命令：\n```bash\n$ etcdctl watch foo foo9\n# 在另外一个终端: etcdctl put foo bar\nfoo\nbar\n# 在另外一个终端: etcdctl put foo1 bar1\nfoo1\nbar1\n\n```\n\n## 观察 key 的历史改动\n\n应用可能想观察 etcd 中 key 的历史改动。例如，应用想接收到某个 key 的所有修改。如果应用一直连接到etcd，那么 `watch` 就足够好了。但是，如果应用或者 etcd 出错，改动可能发生在出错期间，这样应用就没能实时接收到这个更新。为了保证更新被接收，应用必须能够观察到 key 的历史变动。为了做到这点，应用可以在观察时指定一个历史修订版本，就像读取 key 的过往版本一样。\n\n假设我们完成了下列操作序列：\n\n```\netcdctl put foo bar         # revision = 2\netcdctl put foo1 bar1       # revision = 3\netcdctl put foo bar_new     # revision = 4\netcdctl put foo1 bar1_new   # revision = 5\n\n```\n\n这是观察历史改动的例子：\n\n```\n# 从修订版本 2 开始观察key `foo` 的改动\n$ etcdctl watch --rev=2 foo\nPUT\nfoo\nbar\nPUT\nfoo\nbar_new\n\n# 从修订版本 3 开始观察key `foo` 的改动\n$ etcdctl watch --rev=3 foo\nPUT\nfoo\nbar_new\n\n```\n\n# 压缩修订版本\n\n如我们提到的，etcd 保存修订版本以便应用可以读取 key 的过往版本。但是，为了避免积累无限数量的历史数据，压缩过往的修订版本就变得很重要。压缩之后，etcd 删除历史修订版本，释放资源来提供未来使用。所有修订版本在压缩修订版本之前的被替代的数据将不可访问。\n\n这是压缩修订版本的命令：\n\n```\n$ etcdctl compact 5\ncompacted revision 5\n\n# 在压缩修订版本之前的任何修订版本都不可访问\n$ etcdctl get --rev=4 foo\n{\"level\":\"warn\",\"ts\":\"2020-03-24T10:25:00.189+0800\",\"caller\":\"clientv3/retry_interceptor.go:62\",\"msg\":\"retrying of unary invoker failed\",\"target\":\"endpoint://client-d0dbfe68-878e-4b3f-8bc9-8c1c8fad1a10/127.0.0.1:2379\",\"attempt\":0,\"error\":\"rpc error: code = OutOfRange desc = etcdserver: mvcc: required revision has been compacted\"}\n\n```\n\n# 租约\n## 授予租约\n\n应用可以为 etcd 集群里面的 key 授予租约。当 key 被附加到租约时，它的生存时间被绑定到租约的生存时间，而租约的生存时间相应的被 `time-to-live` (TTL)管理。租约的实际 TTL 值是不低于最小 TTL，由 etcd 集群选择。一旦租约的 TTL 到期，租约就过期并且所有附带的 key 都将被删除。\n\n这是授予租约的命令：\n\n```\n# 授予租约，TTL为100秒\n$ etcdctl lease grant 100\nlease 00d4710a3e7c7539 granted with TTL(100s)\n\n# 附加key foo到租约32695410dcc0ca06\n$ etcdctl put --lease=00d4710a3e7c7539 foo bar\nOK\n\n```\n\n## 撤销租约\n\n应用通过租约 id 可以撤销租约。撤销租约将删除所有它附带的 key。\n\n假设我们完成了下列的操作：\n\n```\n$ etcdctl lease grant 10\nlease 32695410dcc0ca06 granted with TTL(10s)\n$ etcdctl put --lease=32695410dcc0ca06 foo bar\nOK\n\n```\n\n这是撤销同一个租约的命令：\n\n```\n$ etcdctl lease revoke 32695410dcc0ca06\nlease 32695410dcc0ca06 revoked\n\n$ etcdctl get foo\n# 空应答，因为租约撤销导致foo被删除\n\n```\n\n## 维持租约\n\n应用可以通过刷新 key 的 TTL 来维持租约，以便租约不过期。\n\n假设我们完成了下列操作：\n\n```\n$ etcdctl lease grant 10\nlease 32695410dcc0ca06 granted with TTL(10s)\n\n```\n\n这是维持同一个租约的命令：\n\n```\n$ etcdctl lease keep-alive 32695410dcc0ca0\nlease 32695410dcc0ca0 keepalived with TTL(100)\nlease 32695410dcc0ca0 keepalived with TTL(100)\nlease 32695410dcc0ca0 keepalived with TTL(100)\n...\n\n```\n\n> 注： 上面的这个命令中，etcdctl 不是单次续约，而是 etcdctl 会一直不断的发送请求来维持这个租约。\n\n [](https://skyao.gitbooks.io/learning-etcd3/content/documentation/dev-guide/local_cluster.html)\n\n\n# 参考文献\n1. [etcd3介绍](https://skyao.gitbooks.io/learning-etcd3/content/introduction/)\n2. [和etcd交互](https://skyao.gitbooks.io/learning-etcd3/content/documentation/dev-guide/interacting_v3.html)\n","slug":"etcdctl命令行交互","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckh351du7000g19z475yrckom","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>etcd 是一个分布式一致性键值存储，用于共享配置和服务发现，专注于：</p>\n<ul>\n<li>简单：良好定义的，面向用户的API (gRPC)</li>\n<li>安全：带有可选客户端证书认证的自动 TLS</li>\n<li>快速：测试验证，每秒 10000 写入</li>\n<li>可靠：使用Raft适当分布</li>\n</ul>\n<p>etcd是Go编写，并使用 Raft 一致性算法来管理高可用复制日志。</p>\n<p>用户通常通过设置或者获取 key 的值来和 etcd 交互。本文描述如何使用 etcdctl 来操作， etcdctl 是一个和 etcd 服务器交互的命令行工具。这里描述的概念也适用于 gRPC API 或者客户端类库 API。</p>\n<p>默认，为了向后兼容 etcdctl 使用 v2 API 来和 etcd 服务器通讯。为了让 etcdctl 使用 v3 API 来和etcd通讯，API 版本必须通过环境变量 <code>ETCDCTL_API</code> 设置为版本3。</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token function\">export</span> ETCDCTL_API<span class=\"token operator\">=</span>3</code></pre>\n<h1 id=\"写入key\"><a href=\"#写入key\" class=\"headerlink\" title=\"写入key\"></a>写入key</h1><p>应用通过写入 key 来储存 key 到 etcd 中。每个存储的 key 被通过 Raft 协议复制到所有 etcd 集群成员来达到一致性和可靠性。</p>\n<p>这是设置 key <code>foo</code> 的值为 <code>bar</code> 的命令:</p>\n<pre><code>$ etcdctl put foo bar\nOK\n</code></pre><p>etcdctl默认操作的etcd是<code>--endpoints=[127.0.0.1:2379]        gRPC endpoints</code>，下同。</p>\n<h1 id=\"读取-key\"><a href=\"#读取-key\" class=\"headerlink\" title=\"读取 key\"></a>读取 key</h1><p>应用可以从 etcd 集群中读取 key 的值。查询可以读取单个 key，或者某个范围的 key。</p>\n<p>假设 etcd 集群存储有下面的 key：</p>\n<pre><code>foo = bar\nfoo1 = bar1\nfoo2 = bar2\nfoo4 = bar4\nfoo5 = bar5</code></pre><p>这是读取 key <code>foo</code> 的值的命令：</p>\n<pre><code>$ etcdctl get foo\nfoo\nbar\n</code></pre><p>这是覆盖从 <code>foo</code> to <code>foo5</code> 的 key 的命令：</p>\n<pre><code>$ etcdctl get foo foo5\nfoo\nbar\nfoo1\nbar1\nfoo2\nbar2\nfoo4\nbar4\n</code></pre><blockquote>\n<p>注： 这里是按照左闭右开的区间进行获取。</p>\n</blockquote>\n<h2 id=\"读取-key-过往版本的值\"><a href=\"#读取-key-过往版本的值\" class=\"headerlink\" title=\"读取 key 过往版本的值\"></a>读取 key 过往版本的值</h2><p>应用可能想读取 key 的被替代的值。例如，应用可能想通过访问 key 的过往版本来回滚到旧的配置。或者，应用可能想通过访问 key 历史记录的多个请求来得到一个覆盖多个 key 上的统一视图。</p>\n<p>因为 etcd 集群上键值存储的每个修改都会增加 etcd 集群的全局修订版本（所有的key共有一个版本），应用可以通过提供旧有的 etcd 版本来读取被替代的 key。</p>\n<p>假设 etcd 集群已经有下列 key：</p>\n<pre><code>$ etcdctl put foo bar         # revision = 2\n$ etcdctl put foo1 bar1       # revision = 3\n$ etcdctl put foo bar_new     # revision = 4\n$ etcdctl put foo1 bar1_new   # revision = 5\n</code></pre><p>这里是访问 key 的过往版本的例子：</p>\n<pre><code>$ etcdctl get foo foo9 # 访问 key 的最新版本\nfoo\nbar_new\nfoo1\nbar1_new\n\n$ etcdctl get --rev=4 foo foo9 # 访问 key 的修订版本4\nfoo\nbar_new\nfoo1\nbar1\n\n$ etcdctl get --rev=3 foo foo9 # 访问 key 的修订版本3\nfoo\nbar\nfoo1\nbar1\n\n$ etcdctl get --rev=2 foo foo9 # 访问 key 的修订版本2\nfoo\nbar\n\n$ etcdctl get --rev=1 foo foo9 # 访问 key 的修订版本1\n</code></pre><h1 id=\"删除-key\"><a href=\"#删除-key\" class=\"headerlink\" title=\"删除 key\"></a>删除 key</h1><p>应用可以从 etcd 集群中删除一个 key 或者特定范围的 key。</p>\n<p>下面是删除 key <code>foo</code> 的命令：</p>\n<pre><code>$ etcdctl del foo\n1 # 删除了一个key\n</code></pre><p>这是删除从 <code>foo</code> to <code>foo9</code> 范围的 key 的命令：</p>\n<pre><code>$ etcdctl del foo foo9\n5 # 删除了5个key\n</code></pre><h1 id=\"前缀匹配\"><a href=\"#前缀匹配\" class=\"headerlink\" title=\"前缀匹配\"></a>前缀匹配</h1><h2 id=\"获取指定前缀所有key\"><a href=\"#获取指定前缀所有key\" class=\"headerlink\" title=\"获取指定前缀所有key\"></a>获取指定前缀所有key</h2><p>通过设置<code>--prefix</code>调用对象是拥有指定前缀的key，设置<code>--keys-only</code>只显示key的名字，设置<code>--from-key</code>获取所有的键值。</p>\n<pre class=\" language-bash\"><code class=\"language-bash\">$ etcdctl --prefix --keys-only<span class=\"token operator\">=</span>true get foo\nfoo\n\nfoo1\n\nfoo2\n\nfoo4\n\nfoo5\n</code></pre>\n<p>如果把前缀变成空字符就是获取当前etcd中所有的key。</p>\n<pre class=\" language-bash\"><code class=\"language-bash\">$ etcdctl --prefix --keys-only<span class=\"token operator\">=</span>true get <span class=\"token string\">\"\"</span>\nfoo\n\nfoo1\n\nfoo2\n\nfoo4\n\nfoo5</code></pre>\n<p><code>--from-key</code>和<code>--prefix</code>不能同时使用。</p>\n<pre class=\" language-bash\"><code class=\"language-bash\">$ etcdctl get <span class=\"token string\">\"\"</span> --from-key --prefix\nError: <span class=\"token variable\"><span class=\"token variable\">`</span>--prefix<span class=\"token variable\">`</span></span> and <span class=\"token variable\"><span class=\"token variable\">`</span>--from-key<span class=\"token variable\">`</span></span> cannot be <span class=\"token keyword\">set</span> at the same time, choose one</code></pre>\n<p>且<code>--from-key</code>必须写在get之后，不然会报错找不到flag。</p>\n<pre><code>$ etcdctl --from-key get \"\"\nError: unknown flag: --from-key</code></pre><h1 id=\"观察-key-的变化\"><a href=\"#观察-key-的变化\" class=\"headerlink\" title=\"观察 key 的变化\"></a>观察 key 的变化</h1><p>应用可以观察一个 key 或者特定范围内的 key 来监控任何更新。</p>\n<p>这是在 key <code>foo</code> 上进行观察的命令：</p>\n<pre><code>$ etcdctl watch foo\nfoo\nbar</code></pre><pre class=\" language-sh\"><code class=\"language-sh\">$ etcdctl put foo bar\nOK</code></pre>\n<p>这是观察从 <code>foo</code> to <code>foo9</code> 范围key的命令：</p>\n<pre class=\" language-bash\"><code class=\"language-bash\">$ etcdctl <span class=\"token function\">watch</span> foo foo9\n<span class=\"token comment\" spellcheck=\"true\"># 在另外一个终端: etcdctl put foo bar</span>\nfoo\nbar\n<span class=\"token comment\" spellcheck=\"true\"># 在另外一个终端: etcdctl put foo1 bar1</span>\nfoo1\nbar1\n</code></pre>\n<h2 id=\"观察-key-的历史改动\"><a href=\"#观察-key-的历史改动\" class=\"headerlink\" title=\"观察 key 的历史改动\"></a>观察 key 的历史改动</h2><p>应用可能想观察 etcd 中 key 的历史改动。例如，应用想接收到某个 key 的所有修改。如果应用一直连接到etcd，那么 <code>watch</code> 就足够好了。但是，如果应用或者 etcd 出错，改动可能发生在出错期间，这样应用就没能实时接收到这个更新。为了保证更新被接收，应用必须能够观察到 key 的历史变动。为了做到这点，应用可以在观察时指定一个历史修订版本，就像读取 key 的过往版本一样。</p>\n<p>假设我们完成了下列操作序列：</p>\n<pre><code>etcdctl put foo bar         # revision = 2\netcdctl put foo1 bar1       # revision = 3\netcdctl put foo bar_new     # revision = 4\netcdctl put foo1 bar1_new   # revision = 5\n</code></pre><p>这是观察历史改动的例子：</p>\n<pre><code># 从修订版本 2 开始观察key `foo` 的改动\n$ etcdctl watch --rev=2 foo\nPUT\nfoo\nbar\nPUT\nfoo\nbar_new\n\n# 从修订版本 3 开始观察key `foo` 的改动\n$ etcdctl watch --rev=3 foo\nPUT\nfoo\nbar_new\n</code></pre><h1 id=\"压缩修订版本\"><a href=\"#压缩修订版本\" class=\"headerlink\" title=\"压缩修订版本\"></a>压缩修订版本</h1><p>如我们提到的，etcd 保存修订版本以便应用可以读取 key 的过往版本。但是，为了避免积累无限数量的历史数据，压缩过往的修订版本就变得很重要。压缩之后，etcd 删除历史修订版本，释放资源来提供未来使用。所有修订版本在压缩修订版本之前的被替代的数据将不可访问。</p>\n<p>这是压缩修订版本的命令：</p>\n<pre><code>$ etcdctl compact 5\ncompacted revision 5\n\n# 在压缩修订版本之前的任何修订版本都不可访问\n$ etcdctl get --rev=4 foo\n{\"level\":\"warn\",\"ts\":\"2020-03-24T10:25:00.189+0800\",\"caller\":\"clientv3/retry_interceptor.go:62\",\"msg\":\"retrying of unary invoker failed\",\"target\":\"endpoint://client-d0dbfe68-878e-4b3f-8bc9-8c1c8fad1a10/127.0.0.1:2379\",\"attempt\":0,\"error\":\"rpc error: code = OutOfRange desc = etcdserver: mvcc: required revision has been compacted\"}\n</code></pre><h1 id=\"租约\"><a href=\"#租约\" class=\"headerlink\" title=\"租约\"></a>租约</h1><h2 id=\"授予租约\"><a href=\"#授予租约\" class=\"headerlink\" title=\"授予租约\"></a>授予租约</h2><p>应用可以为 etcd 集群里面的 key 授予租约。当 key 被附加到租约时，它的生存时间被绑定到租约的生存时间，而租约的生存时间相应的被 <code>time-to-live</code> (TTL)管理。租约的实际 TTL 值是不低于最小 TTL，由 etcd 集群选择。一旦租约的 TTL 到期，租约就过期并且所有附带的 key 都将被删除。</p>\n<p>这是授予租约的命令：</p>\n<pre><code># 授予租约，TTL为100秒\n$ etcdctl lease grant 100\nlease 00d4710a3e7c7539 granted with TTL(100s)\n\n# 附加key foo到租约32695410dcc0ca06\n$ etcdctl put --lease=00d4710a3e7c7539 foo bar\nOK\n</code></pre><h2 id=\"撤销租约\"><a href=\"#撤销租约\" class=\"headerlink\" title=\"撤销租约\"></a>撤销租约</h2><p>应用通过租约 id 可以撤销租约。撤销租约将删除所有它附带的 key。</p>\n<p>假设我们完成了下列的操作：</p>\n<pre><code>$ etcdctl lease grant 10\nlease 32695410dcc0ca06 granted with TTL(10s)\n$ etcdctl put --lease=32695410dcc0ca06 foo bar\nOK\n</code></pre><p>这是撤销同一个租约的命令：</p>\n<pre><code>$ etcdctl lease revoke 32695410dcc0ca06\nlease 32695410dcc0ca06 revoked\n\n$ etcdctl get foo\n# 空应答，因为租约撤销导致foo被删除\n</code></pre><h2 id=\"维持租约\"><a href=\"#维持租约\" class=\"headerlink\" title=\"维持租约\"></a>维持租约</h2><p>应用可以通过刷新 key 的 TTL 来维持租约，以便租约不过期。</p>\n<p>假设我们完成了下列操作：</p>\n<pre><code>$ etcdctl lease grant 10\nlease 32695410dcc0ca06 granted with TTL(10s)\n</code></pre><p>这是维持同一个租约的命令：</p>\n<pre><code>$ etcdctl lease keep-alive 32695410dcc0ca0\nlease 32695410dcc0ca0 keepalived with TTL(100)\nlease 32695410dcc0ca0 keepalived with TTL(100)\nlease 32695410dcc0ca0 keepalived with TTL(100)\n...\n</code></pre><blockquote>\n<p>注： 上面的这个命令中，etcdctl 不是单次续约，而是 etcdctl 会一直不断的发送请求来维持这个租约。</p>\n</blockquote>\n<p> <a href=\"https://skyao.gitbooks.io/learning-etcd3/content/documentation/dev-guide/local_cluster.html\" target=\"_blank\" rel=\"noopener\"></a></p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ol>\n<li><a href=\"https://skyao.gitbooks.io/learning-etcd3/content/introduction/\" target=\"_blank\" rel=\"noopener\">etcd3介绍</a></li>\n<li><a href=\"https://skyao.gitbooks.io/learning-etcd3/content/documentation/dev-guide/interacting_v3.html\" target=\"_blank\" rel=\"noopener\">和etcd交互</a></li>\n</ol>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"friends":[{"avatar":"https://img-1251474779.cos.ap-beijing.myqcloud.com/icon.png","name":"djaigo","introduction":"好好学习，天天向上","url":"/","title":"前去学习"},{"avatar":"https://awps-assets.meituan.net/mit/blog/v20190629/asset/icon/favicon.ico?v=Whistle&t=20181017-1r","name":"美团技术团队","introduction":"一行代码，亿万生活。","url":"https://tech.meituan.com/","title":"点个外卖-->"},{"avatar":"","name":"鸟窝","introduction":"rpcx作者","url":"https://colobu.com/","title":"进个鸟窝-->"},{"avatar":"https://d1j8pt39hxlh3d.cloudfront.net/emoji/emojione/5.0/png/unicode/32/1f92a.png","name":"labuladong的算法小抄","introduction":"算法大神","url":"https://labuladong.gitbook.io/algo/","title":"学个算法-->"}]}},"excerpt":"","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>etcd 是一个分布式一致性键值存储，用于共享配置和服务发现，专注于：</p>\n<ul>\n<li>简单：良好定义的，面向用户的API (gRPC)</li>\n<li>安全：带有可选客户端证书认证的自动 TLS</li>\n<li>快速：测试验证，每秒 10000 写入</li>\n<li>可靠：使用Raft适当分布</li>\n</ul>\n<p>etcd是Go编写，并使用 Raft 一致性算法来管理高可用复制日志。</p>\n<p>用户通常通过设置或者获取 key 的值来和 etcd 交互。本文描述如何使用 etcdctl 来操作， etcdctl 是一个和 etcd 服务器交互的命令行工具。这里描述的概念也适用于 gRPC API 或者客户端类库 API。</p>\n<p>默认，为了向后兼容 etcdctl 使用 v2 API 来和 etcd 服务器通讯。为了让 etcdctl 使用 v3 API 来和etcd通讯，API 版本必须通过环境变量 <code>ETCDCTL_API</code> 设置为版本3。</p>\n<pre><code class=\"bash\">export ETCDCTL_API=3</code></pre>\n<h1 id=\"写入key\"><a href=\"#写入key\" class=\"headerlink\" title=\"写入key\"></a>写入key</h1><p>应用通过写入 key 来储存 key 到 etcd 中。每个存储的 key 被通过 Raft 协议复制到所有 etcd 集群成员来达到一致性和可靠性。</p>\n<p>这是设置 key <code>foo</code> 的值为 <code>bar</code> 的命令:</p>\n<pre><code>$ etcdctl put foo bar\nOK\n</code></pre><p>etcdctl默认操作的etcd是<code>--endpoints=[127.0.0.1:2379]        gRPC endpoints</code>，下同。</p>\n<h1 id=\"读取-key\"><a href=\"#读取-key\" class=\"headerlink\" title=\"读取 key\"></a>读取 key</h1><p>应用可以从 etcd 集群中读取 key 的值。查询可以读取单个 key，或者某个范围的 key。</p>\n<p>假设 etcd 集群存储有下面的 key：</p>\n<pre><code>foo = bar\nfoo1 = bar1\nfoo2 = bar2\nfoo4 = bar4\nfoo5 = bar5</code></pre><p>这是读取 key <code>foo</code> 的值的命令：</p>\n<pre><code>$ etcdctl get foo\nfoo\nbar\n</code></pre><p>这是覆盖从 <code>foo</code> to <code>foo5</code> 的 key 的命令：</p>\n<pre><code>$ etcdctl get foo foo5\nfoo\nbar\nfoo1\nbar1\nfoo2\nbar2\nfoo4\nbar4\n</code></pre><blockquote>\n<p>注： 这里是按照左闭右开的区间进行获取。</p>\n</blockquote>\n<h2 id=\"读取-key-过往版本的值\"><a href=\"#读取-key-过往版本的值\" class=\"headerlink\" title=\"读取 key 过往版本的值\"></a>读取 key 过往版本的值</h2><p>应用可能想读取 key 的被替代的值。例如，应用可能想通过访问 key 的过往版本来回滚到旧的配置。或者，应用可能想通过访问 key 历史记录的多个请求来得到一个覆盖多个 key 上的统一视图。</p>\n<p>因为 etcd 集群上键值存储的每个修改都会增加 etcd 集群的全局修订版本（所有的key共有一个版本），应用可以通过提供旧有的 etcd 版本来读取被替代的 key。</p>\n<p>假设 etcd 集群已经有下列 key：</p>\n<pre><code>$ etcdctl put foo bar         # revision = 2\n$ etcdctl put foo1 bar1       # revision = 3\n$ etcdctl put foo bar_new     # revision = 4\n$ etcdctl put foo1 bar1_new   # revision = 5\n</code></pre><p>这里是访问 key 的过往版本的例子：</p>\n<pre><code>$ etcdctl get foo foo9 # 访问 key 的最新版本\nfoo\nbar_new\nfoo1\nbar1_new\n\n$ etcdctl get --rev=4 foo foo9 # 访问 key 的修订版本4\nfoo\nbar_new\nfoo1\nbar1\n\n$ etcdctl get --rev=3 foo foo9 # 访问 key 的修订版本3\nfoo\nbar\nfoo1\nbar1\n\n$ etcdctl get --rev=2 foo foo9 # 访问 key 的修订版本2\nfoo\nbar\n\n$ etcdctl get --rev=1 foo foo9 # 访问 key 的修订版本1\n</code></pre><h1 id=\"删除-key\"><a href=\"#删除-key\" class=\"headerlink\" title=\"删除 key\"></a>删除 key</h1><p>应用可以从 etcd 集群中删除一个 key 或者特定范围的 key。</p>\n<p>下面是删除 key <code>foo</code> 的命令：</p>\n<pre><code>$ etcdctl del foo\n1 # 删除了一个key\n</code></pre><p>这是删除从 <code>foo</code> to <code>foo9</code> 范围的 key 的命令：</p>\n<pre><code>$ etcdctl del foo foo9\n5 # 删除了5个key\n</code></pre><h1 id=\"前缀匹配\"><a href=\"#前缀匹配\" class=\"headerlink\" title=\"前缀匹配\"></a>前缀匹配</h1><h2 id=\"获取指定前缀所有key\"><a href=\"#获取指定前缀所有key\" class=\"headerlink\" title=\"获取指定前缀所有key\"></a>获取指定前缀所有key</h2><p>通过设置<code>--prefix</code>调用对象是拥有指定前缀的key，设置<code>--keys-only</code>只显示key的名字，设置<code>--from-key</code>获取所有的键值。</p>\n<pre><code class=\"bash\">$ etcdctl --prefix --keys-only=true get foo\nfoo\n\nfoo1\n\nfoo2\n\nfoo4\n\nfoo5\n</code></pre>\n<p>如果把前缀变成空字符就是获取当前etcd中所有的key。</p>\n<pre><code class=\"bash\">$ etcdctl --prefix --keys-only=true get &quot;&quot;\nfoo\n\nfoo1\n\nfoo2\n\nfoo4\n\nfoo5</code></pre>\n<p><code>--from-key</code>和<code>--prefix</code>不能同时使用。</p>\n<pre><code class=\"bash\">$ etcdctl get &quot;&quot; --from-key --prefix\nError: `--prefix` and `--from-key` cannot be set at the same time, choose one</code></pre>\n<p>且<code>--from-key</code>必须写在get之后，不然会报错找不到flag。</p>\n<pre><code>$ etcdctl --from-key get &quot;&quot;\nError: unknown flag: --from-key</code></pre><h1 id=\"观察-key-的变化\"><a href=\"#观察-key-的变化\" class=\"headerlink\" title=\"观察 key 的变化\"></a>观察 key 的变化</h1><p>应用可以观察一个 key 或者特定范围内的 key 来监控任何更新。</p>\n<p>这是在 key <code>foo</code> 上进行观察的命令：</p>\n<pre><code>$ etcdctl watch foo\nfoo\nbar</code></pre><pre><code class=\"sh\">$ etcdctl put foo bar\nOK</code></pre>\n<p>这是观察从 <code>foo</code> to <code>foo9</code> 范围key的命令：</p>\n<pre><code class=\"bash\">$ etcdctl watch foo foo9\n# 在另外一个终端: etcdctl put foo bar\nfoo\nbar\n# 在另外一个终端: etcdctl put foo1 bar1\nfoo1\nbar1\n</code></pre>\n<h2 id=\"观察-key-的历史改动\"><a href=\"#观察-key-的历史改动\" class=\"headerlink\" title=\"观察 key 的历史改动\"></a>观察 key 的历史改动</h2><p>应用可能想观察 etcd 中 key 的历史改动。例如，应用想接收到某个 key 的所有修改。如果应用一直连接到etcd，那么 <code>watch</code> 就足够好了。但是，如果应用或者 etcd 出错，改动可能发生在出错期间，这样应用就没能实时接收到这个更新。为了保证更新被接收，应用必须能够观察到 key 的历史变动。为了做到这点，应用可以在观察时指定一个历史修订版本，就像读取 key 的过往版本一样。</p>\n<p>假设我们完成了下列操作序列：</p>\n<pre><code>etcdctl put foo bar         # revision = 2\netcdctl put foo1 bar1       # revision = 3\netcdctl put foo bar_new     # revision = 4\netcdctl put foo1 bar1_new   # revision = 5\n</code></pre><p>这是观察历史改动的例子：</p>\n<pre><code># 从修订版本 2 开始观察key `foo` 的改动\n$ etcdctl watch --rev=2 foo\nPUT\nfoo\nbar\nPUT\nfoo\nbar_new\n\n# 从修订版本 3 开始观察key `foo` 的改动\n$ etcdctl watch --rev=3 foo\nPUT\nfoo\nbar_new\n</code></pre><h1 id=\"压缩修订版本\"><a href=\"#压缩修订版本\" class=\"headerlink\" title=\"压缩修订版本\"></a>压缩修订版本</h1><p>如我们提到的，etcd 保存修订版本以便应用可以读取 key 的过往版本。但是，为了避免积累无限数量的历史数据，压缩过往的修订版本就变得很重要。压缩之后，etcd 删除历史修订版本，释放资源来提供未来使用。所有修订版本在压缩修订版本之前的被替代的数据将不可访问。</p>\n<p>这是压缩修订版本的命令：</p>\n<pre><code>$ etcdctl compact 5\ncompacted revision 5\n\n# 在压缩修订版本之前的任何修订版本都不可访问\n$ etcdctl get --rev=4 foo\n{&quot;level&quot;:&quot;warn&quot;,&quot;ts&quot;:&quot;2020-03-24T10:25:00.189+0800&quot;,&quot;caller&quot;:&quot;clientv3/retry_interceptor.go:62&quot;,&quot;msg&quot;:&quot;retrying of unary invoker failed&quot;,&quot;target&quot;:&quot;endpoint://client-d0dbfe68-878e-4b3f-8bc9-8c1c8fad1a10/127.0.0.1:2379&quot;,&quot;attempt&quot;:0,&quot;error&quot;:&quot;rpc error: code = OutOfRange desc = etcdserver: mvcc: required revision has been compacted&quot;}\n</code></pre><h1 id=\"租约\"><a href=\"#租约\" class=\"headerlink\" title=\"租约\"></a>租约</h1><h2 id=\"授予租约\"><a href=\"#授予租约\" class=\"headerlink\" title=\"授予租约\"></a>授予租约</h2><p>应用可以为 etcd 集群里面的 key 授予租约。当 key 被附加到租约时，它的生存时间被绑定到租约的生存时间，而租约的生存时间相应的被 <code>time-to-live</code> (TTL)管理。租约的实际 TTL 值是不低于最小 TTL，由 etcd 集群选择。一旦租约的 TTL 到期，租约就过期并且所有附带的 key 都将被删除。</p>\n<p>这是授予租约的命令：</p>\n<pre><code># 授予租约，TTL为100秒\n$ etcdctl lease grant 100\nlease 00d4710a3e7c7539 granted with TTL(100s)\n\n# 附加key foo到租约32695410dcc0ca06\n$ etcdctl put --lease=00d4710a3e7c7539 foo bar\nOK\n</code></pre><h2 id=\"撤销租约\"><a href=\"#撤销租约\" class=\"headerlink\" title=\"撤销租约\"></a>撤销租约</h2><p>应用通过租约 id 可以撤销租约。撤销租约将删除所有它附带的 key。</p>\n<p>假设我们完成了下列的操作：</p>\n<pre><code>$ etcdctl lease grant 10\nlease 32695410dcc0ca06 granted with TTL(10s)\n$ etcdctl put --lease=32695410dcc0ca06 foo bar\nOK\n</code></pre><p>这是撤销同一个租约的命令：</p>\n<pre><code>$ etcdctl lease revoke 32695410dcc0ca06\nlease 32695410dcc0ca06 revoked\n\n$ etcdctl get foo\n# 空应答，因为租约撤销导致foo被删除\n</code></pre><h2 id=\"维持租约\"><a href=\"#维持租约\" class=\"headerlink\" title=\"维持租约\"></a>维持租约</h2><p>应用可以通过刷新 key 的 TTL 来维持租约，以便租约不过期。</p>\n<p>假设我们完成了下列操作：</p>\n<pre><code>$ etcdctl lease grant 10\nlease 32695410dcc0ca06 granted with TTL(10s)\n</code></pre><p>这是维持同一个租约的命令：</p>\n<pre><code>$ etcdctl lease keep-alive 32695410dcc0ca0\nlease 32695410dcc0ca0 keepalived with TTL(100)\nlease 32695410dcc0ca0 keepalived with TTL(100)\nlease 32695410dcc0ca0 keepalived with TTL(100)\n...\n</code></pre><blockquote>\n<p>注： 上面的这个命令中，etcdctl 不是单次续约，而是 etcdctl 会一直不断的发送请求来维持这个租约。</p>\n</blockquote>\n<p> <a href=\"https://skyao.gitbooks.io/learning-etcd3/content/documentation/dev-guide/local_cluster.html\" target=\"_blank\" rel=\"noopener\"></a></p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ol>\n<li><a href=\"https://skyao.gitbooks.io/learning-etcd3/content/introduction/\" target=\"_blank\" rel=\"noopener\">etcd3介绍</a></li>\n<li><a href=\"https://skyao.gitbooks.io/learning-etcd3/content/documentation/dev-guide/interacting_v3.html\" target=\"_blank\" rel=\"noopener\">和etcd交互</a></li>\n</ol>\n"},{"author":"djaigo","title":"golang MPG 场景源码剖析","img":"https://img-1251474779.cos.ap-beijing.myqcloud.com/golang.png","date":"2020-09-29T09:50:35.000Z","updated":"2020-09-29T09:50:35.000Z","_content":"\n# 场景分析\n\n* G创建G\np拥有g1，m绑定p后，执行g1，g1创建g2，g2优先加入g1。\n调用链：\n```text\nnewproc() --> systemstack(newproc1() --> runqput())\n```\n\n* G执行完毕\n当g1执行完毕后，m切换到g0，负责goroutine的切换，从p中获取g2，在从g0切换到g2，并执行g2。\n调用链：\n```text\ngoexit() --> goexit1() --> mcall(goexit0) --> schedule()\n```\n\n* G本地队列满再创建G\ng1创建g2，但p的本地G空闲队列已满，则会p的空闲队列的前一半随机排序后和g2存放到全局空闲G队列中。\n调用链：\n```text\nnewproc() --> systemstack(newproc1() --> runqput() --> runqputslow() --> globrunqputbatch())\n```\n\n* 唤醒M\n在创建 G 时，运行的 G 会尝试唤醒其他空闲的P和M组合去执行。如果g1唤醒了m2，m2且与p2绑定，但p2没有可执行的G，m2会执行g0，进入自旋状态（一直获取可以执行的G）。\n调用链：\n```text\nnewproc() --> systemstack(wakep() --> startm() --> pidleget() --> mget() --> notewakeup())\n```\n\n* 唤醒的M向全局空闲G队列获取\n自旋的M会向全局空闲G队列获取可执行的G，获取公式：`n=min(len(GQ)/GOMAXPROCS+1,len(GQ)/2+1)`，其中GQ是全局空闲G队列，最少获取一个。\n调用链：\n```text\nschedule() --> findrunnable() --> globrunqget()\n```\n\n* M向M偷取G\n当m1进入自旋状态，且全局空闲G队列也为空，则会向m2队尾偷取一般的G放入与m1绑定的p1的本地空闲G队列中。\n调用链：\n```text\nschedule() --> findrunnable() --> runqsteal()\n```\n\n* 自旋最大限制\nM必须绑定了P才会自旋，所以最多有`GOMAXPROCS`个M自旋，其他的M会存入全局休眠M队列。\n调用链：\n```text\nstopm() --> mput()\n```\n\n* G调用系统调用\n`m1`执行的`g1`调用了系统调用，那么会保存`g1`的状态，并将`g1`标记为可抢占，解绑`p`，将`p`的状态设置为`_Psyscall`，但不会做其他事，方便很快的系统调用返回时可以立即拥有`p`执行。当`sysmon`检测当前p处于系统调用时间超时后再去绑定m，做其他事情。退出系统调用时，`g1`会被标记可执行状态存放到全局空闲G队列，`m1`则会存放到全局休眠M队列。\n调用链：\n```text\n进入系统调用\nentersyscall() --> reentersyscall()\nsysmon() --> retake() --> handoffp() --> startm() --> pidleput()\n\n退出系统调用\nexitsyscall() --> exitsyscallfast() --> mcall(exitsyscall0() --> pidleget() --> globrunqput() --> stopm())\n```\n\n\n# 参考文献\n\n* [[典藏版] Golang 调度器 GMP 原理与调度全分析](https://learnku.com/articles/41728)\n\n","source":"_posts/golang-MPG-场景源码剖析.md","raw":"---\nauthor: djaigo\ntitle: golang MPG 场景源码剖析\nimg: 'https://img-1251474779.cos.ap-beijing.myqcloud.com/golang.png'\ncategories:\n  - golang\ntags:\n  - mpg\n  - infra\ndate: 2020-09-29 17:50:35\nupdated: 2020-09-29 17:50:35\n---\n\n# 场景分析\n\n* G创建G\np拥有g1，m绑定p后，执行g1，g1创建g2，g2优先加入g1。\n调用链：\n```text\nnewproc() --> systemstack(newproc1() --> runqput())\n```\n\n* G执行完毕\n当g1执行完毕后，m切换到g0，负责goroutine的切换，从p中获取g2，在从g0切换到g2，并执行g2。\n调用链：\n```text\ngoexit() --> goexit1() --> mcall(goexit0) --> schedule()\n```\n\n* G本地队列满再创建G\ng1创建g2，但p的本地G空闲队列已满，则会p的空闲队列的前一半随机排序后和g2存放到全局空闲G队列中。\n调用链：\n```text\nnewproc() --> systemstack(newproc1() --> runqput() --> runqputslow() --> globrunqputbatch())\n```\n\n* 唤醒M\n在创建 G 时，运行的 G 会尝试唤醒其他空闲的P和M组合去执行。如果g1唤醒了m2，m2且与p2绑定，但p2没有可执行的G，m2会执行g0，进入自旋状态（一直获取可以执行的G）。\n调用链：\n```text\nnewproc() --> systemstack(wakep() --> startm() --> pidleget() --> mget() --> notewakeup())\n```\n\n* 唤醒的M向全局空闲G队列获取\n自旋的M会向全局空闲G队列获取可执行的G，获取公式：`n=min(len(GQ)/GOMAXPROCS+1,len(GQ)/2+1)`，其中GQ是全局空闲G队列，最少获取一个。\n调用链：\n```text\nschedule() --> findrunnable() --> globrunqget()\n```\n\n* M向M偷取G\n当m1进入自旋状态，且全局空闲G队列也为空，则会向m2队尾偷取一般的G放入与m1绑定的p1的本地空闲G队列中。\n调用链：\n```text\nschedule() --> findrunnable() --> runqsteal()\n```\n\n* 自旋最大限制\nM必须绑定了P才会自旋，所以最多有`GOMAXPROCS`个M自旋，其他的M会存入全局休眠M队列。\n调用链：\n```text\nstopm() --> mput()\n```\n\n* G调用系统调用\n`m1`执行的`g1`调用了系统调用，那么会保存`g1`的状态，并将`g1`标记为可抢占，解绑`p`，将`p`的状态设置为`_Psyscall`，但不会做其他事，方便很快的系统调用返回时可以立即拥有`p`执行。当`sysmon`检测当前p处于系统调用时间超时后再去绑定m，做其他事情。退出系统调用时，`g1`会被标记可执行状态存放到全局空闲G队列，`m1`则会存放到全局休眠M队列。\n调用链：\n```text\n进入系统调用\nentersyscall() --> reentersyscall()\nsysmon() --> retake() --> handoffp() --> startm() --> pidleput()\n\n退出系统调用\nexitsyscall() --> exitsyscallfast() --> mcall(exitsyscall0() --> pidleget() --> globrunqput() --> stopm())\n```\n\n\n# 参考文献\n\n* [[典藏版] Golang 调度器 GMP 原理与调度全分析](https://learnku.com/articles/41728)\n\n","slug":"golang-MPG-场景源码剖析","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckh351du9000k19z4h8w70ukx","content":"<h1 id=\"场景分析\"><a href=\"#场景分析\" class=\"headerlink\" title=\"场景分析\"></a>场景分析</h1><ul>\n<li><p>G创建G<br>p拥有g1，m绑定p后，执行g1，g1创建g2，g2优先加入g1。<br>调用链：</p>\n<pre class=\" language-text\"><code class=\"language-text\">newproc() --> systemstack(newproc1() --> runqput())</code></pre>\n</li>\n<li><p>G执行完毕<br>当g1执行完毕后，m切换到g0，负责goroutine的切换，从p中获取g2，在从g0切换到g2，并执行g2。<br>调用链：</p>\n<pre class=\" language-text\"><code class=\"language-text\">goexit() --> goexit1() --> mcall(goexit0) --> schedule()</code></pre>\n</li>\n<li><p>G本地队列满再创建G<br>g1创建g2，但p的本地G空闲队列已满，则会p的空闲队列的前一半随机排序后和g2存放到全局空闲G队列中。<br>调用链：</p>\n<pre class=\" language-text\"><code class=\"language-text\">newproc() --> systemstack(newproc1() --> runqput() --> runqputslow() --> globrunqputbatch())</code></pre>\n</li>\n<li><p>唤醒M<br>在创建 G 时，运行的 G 会尝试唤醒其他空闲的P和M组合去执行。如果g1唤醒了m2，m2且与p2绑定，但p2没有可执行的G，m2会执行g0，进入自旋状态（一直获取可以执行的G）。<br>调用链：</p>\n<pre class=\" language-text\"><code class=\"language-text\">newproc() --> systemstack(wakep() --> startm() --> pidleget() --> mget() --> notewakeup())</code></pre>\n</li>\n<li><p>唤醒的M向全局空闲G队列获取<br>自旋的M会向全局空闲G队列获取可执行的G，获取公式：<code>n=min(len(GQ)/GOMAXPROCS+1,len(GQ)/2+1)</code>，其中GQ是全局空闲G队列，最少获取一个。<br>调用链：</p>\n<pre class=\" language-text\"><code class=\"language-text\">schedule() --> findrunnable() --> globrunqget()</code></pre>\n</li>\n<li><p>M向M偷取G<br>当m1进入自旋状态，且全局空闲G队列也为空，则会向m2队尾偷取一般的G放入与m1绑定的p1的本地空闲G队列中。<br>调用链：</p>\n<pre class=\" language-text\"><code class=\"language-text\">schedule() --> findrunnable() --> runqsteal()</code></pre>\n</li>\n<li><p>自旋最大限制<br>M必须绑定了P才会自旋，所以最多有<code>GOMAXPROCS</code>个M自旋，其他的M会存入全局休眠M队列。<br>调用链：</p>\n<pre class=\" language-text\"><code class=\"language-text\">stopm() --> mput()</code></pre>\n</li>\n<li><p>G调用系统调用<br><code>m1</code>执行的<code>g1</code>调用了系统调用，那么会保存<code>g1</code>的状态，并将<code>g1</code>标记为可抢占，解绑<code>p</code>，将<code>p</code>的状态设置为<code>_Psyscall</code>，但不会做其他事，方便很快的系统调用返回时可以立即拥有<code>p</code>执行。当<code>sysmon</code>检测当前p处于系统调用时间超时后再去绑定m，做其他事情。退出系统调用时，<code>g1</code>会被标记可执行状态存放到全局空闲G队列，<code>m1</code>则会存放到全局休眠M队列。<br>调用链：</p>\n<pre class=\" language-text\"><code class=\"language-text\">进入系统调用\nentersyscall() --> reentersyscall()\nsysmon() --> retake() --> handoffp() --> startm() --> pidleput()\n</code></pre>\n</li>\n</ul>\n<p>退出系统调用<br>exitsyscall() –&gt; exitsyscallfast() –&gt; mcall(exitsyscall0() –&gt; pidleget() –&gt; globrunqput() –&gt; stopm())</p>\n<pre><code>\n\n# 参考文献\n\n* [[典藏版] Golang 调度器 GMP 原理与调度全分析](https://learnku.com/articles/41728)\n</code></pre><script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"friends":[{"avatar":"https://img-1251474779.cos.ap-beijing.myqcloud.com/icon.png","name":"djaigo","introduction":"好好学习，天天向上","url":"/","title":"前去学习"},{"avatar":"https://awps-assets.meituan.net/mit/blog/v20190629/asset/icon/favicon.ico?v=Whistle&t=20181017-1r","name":"美团技术团队","introduction":"一行代码，亿万生活。","url":"https://tech.meituan.com/","title":"点个外卖-->"},{"avatar":"","name":"鸟窝","introduction":"rpcx作者","url":"https://colobu.com/","title":"进个鸟窝-->"},{"avatar":"https://d1j8pt39hxlh3d.cloudfront.net/emoji/emojione/5.0/png/unicode/32/1f92a.png","name":"labuladong的算法小抄","introduction":"算法大神","url":"https://labuladong.gitbook.io/algo/","title":"学个算法-->"}]}},"excerpt":"","more":"<h1 id=\"场景分析\"><a href=\"#场景分析\" class=\"headerlink\" title=\"场景分析\"></a>场景分析</h1><ul>\n<li><p>G创建G<br>p拥有g1，m绑定p后，执行g1，g1创建g2，g2优先加入g1。<br>调用链：</p>\n<pre><code class=\"text\">newproc() --&gt; systemstack(newproc1() --&gt; runqput())</code></pre>\n</li>\n<li><p>G执行完毕<br>当g1执行完毕后，m切换到g0，负责goroutine的切换，从p中获取g2，在从g0切换到g2，并执行g2。<br>调用链：</p>\n<pre><code class=\"text\">goexit() --&gt; goexit1() --&gt; mcall(goexit0) --&gt; schedule()</code></pre>\n</li>\n<li><p>G本地队列满再创建G<br>g1创建g2，但p的本地G空闲队列已满，则会p的空闲队列的前一半随机排序后和g2存放到全局空闲G队列中。<br>调用链：</p>\n<pre><code class=\"text\">newproc() --&gt; systemstack(newproc1() --&gt; runqput() --&gt; runqputslow() --&gt; globrunqputbatch())</code></pre>\n</li>\n<li><p>唤醒M<br>在创建 G 时，运行的 G 会尝试唤醒其他空闲的P和M组合去执行。如果g1唤醒了m2，m2且与p2绑定，但p2没有可执行的G，m2会执行g0，进入自旋状态（一直获取可以执行的G）。<br>调用链：</p>\n<pre><code class=\"text\">newproc() --&gt; systemstack(wakep() --&gt; startm() --&gt; pidleget() --&gt; mget() --&gt; notewakeup())</code></pre>\n</li>\n<li><p>唤醒的M向全局空闲G队列获取<br>自旋的M会向全局空闲G队列获取可执行的G，获取公式：<code>n=min(len(GQ)/GOMAXPROCS+1,len(GQ)/2+1)</code>，其中GQ是全局空闲G队列，最少获取一个。<br>调用链：</p>\n<pre><code class=\"text\">schedule() --&gt; findrunnable() --&gt; globrunqget()</code></pre>\n</li>\n<li><p>M向M偷取G<br>当m1进入自旋状态，且全局空闲G队列也为空，则会向m2队尾偷取一般的G放入与m1绑定的p1的本地空闲G队列中。<br>调用链：</p>\n<pre><code class=\"text\">schedule() --&gt; findrunnable() --&gt; runqsteal()</code></pre>\n</li>\n<li><p>自旋最大限制<br>M必须绑定了P才会自旋，所以最多有<code>GOMAXPROCS</code>个M自旋，其他的M会存入全局休眠M队列。<br>调用链：</p>\n<pre><code class=\"text\">stopm() --&gt; mput()</code></pre>\n</li>\n<li><p>G调用系统调用<br><code>m1</code>执行的<code>g1</code>调用了系统调用，那么会保存<code>g1</code>的状态，并将<code>g1</code>标记为可抢占，解绑<code>p</code>，将<code>p</code>的状态设置为<code>_Psyscall</code>，但不会做其他事，方便很快的系统调用返回时可以立即拥有<code>p</code>执行。当<code>sysmon</code>检测当前p处于系统调用时间超时后再去绑定m，做其他事情。退出系统调用时，<code>g1</code>会被标记可执行状态存放到全局空闲G队列，<code>m1</code>则会存放到全局休眠M队列。<br>调用链：</p>\n<pre><code class=\"text\">进入系统调用\nentersyscall() --&gt; reentersyscall()\nsysmon() --&gt; retake() --&gt; handoffp() --&gt; startm() --&gt; pidleput()\n</code></pre>\n</li>\n</ul>\n<p>退出系统调用<br>exitsyscall() –&gt; exitsyscallfast() –&gt; mcall(exitsyscall0() –&gt; pidleget() –&gt; globrunqput() –&gt; stopm())</p>\n<pre><code>\n\n# 参考文献\n\n* [[典藏版] Golang 调度器 GMP 原理与调度全分析](https://learnku.com/articles/41728)\n</code></pre>"},{"author":"djaigo","title":"golang MPG 有限状态机","img":"https://img-1251474779.cos.ap-beijing.myqcloud.com/golang.png","date":"2020-09-29T09:54:01.000Z","updated":"2020-09-29T09:54:01.000Z","_content":"\n去掉了cgo和GC的相关状态转化\n\n# P状态机\n\n# G状态机","source":"_posts/golang-MPG-有限状态机.md","raw":"---\nauthor: djaigo\ntitle: golang MPG 有限状态机\nimg: 'https://img-1251474779.cos.ap-beijing.myqcloud.com/golang.png'\ncategories:\n  - golang\ntags:\n  - mpg\n  - infra\ndate: 2020-09-29 17:54:01\nupdated: 2020-09-29 17:54:01\n---\n\n去掉了cgo和GC的相关状态转化\n\n# P状态机\n\n# G状态机","slug":"golang-MPG-有限状态机","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckh351dub000m19z4exq34clg","content":"<p>去掉了cgo和GC的相关状态转化</p>\n<h1 id=\"P状态机\"><a href=\"#P状态机\" class=\"headerlink\" title=\"P状态机\"></a>P状态机</h1><h1 id=\"G状态机\"><a href=\"#G状态机\" class=\"headerlink\" title=\"G状态机\"></a>G状态机</h1><script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"friends":[{"avatar":"https://img-1251474779.cos.ap-beijing.myqcloud.com/icon.png","name":"djaigo","introduction":"好好学习，天天向上","url":"/","title":"前去学习"},{"avatar":"https://awps-assets.meituan.net/mit/blog/v20190629/asset/icon/favicon.ico?v=Whistle&t=20181017-1r","name":"美团技术团队","introduction":"一行代码，亿万生活。","url":"https://tech.meituan.com/","title":"点个外卖-->"},{"avatar":"","name":"鸟窝","introduction":"rpcx作者","url":"https://colobu.com/","title":"进个鸟窝-->"},{"avatar":"https://d1j8pt39hxlh3d.cloudfront.net/emoji/emojione/5.0/png/unicode/32/1f92a.png","name":"labuladong的算法小抄","introduction":"算法大神","url":"https://labuladong.gitbook.io/algo/","title":"学个算法-->"}]}},"excerpt":"","more":"<p>去掉了cgo和GC的相关状态转化</p>\n<h1 id=\"P状态机\"><a href=\"#P状态机\" class=\"headerlink\" title=\"P状态机\"></a>P状态机</h1><h1 id=\"G状态机\"><a href=\"#G状态机\" class=\"headerlink\" title=\"G状态机\"></a>G状态机</h1>"},{"author":"djaigo","title":"IP协议","date":"2019-12-10T08:08:53.000Z","update":"2019-12-12T08:08:53.000Z","img":"https://img-1251474779.cos.ap-beijing.myqcloud.com/net.png","mathjax":true,"enable html":true,"_content":"\n# 简介\nIP协议是TCP/IP协议族的动力，它为上层协议提供无状态、无连接、不可靠的服务。\n* 无状态（stateless），是指IP通信双方不同步传输数据的状态信息，因此所有IP数据报的发送、传输和接收都是相互独立的\n* 无连接（connectionless），是指IP通信双方都不长久地维持对方的任何信息，因此每个IP数据报都要带上对方的IP地址\n* 不可靠（unreliable），是指IP协议不能保证IP数据报准确到达接收端，只是尽最大努力\n\n# IPv4\n## 头部结构\nIPv4头部结构，固定长度为20字节，选项最多可有40字节\n![IPv4 header](https://img-1251474779.cos.ap-beijing.myqcloud.com/IP协议/v4header.png)\n* 4位版本号（version），指定IP协议的版本，IPv4的值是4，其他IPv4的扩展版本（SIP和PIP）拥有不同的版本和不同的头部结构\n* 4位头部长度（header length），标识IP头部有多少个4字节，4位比特最大能表示15，所以IP头部长度最长为$4*15=60$字节\n* 8位服务类型（type of service，TOS）\n  * 3位优先权字段（现已被忽略）\n  * 4位TOS分别表示，最小延迟、最大吞吐量、最高可靠性和最小费用，同时只能一个置1，应用程序根据实际情况来设置\n  * 1位保留字段（必须置0）\n* 16位总长度（total length），是指整个IP数据报的长度，以字节为单位，因此IP数据报的最大长度为$2^{16}-1=65535$，但是由于MTU（最大传输单元）限制，超过MTU的数据报将被分片传输\n* 16位标识（identification）唯一的标识主机发送的每一个数据报，初始值由系统随机生成，每发送一个数据报其值加一，该值在数据报分片时复制到每个分片，因此同一个数据报的所有分片都具有相同的标识值\n* 3位标志字段（flag）\n  * 第一位保留\n  * 第二位（Don't Fragment，DF）表示禁止分片，如果设置了这个值，IP模块将不对数据报进行分片，如果数据报超过MTU，IP模块将丢弃数据报并返回一个ICMP差错报文\n  * 第三位（More Fragment，MF）表示更多分片，除了最后一个分片外其他分片都要把它置1\n* 13位分片偏移（fragmentation offset）是分片相对原始IP数据报开始处（仅指数据部分）偏移，实际的偏移值是左移3位（$*8$）后得到的，因为这个原因，除了最后一个IP分片外，每个IP分片的数据部分的长度必须是8的整数倍（保证每个分片有一个合适偏移值）\n* 8位生存时间（Time To Live，TTL）是数据报到达目的地址之前允许经过路由器的跳数，TTL由发送端设置（常见值64），每经过一个路由，该值就减一，当减为0时，路由器将丢弃数据报，并向发送源发送一个ICMP差错报文，TTL可以防止数据报陷入路由循环\n* 8位协议（protocol）用来区分上层协议，`/etc/protocols`文件定义了所有上层协议对应的protocol字段的数值，也可以通过[IANA](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xml)获取\n* 16位头部校验和（header checksum）由发送端填充，接收端对其使用CRC算法检验**IP数据报头部**在传输过程中是否损坏\n* 32位源IP地址和目的端IP地址用来表示IP数据报的发送端和接收端，一般情况下这两个地址在整个数据报的传递过程中保持不变\n* 选项字段（option）是一个可变长可选信息，这部分最多包含40字节，可选内容有\n  * 记录路由（record route）告诉数据报途经的所有路由器都将自己的IP地址填入IP头部的选项部分，这样可以追踪数据报的传递路径\n  * 时间戳（timestamp）告诉每个路由器都将数据报被转发的时间（或时间与IP地址对）填入IP头部的选项部分，这样可以测量途经路由之间数据报传输的时间\n  * 松散源路由选择（loose source routing）指定一个路由器IP地址列表，数据报发送过程中必须经过其中所有路由器\n  * 严格源路由选择（strict source routing）和松散源路由选择类似，不过数据报只能经过被指定的路由器\n\n## IP分片\n当IP数据报的长度超过帧的MTU时，它将被分片传输。分片可能发生在发送端，也有可能发生在中转路由器中，而且可能在传输的过程中多次分片，但只有再最终的目标机器上，这些分片才会被内核中的IP模块重新组装。\nIP头部中提供数据报标识、标志和片偏移提供了足够的重组信息。一个IP数据报的每个分片都具有相同的标识值，但具有不同的片偏移。除了最后一个分片外，其他分片都将设置MF标志，每个分片的IP数据报总长度会被字段将会被设置为该分片的长度。\n一般以太网帧的MTU是1500字节（可以通过ifconfig和netstat查看），IP数据报头部占用20字节，所以最大传输1480字节，这里利用ICMP可以产生IP数据报分片，ICMP头部信息占8字节，所以数据只用传输1473字节就能使IP数据报分片。\n使用golang模拟这个情况\n```go\ntype ICMP struct {\n    Type        uint8\n    Code        uint8\n    CheckSum    uint16\n    Identifier  uint16\n    SequenceNum uint16\n}\n\nfunc Checksum(data []byte) uint16 {\n    var (\n        sum    uint32\n        length = len(data)\n        index  int\n    )\n    for length > 1 {\n        sum += uint32(data[index])<<8 + uint32(data[index+1])\n        index += 2\n        length -= 2\n    }\n    if length > 0 {\n        sum += uint32(data[index])\n    }\n    sum += sum >> 16\n    return uint16(^sum)\n}\n\nfunc getICMP(seq uint16) ICMP {\n    icmp := ICMP{\n        Type:        8,\n        Code:        0,\n        CheckSum:    0,\n        Identifier:  0,\n        SequenceNum: seq,\n    }\n    var buffer bytes.Buffer\n    binary.Write(&buffer, binary.BigEndian, icmp)\n    icmp.CheckSum = Checksum(buffer.Bytes())\n    buffer.Reset()\n    return icmp\n}\n\nfunc main() {\n    icmp := getICMP(1)\n    conn, err := net.DialIP(\"ip4:icmp\", nil, &net.IPAddr{IP: net.IP{220, 181, 38, 150}})\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n    defer conn.Close()\n    arr := make([]byte, 1473)\n    for i := range arr {\n        arr[i] = byte(i)\n    }\n    // 将最后一个字节设置为0\n    arr[1472] = 0\n    var buffer bytes.Buffer\n    binary.Write(&buffer, binary.BigEndian, icmp)\n    binary.Write(&buffer, binary.BigEndian, arr)\n    if _, err := conn.Write(buffer.Bytes()); err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n    conn.SetReadDeadline(time.Now().Add(time.Second * 5))\n    recv := make([]byte, 2048)\n    n, err := conn.Read(recv)\n    if err != nil {\n        fmt.Println(err.Error())\n    }\n    fmt.Printf(\"%#v\", recv[:n])\n}\n```\n\n我们可以通过wireshark查看数据报具体信息\n\n![第一分片IP数据报头部信息](http://img-1251474779.cos.ap-beijing.myqcloud.com/IP%E5%8D%8F%E8%AE%AE/20191211022407734.png)\n\n上图可以看到Flags设置了MF标志\n\n![第二分片IP数据报头部信息](http://img-1251474779.cos.ap-beijing.myqcloud.com/IP%E5%8D%8F%E8%AE%AE/20191211022558072.png)\n\n上图可以看到设置了数据报偏移量$185*8=1480$\n\n![第一分片IP数据报局部内容](http://img-1251474779.cos.ap-beijing.myqcloud.com/IP%E5%8D%8F%E8%AE%AE/20191211022814706.png)\n\n上图蓝色区域表示IP数据报的数据部分，前8字节表示ICMP头部信息，后面是ICMP数据\n\n![第二分片IP数据报内容](http://img-1251474779.cos.ap-beijing.myqcloud.com/IP%E5%8D%8F%E8%AE%AE/20191211022830044.png)\n\n上图说明分片后的IP数据报数据是承接上一个数据报，内核收到这些数据后将其拼装成一个完整IP数据报\n\n## IP路由\nIP协议一个核心任务是数据报的路由，即决定发送数据报到目标机器的路径。\n\n### 工作流程\n![IP模块基本工作流程](http://img-1251474779.cos.ap-beijing.myqcloud.com/IP%E5%8D%8F%E8%AE%AE/IP%E6%A8%A1%E5%9D%97%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B.png)\n\n当IP模块收到来自数据链路层的IP数据报时，先对数据报头部做CRC校验，确认无误后就分析其头部的具体信息。\n如果IP数据报头部设置了源站路由选择（松散源路由选择或严格源路由选择），则IP模块调用数据报转发子模块来处理数据报。如果该IP数据报的头部中目标IP地址是本机的某个IP地址或者是广播地址（即该数据报是发给本机的），则IP模块就根据数据报头部中的协议来决定将它派发给那个上层协议处理。如果IP模块发现这个数据报不是发给本机的，则调用数据报转发子模块来处理数据报。\nIP数据报转发子模块首先检查系统是否允许转发，如果不允许，IP模块就将数据报丢弃，如果允许则将会进行数据报转发。\nIP数据报应该发送至哪一个路由（或目标机器），以及用哪张网卡发送，就是IP路由的过程，都是由计算下一跳路由子模块处理。数据报路由的核心结构是路由表，由目标IP进行分类，同一类型的IP数据报将被发往相同的下一跳路由。\nIP输出队列中存放的是所有等待发送的IP数据报，其中除了需要转发的数据报外，还有本机封装的上层协议的IP数据报。\n虚线箭头显示路由表更新过程，这个过程是指通过路由协议或者route命令调整路由表，是指更适应最新的网络拓扑结构，称之为IP路由策略。\n\n### 路由机制\nIP路由机制的核心就是IP路由表，可以使用route或者netstat查看路由表\n路由表包含每项都有8个字段，字段含义如下：\n\n| 字段      | 含义    | \n| :-----------: | :-------- |\n| Destination    | 目标网络或主机  |\n| Gateway     | 网关地址，`*`表示和本机在同一个网络 |\n| Genmask     | 网络掩码 |\n| Flags | 路由标志常见的标志有：<br/><ul><li>U，该路由项是活动的</li><li>H，该路由项的目标是一台主机</li><li>G，该路由项的目标是网关</li><li>D，该路由项是有重定向生成的</li><li>M，该路由项被重新修改过</li></ul>|\n|Metric|路由距离，即到达指定网络所需的中转数|\n|Ref|路由项被引用的次数（Linux未使用）|\n|Use|该路由项被使用的次数 |\n|Iface|该路由项对应的输出网卡接口|\n\n我们可以执行route命令获取当前的路由表\n```sh\n# route\nKernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\ndefault         gateway         0.0.0.0         UG    0      0        0 eth0\n172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0\n```\n\n目标地址表示default，即默认路由，在标志中有`G`表示下一跳是网关，网关地址是`gateway`，如果Gateway是`*`，则不需要中转，直接发送目标机器。\nIP的路由机制分为以下3个步骤：\n* 步骤1，查找路由表中和数据报的目标地址IP地址完全匹配的主机IP地址，如果找到就使用该路由项，如果没有找到则转到步骤2\n* 步骤2，查找路由表中和数据报的目标IP地址具有相同网络ID的网络IP地址，如果找到就使用该路由项，没有找到则转到步骤3\n* 步骤3，选择默认路由项，通常意味着下一跳路由是网关\n\n有上面的路由表可知，发送到IP地址为`172.17.*.*`（`172.17.0.0/16`）的地址都可以将数据报直接发送到目标机器（路由表第二项），所有访问Internet的请求都将通过默认网关转发。\n\n### 路由表更新\n路由表必须能够更新，以适应网络连接的变化，这样IP模块才能准确、高效的转发数据报。可以通过route命令手动修改路由表，是属于静态的路由更新方式，对于大型路由器，一般通过BGP（Border Gateway Protocol，边际网关协议）、RIP（Routing Information Protocol，路由信息协议）、OSPF（Open Shortest Path First，开放式最短路径优先）等协议来发现路径，并动态更新自己的路由表。\n\n## IP转发\nIP模块把不是发送给本机的IP数据报将由数据报转发子模块来处理，路由器都能执行数据报的转发操作，而主机一般只发送和接收数据报，这是因为主机上的`/proc/sys/net/ipv4/ip_forward`内核参数默认设置为0，我们可以修改这个值来使主机的数据报转发功能。\nIP数据报转发操作流程：\n* 检查数据报头部的TTL值，如果TTL值是0，则丢弃该数据报\n* 查看数据报头部的阉割路由选择选项，如果该选项被设置，则检测数据报的目标IP地址是否是本机的某个IP地址，如果不是，则发送一个ICMP源站选路失败报文给发送端\n* 如果有必要，则给源端发送一个ICMP重定向报文，以告诉它一个更合理的下一跳路由器\n* 将TTL减1\n* 处理IP头部选项\n* 如果有必要，则执行IP分片操作\n\n## 重定向\n### ICMP重定向报文\n利用ICMP重定向报文可以告诉目标机器IP数据报应该使用哪个路由器转发，并且以此来更新路由表（通常是更新路由表缓冲，而不是直接更改路由表）。\n`/proc/sys/net/ipv4/conf/all/send_redirects`内核参数指定是否允许发送ICMP重定向报文，`/proc/sys/net/ipv4/conf/all/accept_redirects`内核参数则指定是否允许接收ICMP重定向报文，一般来说主机只能接收ICMP从定向报文，而路由器只能发送ICMP重定向报文。\n### 主机重定向\n我们可以将目标主机设置开启转发功能，将本机网关设置为目标主机，这样就可以通过目标主机来访问Internet。\n主机重定向流程：\n* 主机向目标主机发送IP数据报\n* 目标主机向路由器发送数据，发现主机可以直接发送给它的路由器是比较合理的路径\n* 目标主机向主机发送一个ICMP重定向报文\n* 后序的IP数据报，主机都会直接发送给路由器\n\n# IPv6\n随着网络技术的发展IPv4已经无法满足需求，而且目前IPv4的地址已经分配完毕。IPv6协议不仅解决了IPv4地址不够用的情况，还做了很多改进。比如：增加了多播和流功能，为网络上多媒体内容的质量提供精细的控制；引入自动配置功能，使局域网管理更方便；增加了专门的网络安全功能等。\n## 头部结构\nIPv6头部由40字节固定头部和可变长的扩展头部组成\n\n![IPv6固定头部结构](http://img-1251474779.cos.ap-beijing.myqcloud.com/IP%E5%8D%8F%E8%AE%AE/IPv6header.png)\n\n* 4位版本号（version）对于IPv6来说，其值是6\n* 8位通信类型（traffic class）只是数据流通信类型或优先级，和IPv4的TOS类似\n* 20位流标签（flow label）是IPv6新加字段，对于某些对连接的服务质量有特殊要求的通信，比如音频或视频等实时数据传输\n* 16位荷载长度（payload length）指的是IPv6扩展头部和应用程序长度之和，不包括固定头部长度\n* 8位下一个包头（next header）指出紧跟IPv6固定头部后的包头类型，如扩展头（如果有的话）或某个上层协议头（比如TCP，UPD和ICMP），它类似于IPv4头部中的协议字段，且取值相同含义相同\n* 8位跳数限制（hop limit）和IPv4的TTL相同\n* 128位表示源IP和目的IP地址，16字节使IP地址的总量达到了$2^{128}$个，号称IPv6能使地球上每一粒沙子都能分配一个IP地址\n\nIPv4使用点分十进制表示IP地址，而IPv6地址则使用16进制字符串表示，比如`fe80:0000:0000:0000:0000:0000:0000:0001`。IPv6地址使用`:`分隔成8组，每组包含，使用16进制表示2个字节。由于0太多的话，这样表示过于麻烦，所以可以使用零压缩法将其简写，就是省略中间全是0的组，上面的例子就可以简写成`fe80::1`，零压缩法只能在IPv6地址中使用一次，不然无法知道中间的省略了多少个零。\n\n## 扩展头\n可变长的扩展头部使得IPv6能支持更多的选项，并且很便于将来的扩展需要。它的长度可以是零，表示数据报没有使用任何扩展头部，一个数据报可以包含多个扩展头部，每个扩展头部的类型由前一个头部（固定头部或扩展头部）中的下一个报头字段指定，目前使用的扩展头部有：\n\n| 扩展头部      | 含义    | \n| :-----------: | -------- |\n| Hop-by-Hop    | 逐跳选项头部，它包含每个路由器都必须检查和处理的特殊参数选项  |\n| Destination option     | 目的选项头部，指定由最终目的节点处理的选项 |\n| Routing     | 路由头部，指定数据报要经过哪些中转路由，功能类似于IPv4的松散源路由选择选项和记录路由选项 |\n| Fragment | 分片头部，处理分片和重组的细节 |\n|Authentication| 认证头部，提供数据源认证、数据完整性检查和反重播保护 |\n|Encapsulation Security Payload| 加密头部，提供加密服务 |\n|No next header| 没有后续扩展头部 |\n\n\n# 参考文献\n* 《Linux高性能服务器编程》\n\n","source":"_posts/IP协议.md","raw":"---\nauthor: djaigo\ntitle: IP协议\ndate: 2019-12-10 16:08:53\nupdate: 2019-12-12 16:08:53\nimg: https://img-1251474779.cos.ap-beijing.myqcloud.com/net.png\ncategories: \n  - net\ntags: \n  - IP\n  - IPv4\n  - IPv6\nmathjax: true\nenable html: true\n---\n\n# 简介\nIP协议是TCP/IP协议族的动力，它为上层协议提供无状态、无连接、不可靠的服务。\n* 无状态（stateless），是指IP通信双方不同步传输数据的状态信息，因此所有IP数据报的发送、传输和接收都是相互独立的\n* 无连接（connectionless），是指IP通信双方都不长久地维持对方的任何信息，因此每个IP数据报都要带上对方的IP地址\n* 不可靠（unreliable），是指IP协议不能保证IP数据报准确到达接收端，只是尽最大努力\n\n# IPv4\n## 头部结构\nIPv4头部结构，固定长度为20字节，选项最多可有40字节\n![IPv4 header](https://img-1251474779.cos.ap-beijing.myqcloud.com/IP协议/v4header.png)\n* 4位版本号（version），指定IP协议的版本，IPv4的值是4，其他IPv4的扩展版本（SIP和PIP）拥有不同的版本和不同的头部结构\n* 4位头部长度（header length），标识IP头部有多少个4字节，4位比特最大能表示15，所以IP头部长度最长为$4*15=60$字节\n* 8位服务类型（type of service，TOS）\n  * 3位优先权字段（现已被忽略）\n  * 4位TOS分别表示，最小延迟、最大吞吐量、最高可靠性和最小费用，同时只能一个置1，应用程序根据实际情况来设置\n  * 1位保留字段（必须置0）\n* 16位总长度（total length），是指整个IP数据报的长度，以字节为单位，因此IP数据报的最大长度为$2^{16}-1=65535$，但是由于MTU（最大传输单元）限制，超过MTU的数据报将被分片传输\n* 16位标识（identification）唯一的标识主机发送的每一个数据报，初始值由系统随机生成，每发送一个数据报其值加一，该值在数据报分片时复制到每个分片，因此同一个数据报的所有分片都具有相同的标识值\n* 3位标志字段（flag）\n  * 第一位保留\n  * 第二位（Don't Fragment，DF）表示禁止分片，如果设置了这个值，IP模块将不对数据报进行分片，如果数据报超过MTU，IP模块将丢弃数据报并返回一个ICMP差错报文\n  * 第三位（More Fragment，MF）表示更多分片，除了最后一个分片外其他分片都要把它置1\n* 13位分片偏移（fragmentation offset）是分片相对原始IP数据报开始处（仅指数据部分）偏移，实际的偏移值是左移3位（$*8$）后得到的，因为这个原因，除了最后一个IP分片外，每个IP分片的数据部分的长度必须是8的整数倍（保证每个分片有一个合适偏移值）\n* 8位生存时间（Time To Live，TTL）是数据报到达目的地址之前允许经过路由器的跳数，TTL由发送端设置（常见值64），每经过一个路由，该值就减一，当减为0时，路由器将丢弃数据报，并向发送源发送一个ICMP差错报文，TTL可以防止数据报陷入路由循环\n* 8位协议（protocol）用来区分上层协议，`/etc/protocols`文件定义了所有上层协议对应的protocol字段的数值，也可以通过[IANA](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xml)获取\n* 16位头部校验和（header checksum）由发送端填充，接收端对其使用CRC算法检验**IP数据报头部**在传输过程中是否损坏\n* 32位源IP地址和目的端IP地址用来表示IP数据报的发送端和接收端，一般情况下这两个地址在整个数据报的传递过程中保持不变\n* 选项字段（option）是一个可变长可选信息，这部分最多包含40字节，可选内容有\n  * 记录路由（record route）告诉数据报途经的所有路由器都将自己的IP地址填入IP头部的选项部分，这样可以追踪数据报的传递路径\n  * 时间戳（timestamp）告诉每个路由器都将数据报被转发的时间（或时间与IP地址对）填入IP头部的选项部分，这样可以测量途经路由之间数据报传输的时间\n  * 松散源路由选择（loose source routing）指定一个路由器IP地址列表，数据报发送过程中必须经过其中所有路由器\n  * 严格源路由选择（strict source routing）和松散源路由选择类似，不过数据报只能经过被指定的路由器\n\n## IP分片\n当IP数据报的长度超过帧的MTU时，它将被分片传输。分片可能发生在发送端，也有可能发生在中转路由器中，而且可能在传输的过程中多次分片，但只有再最终的目标机器上，这些分片才会被内核中的IP模块重新组装。\nIP头部中提供数据报标识、标志和片偏移提供了足够的重组信息。一个IP数据报的每个分片都具有相同的标识值，但具有不同的片偏移。除了最后一个分片外，其他分片都将设置MF标志，每个分片的IP数据报总长度会被字段将会被设置为该分片的长度。\n一般以太网帧的MTU是1500字节（可以通过ifconfig和netstat查看），IP数据报头部占用20字节，所以最大传输1480字节，这里利用ICMP可以产生IP数据报分片，ICMP头部信息占8字节，所以数据只用传输1473字节就能使IP数据报分片。\n使用golang模拟这个情况\n```go\ntype ICMP struct {\n    Type        uint8\n    Code        uint8\n    CheckSum    uint16\n    Identifier  uint16\n    SequenceNum uint16\n}\n\nfunc Checksum(data []byte) uint16 {\n    var (\n        sum    uint32\n        length = len(data)\n        index  int\n    )\n    for length > 1 {\n        sum += uint32(data[index])<<8 + uint32(data[index+1])\n        index += 2\n        length -= 2\n    }\n    if length > 0 {\n        sum += uint32(data[index])\n    }\n    sum += sum >> 16\n    return uint16(^sum)\n}\n\nfunc getICMP(seq uint16) ICMP {\n    icmp := ICMP{\n        Type:        8,\n        Code:        0,\n        CheckSum:    0,\n        Identifier:  0,\n        SequenceNum: seq,\n    }\n    var buffer bytes.Buffer\n    binary.Write(&buffer, binary.BigEndian, icmp)\n    icmp.CheckSum = Checksum(buffer.Bytes())\n    buffer.Reset()\n    return icmp\n}\n\nfunc main() {\n    icmp := getICMP(1)\n    conn, err := net.DialIP(\"ip4:icmp\", nil, &net.IPAddr{IP: net.IP{220, 181, 38, 150}})\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n    defer conn.Close()\n    arr := make([]byte, 1473)\n    for i := range arr {\n        arr[i] = byte(i)\n    }\n    // 将最后一个字节设置为0\n    arr[1472] = 0\n    var buffer bytes.Buffer\n    binary.Write(&buffer, binary.BigEndian, icmp)\n    binary.Write(&buffer, binary.BigEndian, arr)\n    if _, err := conn.Write(buffer.Bytes()); err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n    conn.SetReadDeadline(time.Now().Add(time.Second * 5))\n    recv := make([]byte, 2048)\n    n, err := conn.Read(recv)\n    if err != nil {\n        fmt.Println(err.Error())\n    }\n    fmt.Printf(\"%#v\", recv[:n])\n}\n```\n\n我们可以通过wireshark查看数据报具体信息\n\n![第一分片IP数据报头部信息](http://img-1251474779.cos.ap-beijing.myqcloud.com/IP%E5%8D%8F%E8%AE%AE/20191211022407734.png)\n\n上图可以看到Flags设置了MF标志\n\n![第二分片IP数据报头部信息](http://img-1251474779.cos.ap-beijing.myqcloud.com/IP%E5%8D%8F%E8%AE%AE/20191211022558072.png)\n\n上图可以看到设置了数据报偏移量$185*8=1480$\n\n![第一分片IP数据报局部内容](http://img-1251474779.cos.ap-beijing.myqcloud.com/IP%E5%8D%8F%E8%AE%AE/20191211022814706.png)\n\n上图蓝色区域表示IP数据报的数据部分，前8字节表示ICMP头部信息，后面是ICMP数据\n\n![第二分片IP数据报内容](http://img-1251474779.cos.ap-beijing.myqcloud.com/IP%E5%8D%8F%E8%AE%AE/20191211022830044.png)\n\n上图说明分片后的IP数据报数据是承接上一个数据报，内核收到这些数据后将其拼装成一个完整IP数据报\n\n## IP路由\nIP协议一个核心任务是数据报的路由，即决定发送数据报到目标机器的路径。\n\n### 工作流程\n![IP模块基本工作流程](http://img-1251474779.cos.ap-beijing.myqcloud.com/IP%E5%8D%8F%E8%AE%AE/IP%E6%A8%A1%E5%9D%97%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B.png)\n\n当IP模块收到来自数据链路层的IP数据报时，先对数据报头部做CRC校验，确认无误后就分析其头部的具体信息。\n如果IP数据报头部设置了源站路由选择（松散源路由选择或严格源路由选择），则IP模块调用数据报转发子模块来处理数据报。如果该IP数据报的头部中目标IP地址是本机的某个IP地址或者是广播地址（即该数据报是发给本机的），则IP模块就根据数据报头部中的协议来决定将它派发给那个上层协议处理。如果IP模块发现这个数据报不是发给本机的，则调用数据报转发子模块来处理数据报。\nIP数据报转发子模块首先检查系统是否允许转发，如果不允许，IP模块就将数据报丢弃，如果允许则将会进行数据报转发。\nIP数据报应该发送至哪一个路由（或目标机器），以及用哪张网卡发送，就是IP路由的过程，都是由计算下一跳路由子模块处理。数据报路由的核心结构是路由表，由目标IP进行分类，同一类型的IP数据报将被发往相同的下一跳路由。\nIP输出队列中存放的是所有等待发送的IP数据报，其中除了需要转发的数据报外，还有本机封装的上层协议的IP数据报。\n虚线箭头显示路由表更新过程，这个过程是指通过路由协议或者route命令调整路由表，是指更适应最新的网络拓扑结构，称之为IP路由策略。\n\n### 路由机制\nIP路由机制的核心就是IP路由表，可以使用route或者netstat查看路由表\n路由表包含每项都有8个字段，字段含义如下：\n\n| 字段      | 含义    | \n| :-----------: | :-------- |\n| Destination    | 目标网络或主机  |\n| Gateway     | 网关地址，`*`表示和本机在同一个网络 |\n| Genmask     | 网络掩码 |\n| Flags | 路由标志常见的标志有：<br/><ul><li>U，该路由项是活动的</li><li>H，该路由项的目标是一台主机</li><li>G，该路由项的目标是网关</li><li>D，该路由项是有重定向生成的</li><li>M，该路由项被重新修改过</li></ul>|\n|Metric|路由距离，即到达指定网络所需的中转数|\n|Ref|路由项被引用的次数（Linux未使用）|\n|Use|该路由项被使用的次数 |\n|Iface|该路由项对应的输出网卡接口|\n\n我们可以执行route命令获取当前的路由表\n```sh\n# route\nKernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\ndefault         gateway         0.0.0.0         UG    0      0        0 eth0\n172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0\n```\n\n目标地址表示default，即默认路由，在标志中有`G`表示下一跳是网关，网关地址是`gateway`，如果Gateway是`*`，则不需要中转，直接发送目标机器。\nIP的路由机制分为以下3个步骤：\n* 步骤1，查找路由表中和数据报的目标地址IP地址完全匹配的主机IP地址，如果找到就使用该路由项，如果没有找到则转到步骤2\n* 步骤2，查找路由表中和数据报的目标IP地址具有相同网络ID的网络IP地址，如果找到就使用该路由项，没有找到则转到步骤3\n* 步骤3，选择默认路由项，通常意味着下一跳路由是网关\n\n有上面的路由表可知，发送到IP地址为`172.17.*.*`（`172.17.0.0/16`）的地址都可以将数据报直接发送到目标机器（路由表第二项），所有访问Internet的请求都将通过默认网关转发。\n\n### 路由表更新\n路由表必须能够更新，以适应网络连接的变化，这样IP模块才能准确、高效的转发数据报。可以通过route命令手动修改路由表，是属于静态的路由更新方式，对于大型路由器，一般通过BGP（Border Gateway Protocol，边际网关协议）、RIP（Routing Information Protocol，路由信息协议）、OSPF（Open Shortest Path First，开放式最短路径优先）等协议来发现路径，并动态更新自己的路由表。\n\n## IP转发\nIP模块把不是发送给本机的IP数据报将由数据报转发子模块来处理，路由器都能执行数据报的转发操作，而主机一般只发送和接收数据报，这是因为主机上的`/proc/sys/net/ipv4/ip_forward`内核参数默认设置为0，我们可以修改这个值来使主机的数据报转发功能。\nIP数据报转发操作流程：\n* 检查数据报头部的TTL值，如果TTL值是0，则丢弃该数据报\n* 查看数据报头部的阉割路由选择选项，如果该选项被设置，则检测数据报的目标IP地址是否是本机的某个IP地址，如果不是，则发送一个ICMP源站选路失败报文给发送端\n* 如果有必要，则给源端发送一个ICMP重定向报文，以告诉它一个更合理的下一跳路由器\n* 将TTL减1\n* 处理IP头部选项\n* 如果有必要，则执行IP分片操作\n\n## 重定向\n### ICMP重定向报文\n利用ICMP重定向报文可以告诉目标机器IP数据报应该使用哪个路由器转发，并且以此来更新路由表（通常是更新路由表缓冲，而不是直接更改路由表）。\n`/proc/sys/net/ipv4/conf/all/send_redirects`内核参数指定是否允许发送ICMP重定向报文，`/proc/sys/net/ipv4/conf/all/accept_redirects`内核参数则指定是否允许接收ICMP重定向报文，一般来说主机只能接收ICMP从定向报文，而路由器只能发送ICMP重定向报文。\n### 主机重定向\n我们可以将目标主机设置开启转发功能，将本机网关设置为目标主机，这样就可以通过目标主机来访问Internet。\n主机重定向流程：\n* 主机向目标主机发送IP数据报\n* 目标主机向路由器发送数据，发现主机可以直接发送给它的路由器是比较合理的路径\n* 目标主机向主机发送一个ICMP重定向报文\n* 后序的IP数据报，主机都会直接发送给路由器\n\n# IPv6\n随着网络技术的发展IPv4已经无法满足需求，而且目前IPv4的地址已经分配完毕。IPv6协议不仅解决了IPv4地址不够用的情况，还做了很多改进。比如：增加了多播和流功能，为网络上多媒体内容的质量提供精细的控制；引入自动配置功能，使局域网管理更方便；增加了专门的网络安全功能等。\n## 头部结构\nIPv6头部由40字节固定头部和可变长的扩展头部组成\n\n![IPv6固定头部结构](http://img-1251474779.cos.ap-beijing.myqcloud.com/IP%E5%8D%8F%E8%AE%AE/IPv6header.png)\n\n* 4位版本号（version）对于IPv6来说，其值是6\n* 8位通信类型（traffic class）只是数据流通信类型或优先级，和IPv4的TOS类似\n* 20位流标签（flow label）是IPv6新加字段，对于某些对连接的服务质量有特殊要求的通信，比如音频或视频等实时数据传输\n* 16位荷载长度（payload length）指的是IPv6扩展头部和应用程序长度之和，不包括固定头部长度\n* 8位下一个包头（next header）指出紧跟IPv6固定头部后的包头类型，如扩展头（如果有的话）或某个上层协议头（比如TCP，UPD和ICMP），它类似于IPv4头部中的协议字段，且取值相同含义相同\n* 8位跳数限制（hop limit）和IPv4的TTL相同\n* 128位表示源IP和目的IP地址，16字节使IP地址的总量达到了$2^{128}$个，号称IPv6能使地球上每一粒沙子都能分配一个IP地址\n\nIPv4使用点分十进制表示IP地址，而IPv6地址则使用16进制字符串表示，比如`fe80:0000:0000:0000:0000:0000:0000:0001`。IPv6地址使用`:`分隔成8组，每组包含，使用16进制表示2个字节。由于0太多的话，这样表示过于麻烦，所以可以使用零压缩法将其简写，就是省略中间全是0的组，上面的例子就可以简写成`fe80::1`，零压缩法只能在IPv6地址中使用一次，不然无法知道中间的省略了多少个零。\n\n## 扩展头\n可变长的扩展头部使得IPv6能支持更多的选项，并且很便于将来的扩展需要。它的长度可以是零，表示数据报没有使用任何扩展头部，一个数据报可以包含多个扩展头部，每个扩展头部的类型由前一个头部（固定头部或扩展头部）中的下一个报头字段指定，目前使用的扩展头部有：\n\n| 扩展头部      | 含义    | \n| :-----------: | -------- |\n| Hop-by-Hop    | 逐跳选项头部，它包含每个路由器都必须检查和处理的特殊参数选项  |\n| Destination option     | 目的选项头部，指定由最终目的节点处理的选项 |\n| Routing     | 路由头部，指定数据报要经过哪些中转路由，功能类似于IPv4的松散源路由选择选项和记录路由选项 |\n| Fragment | 分片头部，处理分片和重组的细节 |\n|Authentication| 认证头部，提供数据源认证、数据完整性检查和反重播保护 |\n|Encapsulation Security Payload| 加密头部，提供加密服务 |\n|No next header| 没有后续扩展头部 |\n\n\n# 参考文献\n* 《Linux高性能服务器编程》\n\n","slug":"IP协议","published":1,"updated":"2019-12-10T08:08:53.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh351duc000r19z48f444o4a","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>IP协议是TCP/IP协议族的动力，它为上层协议提供无状态、无连接、不可靠的服务。</p>\n<ul>\n<li>无状态（stateless），是指IP通信双方不同步传输数据的状态信息，因此所有IP数据报的发送、传输和接收都是相互独立的</li>\n<li>无连接（connectionless），是指IP通信双方都不长久地维持对方的任何信息，因此每个IP数据报都要带上对方的IP地址</li>\n<li>不可靠（unreliable），是指IP协议不能保证IP数据报准确到达接收端，只是尽最大努力</li>\n</ul>\n<h1 id=\"IPv4\"><a href=\"#IPv4\" class=\"headerlink\" title=\"IPv4\"></a>IPv4</h1><h2 id=\"头部结构\"><a href=\"#头部结构\" class=\"headerlink\" title=\"头部结构\"></a>头部结构</h2><p>IPv4头部结构，固定长度为20字节，选项最多可有40字节<br><img src=\"https://img-1251474779.cos.ap-beijing.myqcloud.com/IP%E5%8D%8F%E8%AE%AE/v4header.png\" alt=\"IPv4 header\"></p>\n<ul>\n<li>4位版本号（version），指定IP协议的版本，IPv4的值是4，其他IPv4的扩展版本（SIP和PIP）拥有不同的版本和不同的头部结构</li>\n<li>4位头部长度（header length），标识IP头部有多少个4字节，4位比特最大能表示15，所以IP头部长度最长为$4*15=60$字节</li>\n<li>8位服务类型（type of service，TOS）<ul>\n<li>3位优先权字段（现已被忽略）</li>\n<li>4位TOS分别表示，最小延迟、最大吞吐量、最高可靠性和最小费用，同时只能一个置1，应用程序根据实际情况来设置</li>\n<li>1位保留字段（必须置0）</li>\n</ul>\n</li>\n<li>16位总长度（total length），是指整个IP数据报的长度，以字节为单位，因此IP数据报的最大长度为$2^{16}-1=65535$，但是由于MTU（最大传输单元）限制，超过MTU的数据报将被分片传输</li>\n<li>16位标识（identification）唯一的标识主机发送的每一个数据报，初始值由系统随机生成，每发送一个数据报其值加一，该值在数据报分片时复制到每个分片，因此同一个数据报的所有分片都具有相同的标识值</li>\n<li>3位标志字段（flag）<ul>\n<li>第一位保留</li>\n<li>第二位（Don’t Fragment，DF）表示禁止分片，如果设置了这个值，IP模块将不对数据报进行分片，如果数据报超过MTU，IP模块将丢弃数据报并返回一个ICMP差错报文</li>\n<li>第三位（More Fragment，MF）表示更多分片，除了最后一个分片外其他分片都要把它置1</li>\n</ul>\n</li>\n<li>13位分片偏移（fragmentation offset）是分片相对原始IP数据报开始处（仅指数据部分）偏移，实际的偏移值是左移3位（$*8$）后得到的，因为这个原因，除了最后一个IP分片外，每个IP分片的数据部分的长度必须是8的整数倍（保证每个分片有一个合适偏移值）</li>\n<li>8位生存时间（Time To Live，TTL）是数据报到达目的地址之前允许经过路由器的跳数，TTL由发送端设置（常见值64），每经过一个路由，该值就减一，当减为0时，路由器将丢弃数据报，并向发送源发送一个ICMP差错报文，TTL可以防止数据报陷入路由循环</li>\n<li>8位协议（protocol）用来区分上层协议，<code>/etc/protocols</code>文件定义了所有上层协议对应的protocol字段的数值，也可以通过<a href=\"https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xml\" target=\"_blank\" rel=\"noopener\">IANA</a>获取</li>\n<li>16位头部校验和（header checksum）由发送端填充，接收端对其使用CRC算法检验<strong>IP数据报头部</strong>在传输过程中是否损坏</li>\n<li>32位源IP地址和目的端IP地址用来表示IP数据报的发送端和接收端，一般情况下这两个地址在整个数据报的传递过程中保持不变</li>\n<li>选项字段（option）是一个可变长可选信息，这部分最多包含40字节，可选内容有<ul>\n<li>记录路由（record route）告诉数据报途经的所有路由器都将自己的IP地址填入IP头部的选项部分，这样可以追踪数据报的传递路径</li>\n<li>时间戳（timestamp）告诉每个路由器都将数据报被转发的时间（或时间与IP地址对）填入IP头部的选项部分，这样可以测量途经路由之间数据报传输的时间</li>\n<li>松散源路由选择（loose source routing）指定一个路由器IP地址列表，数据报发送过程中必须经过其中所有路由器</li>\n<li>严格源路由选择（strict source routing）和松散源路由选择类似，不过数据报只能经过被指定的路由器</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"IP分片\"><a href=\"#IP分片\" class=\"headerlink\" title=\"IP分片\"></a>IP分片</h2><p>当IP数据报的长度超过帧的MTU时，它将被分片传输。分片可能发生在发送端，也有可能发生在中转路由器中，而且可能在传输的过程中多次分片，但只有再最终的目标机器上，这些分片才会被内核中的IP模块重新组装。<br>IP头部中提供数据报标识、标志和片偏移提供了足够的重组信息。一个IP数据报的每个分片都具有相同的标识值，但具有不同的片偏移。除了最后一个分片外，其他分片都将设置MF标志，每个分片的IP数据报总长度会被字段将会被设置为该分片的长度。<br>一般以太网帧的MTU是1500字节（可以通过ifconfig和netstat查看），IP数据报头部占用20字节，所以最大传输1480字节，这里利用ICMP可以产生IP数据报分片，ICMP头部信息占8字节，所以数据只用传输1473字节就能使IP数据报分片。<br>使用golang模拟这个情况</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> ICMP <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    Type        <span class=\"token builtin\">uint8</span>\n    Code        <span class=\"token builtin\">uint8</span>\n    CheckSum    <span class=\"token builtin\">uint16</span>\n    Identifier  <span class=\"token builtin\">uint16</span>\n    SequenceNum <span class=\"token builtin\">uint16</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">Checksum</span><span class=\"token punctuation\">(</span>data <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">byte</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">uint16</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> <span class=\"token punctuation\">(</span>\n        sum    <span class=\"token builtin\">uint32</span>\n        length <span class=\"token operator\">=</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span>\n        index  <span class=\"token builtin\">int</span>\n    <span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">for</span> length <span class=\"token operator\">></span> <span class=\"token number\">1</span> <span class=\"token punctuation\">{</span>\n        sum <span class=\"token operator\">+=</span> <span class=\"token function\">uint32</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token operator\">&lt;&lt;</span><span class=\"token number\">8</span> <span class=\"token operator\">+</span> <span class=\"token function\">uint32</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">[</span>index<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        index <span class=\"token operator\">+=</span> <span class=\"token number\">2</span>\n        length <span class=\"token operator\">-=</span> <span class=\"token number\">2</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> length <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n        sum <span class=\"token operator\">+=</span> <span class=\"token function\">uint32</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    sum <span class=\"token operator\">+=</span> sum <span class=\"token operator\">>></span> <span class=\"token number\">16</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">uint16</span><span class=\"token punctuation\">(</span><span class=\"token operator\">^</span>sum<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">getICMP</span><span class=\"token punctuation\">(</span>seq <span class=\"token builtin\">uint16</span><span class=\"token punctuation\">)</span> ICMP <span class=\"token punctuation\">{</span>\n    icmp <span class=\"token operator\">:=</span> ICMP<span class=\"token punctuation\">{</span>\n        Type<span class=\"token punctuation\">:</span>        <span class=\"token number\">8</span><span class=\"token punctuation\">,</span>\n        Code<span class=\"token punctuation\">:</span>        <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n        CheckSum<span class=\"token punctuation\">:</span>    <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n        Identifier<span class=\"token punctuation\">:</span>  <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n        SequenceNum<span class=\"token punctuation\">:</span> seq<span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">var</span> buffer bytes<span class=\"token punctuation\">.</span>Buffer\n    binary<span class=\"token punctuation\">.</span><span class=\"token function\">Write</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>buffer<span class=\"token punctuation\">,</span> binary<span class=\"token punctuation\">.</span>BigEndian<span class=\"token punctuation\">,</span> icmp<span class=\"token punctuation\">)</span>\n    icmp<span class=\"token punctuation\">.</span>CheckSum <span class=\"token operator\">=</span> <span class=\"token function\">Checksum</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">.</span><span class=\"token function\">Bytes</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    buffer<span class=\"token punctuation\">.</span><span class=\"token function\">Reset</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> icmp\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    icmp <span class=\"token operator\">:=</span> <span class=\"token function\">getICMP</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    conn<span class=\"token punctuation\">,</span> err <span class=\"token operator\">:=</span> net<span class=\"token punctuation\">.</span><span class=\"token function\">DialIP</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"ip4:icmp\"</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">nil</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>net<span class=\"token punctuation\">.</span>IPAddr<span class=\"token punctuation\">{</span>IP<span class=\"token punctuation\">:</span> net<span class=\"token punctuation\">.</span>IP<span class=\"token punctuation\">{</span><span class=\"token number\">220</span><span class=\"token punctuation\">,</span> <span class=\"token number\">181</span><span class=\"token punctuation\">,</span> <span class=\"token number\">38</span><span class=\"token punctuation\">,</span> <span class=\"token number\">150</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">.</span><span class=\"token function\">Error</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">defer</span> conn<span class=\"token punctuation\">.</span><span class=\"token function\">Close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    arr <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">byte</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1473</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token keyword\">range</span> arr <span class=\"token punctuation\">{</span>\n        arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">byte</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 将最后一个字节设置为0</span>\n    arr<span class=\"token punctuation\">[</span><span class=\"token number\">1472</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    <span class=\"token keyword\">var</span> buffer bytes<span class=\"token punctuation\">.</span>Buffer\n    binary<span class=\"token punctuation\">.</span><span class=\"token function\">Write</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>buffer<span class=\"token punctuation\">,</span> binary<span class=\"token punctuation\">.</span>BigEndian<span class=\"token punctuation\">,</span> icmp<span class=\"token punctuation\">)</span>\n    binary<span class=\"token punctuation\">.</span><span class=\"token function\">Write</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>buffer<span class=\"token punctuation\">,</span> binary<span class=\"token punctuation\">.</span>BigEndian<span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> <span class=\"token boolean\">_</span><span class=\"token punctuation\">,</span> err <span class=\"token operator\">:=</span> conn<span class=\"token punctuation\">.</span><span class=\"token function\">Write</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">.</span><span class=\"token function\">Bytes</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">.</span><span class=\"token function\">Error</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span>\n    <span class=\"token punctuation\">}</span>\n    conn<span class=\"token punctuation\">.</span><span class=\"token function\">SetReadDeadline</span><span class=\"token punctuation\">(</span>time<span class=\"token punctuation\">.</span><span class=\"token function\">Now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">Add</span><span class=\"token punctuation\">(</span>time<span class=\"token punctuation\">.</span>Second <span class=\"token operator\">*</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    recv <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">byte</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2048</span><span class=\"token punctuation\">)</span>\n    n<span class=\"token punctuation\">,</span> err <span class=\"token operator\">:=</span> conn<span class=\"token punctuation\">.</span><span class=\"token function\">Read</span><span class=\"token punctuation\">(</span>recv<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">.</span><span class=\"token function\">Error</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%#v\"</span><span class=\"token punctuation\">,</span> recv<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>我们可以通过wireshark查看数据报具体信息</p>\n<p><img src=\"http://img-1251474779.cos.ap-beijing.myqcloud.com/IP%E5%8D%8F%E8%AE%AE/20191211022407734.png\" alt=\"第一分片IP数据报头部信息\"></p>\n<p>上图可以看到Flags设置了MF标志</p>\n<p><img src=\"http://img-1251474779.cos.ap-beijing.myqcloud.com/IP%E5%8D%8F%E8%AE%AE/20191211022558072.png\" alt=\"第二分片IP数据报头部信息\"></p>\n<p>上图可以看到设置了数据报偏移量$185*8=1480$</p>\n<p><img src=\"http://img-1251474779.cos.ap-beijing.myqcloud.com/IP%E5%8D%8F%E8%AE%AE/20191211022814706.png\" alt=\"第一分片IP数据报局部内容\"></p>\n<p>上图蓝色区域表示IP数据报的数据部分，前8字节表示ICMP头部信息，后面是ICMP数据</p>\n<p><img src=\"http://img-1251474779.cos.ap-beijing.myqcloud.com/IP%E5%8D%8F%E8%AE%AE/20191211022830044.png\" alt=\"第二分片IP数据报内容\"></p>\n<p>上图说明分片后的IP数据报数据是承接上一个数据报，内核收到这些数据后将其拼装成一个完整IP数据报</p>\n<h2 id=\"IP路由\"><a href=\"#IP路由\" class=\"headerlink\" title=\"IP路由\"></a>IP路由</h2><p>IP协议一个核心任务是数据报的路由，即决定发送数据报到目标机器的路径。</p>\n<h3 id=\"工作流程\"><a href=\"#工作流程\" class=\"headerlink\" title=\"工作流程\"></a>工作流程</h3><p><img src=\"http://img-1251474779.cos.ap-beijing.myqcloud.com/IP%E5%8D%8F%E8%AE%AE/IP%E6%A8%A1%E5%9D%97%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B.png\" alt=\"IP模块基本工作流程\"></p>\n<p>当IP模块收到来自数据链路层的IP数据报时，先对数据报头部做CRC校验，确认无误后就分析其头部的具体信息。<br>如果IP数据报头部设置了源站路由选择（松散源路由选择或严格源路由选择），则IP模块调用数据报转发子模块来处理数据报。如果该IP数据报的头部中目标IP地址是本机的某个IP地址或者是广播地址（即该数据报是发给本机的），则IP模块就根据数据报头部中的协议来决定将它派发给那个上层协议处理。如果IP模块发现这个数据报不是发给本机的，则调用数据报转发子模块来处理数据报。<br>IP数据报转发子模块首先检查系统是否允许转发，如果不允许，IP模块就将数据报丢弃，如果允许则将会进行数据报转发。<br>IP数据报应该发送至哪一个路由（或目标机器），以及用哪张网卡发送，就是IP路由的过程，都是由计算下一跳路由子模块处理。数据报路由的核心结构是路由表，由目标IP进行分类，同一类型的IP数据报将被发往相同的下一跳路由。<br>IP输出队列中存放的是所有等待发送的IP数据报，其中除了需要转发的数据报外，还有本机封装的上层协议的IP数据报。<br>虚线箭头显示路由表更新过程，这个过程是指通过路由协议或者route命令调整路由表，是指更适应最新的网络拓扑结构，称之为IP路由策略。</p>\n<h3 id=\"路由机制\"><a href=\"#路由机制\" class=\"headerlink\" title=\"路由机制\"></a>路由机制</h3><p>IP路由机制的核心就是IP路由表，可以使用route或者netstat查看路由表<br>路由表包含每项都有8个字段，字段含义如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">字段</th>\n<th align=\"left\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Destination</td>\n<td align=\"left\">目标网络或主机</td>\n</tr>\n<tr>\n<td align=\"center\">Gateway</td>\n<td align=\"left\">网关地址，<code>*</code>表示和本机在同一个网络</td>\n</tr>\n<tr>\n<td align=\"center\">Genmask</td>\n<td align=\"left\">网络掩码</td>\n</tr>\n<tr>\n<td align=\"center\">Flags</td>\n<td align=\"left\">路由标志常见的标志有：<br><ul><li>U，该路由项是活动的</li><li>H，该路由项的目标是一台主机</li><li>G，该路由项的目标是网关</li><li>D，该路由项是有重定向生成的</li><li>M，该路由项被重新修改过</li></ul></td>\n</tr>\n<tr>\n<td align=\"center\">Metric</td>\n<td align=\"left\">路由距离，即到达指定网络所需的中转数</td>\n</tr>\n<tr>\n<td align=\"center\">Ref</td>\n<td align=\"left\">路由项被引用的次数（Linux未使用）</td>\n</tr>\n<tr>\n<td align=\"center\">Use</td>\n<td align=\"left\">该路由项被使用的次数</td>\n</tr>\n<tr>\n<td align=\"center\">Iface</td>\n<td align=\"left\">该路由项对应的输出网卡接口</td>\n</tr>\n</tbody></table>\n<p>我们可以执行route命令获取当前的路由表</p>\n<pre class=\" language-sh\"><code class=\"language-sh\"># route\nKernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\ndefault         gateway         0.0.0.0         UG    0      0        0 eth0\n172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</code></pre>\n<p>目标地址表示default，即默认路由，在标志中有<code>G</code>表示下一跳是网关，网关地址是<code>gateway</code>，如果Gateway是<code>*</code>，则不需要中转，直接发送目标机器。<br>IP的路由机制分为以下3个步骤：</p>\n<ul>\n<li>步骤1，查找路由表中和数据报的目标地址IP地址完全匹配的主机IP地址，如果找到就使用该路由项，如果没有找到则转到步骤2</li>\n<li>步骤2，查找路由表中和数据报的目标IP地址具有相同网络ID的网络IP地址，如果找到就使用该路由项，没有找到则转到步骤3</li>\n<li>步骤3，选择默认路由项，通常意味着下一跳路由是网关</li>\n</ul>\n<p>有上面的路由表可知，发送到IP地址为<code>172.17.*.*</code>（<code>172.17.0.0/16</code>）的地址都可以将数据报直接发送到目标机器（路由表第二项），所有访问Internet的请求都将通过默认网关转发。</p>\n<h3 id=\"路由表更新\"><a href=\"#路由表更新\" class=\"headerlink\" title=\"路由表更新\"></a>路由表更新</h3><p>路由表必须能够更新，以适应网络连接的变化，这样IP模块才能准确、高效的转发数据报。可以通过route命令手动修改路由表，是属于静态的路由更新方式，对于大型路由器，一般通过BGP（Border Gateway Protocol，边际网关协议）、RIP（Routing Information Protocol，路由信息协议）、OSPF（Open Shortest Path First，开放式最短路径优先）等协议来发现路径，并动态更新自己的路由表。</p>\n<h2 id=\"IP转发\"><a href=\"#IP转发\" class=\"headerlink\" title=\"IP转发\"></a>IP转发</h2><p>IP模块把不是发送给本机的IP数据报将由数据报转发子模块来处理，路由器都能执行数据报的转发操作，而主机一般只发送和接收数据报，这是因为主机上的<code>/proc/sys/net/ipv4/ip_forward</code>内核参数默认设置为0，我们可以修改这个值来使主机的数据报转发功能。<br>IP数据报转发操作流程：</p>\n<ul>\n<li>检查数据报头部的TTL值，如果TTL值是0，则丢弃该数据报</li>\n<li>查看数据报头部的阉割路由选择选项，如果该选项被设置，则检测数据报的目标IP地址是否是本机的某个IP地址，如果不是，则发送一个ICMP源站选路失败报文给发送端</li>\n<li>如果有必要，则给源端发送一个ICMP重定向报文，以告诉它一个更合理的下一跳路由器</li>\n<li>将TTL减1</li>\n<li>处理IP头部选项</li>\n<li>如果有必要，则执行IP分片操作</li>\n</ul>\n<h2 id=\"重定向\"><a href=\"#重定向\" class=\"headerlink\" title=\"重定向\"></a>重定向</h2><h3 id=\"ICMP重定向报文\"><a href=\"#ICMP重定向报文\" class=\"headerlink\" title=\"ICMP重定向报文\"></a>ICMP重定向报文</h3><p>利用ICMP重定向报文可以告诉目标机器IP数据报应该使用哪个路由器转发，并且以此来更新路由表（通常是更新路由表缓冲，而不是直接更改路由表）。<br><code>/proc/sys/net/ipv4/conf/all/send_redirects</code>内核参数指定是否允许发送ICMP重定向报文，<code>/proc/sys/net/ipv4/conf/all/accept_redirects</code>内核参数则指定是否允许接收ICMP重定向报文，一般来说主机只能接收ICMP从定向报文，而路由器只能发送ICMP重定向报文。</p>\n<h3 id=\"主机重定向\"><a href=\"#主机重定向\" class=\"headerlink\" title=\"主机重定向\"></a>主机重定向</h3><p>我们可以将目标主机设置开启转发功能，将本机网关设置为目标主机，这样就可以通过目标主机来访问Internet。<br>主机重定向流程：</p>\n<ul>\n<li>主机向目标主机发送IP数据报</li>\n<li>目标主机向路由器发送数据，发现主机可以直接发送给它的路由器是比较合理的路径</li>\n<li>目标主机向主机发送一个ICMP重定向报文</li>\n<li>后序的IP数据报，主机都会直接发送给路由器</li>\n</ul>\n<h1 id=\"IPv6\"><a href=\"#IPv6\" class=\"headerlink\" title=\"IPv6\"></a>IPv6</h1><p>随着网络技术的发展IPv4已经无法满足需求，而且目前IPv4的地址已经分配完毕。IPv6协议不仅解决了IPv4地址不够用的情况，还做了很多改进。比如：增加了多播和流功能，为网络上多媒体内容的质量提供精细的控制；引入自动配置功能，使局域网管理更方便；增加了专门的网络安全功能等。</p>\n<h2 id=\"头部结构-1\"><a href=\"#头部结构-1\" class=\"headerlink\" title=\"头部结构\"></a>头部结构</h2><p>IPv6头部由40字节固定头部和可变长的扩展头部组成</p>\n<p><img src=\"http://img-1251474779.cos.ap-beijing.myqcloud.com/IP%E5%8D%8F%E8%AE%AE/IPv6header.png\" alt=\"IPv6固定头部结构\"></p>\n<ul>\n<li>4位版本号（version）对于IPv6来说，其值是6</li>\n<li>8位通信类型（traffic class）只是数据流通信类型或优先级，和IPv4的TOS类似</li>\n<li>20位流标签（flow label）是IPv6新加字段，对于某些对连接的服务质量有特殊要求的通信，比如音频或视频等实时数据传输</li>\n<li>16位荷载长度（payload length）指的是IPv6扩展头部和应用程序长度之和，不包括固定头部长度</li>\n<li>8位下一个包头（next header）指出紧跟IPv6固定头部后的包头类型，如扩展头（如果有的话）或某个上层协议头（比如TCP，UPD和ICMP），它类似于IPv4头部中的协议字段，且取值相同含义相同</li>\n<li>8位跳数限制（hop limit）和IPv4的TTL相同</li>\n<li>128位表示源IP和目的IP地址，16字节使IP地址的总量达到了$2^{128}$个，号称IPv6能使地球上每一粒沙子都能分配一个IP地址</li>\n</ul>\n<p>IPv4使用点分十进制表示IP地址，而IPv6地址则使用16进制字符串表示，比如<code>fe80:0000:0000:0000:0000:0000:0000:0001</code>。IPv6地址使用<code>:</code>分隔成8组，每组包含，使用16进制表示2个字节。由于0太多的话，这样表示过于麻烦，所以可以使用零压缩法将其简写，就是省略中间全是0的组，上面的例子就可以简写成<code>fe80::1</code>，零压缩法只能在IPv6地址中使用一次，不然无法知道中间的省略了多少个零。</p>\n<h2 id=\"扩展头\"><a href=\"#扩展头\" class=\"headerlink\" title=\"扩展头\"></a>扩展头</h2><p>可变长的扩展头部使得IPv6能支持更多的选项，并且很便于将来的扩展需要。它的长度可以是零，表示数据报没有使用任何扩展头部，一个数据报可以包含多个扩展头部，每个扩展头部的类型由前一个头部（固定头部或扩展头部）中的下一个报头字段指定，目前使用的扩展头部有：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">扩展头部</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Hop-by-Hop</td>\n<td>逐跳选项头部，它包含每个路由器都必须检查和处理的特殊参数选项</td>\n</tr>\n<tr>\n<td align=\"center\">Destination option</td>\n<td>目的选项头部，指定由最终目的节点处理的选项</td>\n</tr>\n<tr>\n<td align=\"center\">Routing</td>\n<td>路由头部，指定数据报要经过哪些中转路由，功能类似于IPv4的松散源路由选择选项和记录路由选项</td>\n</tr>\n<tr>\n<td align=\"center\">Fragment</td>\n<td>分片头部，处理分片和重组的细节</td>\n</tr>\n<tr>\n<td align=\"center\">Authentication</td>\n<td>认证头部，提供数据源认证、数据完整性检查和反重播保护</td>\n</tr>\n<tr>\n<td align=\"center\">Encapsulation Security Payload</td>\n<td>加密头部，提供加密服务</td>\n</tr>\n<tr>\n<td align=\"center\">No next header</td>\n<td>没有后续扩展头部</td>\n</tr>\n</tbody></table>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ul>\n<li>《Linux高性能服务器编程》</li>\n</ul>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"friends":[{"avatar":"https://img-1251474779.cos.ap-beijing.myqcloud.com/icon.png","name":"djaigo","introduction":"好好学习，天天向上","url":"/","title":"前去学习"},{"avatar":"https://awps-assets.meituan.net/mit/blog/v20190629/asset/icon/favicon.ico?v=Whistle&t=20181017-1r","name":"美团技术团队","introduction":"一行代码，亿万生活。","url":"https://tech.meituan.com/","title":"点个外卖-->"},{"avatar":"","name":"鸟窝","introduction":"rpcx作者","url":"https://colobu.com/","title":"进个鸟窝-->"},{"avatar":"https://d1j8pt39hxlh3d.cloudfront.net/emoji/emojione/5.0/png/unicode/32/1f92a.png","name":"labuladong的算法小抄","introduction":"算法大神","url":"https://labuladong.gitbook.io/algo/","title":"学个算法-->"}]}},"excerpt":"","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>IP协议是TCP/IP协议族的动力，它为上层协议提供无状态、无连接、不可靠的服务。</p>\n<ul>\n<li>无状态（stateless），是指IP通信双方不同步传输数据的状态信息，因此所有IP数据报的发送、传输和接收都是相互独立的</li>\n<li>无连接（connectionless），是指IP通信双方都不长久地维持对方的任何信息，因此每个IP数据报都要带上对方的IP地址</li>\n<li>不可靠（unreliable），是指IP协议不能保证IP数据报准确到达接收端，只是尽最大努力</li>\n</ul>\n<h1 id=\"IPv4\"><a href=\"#IPv4\" class=\"headerlink\" title=\"IPv4\"></a>IPv4</h1><h2 id=\"头部结构\"><a href=\"#头部结构\" class=\"headerlink\" title=\"头部结构\"></a>头部结构</h2><p>IPv4头部结构，固定长度为20字节，选项最多可有40字节<br><img src=\"https://img-1251474779.cos.ap-beijing.myqcloud.com/IP%E5%8D%8F%E8%AE%AE/v4header.png\" alt=\"IPv4 header\"></p>\n<ul>\n<li>4位版本号（version），指定IP协议的版本，IPv4的值是4，其他IPv4的扩展版本（SIP和PIP）拥有不同的版本和不同的头部结构</li>\n<li>4位头部长度（header length），标识IP头部有多少个4字节，4位比特最大能表示15，所以IP头部长度最长为$4*15=60$字节</li>\n<li>8位服务类型（type of service，TOS）<ul>\n<li>3位优先权字段（现已被忽略）</li>\n<li>4位TOS分别表示，最小延迟、最大吞吐量、最高可靠性和最小费用，同时只能一个置1，应用程序根据实际情况来设置</li>\n<li>1位保留字段（必须置0）</li>\n</ul>\n</li>\n<li>16位总长度（total length），是指整个IP数据报的长度，以字节为单位，因此IP数据报的最大长度为$2^{16}-1=65535$，但是由于MTU（最大传输单元）限制，超过MTU的数据报将被分片传输</li>\n<li>16位标识（identification）唯一的标识主机发送的每一个数据报，初始值由系统随机生成，每发送一个数据报其值加一，该值在数据报分片时复制到每个分片，因此同一个数据报的所有分片都具有相同的标识值</li>\n<li>3位标志字段（flag）<ul>\n<li>第一位保留</li>\n<li>第二位（Don’t Fragment，DF）表示禁止分片，如果设置了这个值，IP模块将不对数据报进行分片，如果数据报超过MTU，IP模块将丢弃数据报并返回一个ICMP差错报文</li>\n<li>第三位（More Fragment，MF）表示更多分片，除了最后一个分片外其他分片都要把它置1</li>\n</ul>\n</li>\n<li>13位分片偏移（fragmentation offset）是分片相对原始IP数据报开始处（仅指数据部分）偏移，实际的偏移值是左移3位（$*8$）后得到的，因为这个原因，除了最后一个IP分片外，每个IP分片的数据部分的长度必须是8的整数倍（保证每个分片有一个合适偏移值）</li>\n<li>8位生存时间（Time To Live，TTL）是数据报到达目的地址之前允许经过路由器的跳数，TTL由发送端设置（常见值64），每经过一个路由，该值就减一，当减为0时，路由器将丢弃数据报，并向发送源发送一个ICMP差错报文，TTL可以防止数据报陷入路由循环</li>\n<li>8位协议（protocol）用来区分上层协议，<code>/etc/protocols</code>文件定义了所有上层协议对应的protocol字段的数值，也可以通过<a href=\"https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xml\" target=\"_blank\" rel=\"noopener\">IANA</a>获取</li>\n<li>16位头部校验和（header checksum）由发送端填充，接收端对其使用CRC算法检验<strong>IP数据报头部</strong>在传输过程中是否损坏</li>\n<li>32位源IP地址和目的端IP地址用来表示IP数据报的发送端和接收端，一般情况下这两个地址在整个数据报的传递过程中保持不变</li>\n<li>选项字段（option）是一个可变长可选信息，这部分最多包含40字节，可选内容有<ul>\n<li>记录路由（record route）告诉数据报途经的所有路由器都将自己的IP地址填入IP头部的选项部分，这样可以追踪数据报的传递路径</li>\n<li>时间戳（timestamp）告诉每个路由器都将数据报被转发的时间（或时间与IP地址对）填入IP头部的选项部分，这样可以测量途经路由之间数据报传输的时间</li>\n<li>松散源路由选择（loose source routing）指定一个路由器IP地址列表，数据报发送过程中必须经过其中所有路由器</li>\n<li>严格源路由选择（strict source routing）和松散源路由选择类似，不过数据报只能经过被指定的路由器</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"IP分片\"><a href=\"#IP分片\" class=\"headerlink\" title=\"IP分片\"></a>IP分片</h2><p>当IP数据报的长度超过帧的MTU时，它将被分片传输。分片可能发生在发送端，也有可能发生在中转路由器中，而且可能在传输的过程中多次分片，但只有再最终的目标机器上，这些分片才会被内核中的IP模块重新组装。<br>IP头部中提供数据报标识、标志和片偏移提供了足够的重组信息。一个IP数据报的每个分片都具有相同的标识值，但具有不同的片偏移。除了最后一个分片外，其他分片都将设置MF标志，每个分片的IP数据报总长度会被字段将会被设置为该分片的长度。<br>一般以太网帧的MTU是1500字节（可以通过ifconfig和netstat查看），IP数据报头部占用20字节，所以最大传输1480字节，这里利用ICMP可以产生IP数据报分片，ICMP头部信息占8字节，所以数据只用传输1473字节就能使IP数据报分片。<br>使用golang模拟这个情况</p>\n<pre><code class=\"go\">type ICMP struct {\n    Type        uint8\n    Code        uint8\n    CheckSum    uint16\n    Identifier  uint16\n    SequenceNum uint16\n}\n\nfunc Checksum(data []byte) uint16 {\n    var (\n        sum    uint32\n        length = len(data)\n        index  int\n    )\n    for length &gt; 1 {\n        sum += uint32(data[index])&lt;&lt;8 + uint32(data[index+1])\n        index += 2\n        length -= 2\n    }\n    if length &gt; 0 {\n        sum += uint32(data[index])\n    }\n    sum += sum &gt;&gt; 16\n    return uint16(^sum)\n}\n\nfunc getICMP(seq uint16) ICMP {\n    icmp := ICMP{\n        Type:        8,\n        Code:        0,\n        CheckSum:    0,\n        Identifier:  0,\n        SequenceNum: seq,\n    }\n    var buffer bytes.Buffer\n    binary.Write(&amp;buffer, binary.BigEndian, icmp)\n    icmp.CheckSum = Checksum(buffer.Bytes())\n    buffer.Reset()\n    return icmp\n}\n\nfunc main() {\n    icmp := getICMP(1)\n    conn, err := net.DialIP(&quot;ip4:icmp&quot;, nil, &amp;net.IPAddr{IP: net.IP{220, 181, 38, 150}})\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n    defer conn.Close()\n    arr := make([]byte, 1473)\n    for i := range arr {\n        arr[i] = byte(i)\n    }\n    // 将最后一个字节设置为0\n    arr[1472] = 0\n    var buffer bytes.Buffer\n    binary.Write(&amp;buffer, binary.BigEndian, icmp)\n    binary.Write(&amp;buffer, binary.BigEndian, arr)\n    if _, err := conn.Write(buffer.Bytes()); err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n    conn.SetReadDeadline(time.Now().Add(time.Second * 5))\n    recv := make([]byte, 2048)\n    n, err := conn.Read(recv)\n    if err != nil {\n        fmt.Println(err.Error())\n    }\n    fmt.Printf(&quot;%#v&quot;, recv[:n])\n}</code></pre>\n<p>我们可以通过wireshark查看数据报具体信息</p>\n<p><img src=\"http://img-1251474779.cos.ap-beijing.myqcloud.com/IP%E5%8D%8F%E8%AE%AE/20191211022407734.png\" alt=\"第一分片IP数据报头部信息\"></p>\n<p>上图可以看到Flags设置了MF标志</p>\n<p><img src=\"http://img-1251474779.cos.ap-beijing.myqcloud.com/IP%E5%8D%8F%E8%AE%AE/20191211022558072.png\" alt=\"第二分片IP数据报头部信息\"></p>\n<p>上图可以看到设置了数据报偏移量$185*8=1480$</p>\n<p><img src=\"http://img-1251474779.cos.ap-beijing.myqcloud.com/IP%E5%8D%8F%E8%AE%AE/20191211022814706.png\" alt=\"第一分片IP数据报局部内容\"></p>\n<p>上图蓝色区域表示IP数据报的数据部分，前8字节表示ICMP头部信息，后面是ICMP数据</p>\n<p><img src=\"http://img-1251474779.cos.ap-beijing.myqcloud.com/IP%E5%8D%8F%E8%AE%AE/20191211022830044.png\" alt=\"第二分片IP数据报内容\"></p>\n<p>上图说明分片后的IP数据报数据是承接上一个数据报，内核收到这些数据后将其拼装成一个完整IP数据报</p>\n<h2 id=\"IP路由\"><a href=\"#IP路由\" class=\"headerlink\" title=\"IP路由\"></a>IP路由</h2><p>IP协议一个核心任务是数据报的路由，即决定发送数据报到目标机器的路径。</p>\n<h3 id=\"工作流程\"><a href=\"#工作流程\" class=\"headerlink\" title=\"工作流程\"></a>工作流程</h3><p><img src=\"http://img-1251474779.cos.ap-beijing.myqcloud.com/IP%E5%8D%8F%E8%AE%AE/IP%E6%A8%A1%E5%9D%97%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B.png\" alt=\"IP模块基本工作流程\"></p>\n<p>当IP模块收到来自数据链路层的IP数据报时，先对数据报头部做CRC校验，确认无误后就分析其头部的具体信息。<br>如果IP数据报头部设置了源站路由选择（松散源路由选择或严格源路由选择），则IP模块调用数据报转发子模块来处理数据报。如果该IP数据报的头部中目标IP地址是本机的某个IP地址或者是广播地址（即该数据报是发给本机的），则IP模块就根据数据报头部中的协议来决定将它派发给那个上层协议处理。如果IP模块发现这个数据报不是发给本机的，则调用数据报转发子模块来处理数据报。<br>IP数据报转发子模块首先检查系统是否允许转发，如果不允许，IP模块就将数据报丢弃，如果允许则将会进行数据报转发。<br>IP数据报应该发送至哪一个路由（或目标机器），以及用哪张网卡发送，就是IP路由的过程，都是由计算下一跳路由子模块处理。数据报路由的核心结构是路由表，由目标IP进行分类，同一类型的IP数据报将被发往相同的下一跳路由。<br>IP输出队列中存放的是所有等待发送的IP数据报，其中除了需要转发的数据报外，还有本机封装的上层协议的IP数据报。<br>虚线箭头显示路由表更新过程，这个过程是指通过路由协议或者route命令调整路由表，是指更适应最新的网络拓扑结构，称之为IP路由策略。</p>\n<h3 id=\"路由机制\"><a href=\"#路由机制\" class=\"headerlink\" title=\"路由机制\"></a>路由机制</h3><p>IP路由机制的核心就是IP路由表，可以使用route或者netstat查看路由表<br>路由表包含每项都有8个字段，字段含义如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">字段</th>\n<th align=\"left\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Destination</td>\n<td align=\"left\">目标网络或主机</td>\n</tr>\n<tr>\n<td align=\"center\">Gateway</td>\n<td align=\"left\">网关地址，<code>*</code>表示和本机在同一个网络</td>\n</tr>\n<tr>\n<td align=\"center\">Genmask</td>\n<td align=\"left\">网络掩码</td>\n</tr>\n<tr>\n<td align=\"center\">Flags</td>\n<td align=\"left\">路由标志常见的标志有：<br/><ul><li>U，该路由项是活动的</li><li>H，该路由项的目标是一台主机</li><li>G，该路由项的目标是网关</li><li>D，该路由项是有重定向生成的</li><li>M，该路由项被重新修改过</li></ul></td>\n</tr>\n<tr>\n<td align=\"center\">Metric</td>\n<td align=\"left\">路由距离，即到达指定网络所需的中转数</td>\n</tr>\n<tr>\n<td align=\"center\">Ref</td>\n<td align=\"left\">路由项被引用的次数（Linux未使用）</td>\n</tr>\n<tr>\n<td align=\"center\">Use</td>\n<td align=\"left\">该路由项被使用的次数</td>\n</tr>\n<tr>\n<td align=\"center\">Iface</td>\n<td align=\"left\">该路由项对应的输出网卡接口</td>\n</tr>\n</tbody></table>\n<p>我们可以执行route命令获取当前的路由表</p>\n<pre><code class=\"sh\"># route\nKernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\ndefault         gateway         0.0.0.0         UG    0      0        0 eth0\n172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</code></pre>\n<p>目标地址表示default，即默认路由，在标志中有<code>G</code>表示下一跳是网关，网关地址是<code>gateway</code>，如果Gateway是<code>*</code>，则不需要中转，直接发送目标机器。<br>IP的路由机制分为以下3个步骤：</p>\n<ul>\n<li>步骤1，查找路由表中和数据报的目标地址IP地址完全匹配的主机IP地址，如果找到就使用该路由项，如果没有找到则转到步骤2</li>\n<li>步骤2，查找路由表中和数据报的目标IP地址具有相同网络ID的网络IP地址，如果找到就使用该路由项，没有找到则转到步骤3</li>\n<li>步骤3，选择默认路由项，通常意味着下一跳路由是网关</li>\n</ul>\n<p>有上面的路由表可知，发送到IP地址为<code>172.17.*.*</code>（<code>172.17.0.0/16</code>）的地址都可以将数据报直接发送到目标机器（路由表第二项），所有访问Internet的请求都将通过默认网关转发。</p>\n<h3 id=\"路由表更新\"><a href=\"#路由表更新\" class=\"headerlink\" title=\"路由表更新\"></a>路由表更新</h3><p>路由表必须能够更新，以适应网络连接的变化，这样IP模块才能准确、高效的转发数据报。可以通过route命令手动修改路由表，是属于静态的路由更新方式，对于大型路由器，一般通过BGP（Border Gateway Protocol，边际网关协议）、RIP（Routing Information Protocol，路由信息协议）、OSPF（Open Shortest Path First，开放式最短路径优先）等协议来发现路径，并动态更新自己的路由表。</p>\n<h2 id=\"IP转发\"><a href=\"#IP转发\" class=\"headerlink\" title=\"IP转发\"></a>IP转发</h2><p>IP模块把不是发送给本机的IP数据报将由数据报转发子模块来处理，路由器都能执行数据报的转发操作，而主机一般只发送和接收数据报，这是因为主机上的<code>/proc/sys/net/ipv4/ip_forward</code>内核参数默认设置为0，我们可以修改这个值来使主机的数据报转发功能。<br>IP数据报转发操作流程：</p>\n<ul>\n<li>检查数据报头部的TTL值，如果TTL值是0，则丢弃该数据报</li>\n<li>查看数据报头部的阉割路由选择选项，如果该选项被设置，则检测数据报的目标IP地址是否是本机的某个IP地址，如果不是，则发送一个ICMP源站选路失败报文给发送端</li>\n<li>如果有必要，则给源端发送一个ICMP重定向报文，以告诉它一个更合理的下一跳路由器</li>\n<li>将TTL减1</li>\n<li>处理IP头部选项</li>\n<li>如果有必要，则执行IP分片操作</li>\n</ul>\n<h2 id=\"重定向\"><a href=\"#重定向\" class=\"headerlink\" title=\"重定向\"></a>重定向</h2><h3 id=\"ICMP重定向报文\"><a href=\"#ICMP重定向报文\" class=\"headerlink\" title=\"ICMP重定向报文\"></a>ICMP重定向报文</h3><p>利用ICMP重定向报文可以告诉目标机器IP数据报应该使用哪个路由器转发，并且以此来更新路由表（通常是更新路由表缓冲，而不是直接更改路由表）。<br><code>/proc/sys/net/ipv4/conf/all/send_redirects</code>内核参数指定是否允许发送ICMP重定向报文，<code>/proc/sys/net/ipv4/conf/all/accept_redirects</code>内核参数则指定是否允许接收ICMP重定向报文，一般来说主机只能接收ICMP从定向报文，而路由器只能发送ICMP重定向报文。</p>\n<h3 id=\"主机重定向\"><a href=\"#主机重定向\" class=\"headerlink\" title=\"主机重定向\"></a>主机重定向</h3><p>我们可以将目标主机设置开启转发功能，将本机网关设置为目标主机，这样就可以通过目标主机来访问Internet。<br>主机重定向流程：</p>\n<ul>\n<li>主机向目标主机发送IP数据报</li>\n<li>目标主机向路由器发送数据，发现主机可以直接发送给它的路由器是比较合理的路径</li>\n<li>目标主机向主机发送一个ICMP重定向报文</li>\n<li>后序的IP数据报，主机都会直接发送给路由器</li>\n</ul>\n<h1 id=\"IPv6\"><a href=\"#IPv6\" class=\"headerlink\" title=\"IPv6\"></a>IPv6</h1><p>随着网络技术的发展IPv4已经无法满足需求，而且目前IPv4的地址已经分配完毕。IPv6协议不仅解决了IPv4地址不够用的情况，还做了很多改进。比如：增加了多播和流功能，为网络上多媒体内容的质量提供精细的控制；引入自动配置功能，使局域网管理更方便；增加了专门的网络安全功能等。</p>\n<h2 id=\"头部结构-1\"><a href=\"#头部结构-1\" class=\"headerlink\" title=\"头部结构\"></a>头部结构</h2><p>IPv6头部由40字节固定头部和可变长的扩展头部组成</p>\n<p><img src=\"http://img-1251474779.cos.ap-beijing.myqcloud.com/IP%E5%8D%8F%E8%AE%AE/IPv6header.png\" alt=\"IPv6固定头部结构\"></p>\n<ul>\n<li>4位版本号（version）对于IPv6来说，其值是6</li>\n<li>8位通信类型（traffic class）只是数据流通信类型或优先级，和IPv4的TOS类似</li>\n<li>20位流标签（flow label）是IPv6新加字段，对于某些对连接的服务质量有特殊要求的通信，比如音频或视频等实时数据传输</li>\n<li>16位荷载长度（payload length）指的是IPv6扩展头部和应用程序长度之和，不包括固定头部长度</li>\n<li>8位下一个包头（next header）指出紧跟IPv6固定头部后的包头类型，如扩展头（如果有的话）或某个上层协议头（比如TCP，UPD和ICMP），它类似于IPv4头部中的协议字段，且取值相同含义相同</li>\n<li>8位跳数限制（hop limit）和IPv4的TTL相同</li>\n<li>128位表示源IP和目的IP地址，16字节使IP地址的总量达到了$2^{128}$个，号称IPv6能使地球上每一粒沙子都能分配一个IP地址</li>\n</ul>\n<p>IPv4使用点分十进制表示IP地址，而IPv6地址则使用16进制字符串表示，比如<code>fe80:0000:0000:0000:0000:0000:0000:0001</code>。IPv6地址使用<code>:</code>分隔成8组，每组包含，使用16进制表示2个字节。由于0太多的话，这样表示过于麻烦，所以可以使用零压缩法将其简写，就是省略中间全是0的组，上面的例子就可以简写成<code>fe80::1</code>，零压缩法只能在IPv6地址中使用一次，不然无法知道中间的省略了多少个零。</p>\n<h2 id=\"扩展头\"><a href=\"#扩展头\" class=\"headerlink\" title=\"扩展头\"></a>扩展头</h2><p>可变长的扩展头部使得IPv6能支持更多的选项，并且很便于将来的扩展需要。它的长度可以是零，表示数据报没有使用任何扩展头部，一个数据报可以包含多个扩展头部，每个扩展头部的类型由前一个头部（固定头部或扩展头部）中的下一个报头字段指定，目前使用的扩展头部有：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">扩展头部</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Hop-by-Hop</td>\n<td>逐跳选项头部，它包含每个路由器都必须检查和处理的特殊参数选项</td>\n</tr>\n<tr>\n<td align=\"center\">Destination option</td>\n<td>目的选项头部，指定由最终目的节点处理的选项</td>\n</tr>\n<tr>\n<td align=\"center\">Routing</td>\n<td>路由头部，指定数据报要经过哪些中转路由，功能类似于IPv4的松散源路由选择选项和记录路由选项</td>\n</tr>\n<tr>\n<td align=\"center\">Fragment</td>\n<td>分片头部，处理分片和重组的细节</td>\n</tr>\n<tr>\n<td align=\"center\">Authentication</td>\n<td>认证头部，提供数据源认证、数据完整性检查和反重播保护</td>\n</tr>\n<tr>\n<td align=\"center\">Encapsulation Security Payload</td>\n<td>加密头部，提供加密服务</td>\n</tr>\n<tr>\n<td align=\"center\">No next header</td>\n<td>没有后续扩展头部</td>\n</tr>\n</tbody></table>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ul>\n<li>《Linux高性能服务器编程》</li>\n</ul>\n"},{"author":"djaigo","title":"golang-协程栈","img":"https://img-1251474779.cos.ap-beijing.myqcloud.com/golang.png","date":"2020-10-28T03:01:55.000Z","_content":"\ngolang栈的增长方向\n```go\nfunc main() {\n\ta := 1\n\tb := 2\n\tfmt.Println(&a, &b)\n}\n\n// output: 0xc00036a2b0 0xc00036a2b8\n```\n\n由此可见栈的增长方向是由低地址向高地址增长\n\n\n","source":"_posts/golang-协程栈.md","raw":"---\nauthor: djaigo\ntitle: golang-协程栈\nimg: 'https://img-1251474779.cos.ap-beijing.myqcloud.com/golang.png'\ncategories:\n  - golang\ntags:\n  - runtime\ndate: 2020-10-28 11:01:55\n---\n\ngolang栈的增长方向\n```go\nfunc main() {\n\ta := 1\n\tb := 2\n\tfmt.Println(&a, &b)\n}\n\n// output: 0xc00036a2b0 0xc00036a2b8\n```\n\n由此可见栈的增长方向是由低地址向高地址增长\n\n\n","slug":"golang-协程栈","published":1,"updated":"2020-10-28T03:01:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh351dud000t19z4bcbmg2p0","content":"<p>golang栈的增长方向</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    a <span class=\"token operator\">:=</span> <span class=\"token number\">1</span>\n    b <span class=\"token operator\">:=</span> <span class=\"token number\">2</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>b<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// output: 0xc00036a2b0 0xc00036a2b8</span></code></pre>\n<p>由此可见栈的增长方向是由低地址向高地址增长</p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"friends":[{"avatar":"https://img-1251474779.cos.ap-beijing.myqcloud.com/icon.png","name":"djaigo","introduction":"好好学习，天天向上","url":"/","title":"前去学习"},{"avatar":"https://awps-assets.meituan.net/mit/blog/v20190629/asset/icon/favicon.ico?v=Whistle&t=20181017-1r","name":"美团技术团队","introduction":"一行代码，亿万生活。","url":"https://tech.meituan.com/","title":"点个外卖-->"},{"avatar":"","name":"鸟窝","introduction":"rpcx作者","url":"https://colobu.com/","title":"进个鸟窝-->"},{"avatar":"https://d1j8pt39hxlh3d.cloudfront.net/emoji/emojione/5.0/png/unicode/32/1f92a.png","name":"labuladong的算法小抄","introduction":"算法大神","url":"https://labuladong.gitbook.io/algo/","title":"学个算法-->"}]}},"excerpt":"","more":"<p>golang栈的增长方向</p>\n<pre><code class=\"go\">func main() {\n    a := 1\n    b := 2\n    fmt.Println(&amp;a, &amp;b)\n}\n\n// output: 0xc00036a2b0 0xc00036a2b8</code></pre>\n<p>由此可见栈的增长方向是由低地址向高地址增长</p>\n"},{"author":"djaigo","title":"golang MPG调度","img":"https://img-1251474779.cos.ap-beijing.myqcloud.com/golang.png","date":"2020-08-07T11:40:47.000Z","updated":"2020-08-07T11:40:47.000Z","_content":"\n# MPG\nMPG是golang的并发模型，结构源码在`runtime/runtime2.go`里面，主体逻辑结构在`runtime/proc.go`里，是golang可以高并发的根本。\n* M，连接一个内核态的线程，goroutine跑在M上，每个M都会有一个g0的G，用于协调P队列里的G，在调度或系统调用时会用到g0的栈\n* P，维护执行G队列，管理G上下文\n* G，代表goroutine的元数据，包括栈信息，M信息，计数器等\n\n除了MPG之外，还有Sched来负责全局队列的处理。\n四者协同完成整个golang的高并发处理的主要逻辑，还有其他小的结构进行辅助，例如：sudog（G队列）、stack（栈信息）等。\n\nM、P数量：\n* P的数量可以在启动时通过环境变量`$GOMAXPROCS`，或在代码中通过`runtime`包的`GOMAXPROCS()`设置。P的数量限制了最大goroutine并发执行数。\n* M的数量在启动时会被`schedinit()`设置成`sched.maxmcount = 10000`，可在代码中调用`runtime/debug`包的`SetMaxThreads()`。M的数量限制了最大可用的系统线程数。\n\nM、P创建：\n* P，在系统确定了P的数量后就会创建指定个数的P\n* M，如果P没有M，则会去全局休眠M队列中找，如果还没有则会创建M\n\nM调度策略：\n* work stealing，当M执行G结束后，会从绑定P中获取G，而不是销毁当前M\n* hand off，当G调用阻塞系统调用时，M释放绑定的P，将P交给空闲的M\n\n## 生命周期\n程序启动第一时间都会调用`runtime.main()`，进行相关值的初始化。\n```\n// The main goroutine.\nfunc main() {\n\tg := getg()\n\n\t// Racectx of m0->g0 is used only as the parent of the main goroutine.\n\t// It must not be used for anything else.\n\tg.m.g0.racectx = 0\n\n\t// Max stack size is 1 GB on 64-bit, 250 MB on 32-bit.\n\t// Using decimal instead of binary GB and MB because\n\t// they look nicer in the stack overflow failure message.\n\t// 设置栈的最大值\n\tif sys.PtrSize == 8 {\n\t\tmaxstacksize = 1000000000\n\t} else {\n\t\tmaxstacksize = 250000000\n\t}\n\n\t// Allow newproc to start new Ms.\n\t// 允许新P创建M\n\tmainStarted = true\n\n\tif GOARCH != \"wasm\" { // no threads on wasm yet, so no sysmon\n\t\tsystemstack(func() {\n\t\t\tnewm(sysmon, nil, -1)\n\t\t})\n\t}\n\n\t// Lock the main goroutine onto this, the main OS thread,\n\t// during initialization. Most programs won't care, but a few\n\t// do require certain calls to be made by the main thread.\n\t// Those can arrange for main.main to run in the main thread\n\t// by calling runtime.LockOSThread during initialization\n\t// to preserve the lock.\n\tlockOSThread()\n\n\tif g.m != &m0 {\n\t\tthrow(\"runtime.main not on m0\")\n\t}\n\n\tdoInit(&runtime_inittask) // must be before defer\n\tif nanotime() == 0 {\n\t\tthrow(\"nanotime returning zero\")\n\t}\n\n\t// Defer unlock so that runtime.Goexit during init does the unlock too.\n\tneedUnlock := true\n\tdefer func() {\n\t\tif needUnlock {\n\t\t\tunlockOSThread()\n\t\t}\n\t}()\n\n\t// Record when the world started.\n\t// 记录启动时间\n\truntimeInitTime = nanotime()\n\n\tgcenable() // 开启GC\n    ...\n\tneedUnlock = false\n\tunlockOSThread()\n\n\tif isarchive || islibrary {\n\t\t// A program compiled with -buildmode=c-archive or c-shared\n\t\t// has a main, but it is not executed.\n\t\treturn\n\t}\n\t\n\t// 执行main包的main函数\n\tfn := main_main // make an indirect call, as the linker doesn't know the address of the main package when laying down the runtime\n\tfn()\n\tif raceenabled {\n\t\tracefini() // 竞态检测\n\t}\n\n\t// Make racy client program work: if panicking on\n\t// another goroutine at the same time as main returns,\n\t// let the other goroutine finish printing the panic trace.\n\t// Once it does, it will exit. See issues 3934 and 20018.\n    // 如果goroutine panic了则创建另一个goroutine打印相关信息，完成之后新建goroutine将退出\n\tif atomic.Load(&runningPanicDefers) != 0 {\n\t\t// Running deferred functions should not take long.\n\t\tfor c := 0; c < 1000; c++ {\n\t\t\tif atomic.Load(&runningPanicDefers) == 0 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tGosched()\n\t\t}\n\t}\n\tif atomic.Load(&panicking) != 0 {\n\t\tgopark(nil, nil, waitReasonPanicWait, traceEvGoStop, 1)\n\t}\n\n\texit(0) // 退出进程\n\tfor {\n\t\tvar x *int32\n\t\t*x = 0\n\t}\n}\n```\n\n在程序启动时会创建m0，同时创建g0，在`runtime/proc.go`声明：\n```go\nvar (\n\tm0 m\n\tg0 g\n)\n```\n\n> 特殊的m0，是启动程序后的编号为0的主线程，这个M对应的实例会在全局变量`runtime.m0`中，不需要在heap上分配，m0负责执行初始化操作和启动第一个G，在之后M0就和其他的一样了。\n\n初始化P，创建`main()`的g1，将g1存放于p的本地G队列中，启动m0，m0绑定p，如果绑定不成功就会进入全局休眠M队列等待被唤醒，从p中获取可执行的G，如果没有课执行的G则会进入自旋状态，如果获取到g1，设置g1的运行环境，运行g1，g1退出，m0继续通过p获取G。\n\n> 自旋状态，是指M绑定的P没有可以执行的G，此时M执行的g0，轮询P的本地空闲G队列有没有可执行的G\n\n## 三者关系\n*   `G`需要绑定在`M`上才能运行；\n*   `M`需要绑定`P`才能运行；\n*   程序中的多个`M`并不会同时都处于执行状态，最多只有`GOMAXPROCS`个`M`在执行。\n\n 早期版本的Golang是没有`P`的，调度是由`G`与`M`完成。 这样的问题在于每当创建、终止Goroutine或者需要调度时，需要一个全局的锁来保护调度的相关对象(sched)。 全局锁严重影响Goroutine的并发性能。\n 通过引入`P`，实现了一种叫做`work-stealing`的调度算法：\n\n*   每个`P`维护一个`G`队列；\n*   当一个`G`被创建出来，或者变为可执行状态时，就把他放到`P`的可执行队列中；\n*   当一个`G`执行结束时，`P`会从队列中把该`G`取出；如果此时`P`的队列为空，即没有其他`G`可以执行， 就随机选择另外一个`P`，从其可执行的`G`队列中偷取一半。\n\n该算法避免了在Goroutine调度时使用全局锁。\n\n\n# 可视化\n## trace\n代码：\n```\npackage main\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"runtime/trace\"\n)\n\nfunc main() {\n    f, err := os.Create(\"trace.out\")\n    if err != nil {\n        panic(err)\n    }\n    \n    defer f.Close()\n    \n    err = trace.Start(f)\n    if err != nil {\n        panic(err)\n    }\n    defer trace.Stop()\n    \n    fmt.Println(\"Hello world!\")\n}\n```\n\n运行程序会生成一个trace.out的文件，可以通过tool工具将其可视化\n```\n➜ go tool trace trace.out\n```\n\n这样写会对代码侵入太强，可以写成测试文件，在test的时候生成trace.out文件，在`Test()`不需要显式的调用上面的代码，代码如下：\n```\npackage main\n\nimport (\n    \"fmt\"\n    \"testing\"\n)\n\nfunc Test(t *testing.T) {\n    fmt.Println(\"Hello world!\")\n}\n```\n\n执行代码\n```\ngo test -trace trace.out -run Test\n```\n\n也可以生成trace.out文件。\n在有了trace.out文件后，执行`go tool trace trace.out`，启动http服务可视化查看MPG的相关信息。\n\n\n## debug\n代码：\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\nfunc main() {\n    fmt.Println(\"Hello world!\")\n}\n```\n\n在执行之前设置`GODEBUG=schedtrace=10`，单位毫秒\n执行结果\n```sh\nGODEBUG=schedtrace=10 go run main.go \nSCHED 0ms: gomaxprocs=4 idleprocs=1 threads=6 spinningthreads=1 idlethreads=0 runqueue=0 [1 0 0 0]\nSCHED 18ms: gomaxprocs=4 idleprocs=0 threads=9 spinningthreads=1 idlethreads=2 runqueue=1 [0 4 0 0]\nSCHED 30ms: gomaxprocs=4 idleprocs=1 threads=9 spinningthreads=1 idlethreads=2 runqueue=0 [0 0 0 0]\nSCHED 42ms: gomaxprocs=4 idleprocs=2 threads=9 spinningthreads=0 idlethreads=3 runqueue=1 [0 0 0 0]\nSCHED 53ms: gomaxprocs=4 idleprocs=4 threads=9 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]\nSCHED 66ms: gomaxprocs=4 idleprocs=0 threads=9 spinningthreads=1 idlethreads=2 runqueue=1 [0 0 0 0]\nSCHED 79ms: gomaxprocs=4 idleprocs=3 threads=9 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]\n```\n\n* `SCHED 0ms`：调试信息输出标志字符串，后面是执行的时间戳\n* `gomaxprocs`：P的数量，本例有4个P，默认与cpu核心数量一致，可以通过GOMAXPROCS来设置\n* `idleprocs`：处于idle状态P的数量\n* `threads`：M的数量，包含scheduler使用的M数量，加上runtime自用的类似sysmon这样的thread的数量\n* `spinningthreads`: 处于自旋状态M数量\n* `idlethread`: 处于idle状态的M的数量\n* `runqueue=0`：Scheduler全局队列中G的数量\n* `[0 0 0 0]`: 分别为4个的`local queue`中的G的数量\n\n# 关键字段说明\n## M\n```go\ntype m struct {\n\tg0      *g     // goroutine with scheduling stack\n\tmorebuf gobuf  // gobuf arg to morestack\n\tdivmod  uint32 // div/mod denominator for arm - known to liblink\n\n\t// Fields not known to debuggers.\n\tprocid        uint64       // for debuggers, but offset not hard-coded\n\tgsignal       *g           // signal-handling g\n\tgoSigStack    gsignalStack // Go-allocated signal handling stack\n\tsigmask       sigset       // storage for saved signal mask\n\ttls           [6]uintptr   // thread-local storage (for x86 extern register)\n\tmstartfn      func()\n\tcurg          *g       // 当前执行的G，检测gp\n\tcaughtsig     guintptr // goroutine running during fatal signal\n\tp             puintptr // 绑定的P执行go代码 (如果没有执行go代码则为nil)\n\tnextp         puintptr\n\toldp          puintptr // 执行系统调用之前的P\n\tid            int64\n\tmallocing     int32\n\tthrowing      int32\n\tpreemptoff    string // if != \"\", keep curg running on this m\n\tlocks         int32  // m的引用计数 \n\tdying         int32\n\tprofilehz     int32\n\tspinning      bool // m is out of work and is actively looking for work\n\tblocked       bool // m is blocked on a note\n\tnewSigstack   bool // minit on C thread called sigaltstack\n\tprintlock     int8\n\tincgo         bool   // m is executing a cgo call\n\tfreeWait      uint32 // if == 0, safe to free g0 and delete m (atomic)\n\tfastrand      [2]uint32 // 两个随机值，不能同时为0\n\tneedextram    bool\n\ttraceback     uint8\n\tncgocall      uint64      // number of cgo calls in total\n\tncgo          int32       // number of cgo calls currently in progress\n\tcgoCallersUse uint32      // if non-zero, cgoCallers in use temporarily\n\tcgoCallers    *cgoCallers // cgo traceback if crashing in cgo call\n\tpark          note\n\talllink       *m // on allm\n\tschedlink     muintptr    // M的单链表\n\tlockedg       guintptr    // M锁定的G\n\tcreatestack   [32]uintptr // stack that created this thread.\n\tlockedExt     uint32      // tracking for external LockOSThread\n\tlockedInt     uint32      // tracking for internal lockOSThread\n\tnextwaitm     muintptr    // next m waiting for lock\n\twaitunlockf   func(*g, unsafe.Pointer) bool\n\twaitlock      unsafe.Pointer\n\twaittraceev   byte\n\twaittraceskip int\n\tstartingtrace bool\n\tsyscalltick   uint32\n\tfreelink      *m // 对应全局休眠M队列\n\n\t// these are here because they are too large to be on the stack\n\t// of low-level NOSPLIT functions.\n\tlibcall   libcall\n\tlibcallpc uintptr // for cpu profiler\n\tlibcallsp uintptr\n\tlibcallg  guintptr\n\tsyscall   libcall // stores syscall parameters on windows\n\n\tvdsoSP uintptr // SP for traceback while in VDSO call (0 if not in call)\n\tvdsoPC uintptr // PC for traceback while in VDSO call\n\n\t// preemptGen counts the number of completed preemption\n\t// signals. This is used to detect when a preemption is\n\t// requested, but fails. Accessed atomically.\n\tpreemptGen uint32\n\n\t// Whether this is a pending preemption signal on this M.\n\t// Accessed atomically.\n\tsignalPending uint32\n\n\tdlogPerM\n\n\tmOS\n\n\t// Up to 10 locks held by this m, maintained by the lock ranking code.\n\tlocksHeldLen int\n\tlocksHeld    [10]heldLockInfo\n}\n```\n\n## P\n```go\ntype p struct {\n\tid          int32\n\tstatus      uint32 // one of pidle/prunning/...\n\tlink        puintptr   // P的单链表\n\tschedtick   uint32     // incremented on every scheduler call\n\tsyscalltick uint32     // incremented on every system call\n\tsysmontick  sysmontick // last tick observed by sysmon\n\tm           muintptr   // 当前的M，如果空闲则为nil\n\tmcache      *mcache\n\tpcache      pageCache\n\traceprocctx uintptr\n\n\tdeferpool    [5][]*_defer // pool of available defer structs of different sizes (see panic.go)\n\tdeferpoolbuf [5][32]*_defer\n\n\t// Cache of goroutine ids, amortizes accesses to runtime·sched.goidgen.\n\tgoidcache    uint64\n\tgoidcacheend uint64\n\n\t// Queue of runnable goroutines. Accessed without lock.\n\trunqhead uint32         // 队首下标\n\trunqtail uint32         // 队尾下标\n\trunq     [256]guintptr  // 可执行队列，最多256个\n\t// runnext, if non-nil, is a runnable G that was ready'd by\n\t// the current G and should be run next instead of what's in\n\t// runq if there's time remaining in the running G's time\n\t// slice. It will inherit the time left in the current time\n\t// slice. If a set of goroutines is locked in a\n\t// communicate-and-wait pattern, this schedules that set as a\n\t// unit and eliminates the (potentially large) scheduling\n\t// latency that otherwise arises from adding the ready'd\n\t// goroutines to the end of the run queue.\n\trunnext guintptr\n\n\t// Available G's (status == Gdead)\n\tgFree struct {\n\t\tgList\n\t\tn int32\n\t}\n\n\tsudogcache []*sudog     // 本地G的队列\n\tsudogbuf   [128]*sudog\n\n\t// Cache of mspan objects from the heap.\n\tmspancache struct {\n\t\t// We need an explicit length here because this field is used\n\t\t// in allocation codepaths where write barriers are not allowed,\n\t\t// and eliminating the write barrier/keeping it eliminated from\n\t\t// slice updates is tricky, moreso than just managing the length\n\t\t// ourselves.\n\t\tlen int\n\t\tbuf [128]*mspan\n\t}\n\n\ttracebuf traceBufPtr\n\n\t// traceSweep indicates the sweep events should be traced.\n\t// This is used to defer the sweep start event until a span\n\t// has actually been swept.\n\ttraceSweep bool\n\t// traceSwept and traceReclaimed track the number of bytes\n\t// swept and reclaimed by sweeping in the current sweep loop.\n\ttraceSwept, traceReclaimed uintptr\n\n\tpalloc persistentAlloc // per-P to avoid mutex\n\n\t_ uint32 // Alignment for atomic fields below\n\n\t// The when field of the first entry on the timer heap.\n\t// This is updated using atomic functions.\n\t// This is 0 if the timer heap is empty.\n\ttimer0When uint64\n\n\t// Per-P GC state\n\tgcAssistTime         int64    // Nanoseconds in assistAlloc\n\tgcFractionalMarkTime int64    // Nanoseconds in fractional mark worker (atomic)\n\tgcBgMarkWorker       guintptr // (atomic)\n\tgcMarkWorkerMode     gcMarkWorkerMode\n\n\t// gcMarkWorkerStartTime is the nanotime() at which this mark\n\t// worker started.\n\tgcMarkWorkerStartTime int64\n\n\t// gcw is this P's GC work buffer cache. The work buffer is\n\t// filled by write barriers, drained by mutator assists, and\n\t// disposed on certain GC state transitions.\n\tgcw gcWork\n\n\t// wbBuf is this P's GC write barrier buffer.\n\t//\n\t// TODO: Consider caching this in the running G.\n\twbBuf wbBuf\n\n\trunSafePointFn uint32 // if 1, run sched.safePointFn at next safe point\n\n\t// Lock for timers. We normally access the timers while running\n\t// on this P, but the scheduler can also do it from a different P.\n\ttimersLock mutex\n\n\t// Actions to take at some time. This is used to implement the\n\t// standard library's time package.\n\t// Must hold timersLock to access.\n\ttimers []*timer\n\n\t// Number of timers in P's heap.\n\t// Modified using atomic instructions.\n\tnumTimers uint32\n\n\t// Number of timerModifiedEarlier timers on P's heap.\n\t// This should only be modified while holding timersLock,\n\t// or while the timer status is in a transient state\n\t// such as timerModifying.\n\tadjustTimers uint32\n\n\t// Number of timerDeleted timers in P's heap.\n\t// Modified using atomic instructions.\n\tdeletedTimers uint32\n\n\t// Race context used while executing timer functions.\n\ttimerRaceCtx uintptr\n\n\t// preempt is set to indicate that this P should be enter the\n\t// scheduler ASAP (regardless of what G is running on it).\n\tpreempt bool\n\n\tpad cpu.CacheLinePad\n}\n```\n\n## G\n```go\ntype g struct {\n\t// Stack parameters.\n\t// stack describes the actual stack memory: [stack.lo, stack.hi).\n\t// stackguard0 is the stack pointer compared in the Go stack growth prologue.\n\t// It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption.\n\t// stackguard1 is the stack pointer compared in the C stack growth prologue.\n\t// It is stack.lo+StackGuard on g0 and gsignal stacks.\n\t// It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash).\n\tstack       stack   // offset known to runtime/cgo\n\tstackguard0 uintptr // offset known to liblink\n\tstackguard1 uintptr // offset known to liblink\n\n\t_panic       *_panic // innermost panic - offset known to liblink\n\t_defer       *_defer // innermost defer\n\tm            *m      // 当前M；offset known to arm liblink\n\tsched        gobuf\n\tsyscallsp    uintptr        // if status==Gsyscall, syscallsp = sched.sp to use during gc\n\tsyscallpc    uintptr        // if status==Gsyscall, syscallpc = sched.pc to use during gc\n\tstktopsp     uintptr        // expected sp at top of stack, to check in traceback\n\tparam        unsafe.Pointer // passed parameter on wakeup\n\tatomicstatus uint32     // G的状态\n\tstackLock    uint32     // sigprof/scang lock; TODO: fold in to atomicstatus\n\tgoid         int64      // goroutine id\n\tschedlink    guintptr   // 下一个G的地址\n\twaitsince    int64      // approx time when the g become blocked\n\twaitreason   waitReason // if status==Gwaiting\n\n\tpreempt       bool // preemption signal, duplicates stackguard0 = stackpreempt\n\tpreemptStop   bool // transition to _Gpreempted on preemption; otherwise, just deschedule\n\tpreemptShrink bool // shrink stack at synchronous safe point\n\n\t// asyncSafePoint is set if g is stopped at an asynchronous\n\t// safe point. This means there are frames on the stack\n\t// without precise pointer information.\n\tasyncSafePoint bool\n\n\tpaniconfault bool // panic (instead of crash) on unexpected fault address\n\tgcscandone   bool // g has scanned stack; protected by _Gscan bit in status\n\tthrowsplit   bool // must not split stack\n\t// activeStackChans indicates that there are unlocked channels\n\t// pointing into this goroutine's stack. If true, stack\n\t// copying needs to acquire channel locks to protect these\n\t// areas of the stack.\n\tactiveStackChans bool\n\n\traceignore     int8     // ignore race detection events\n\tsysblocktraced bool     // StartTrace has emitted EvGoInSyscall about this goroutine\n\tsysexitticks   int64    // cputicks when syscall has returned (for tracing)\n\ttraceseq       uint64   // trace event sequencer\n\ttracelastp     puintptr // last P emitted an event for this goroutine\n\tlockedm        muintptr\n\tsig            uint32\n\twritebuf       []byte\n\tsigcode0       uintptr\n\tsigcode1       uintptr\n\tsigpc          uintptr\n\tgopc           uintptr         // pc of go statement that created this goroutine\n\tancestors      *[]ancestorInfo // ancestor information goroutine(s) that created this goroutine (only used if debug.tracebackancestors)\n\tstartpc        uintptr         // pc of goroutine function\n\tracectx        uintptr\n\twaiting        *sudog         // sudog structures this g is waiting on (that have a valid elem ptr); in lock order\n\tcgoCtxt        []uintptr      // cgo traceback context\n\tlabels         unsafe.Pointer // profiler labels\n\ttimer          *timer         // cached timer for time.Sleep\n\tselectDone     uint32         // are we participating in a select and did someone win the race?\n\n\t// Per-G GC state\n\n\t// gcAssistBytes is this G's GC assist credit in terms of\n\t// bytes allocated. If this is positive, then the G has credit\n\t// to allocate gcAssistBytes bytes without assisting. If this\n\t// is negative, then the G must correct this by performing\n\t// scan work. We track this in bytes to make it fast to update\n\t// and check for debt in the malloc hot path. The assist ratio\n\t// determines how this corresponds to scan work debt.\n\tgcAssistBytes int64\n}\n```\n\n## Sched\n```go\ntype schedt struct {\n\t// accessed atomically. keep at top to ensure alignment on 32-bit systems.\n\tgoidgen   uint64\n\tlastpoll  uint64 // time of last network poll, 0 if currently polling\n\tpollUntil uint64 // time to which current poll is sleeping\n\n\tlock mutex // 操作锁，锁定schedt\n\n\t// When increasing nmidle, nmidlelocked, nmsys, or nmfreed, be\n\t// sure to call checkdead().\n\n\tmidle        muintptr // 空闲M单链表\n\tnmidle       int32    // 空闲M的个数\n\tnmidlelocked int32    // number of locked m's waiting for work\n\tmnext        int64    // number of m's that have been created and next M ID\n\tmaxmcount    int32    // maximum number of m's allowed (or die)\n\tnmsys        int32    // number of system m's not counted for deadlock\n\tnmfreed      int64    // cumulative number of freed m's\n\n\tngsys uint32 // number of system goroutines; updated atomically\n\n\tpidle      puintptr // 空闲的P\n\tnpidle     uint32\n\tnmspinning uint32 // See \"Worker thread parking/unparking\" comment in proc.go.\n\n\t// Global runnable queue.\n\trunq     gQueue  // 全局可执行队列\n\trunqsize int32   // 全局队列大小\n\n\t// disable控制有选择的禁用调度\n\t//\n\t// 使用schedEnableUser(enable bool)进行控制\n\t//\n\t// disable需要被sched.lock保护\n\tdisable struct {\n\t\t// user是否禁止调度goroutines.\n\t\tuser     bool\n\t\trunnable gQueue // pending runnable Gs\n\t\tn        int32  // length of runnable\n\t}\n\n\t// Global cache of dead G's.\n\tgFree struct {\n\t\tlock    mutex\n\t\tstack   gList // Gs with stacks\n\t\tnoStack gList // Gs without stacks\n\t\tn       int32\n\t}\n\n\t// Central cache of sudog structs.\n\tsudoglock  mutex  // 全局空闲G队列锁\n\tsudogcache *sudog // 全局空闲G队列\n\n\t// Central pool of available defer structs of different sizes.\n\tdeferlock mutex\n\tdeferpool [5]*_defer\n\n\t// freem is the list of m's waiting to be freed when their\n\t// m.exited is set. Linked through m.freelink.\n\tfreem *m // 全局休眠M队列\n\n\tgcwaiting  uint32 // gc is waiting to run\n\tstopwait   int32\n\tstopnote   note\n\tsysmonwait uint32\n\tsysmonnote note\n\n\t// safepointFn should be called on each P at the next GC\n\t// safepoint if p.runSafePointFn is set.\n\tsafePointFn   func(*p)\n\tsafePointWait int32\n\tsafePointNote note\n\n\tprofilehz int32 // cpu profiling rate\n\n\tprocresizetime int64 // nanotime() of last change to gomaxprocs\n\ttotaltime      int64 // ∫gomaxprocs dt up to procresizetime\n\n\t// sysmonlock protects sysmon's actions on the runtime.\n\t//\n\t// Acquire and hold this mutex to block sysmon from interacting\n\t// with the rest of the runtime.\n\tsysmonlock mutex\n}\n```\n\n\n# 字段和结构体\n## G状态\n```go\nconst (\n\t// G status\n\t//\n\t// 除了指示G的一般状态外，G状态还像goroutine堆栈上的锁一样（因此具有执行用户代码的能力）。\n\n\t// _Gidle表示此goroutine已分配，尚未初始化。\n\t_Gidle = iota // 0\n\n\t// _Grunnable表示此goroutine在运行队列中，当前未执行用户代码，没有堆栈。\n\t_Grunnable // 1\n\n\t// _Grunning表示此goroutine可以执行用户代码。\n\t// 该goroutine拥有堆栈，且不在运行队列中。\n\t// 它已分配一个M和一个P。\n\t_Grunning // 2\n\n\t// _Gsyscall表示此goroutine正在执行系统调用。\n\t// 它不执行用户代码，堆栈由该goroutine拥有，它不在运行队列中。\n\t// 它被分配了一个M。\n\t_Gsyscall // 3\n\n\t// _Gwaiting 意味着goroutine被runtime阻止。\n\t// 它不执行用户代码，它也不再运行队列，但应该被记录下来（例如：等待chan中的数据），必要时可以调用ready()恢复。\n\t// 除chan操作可以在适当的锁下读取或写入堆栈的某些部分外，不应该拥有该堆栈。\n\t_Gwaiting // 4\n\n\t// _Gmoribund_unused当前未使用，但已在gdb脚本中进行了硬编码。\n\t_Gmoribund_unused // 5\n\n\t// _Gdead表示此goroutine当前未使用。\n\t// 它有可能已退出，在空闲列表或刚被初始化。它不能执行用户代码。它可能拥有堆栈也可能不拥有堆栈。\n\t// G及其堆栈（如果有）由退出G或从空闲列表中获得G的M拥有。\n\t_Gdead // 6\n\n\t// _Genqueue_unused当前未使用。\n\t_Genqueue_unused // 7\n\n\t// _Gcopystack表示此goroutine的堆栈正在迁移。\n\t// 它不能执行用户代码，并且不再运行队列中。\n\t// 堆栈由将其放入_Gcopystack的goroutine拥有。\n\t_Gcopystack // 8\n\n\t// _Gscan与上述状态之一组合表示GC正在扫描堆栈（除_Grunning）。\n\t// goroutine未执行用户代码，并且堆栈由设置_Gscan位的goroutine拥有。\n\t// _Gscanrunning不同: 它用于短暂阻止状态转换，而GC则通知G扫描其自身的堆栈。否则就像_Grunning。\n\t// atomicstatus&~Gscan 给出goroutine将在扫描完成时返回的状态。\n\t_Gscan         = 0x1000\n\t_Gscanrunnable = _Gscan + _Grunnable // 0x1001\n\t_Gscanrunning  = _Gscan + _Grunning  // 0x1002\n\t_Gscansyscall  = _Gscan + _Gsyscall  // 0x1003\n\t_Gscanwaiting  = _Gscan + _Gwaiting  // 0x1004\n)\n```\n\n## P状态\n```go\nconst (\n\t// P status\n\n\t// _Pidle表示不使用P来运行用户代码或调度程序。\n\t// 它在空闲的P列表中，可供调度程序使用，但可能只是在其他状态之间转换。\n\t//\n\t// P由空闲列表或转换其状态的任何内容所拥有。它的运行队列为空。\n\t_Pidle = iota\n\n\t// _Prunning表示P由M拥有，并用于运行用户代码或调度程序。\n\t// 仅拥有此P的M允许从_Prunning更改P的状态。\n\t// M可以将P转换为_Pidle（如果没有更多工作要做），_Psyscall（进入系统调用时）或_Pgcstop（以停止GC）。\n\t// M也可以将P的所有权直接移交给另一个M（例如，调度锁定的G）。\n\t_Prunning\n\n\t// _Psyscall表示P没有运行用户代码。\n\t// 它与系统调用中的M有亲缘关系，但不归其所有，并且可能被另一个M窃取。\n\t// 这类似于_Pidle，但使用轻量级转换并保持M相似性。\n\t//\n\t// 必须通过CAS离开_Psyscall才能窃取或重新获得P。\n\t// 注意ABA危害：\n\t// 即使M在系统调用后成功将其原始P恢复为_Prunning，它也必须了解该P在此期间可能已被另一个M使用。\n\t_Psyscall\n\n\t// _Pgcstop表示对STW(stop the world)暂停P并由STW的M拥有。\n\t// STW的M甚至在_Pgcstop中也继续使用其P。\n\t// 从_Prunning过渡到_Pgcstop会导致M释放其P并停放。\n\t//\n\t// P保留其运行队列，STW将使用非空运行队列在P上重新启动调度程序。\n\t_Pgcstop\n\n\t// _Pdead表示不再使用P（GOMAXPROCS缩小），如果P的数量增加将会复用P。\n\t// 一个死掉的P大部分被剥夺了其资源，尽管还剩下一些东西（例如跟踪缓冲区）。\n\t_Pdead\n)\n```\n\n## runtime2.go 全局变量\n```go\nvar (\n\tallglen    uintptr // allgs的长度\n\tallm       *m      // 所有m的单链表\n\tallp       []*p    // 所有的P列表，len(allp) == gomaxprocs，只能通过GOMAXPROCS()修改\n\tallpLock   mutex   // Protects P-less reads of allp and all writes\n\tgomaxprocs int32         // 最大P的数量\n\tncpu       int32         // CPU数\n\tforcegc    forcegcstate\n\tsched      schedt        // 调度者\n\tnewprocs   int32\n\n\t// Information about what cpu features are available.\n\t// Packages outside the runtime should not use these\n\t// as they are not an external api.\n\t// Set on startup in asm_{386,amd64}.s\n\tprocessorVersionInfo uint32\n\tisIntel              bool\n\tlfenceBeforeRdtsc    bool\n\n\tgoarm                uint8 // set by cmd/link on arm systems\n\tframepointer_enabled bool  // set by cmd/link\n)\n\nvar (\n\tallgs    []*g  // 所有g的单链表\n\tallglock mutex // 修改单链表锁\n)\n```\n\n\n## sodug\n```\ntype hchan struct {\n\tqcount   uint           // 队列元素总数\n\tdataqsiz uint           // 循环队列的大小\n\tbuf      unsafe.Pointer // 指向dataqsiz元素数组\n\telemsize uint16\n\tclosed   uint32\n\telemtype *_type // element type\n\tsendx    uint   // send index\n\trecvx    uint   // receive index\n\trecvq    waitq  // list of recv waiters\n\tsendq    waitq  // list of send waiters\n\n\t// lock保护hchan的所有字段，也保护sudog的所有字段在这个channel。\n\t//\n\t// 锁住此锁时，请勿更改另一个G的状态（特别是不要对G调用ready），因为这会因堆栈收缩而死锁。\n\tlock mutex\n}\n\ntype waitq struct {\n\tfirst *sudog\n\tlast  *sudog\n}\n\n// sudog 表示可执行G的列表，一个G可能在多个sudog中，\n// 并且许多G可能正在等待同一个同步对象，因此一个对象可能有许多sudog。\n// \n// sudog 由特殊的池分配，所以只能通过acquireSudog和releaseSudog来分配和释放sudog。\ntype sudog struct {\n\t// 由hchan.lock来保护以下字段，收缩栈依赖sudog的操作\n\n\tg *g\n\n\tnext *sudog\n\tprev *sudog\n\telem unsafe.Pointer // data element (may point to stack)\n\n\t// 以下字段永远不能同时访问\n\t// 对于channel，waitlink仅由g访问。\n\t// 对于信号量，仅在持有semaRoot锁时才能访问所有字段（包括上述字段）。\n\n\tacquiretime int64\n\treleasetime int64\n\tticket      uint32\n\n\t// isSelect表示g正在参与选择，因此必须对g.selectDone进行CAS操作才能wake-up竞争。\n\tisSelect bool\n\n\tparent   *sudog // semaRoot binary tree\n\twaitlink *sudog // g.waiting list or semaRoot\n\twaittail *sudog // semaRoot\n\tc        *hchan // channel，引用chan的底层实现\n}\n```\n\n\n\n# 参考文献\n* [[典藏版] Golang 调度器 GMP 原理与调度全分析](https://learnku.com/articles/41728)\n* [Golang调度器源码分析](http://ga0.github.io/golang/2015/09/20/golang-runtime-scheduler.html)\n","source":"_posts/golang-MPG调度.md","raw":"---\nauthor: djaigo\ntitle: golang MPG调度\nimg: 'https://img-1251474779.cos.ap-beijing.myqcloud.com/golang.png'\ncategories:\n  - golang\ntags:\n  - mpg\n  - infra\ndate: 2020-08-07 19:40:47\nupdated: 2020-08-07 19:40:47\n---\n\n# MPG\nMPG是golang的并发模型，结构源码在`runtime/runtime2.go`里面，主体逻辑结构在`runtime/proc.go`里，是golang可以高并发的根本。\n* M，连接一个内核态的线程，goroutine跑在M上，每个M都会有一个g0的G，用于协调P队列里的G，在调度或系统调用时会用到g0的栈\n* P，维护执行G队列，管理G上下文\n* G，代表goroutine的元数据，包括栈信息，M信息，计数器等\n\n除了MPG之外，还有Sched来负责全局队列的处理。\n四者协同完成整个golang的高并发处理的主要逻辑，还有其他小的结构进行辅助，例如：sudog（G队列）、stack（栈信息）等。\n\nM、P数量：\n* P的数量可以在启动时通过环境变量`$GOMAXPROCS`，或在代码中通过`runtime`包的`GOMAXPROCS()`设置。P的数量限制了最大goroutine并发执行数。\n* M的数量在启动时会被`schedinit()`设置成`sched.maxmcount = 10000`，可在代码中调用`runtime/debug`包的`SetMaxThreads()`。M的数量限制了最大可用的系统线程数。\n\nM、P创建：\n* P，在系统确定了P的数量后就会创建指定个数的P\n* M，如果P没有M，则会去全局休眠M队列中找，如果还没有则会创建M\n\nM调度策略：\n* work stealing，当M执行G结束后，会从绑定P中获取G，而不是销毁当前M\n* hand off，当G调用阻塞系统调用时，M释放绑定的P，将P交给空闲的M\n\n## 生命周期\n程序启动第一时间都会调用`runtime.main()`，进行相关值的初始化。\n```\n// The main goroutine.\nfunc main() {\n\tg := getg()\n\n\t// Racectx of m0->g0 is used only as the parent of the main goroutine.\n\t// It must not be used for anything else.\n\tg.m.g0.racectx = 0\n\n\t// Max stack size is 1 GB on 64-bit, 250 MB on 32-bit.\n\t// Using decimal instead of binary GB and MB because\n\t// they look nicer in the stack overflow failure message.\n\t// 设置栈的最大值\n\tif sys.PtrSize == 8 {\n\t\tmaxstacksize = 1000000000\n\t} else {\n\t\tmaxstacksize = 250000000\n\t}\n\n\t// Allow newproc to start new Ms.\n\t// 允许新P创建M\n\tmainStarted = true\n\n\tif GOARCH != \"wasm\" { // no threads on wasm yet, so no sysmon\n\t\tsystemstack(func() {\n\t\t\tnewm(sysmon, nil, -1)\n\t\t})\n\t}\n\n\t// Lock the main goroutine onto this, the main OS thread,\n\t// during initialization. Most programs won't care, but a few\n\t// do require certain calls to be made by the main thread.\n\t// Those can arrange for main.main to run in the main thread\n\t// by calling runtime.LockOSThread during initialization\n\t// to preserve the lock.\n\tlockOSThread()\n\n\tif g.m != &m0 {\n\t\tthrow(\"runtime.main not on m0\")\n\t}\n\n\tdoInit(&runtime_inittask) // must be before defer\n\tif nanotime() == 0 {\n\t\tthrow(\"nanotime returning zero\")\n\t}\n\n\t// Defer unlock so that runtime.Goexit during init does the unlock too.\n\tneedUnlock := true\n\tdefer func() {\n\t\tif needUnlock {\n\t\t\tunlockOSThread()\n\t\t}\n\t}()\n\n\t// Record when the world started.\n\t// 记录启动时间\n\truntimeInitTime = nanotime()\n\n\tgcenable() // 开启GC\n    ...\n\tneedUnlock = false\n\tunlockOSThread()\n\n\tif isarchive || islibrary {\n\t\t// A program compiled with -buildmode=c-archive or c-shared\n\t\t// has a main, but it is not executed.\n\t\treturn\n\t}\n\t\n\t// 执行main包的main函数\n\tfn := main_main // make an indirect call, as the linker doesn't know the address of the main package when laying down the runtime\n\tfn()\n\tif raceenabled {\n\t\tracefini() // 竞态检测\n\t}\n\n\t// Make racy client program work: if panicking on\n\t// another goroutine at the same time as main returns,\n\t// let the other goroutine finish printing the panic trace.\n\t// Once it does, it will exit. See issues 3934 and 20018.\n    // 如果goroutine panic了则创建另一个goroutine打印相关信息，完成之后新建goroutine将退出\n\tif atomic.Load(&runningPanicDefers) != 0 {\n\t\t// Running deferred functions should not take long.\n\t\tfor c := 0; c < 1000; c++ {\n\t\t\tif atomic.Load(&runningPanicDefers) == 0 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tGosched()\n\t\t}\n\t}\n\tif atomic.Load(&panicking) != 0 {\n\t\tgopark(nil, nil, waitReasonPanicWait, traceEvGoStop, 1)\n\t}\n\n\texit(0) // 退出进程\n\tfor {\n\t\tvar x *int32\n\t\t*x = 0\n\t}\n}\n```\n\n在程序启动时会创建m0，同时创建g0，在`runtime/proc.go`声明：\n```go\nvar (\n\tm0 m\n\tg0 g\n)\n```\n\n> 特殊的m0，是启动程序后的编号为0的主线程，这个M对应的实例会在全局变量`runtime.m0`中，不需要在heap上分配，m0负责执行初始化操作和启动第一个G，在之后M0就和其他的一样了。\n\n初始化P，创建`main()`的g1，将g1存放于p的本地G队列中，启动m0，m0绑定p，如果绑定不成功就会进入全局休眠M队列等待被唤醒，从p中获取可执行的G，如果没有课执行的G则会进入自旋状态，如果获取到g1，设置g1的运行环境，运行g1，g1退出，m0继续通过p获取G。\n\n> 自旋状态，是指M绑定的P没有可以执行的G，此时M执行的g0，轮询P的本地空闲G队列有没有可执行的G\n\n## 三者关系\n*   `G`需要绑定在`M`上才能运行；\n*   `M`需要绑定`P`才能运行；\n*   程序中的多个`M`并不会同时都处于执行状态，最多只有`GOMAXPROCS`个`M`在执行。\n\n 早期版本的Golang是没有`P`的，调度是由`G`与`M`完成。 这样的问题在于每当创建、终止Goroutine或者需要调度时，需要一个全局的锁来保护调度的相关对象(sched)。 全局锁严重影响Goroutine的并发性能。\n 通过引入`P`，实现了一种叫做`work-stealing`的调度算法：\n\n*   每个`P`维护一个`G`队列；\n*   当一个`G`被创建出来，或者变为可执行状态时，就把他放到`P`的可执行队列中；\n*   当一个`G`执行结束时，`P`会从队列中把该`G`取出；如果此时`P`的队列为空，即没有其他`G`可以执行， 就随机选择另外一个`P`，从其可执行的`G`队列中偷取一半。\n\n该算法避免了在Goroutine调度时使用全局锁。\n\n\n# 可视化\n## trace\n代码：\n```\npackage main\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"runtime/trace\"\n)\n\nfunc main() {\n    f, err := os.Create(\"trace.out\")\n    if err != nil {\n        panic(err)\n    }\n    \n    defer f.Close()\n    \n    err = trace.Start(f)\n    if err != nil {\n        panic(err)\n    }\n    defer trace.Stop()\n    \n    fmt.Println(\"Hello world!\")\n}\n```\n\n运行程序会生成一个trace.out的文件，可以通过tool工具将其可视化\n```\n➜ go tool trace trace.out\n```\n\n这样写会对代码侵入太强，可以写成测试文件，在test的时候生成trace.out文件，在`Test()`不需要显式的调用上面的代码，代码如下：\n```\npackage main\n\nimport (\n    \"fmt\"\n    \"testing\"\n)\n\nfunc Test(t *testing.T) {\n    fmt.Println(\"Hello world!\")\n}\n```\n\n执行代码\n```\ngo test -trace trace.out -run Test\n```\n\n也可以生成trace.out文件。\n在有了trace.out文件后，执行`go tool trace trace.out`，启动http服务可视化查看MPG的相关信息。\n\n\n## debug\n代码：\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\nfunc main() {\n    fmt.Println(\"Hello world!\")\n}\n```\n\n在执行之前设置`GODEBUG=schedtrace=10`，单位毫秒\n执行结果\n```sh\nGODEBUG=schedtrace=10 go run main.go \nSCHED 0ms: gomaxprocs=4 idleprocs=1 threads=6 spinningthreads=1 idlethreads=0 runqueue=0 [1 0 0 0]\nSCHED 18ms: gomaxprocs=4 idleprocs=0 threads=9 spinningthreads=1 idlethreads=2 runqueue=1 [0 4 0 0]\nSCHED 30ms: gomaxprocs=4 idleprocs=1 threads=9 spinningthreads=1 idlethreads=2 runqueue=0 [0 0 0 0]\nSCHED 42ms: gomaxprocs=4 idleprocs=2 threads=9 spinningthreads=0 idlethreads=3 runqueue=1 [0 0 0 0]\nSCHED 53ms: gomaxprocs=4 idleprocs=4 threads=9 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]\nSCHED 66ms: gomaxprocs=4 idleprocs=0 threads=9 spinningthreads=1 idlethreads=2 runqueue=1 [0 0 0 0]\nSCHED 79ms: gomaxprocs=4 idleprocs=3 threads=9 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]\n```\n\n* `SCHED 0ms`：调试信息输出标志字符串，后面是执行的时间戳\n* `gomaxprocs`：P的数量，本例有4个P，默认与cpu核心数量一致，可以通过GOMAXPROCS来设置\n* `idleprocs`：处于idle状态P的数量\n* `threads`：M的数量，包含scheduler使用的M数量，加上runtime自用的类似sysmon这样的thread的数量\n* `spinningthreads`: 处于自旋状态M数量\n* `idlethread`: 处于idle状态的M的数量\n* `runqueue=0`：Scheduler全局队列中G的数量\n* `[0 0 0 0]`: 分别为4个的`local queue`中的G的数量\n\n# 关键字段说明\n## M\n```go\ntype m struct {\n\tg0      *g     // goroutine with scheduling stack\n\tmorebuf gobuf  // gobuf arg to morestack\n\tdivmod  uint32 // div/mod denominator for arm - known to liblink\n\n\t// Fields not known to debuggers.\n\tprocid        uint64       // for debuggers, but offset not hard-coded\n\tgsignal       *g           // signal-handling g\n\tgoSigStack    gsignalStack // Go-allocated signal handling stack\n\tsigmask       sigset       // storage for saved signal mask\n\ttls           [6]uintptr   // thread-local storage (for x86 extern register)\n\tmstartfn      func()\n\tcurg          *g       // 当前执行的G，检测gp\n\tcaughtsig     guintptr // goroutine running during fatal signal\n\tp             puintptr // 绑定的P执行go代码 (如果没有执行go代码则为nil)\n\tnextp         puintptr\n\toldp          puintptr // 执行系统调用之前的P\n\tid            int64\n\tmallocing     int32\n\tthrowing      int32\n\tpreemptoff    string // if != \"\", keep curg running on this m\n\tlocks         int32  // m的引用计数 \n\tdying         int32\n\tprofilehz     int32\n\tspinning      bool // m is out of work and is actively looking for work\n\tblocked       bool // m is blocked on a note\n\tnewSigstack   bool // minit on C thread called sigaltstack\n\tprintlock     int8\n\tincgo         bool   // m is executing a cgo call\n\tfreeWait      uint32 // if == 0, safe to free g0 and delete m (atomic)\n\tfastrand      [2]uint32 // 两个随机值，不能同时为0\n\tneedextram    bool\n\ttraceback     uint8\n\tncgocall      uint64      // number of cgo calls in total\n\tncgo          int32       // number of cgo calls currently in progress\n\tcgoCallersUse uint32      // if non-zero, cgoCallers in use temporarily\n\tcgoCallers    *cgoCallers // cgo traceback if crashing in cgo call\n\tpark          note\n\talllink       *m // on allm\n\tschedlink     muintptr    // M的单链表\n\tlockedg       guintptr    // M锁定的G\n\tcreatestack   [32]uintptr // stack that created this thread.\n\tlockedExt     uint32      // tracking for external LockOSThread\n\tlockedInt     uint32      // tracking for internal lockOSThread\n\tnextwaitm     muintptr    // next m waiting for lock\n\twaitunlockf   func(*g, unsafe.Pointer) bool\n\twaitlock      unsafe.Pointer\n\twaittraceev   byte\n\twaittraceskip int\n\tstartingtrace bool\n\tsyscalltick   uint32\n\tfreelink      *m // 对应全局休眠M队列\n\n\t// these are here because they are too large to be on the stack\n\t// of low-level NOSPLIT functions.\n\tlibcall   libcall\n\tlibcallpc uintptr // for cpu profiler\n\tlibcallsp uintptr\n\tlibcallg  guintptr\n\tsyscall   libcall // stores syscall parameters on windows\n\n\tvdsoSP uintptr // SP for traceback while in VDSO call (0 if not in call)\n\tvdsoPC uintptr // PC for traceback while in VDSO call\n\n\t// preemptGen counts the number of completed preemption\n\t// signals. This is used to detect when a preemption is\n\t// requested, but fails. Accessed atomically.\n\tpreemptGen uint32\n\n\t// Whether this is a pending preemption signal on this M.\n\t// Accessed atomically.\n\tsignalPending uint32\n\n\tdlogPerM\n\n\tmOS\n\n\t// Up to 10 locks held by this m, maintained by the lock ranking code.\n\tlocksHeldLen int\n\tlocksHeld    [10]heldLockInfo\n}\n```\n\n## P\n```go\ntype p struct {\n\tid          int32\n\tstatus      uint32 // one of pidle/prunning/...\n\tlink        puintptr   // P的单链表\n\tschedtick   uint32     // incremented on every scheduler call\n\tsyscalltick uint32     // incremented on every system call\n\tsysmontick  sysmontick // last tick observed by sysmon\n\tm           muintptr   // 当前的M，如果空闲则为nil\n\tmcache      *mcache\n\tpcache      pageCache\n\traceprocctx uintptr\n\n\tdeferpool    [5][]*_defer // pool of available defer structs of different sizes (see panic.go)\n\tdeferpoolbuf [5][32]*_defer\n\n\t// Cache of goroutine ids, amortizes accesses to runtime·sched.goidgen.\n\tgoidcache    uint64\n\tgoidcacheend uint64\n\n\t// Queue of runnable goroutines. Accessed without lock.\n\trunqhead uint32         // 队首下标\n\trunqtail uint32         // 队尾下标\n\trunq     [256]guintptr  // 可执行队列，最多256个\n\t// runnext, if non-nil, is a runnable G that was ready'd by\n\t// the current G and should be run next instead of what's in\n\t// runq if there's time remaining in the running G's time\n\t// slice. It will inherit the time left in the current time\n\t// slice. If a set of goroutines is locked in a\n\t// communicate-and-wait pattern, this schedules that set as a\n\t// unit and eliminates the (potentially large) scheduling\n\t// latency that otherwise arises from adding the ready'd\n\t// goroutines to the end of the run queue.\n\trunnext guintptr\n\n\t// Available G's (status == Gdead)\n\tgFree struct {\n\t\tgList\n\t\tn int32\n\t}\n\n\tsudogcache []*sudog     // 本地G的队列\n\tsudogbuf   [128]*sudog\n\n\t// Cache of mspan objects from the heap.\n\tmspancache struct {\n\t\t// We need an explicit length here because this field is used\n\t\t// in allocation codepaths where write barriers are not allowed,\n\t\t// and eliminating the write barrier/keeping it eliminated from\n\t\t// slice updates is tricky, moreso than just managing the length\n\t\t// ourselves.\n\t\tlen int\n\t\tbuf [128]*mspan\n\t}\n\n\ttracebuf traceBufPtr\n\n\t// traceSweep indicates the sweep events should be traced.\n\t// This is used to defer the sweep start event until a span\n\t// has actually been swept.\n\ttraceSweep bool\n\t// traceSwept and traceReclaimed track the number of bytes\n\t// swept and reclaimed by sweeping in the current sweep loop.\n\ttraceSwept, traceReclaimed uintptr\n\n\tpalloc persistentAlloc // per-P to avoid mutex\n\n\t_ uint32 // Alignment for atomic fields below\n\n\t// The when field of the first entry on the timer heap.\n\t// This is updated using atomic functions.\n\t// This is 0 if the timer heap is empty.\n\ttimer0When uint64\n\n\t// Per-P GC state\n\tgcAssistTime         int64    // Nanoseconds in assistAlloc\n\tgcFractionalMarkTime int64    // Nanoseconds in fractional mark worker (atomic)\n\tgcBgMarkWorker       guintptr // (atomic)\n\tgcMarkWorkerMode     gcMarkWorkerMode\n\n\t// gcMarkWorkerStartTime is the nanotime() at which this mark\n\t// worker started.\n\tgcMarkWorkerStartTime int64\n\n\t// gcw is this P's GC work buffer cache. The work buffer is\n\t// filled by write barriers, drained by mutator assists, and\n\t// disposed on certain GC state transitions.\n\tgcw gcWork\n\n\t// wbBuf is this P's GC write barrier buffer.\n\t//\n\t// TODO: Consider caching this in the running G.\n\twbBuf wbBuf\n\n\trunSafePointFn uint32 // if 1, run sched.safePointFn at next safe point\n\n\t// Lock for timers. We normally access the timers while running\n\t// on this P, but the scheduler can also do it from a different P.\n\ttimersLock mutex\n\n\t// Actions to take at some time. This is used to implement the\n\t// standard library's time package.\n\t// Must hold timersLock to access.\n\ttimers []*timer\n\n\t// Number of timers in P's heap.\n\t// Modified using atomic instructions.\n\tnumTimers uint32\n\n\t// Number of timerModifiedEarlier timers on P's heap.\n\t// This should only be modified while holding timersLock,\n\t// or while the timer status is in a transient state\n\t// such as timerModifying.\n\tadjustTimers uint32\n\n\t// Number of timerDeleted timers in P's heap.\n\t// Modified using atomic instructions.\n\tdeletedTimers uint32\n\n\t// Race context used while executing timer functions.\n\ttimerRaceCtx uintptr\n\n\t// preempt is set to indicate that this P should be enter the\n\t// scheduler ASAP (regardless of what G is running on it).\n\tpreempt bool\n\n\tpad cpu.CacheLinePad\n}\n```\n\n## G\n```go\ntype g struct {\n\t// Stack parameters.\n\t// stack describes the actual stack memory: [stack.lo, stack.hi).\n\t// stackguard0 is the stack pointer compared in the Go stack growth prologue.\n\t// It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption.\n\t// stackguard1 is the stack pointer compared in the C stack growth prologue.\n\t// It is stack.lo+StackGuard on g0 and gsignal stacks.\n\t// It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash).\n\tstack       stack   // offset known to runtime/cgo\n\tstackguard0 uintptr // offset known to liblink\n\tstackguard1 uintptr // offset known to liblink\n\n\t_panic       *_panic // innermost panic - offset known to liblink\n\t_defer       *_defer // innermost defer\n\tm            *m      // 当前M；offset known to arm liblink\n\tsched        gobuf\n\tsyscallsp    uintptr        // if status==Gsyscall, syscallsp = sched.sp to use during gc\n\tsyscallpc    uintptr        // if status==Gsyscall, syscallpc = sched.pc to use during gc\n\tstktopsp     uintptr        // expected sp at top of stack, to check in traceback\n\tparam        unsafe.Pointer // passed parameter on wakeup\n\tatomicstatus uint32     // G的状态\n\tstackLock    uint32     // sigprof/scang lock; TODO: fold in to atomicstatus\n\tgoid         int64      // goroutine id\n\tschedlink    guintptr   // 下一个G的地址\n\twaitsince    int64      // approx time when the g become blocked\n\twaitreason   waitReason // if status==Gwaiting\n\n\tpreempt       bool // preemption signal, duplicates stackguard0 = stackpreempt\n\tpreemptStop   bool // transition to _Gpreempted on preemption; otherwise, just deschedule\n\tpreemptShrink bool // shrink stack at synchronous safe point\n\n\t// asyncSafePoint is set if g is stopped at an asynchronous\n\t// safe point. This means there are frames on the stack\n\t// without precise pointer information.\n\tasyncSafePoint bool\n\n\tpaniconfault bool // panic (instead of crash) on unexpected fault address\n\tgcscandone   bool // g has scanned stack; protected by _Gscan bit in status\n\tthrowsplit   bool // must not split stack\n\t// activeStackChans indicates that there are unlocked channels\n\t// pointing into this goroutine's stack. If true, stack\n\t// copying needs to acquire channel locks to protect these\n\t// areas of the stack.\n\tactiveStackChans bool\n\n\traceignore     int8     // ignore race detection events\n\tsysblocktraced bool     // StartTrace has emitted EvGoInSyscall about this goroutine\n\tsysexitticks   int64    // cputicks when syscall has returned (for tracing)\n\ttraceseq       uint64   // trace event sequencer\n\ttracelastp     puintptr // last P emitted an event for this goroutine\n\tlockedm        muintptr\n\tsig            uint32\n\twritebuf       []byte\n\tsigcode0       uintptr\n\tsigcode1       uintptr\n\tsigpc          uintptr\n\tgopc           uintptr         // pc of go statement that created this goroutine\n\tancestors      *[]ancestorInfo // ancestor information goroutine(s) that created this goroutine (only used if debug.tracebackancestors)\n\tstartpc        uintptr         // pc of goroutine function\n\tracectx        uintptr\n\twaiting        *sudog         // sudog structures this g is waiting on (that have a valid elem ptr); in lock order\n\tcgoCtxt        []uintptr      // cgo traceback context\n\tlabels         unsafe.Pointer // profiler labels\n\ttimer          *timer         // cached timer for time.Sleep\n\tselectDone     uint32         // are we participating in a select and did someone win the race?\n\n\t// Per-G GC state\n\n\t// gcAssistBytes is this G's GC assist credit in terms of\n\t// bytes allocated. If this is positive, then the G has credit\n\t// to allocate gcAssistBytes bytes without assisting. If this\n\t// is negative, then the G must correct this by performing\n\t// scan work. We track this in bytes to make it fast to update\n\t// and check for debt in the malloc hot path. The assist ratio\n\t// determines how this corresponds to scan work debt.\n\tgcAssistBytes int64\n}\n```\n\n## Sched\n```go\ntype schedt struct {\n\t// accessed atomically. keep at top to ensure alignment on 32-bit systems.\n\tgoidgen   uint64\n\tlastpoll  uint64 // time of last network poll, 0 if currently polling\n\tpollUntil uint64 // time to which current poll is sleeping\n\n\tlock mutex // 操作锁，锁定schedt\n\n\t// When increasing nmidle, nmidlelocked, nmsys, or nmfreed, be\n\t// sure to call checkdead().\n\n\tmidle        muintptr // 空闲M单链表\n\tnmidle       int32    // 空闲M的个数\n\tnmidlelocked int32    // number of locked m's waiting for work\n\tmnext        int64    // number of m's that have been created and next M ID\n\tmaxmcount    int32    // maximum number of m's allowed (or die)\n\tnmsys        int32    // number of system m's not counted for deadlock\n\tnmfreed      int64    // cumulative number of freed m's\n\n\tngsys uint32 // number of system goroutines; updated atomically\n\n\tpidle      puintptr // 空闲的P\n\tnpidle     uint32\n\tnmspinning uint32 // See \"Worker thread parking/unparking\" comment in proc.go.\n\n\t// Global runnable queue.\n\trunq     gQueue  // 全局可执行队列\n\trunqsize int32   // 全局队列大小\n\n\t// disable控制有选择的禁用调度\n\t//\n\t// 使用schedEnableUser(enable bool)进行控制\n\t//\n\t// disable需要被sched.lock保护\n\tdisable struct {\n\t\t// user是否禁止调度goroutines.\n\t\tuser     bool\n\t\trunnable gQueue // pending runnable Gs\n\t\tn        int32  // length of runnable\n\t}\n\n\t// Global cache of dead G's.\n\tgFree struct {\n\t\tlock    mutex\n\t\tstack   gList // Gs with stacks\n\t\tnoStack gList // Gs without stacks\n\t\tn       int32\n\t}\n\n\t// Central cache of sudog structs.\n\tsudoglock  mutex  // 全局空闲G队列锁\n\tsudogcache *sudog // 全局空闲G队列\n\n\t// Central pool of available defer structs of different sizes.\n\tdeferlock mutex\n\tdeferpool [5]*_defer\n\n\t// freem is the list of m's waiting to be freed when their\n\t// m.exited is set. Linked through m.freelink.\n\tfreem *m // 全局休眠M队列\n\n\tgcwaiting  uint32 // gc is waiting to run\n\tstopwait   int32\n\tstopnote   note\n\tsysmonwait uint32\n\tsysmonnote note\n\n\t// safepointFn should be called on each P at the next GC\n\t// safepoint if p.runSafePointFn is set.\n\tsafePointFn   func(*p)\n\tsafePointWait int32\n\tsafePointNote note\n\n\tprofilehz int32 // cpu profiling rate\n\n\tprocresizetime int64 // nanotime() of last change to gomaxprocs\n\ttotaltime      int64 // ∫gomaxprocs dt up to procresizetime\n\n\t// sysmonlock protects sysmon's actions on the runtime.\n\t//\n\t// Acquire and hold this mutex to block sysmon from interacting\n\t// with the rest of the runtime.\n\tsysmonlock mutex\n}\n```\n\n\n# 字段和结构体\n## G状态\n```go\nconst (\n\t// G status\n\t//\n\t// 除了指示G的一般状态外，G状态还像goroutine堆栈上的锁一样（因此具有执行用户代码的能力）。\n\n\t// _Gidle表示此goroutine已分配，尚未初始化。\n\t_Gidle = iota // 0\n\n\t// _Grunnable表示此goroutine在运行队列中，当前未执行用户代码，没有堆栈。\n\t_Grunnable // 1\n\n\t// _Grunning表示此goroutine可以执行用户代码。\n\t// 该goroutine拥有堆栈，且不在运行队列中。\n\t// 它已分配一个M和一个P。\n\t_Grunning // 2\n\n\t// _Gsyscall表示此goroutine正在执行系统调用。\n\t// 它不执行用户代码，堆栈由该goroutine拥有，它不在运行队列中。\n\t// 它被分配了一个M。\n\t_Gsyscall // 3\n\n\t// _Gwaiting 意味着goroutine被runtime阻止。\n\t// 它不执行用户代码，它也不再运行队列，但应该被记录下来（例如：等待chan中的数据），必要时可以调用ready()恢复。\n\t// 除chan操作可以在适当的锁下读取或写入堆栈的某些部分外，不应该拥有该堆栈。\n\t_Gwaiting // 4\n\n\t// _Gmoribund_unused当前未使用，但已在gdb脚本中进行了硬编码。\n\t_Gmoribund_unused // 5\n\n\t// _Gdead表示此goroutine当前未使用。\n\t// 它有可能已退出，在空闲列表或刚被初始化。它不能执行用户代码。它可能拥有堆栈也可能不拥有堆栈。\n\t// G及其堆栈（如果有）由退出G或从空闲列表中获得G的M拥有。\n\t_Gdead // 6\n\n\t// _Genqueue_unused当前未使用。\n\t_Genqueue_unused // 7\n\n\t// _Gcopystack表示此goroutine的堆栈正在迁移。\n\t// 它不能执行用户代码，并且不再运行队列中。\n\t// 堆栈由将其放入_Gcopystack的goroutine拥有。\n\t_Gcopystack // 8\n\n\t// _Gscan与上述状态之一组合表示GC正在扫描堆栈（除_Grunning）。\n\t// goroutine未执行用户代码，并且堆栈由设置_Gscan位的goroutine拥有。\n\t// _Gscanrunning不同: 它用于短暂阻止状态转换，而GC则通知G扫描其自身的堆栈。否则就像_Grunning。\n\t// atomicstatus&~Gscan 给出goroutine将在扫描完成时返回的状态。\n\t_Gscan         = 0x1000\n\t_Gscanrunnable = _Gscan + _Grunnable // 0x1001\n\t_Gscanrunning  = _Gscan + _Grunning  // 0x1002\n\t_Gscansyscall  = _Gscan + _Gsyscall  // 0x1003\n\t_Gscanwaiting  = _Gscan + _Gwaiting  // 0x1004\n)\n```\n\n## P状态\n```go\nconst (\n\t// P status\n\n\t// _Pidle表示不使用P来运行用户代码或调度程序。\n\t// 它在空闲的P列表中，可供调度程序使用，但可能只是在其他状态之间转换。\n\t//\n\t// P由空闲列表或转换其状态的任何内容所拥有。它的运行队列为空。\n\t_Pidle = iota\n\n\t// _Prunning表示P由M拥有，并用于运行用户代码或调度程序。\n\t// 仅拥有此P的M允许从_Prunning更改P的状态。\n\t// M可以将P转换为_Pidle（如果没有更多工作要做），_Psyscall（进入系统调用时）或_Pgcstop（以停止GC）。\n\t// M也可以将P的所有权直接移交给另一个M（例如，调度锁定的G）。\n\t_Prunning\n\n\t// _Psyscall表示P没有运行用户代码。\n\t// 它与系统调用中的M有亲缘关系，但不归其所有，并且可能被另一个M窃取。\n\t// 这类似于_Pidle，但使用轻量级转换并保持M相似性。\n\t//\n\t// 必须通过CAS离开_Psyscall才能窃取或重新获得P。\n\t// 注意ABA危害：\n\t// 即使M在系统调用后成功将其原始P恢复为_Prunning，它也必须了解该P在此期间可能已被另一个M使用。\n\t_Psyscall\n\n\t// _Pgcstop表示对STW(stop the world)暂停P并由STW的M拥有。\n\t// STW的M甚至在_Pgcstop中也继续使用其P。\n\t// 从_Prunning过渡到_Pgcstop会导致M释放其P并停放。\n\t//\n\t// P保留其运行队列，STW将使用非空运行队列在P上重新启动调度程序。\n\t_Pgcstop\n\n\t// _Pdead表示不再使用P（GOMAXPROCS缩小），如果P的数量增加将会复用P。\n\t// 一个死掉的P大部分被剥夺了其资源，尽管还剩下一些东西（例如跟踪缓冲区）。\n\t_Pdead\n)\n```\n\n## runtime2.go 全局变量\n```go\nvar (\n\tallglen    uintptr // allgs的长度\n\tallm       *m      // 所有m的单链表\n\tallp       []*p    // 所有的P列表，len(allp) == gomaxprocs，只能通过GOMAXPROCS()修改\n\tallpLock   mutex   // Protects P-less reads of allp and all writes\n\tgomaxprocs int32         // 最大P的数量\n\tncpu       int32         // CPU数\n\tforcegc    forcegcstate\n\tsched      schedt        // 调度者\n\tnewprocs   int32\n\n\t// Information about what cpu features are available.\n\t// Packages outside the runtime should not use these\n\t// as they are not an external api.\n\t// Set on startup in asm_{386,amd64}.s\n\tprocessorVersionInfo uint32\n\tisIntel              bool\n\tlfenceBeforeRdtsc    bool\n\n\tgoarm                uint8 // set by cmd/link on arm systems\n\tframepointer_enabled bool  // set by cmd/link\n)\n\nvar (\n\tallgs    []*g  // 所有g的单链表\n\tallglock mutex // 修改单链表锁\n)\n```\n\n\n## sodug\n```\ntype hchan struct {\n\tqcount   uint           // 队列元素总数\n\tdataqsiz uint           // 循环队列的大小\n\tbuf      unsafe.Pointer // 指向dataqsiz元素数组\n\telemsize uint16\n\tclosed   uint32\n\telemtype *_type // element type\n\tsendx    uint   // send index\n\trecvx    uint   // receive index\n\trecvq    waitq  // list of recv waiters\n\tsendq    waitq  // list of send waiters\n\n\t// lock保护hchan的所有字段，也保护sudog的所有字段在这个channel。\n\t//\n\t// 锁住此锁时，请勿更改另一个G的状态（特别是不要对G调用ready），因为这会因堆栈收缩而死锁。\n\tlock mutex\n}\n\ntype waitq struct {\n\tfirst *sudog\n\tlast  *sudog\n}\n\n// sudog 表示可执行G的列表，一个G可能在多个sudog中，\n// 并且许多G可能正在等待同一个同步对象，因此一个对象可能有许多sudog。\n// \n// sudog 由特殊的池分配，所以只能通过acquireSudog和releaseSudog来分配和释放sudog。\ntype sudog struct {\n\t// 由hchan.lock来保护以下字段，收缩栈依赖sudog的操作\n\n\tg *g\n\n\tnext *sudog\n\tprev *sudog\n\telem unsafe.Pointer // data element (may point to stack)\n\n\t// 以下字段永远不能同时访问\n\t// 对于channel，waitlink仅由g访问。\n\t// 对于信号量，仅在持有semaRoot锁时才能访问所有字段（包括上述字段）。\n\n\tacquiretime int64\n\treleasetime int64\n\tticket      uint32\n\n\t// isSelect表示g正在参与选择，因此必须对g.selectDone进行CAS操作才能wake-up竞争。\n\tisSelect bool\n\n\tparent   *sudog // semaRoot binary tree\n\twaitlink *sudog // g.waiting list or semaRoot\n\twaittail *sudog // semaRoot\n\tc        *hchan // channel，引用chan的底层实现\n}\n```\n\n\n\n# 参考文献\n* [[典藏版] Golang 调度器 GMP 原理与调度全分析](https://learnku.com/articles/41728)\n* [Golang调度器源码分析](http://ga0.github.io/golang/2015/09/20/golang-runtime-scheduler.html)\n","slug":"golang-MPG调度","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckh351duf000x19z40tmkgqxi","content":"<h1 id=\"MPG\"><a href=\"#MPG\" class=\"headerlink\" title=\"MPG\"></a>MPG</h1><p>MPG是golang的并发模型，结构源码在<code>runtime/runtime2.go</code>里面，主体逻辑结构在<code>runtime/proc.go</code>里，是golang可以高并发的根本。</p>\n<ul>\n<li>M，连接一个内核态的线程，goroutine跑在M上，每个M都会有一个g0的G，用于协调P队列里的G，在调度或系统调用时会用到g0的栈</li>\n<li>P，维护执行G队列，管理G上下文</li>\n<li>G，代表goroutine的元数据，包括栈信息，M信息，计数器等</li>\n</ul>\n<p>除了MPG之外，还有Sched来负责全局队列的处理。<br>四者协同完成整个golang的高并发处理的主要逻辑，还有其他小的结构进行辅助，例如：sudog（G队列）、stack（栈信息）等。</p>\n<p>M、P数量：</p>\n<ul>\n<li>P的数量可以在启动时通过环境变量<code>$GOMAXPROCS</code>，或在代码中通过<code>runtime</code>包的<code>GOMAXPROCS()</code>设置。P的数量限制了最大goroutine并发执行数。</li>\n<li>M的数量在启动时会被<code>schedinit()</code>设置成<code>sched.maxmcount = 10000</code>，可在代码中调用<code>runtime/debug</code>包的<code>SetMaxThreads()</code>。M的数量限制了最大可用的系统线程数。</li>\n</ul>\n<p>M、P创建：</p>\n<ul>\n<li>P，在系统确定了P的数量后就会创建指定个数的P</li>\n<li>M，如果P没有M，则会去全局休眠M队列中找，如果还没有则会创建M</li>\n</ul>\n<p>M调度策略：</p>\n<ul>\n<li>work stealing，当M执行G结束后，会从绑定P中获取G，而不是销毁当前M</li>\n<li>hand off，当G调用阻塞系统调用时，M释放绑定的P，将P交给空闲的M</li>\n</ul>\n<h2 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h2><p>程序启动第一时间都会调用<code>runtime.main()</code>，进行相关值的初始化。</p>\n<pre><code>// The main goroutine.\nfunc main() {\n    g := getg()\n\n    // Racectx of m0-&gt;g0 is used only as the parent of the main goroutine.\n    // It must not be used for anything else.\n    g.m.g0.racectx = 0\n\n    // Max stack size is 1 GB on 64-bit, 250 MB on 32-bit.\n    // Using decimal instead of binary GB and MB because\n    // they look nicer in the stack overflow failure message.\n    // 设置栈的最大值\n    if sys.PtrSize == 8 {\n        maxstacksize = 1000000000\n    } else {\n        maxstacksize = 250000000\n    }\n\n    // Allow newproc to start new Ms.\n    // 允许新P创建M\n    mainStarted = true\n\n    if GOARCH != \"wasm\" { // no threads on wasm yet, so no sysmon\n        systemstack(func() {\n            newm(sysmon, nil, -1)\n        })\n    }\n\n    // Lock the main goroutine onto this, the main OS thread,\n    // during initialization. Most programs won't care, but a few\n    // do require certain calls to be made by the main thread.\n    // Those can arrange for main.main to run in the main thread\n    // by calling runtime.LockOSThread during initialization\n    // to preserve the lock.\n    lockOSThread()\n\n    if g.m != &amp;m0 {\n        throw(\"runtime.main not on m0\")\n    }\n\n    doInit(&amp;runtime_inittask) // must be before defer\n    if nanotime() == 0 {\n        throw(\"nanotime returning zero\")\n    }\n\n    // Defer unlock so that runtime.Goexit during init does the unlock too.\n    needUnlock := true\n    defer func() {\n        if needUnlock {\n            unlockOSThread()\n        }\n    }()\n\n    // Record when the world started.\n    // 记录启动时间\n    runtimeInitTime = nanotime()\n\n    gcenable() // 开启GC\n    ...\n    needUnlock = false\n    unlockOSThread()\n\n    if isarchive || islibrary {\n        // A program compiled with -buildmode=c-archive or c-shared\n        // has a main, but it is not executed.\n        return\n    }\n\n    // 执行main包的main函数\n    fn := main_main // make an indirect call, as the linker doesn't know the address of the main package when laying down the runtime\n    fn()\n    if raceenabled {\n        racefini() // 竞态检测\n    }\n\n    // Make racy client program work: if panicking on\n    // another goroutine at the same time as main returns,\n    // let the other goroutine finish printing the panic trace.\n    // Once it does, it will exit. See issues 3934 and 20018.\n    // 如果goroutine panic了则创建另一个goroutine打印相关信息，完成之后新建goroutine将退出\n    if atomic.Load(&amp;runningPanicDefers) != 0 {\n        // Running deferred functions should not take long.\n        for c := 0; c &lt; 1000; c++ {\n            if atomic.Load(&amp;runningPanicDefers) == 0 {\n                break\n            }\n            Gosched()\n        }\n    }\n    if atomic.Load(&amp;panicking) != 0 {\n        gopark(nil, nil, waitReasonPanicWait, traceEvGoStop, 1)\n    }\n\n    exit(0) // 退出进程\n    for {\n        var x *int32\n        *x = 0\n    }\n}</code></pre><p>在程序启动时会创建m0，同时创建g0，在<code>runtime/proc.go</code>声明：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> <span class=\"token punctuation\">(</span>\n    m0 m\n    g0 g\n<span class=\"token punctuation\">)</span></code></pre>\n<blockquote>\n<p>特殊的m0，是启动程序后的编号为0的主线程，这个M对应的实例会在全局变量<code>runtime.m0</code>中，不需要在heap上分配，m0负责执行初始化操作和启动第一个G，在之后M0就和其他的一样了。</p>\n</blockquote>\n<p>初始化P，创建<code>main()</code>的g1，将g1存放于p的本地G队列中，启动m0，m0绑定p，如果绑定不成功就会进入全局休眠M队列等待被唤醒，从p中获取可执行的G，如果没有课执行的G则会进入自旋状态，如果获取到g1，设置g1的运行环境，运行g1，g1退出，m0继续通过p获取G。</p>\n<blockquote>\n<p>自旋状态，是指M绑定的P没有可以执行的G，此时M执行的g0，轮询P的本地空闲G队列有没有可执行的G</p>\n</blockquote>\n<h2 id=\"三者关系\"><a href=\"#三者关系\" class=\"headerlink\" title=\"三者关系\"></a>三者关系</h2><ul>\n<li><p><code>G</code>需要绑定在<code>M</code>上才能运行；</p>\n</li>\n<li><p><code>M</code>需要绑定<code>P</code>才能运行；</p>\n</li>\n<li><p>程序中的多个<code>M</code>并不会同时都处于执行状态，最多只有<code>GOMAXPROCS</code>个<code>M</code>在执行。</p>\n<p>早期版本的Golang是没有<code>P</code>的，调度是由<code>G</code>与<code>M</code>完成。 这样的问题在于每当创建、终止Goroutine或者需要调度时，需要一个全局的锁来保护调度的相关对象(sched)。 全局锁严重影响Goroutine的并发性能。<br>通过引入<code>P</code>，实现了一种叫做<code>work-stealing</code>的调度算法：</p>\n</li>\n<li><p>每个<code>P</code>维护一个<code>G</code>队列；</p>\n</li>\n<li><p>当一个<code>G</code>被创建出来，或者变为可执行状态时，就把他放到<code>P</code>的可执行队列中；</p>\n</li>\n<li><p>当一个<code>G</code>执行结束时，<code>P</code>会从队列中把该<code>G</code>取出；如果此时<code>P</code>的队列为空，即没有其他<code>G</code>可以执行， 就随机选择另外一个<code>P</code>，从其可执行的<code>G</code>队列中偷取一半。</p>\n</li>\n</ul>\n<p>该算法避免了在Goroutine调度时使用全局锁。</p>\n<h1 id=\"可视化\"><a href=\"#可视化\" class=\"headerlink\" title=\"可视化\"></a>可视化</h1><h2 id=\"trace\"><a href=\"#trace\" class=\"headerlink\" title=\"trace\"></a>trace</h2><p>代码：</p>\n<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"runtime/trace\"\n)\n\nfunc main() {\n    f, err := os.Create(\"trace.out\")\n    if err != nil {\n        panic(err)\n    }\n\n    defer f.Close()\n\n    err = trace.Start(f)\n    if err != nil {\n        panic(err)\n    }\n    defer trace.Stop()\n\n    fmt.Println(\"Hello world!\")\n}</code></pre><p>运行程序会生成一个trace.out的文件，可以通过tool工具将其可视化</p>\n<pre><code>➜ go tool trace trace.out</code></pre><p>这样写会对代码侵入太强，可以写成测试文件，在test的时候生成trace.out文件，在<code>Test()</code>不需要显式的调用上面的代码，代码如下：</p>\n<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"testing\"\n)\n\nfunc Test(t *testing.T) {\n    fmt.Println(\"Hello world!\")\n}</code></pre><p>执行代码</p>\n<pre><code>go test -trace trace.out -run Test</code></pre><p>也可以生成trace.out文件。<br>在有了trace.out文件后，执行<code>go tool trace trace.out</code>，启动http服务可视化查看MPG的相关信息。</p>\n<h2 id=\"debug\"><a href=\"#debug\" class=\"headerlink\" title=\"debug\"></a>debug</h2><p>代码：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">package</span> main\n\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token string\">\"fmt\"</span>\n<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello world!\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>在执行之前设置<code>GODEBUG=schedtrace=10</code>，单位毫秒<br>执行结果</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">GODEBUG=schedtrace=10 go run main.go \nSCHED 0ms: gomaxprocs=4 idleprocs=1 threads=6 spinningthreads=1 idlethreads=0 runqueue=0 [1 0 0 0]\nSCHED 18ms: gomaxprocs=4 idleprocs=0 threads=9 spinningthreads=1 idlethreads=2 runqueue=1 [0 4 0 0]\nSCHED 30ms: gomaxprocs=4 idleprocs=1 threads=9 spinningthreads=1 idlethreads=2 runqueue=0 [0 0 0 0]\nSCHED 42ms: gomaxprocs=4 idleprocs=2 threads=9 spinningthreads=0 idlethreads=3 runqueue=1 [0 0 0 0]\nSCHED 53ms: gomaxprocs=4 idleprocs=4 threads=9 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]\nSCHED 66ms: gomaxprocs=4 idleprocs=0 threads=9 spinningthreads=1 idlethreads=2 runqueue=1 [0 0 0 0]\nSCHED 79ms: gomaxprocs=4 idleprocs=3 threads=9 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]</code></pre>\n<ul>\n<li><code>SCHED 0ms</code>：调试信息输出标志字符串，后面是执行的时间戳</li>\n<li><code>gomaxprocs</code>：P的数量，本例有4个P，默认与cpu核心数量一致，可以通过GOMAXPROCS来设置</li>\n<li><code>idleprocs</code>：处于idle状态P的数量</li>\n<li><code>threads</code>：M的数量，包含scheduler使用的M数量，加上runtime自用的类似sysmon这样的thread的数量</li>\n<li><code>spinningthreads</code>: 处于自旋状态M数量</li>\n<li><code>idlethread</code>: 处于idle状态的M的数量</li>\n<li><code>runqueue=0</code>：Scheduler全局队列中G的数量</li>\n<li><code>[0 0 0 0]</code>: 分别为4个的<code>local queue</code>中的G的数量</li>\n</ul>\n<h1 id=\"关键字段说明\"><a href=\"#关键字段说明\" class=\"headerlink\" title=\"关键字段说明\"></a>关键字段说明</h1><h2 id=\"M\"><a href=\"#M\" class=\"headerlink\" title=\"M\"></a>M</h2><pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> m <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    g0      <span class=\"token operator\">*</span>g     <span class=\"token comment\" spellcheck=\"true\">// goroutine with scheduling stack</span>\n    morebuf gobuf  <span class=\"token comment\" spellcheck=\"true\">// gobuf arg to morestack</span>\n    divmod  <span class=\"token builtin\">uint32</span> <span class=\"token comment\" spellcheck=\"true\">// div/mod denominator for arm - known to liblink</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Fields not known to debuggers.</span>\n    procid        <span class=\"token builtin\">uint64</span>       <span class=\"token comment\" spellcheck=\"true\">// for debuggers, but offset not hard-coded</span>\n    gsignal       <span class=\"token operator\">*</span>g           <span class=\"token comment\" spellcheck=\"true\">// signal-handling g</span>\n    goSigStack    gsignalStack <span class=\"token comment\" spellcheck=\"true\">// Go-allocated signal handling stack</span>\n    sigmask       sigset       <span class=\"token comment\" spellcheck=\"true\">// storage for saved signal mask</span>\n    tls           <span class=\"token punctuation\">[</span><span class=\"token number\">6</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">uintptr</span>   <span class=\"token comment\" spellcheck=\"true\">// thread-local storage (for x86 extern register)</span>\n    mstartfn      <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    curg          <span class=\"token operator\">*</span>g       <span class=\"token comment\" spellcheck=\"true\">// 当前执行的G，检测gp</span>\n    caughtsig     guintptr <span class=\"token comment\" spellcheck=\"true\">// goroutine running during fatal signal</span>\n    p             puintptr <span class=\"token comment\" spellcheck=\"true\">// 绑定的P执行go代码 (如果没有执行go代码则为nil)</span>\n    nextp         puintptr\n    oldp          puintptr <span class=\"token comment\" spellcheck=\"true\">// 执行系统调用之前的P</span>\n    id            <span class=\"token builtin\">int64</span>\n    mallocing     <span class=\"token builtin\">int32</span>\n    throwing      <span class=\"token builtin\">int32</span>\n    preemptoff    <span class=\"token builtin\">string</span> <span class=\"token comment\" spellcheck=\"true\">// if != \"\", keep curg running on this m</span>\n    locks         <span class=\"token builtin\">int32</span>  <span class=\"token comment\" spellcheck=\"true\">// m的引用计数 </span>\n    dying         <span class=\"token builtin\">int32</span>\n    profilehz     <span class=\"token builtin\">int32</span>\n    spinning      <span class=\"token builtin\">bool</span> <span class=\"token comment\" spellcheck=\"true\">// m is out of work and is actively looking for work</span>\n    blocked       <span class=\"token builtin\">bool</span> <span class=\"token comment\" spellcheck=\"true\">// m is blocked on a note</span>\n    newSigstack   <span class=\"token builtin\">bool</span> <span class=\"token comment\" spellcheck=\"true\">// minit on C thread called sigaltstack</span>\n    printlock     <span class=\"token builtin\">int8</span>\n    incgo         <span class=\"token builtin\">bool</span>   <span class=\"token comment\" spellcheck=\"true\">// m is executing a cgo call</span>\n    freeWait      <span class=\"token builtin\">uint32</span> <span class=\"token comment\" spellcheck=\"true\">// if == 0, safe to free g0 and delete m (atomic)</span>\n    fastrand      <span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">uint32</span> <span class=\"token comment\" spellcheck=\"true\">// 两个随机值，不能同时为0</span>\n    needextram    <span class=\"token builtin\">bool</span>\n    traceback     <span class=\"token builtin\">uint8</span>\n    ncgocall      <span class=\"token builtin\">uint64</span>      <span class=\"token comment\" spellcheck=\"true\">// number of cgo calls in total</span>\n    ncgo          <span class=\"token builtin\">int32</span>       <span class=\"token comment\" spellcheck=\"true\">// number of cgo calls currently in progress</span>\n    cgoCallersUse <span class=\"token builtin\">uint32</span>      <span class=\"token comment\" spellcheck=\"true\">// if non-zero, cgoCallers in use temporarily</span>\n    cgoCallers    <span class=\"token operator\">*</span>cgoCallers <span class=\"token comment\" spellcheck=\"true\">// cgo traceback if crashing in cgo call</span>\n    park          note\n    alllink       <span class=\"token operator\">*</span>m <span class=\"token comment\" spellcheck=\"true\">// on allm</span>\n    schedlink     muintptr    <span class=\"token comment\" spellcheck=\"true\">// M的单链表</span>\n    lockedg       guintptr    <span class=\"token comment\" spellcheck=\"true\">// M锁定的G</span>\n    createstack   <span class=\"token punctuation\">[</span><span class=\"token number\">32</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">uintptr</span> <span class=\"token comment\" spellcheck=\"true\">// stack that created this thread.</span>\n    lockedExt     <span class=\"token builtin\">uint32</span>      <span class=\"token comment\" spellcheck=\"true\">// tracking for external LockOSThread</span>\n    lockedInt     <span class=\"token builtin\">uint32</span>      <span class=\"token comment\" spellcheck=\"true\">// tracking for internal lockOSThread</span>\n    nextwaitm     muintptr    <span class=\"token comment\" spellcheck=\"true\">// next m waiting for lock</span>\n    waitunlockf   <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>g<span class=\"token punctuation\">,</span> unsafe<span class=\"token punctuation\">.</span>Pointer<span class=\"token punctuation\">)</span> <span class=\"token builtin\">bool</span>\n    waitlock      unsafe<span class=\"token punctuation\">.</span>Pointer\n    waittraceev   <span class=\"token builtin\">byte</span>\n    waittraceskip <span class=\"token builtin\">int</span>\n    startingtrace <span class=\"token builtin\">bool</span>\n    syscalltick   <span class=\"token builtin\">uint32</span>\n    freelink      <span class=\"token operator\">*</span>m <span class=\"token comment\" spellcheck=\"true\">// 对应全局休眠M队列</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// these are here because they are too large to be on the stack</span>\n    <span class=\"token comment\" spellcheck=\"true\">// of low-level NOSPLIT functions.</span>\n    libcall   libcall\n    libcallpc <span class=\"token builtin\">uintptr</span> <span class=\"token comment\" spellcheck=\"true\">// for cpu profiler</span>\n    libcallsp <span class=\"token builtin\">uintptr</span>\n    libcallg  guintptr\n    syscall   libcall <span class=\"token comment\" spellcheck=\"true\">// stores syscall parameters on windows</span>\n\n    vdsoSP <span class=\"token builtin\">uintptr</span> <span class=\"token comment\" spellcheck=\"true\">// SP for traceback while in VDSO call (0 if not in call)</span>\n    vdsoPC <span class=\"token builtin\">uintptr</span> <span class=\"token comment\" spellcheck=\"true\">// PC for traceback while in VDSO call</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// preemptGen counts the number of completed preemption</span>\n    <span class=\"token comment\" spellcheck=\"true\">// signals. This is used to detect when a preemption is</span>\n    <span class=\"token comment\" spellcheck=\"true\">// requested, but fails. Accessed atomically.</span>\n    preemptGen <span class=\"token builtin\">uint32</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Whether this is a pending preemption signal on this M.</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Accessed atomically.</span>\n    signalPending <span class=\"token builtin\">uint32</span>\n\n    dlogPerM\n\n    mOS\n\n    <span class=\"token comment\" spellcheck=\"true\">// Up to 10 locks held by this m, maintained by the lock ranking code.</span>\n    locksHeldLen <span class=\"token builtin\">int</span>\n    locksHeld    <span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span>heldLockInfo\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"P\"><a href=\"#P\" class=\"headerlink\" title=\"P\"></a>P</h2><pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> p <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    id          <span class=\"token builtin\">int32</span>\n    status      <span class=\"token builtin\">uint32</span> <span class=\"token comment\" spellcheck=\"true\">// one of pidle/prunning/...</span>\n    link        puintptr   <span class=\"token comment\" spellcheck=\"true\">// P的单链表</span>\n    schedtick   <span class=\"token builtin\">uint32</span>     <span class=\"token comment\" spellcheck=\"true\">// incremented on every scheduler call</span>\n    syscalltick <span class=\"token builtin\">uint32</span>     <span class=\"token comment\" spellcheck=\"true\">// incremented on every system call</span>\n    sysmontick  sysmontick <span class=\"token comment\" spellcheck=\"true\">// last tick observed by sysmon</span>\n    m           muintptr   <span class=\"token comment\" spellcheck=\"true\">// 当前的M，如果空闲则为nil</span>\n    mcache      <span class=\"token operator\">*</span>mcache\n    pcache      pageCache\n    raceprocctx <span class=\"token builtin\">uintptr</span>\n\n    deferpool    <span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token operator\">*</span>_defer <span class=\"token comment\" spellcheck=\"true\">// pool of available defer structs of different sizes (see panic.go)</span>\n    deferpoolbuf <span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">32</span><span class=\"token punctuation\">]</span><span class=\"token operator\">*</span>_defer\n\n    <span class=\"token comment\" spellcheck=\"true\">// Cache of goroutine ids, amortizes accesses to runtime·sched.goidgen.</span>\n    goidcache    <span class=\"token builtin\">uint64</span>\n    goidcacheend <span class=\"token builtin\">uint64</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Queue of runnable goroutines. Accessed without lock.</span>\n    runqhead <span class=\"token builtin\">uint32</span>         <span class=\"token comment\" spellcheck=\"true\">// 队首下标</span>\n    runqtail <span class=\"token builtin\">uint32</span>         <span class=\"token comment\" spellcheck=\"true\">// 队尾下标</span>\n    runq     <span class=\"token punctuation\">[</span><span class=\"token number\">256</span><span class=\"token punctuation\">]</span>guintptr  <span class=\"token comment\" spellcheck=\"true\">// 可执行队列，最多256个</span>\n    <span class=\"token comment\" spellcheck=\"true\">// runnext, if non-nil, is a runnable G that was ready'd by</span>\n    <span class=\"token comment\" spellcheck=\"true\">// the current G and should be run next instead of what's in</span>\n    <span class=\"token comment\" spellcheck=\"true\">// runq if there's time remaining in the running G's time</span>\n    <span class=\"token comment\" spellcheck=\"true\">// slice. It will inherit the time left in the current time</span>\n    <span class=\"token comment\" spellcheck=\"true\">// slice. If a set of goroutines is locked in a</span>\n    <span class=\"token comment\" spellcheck=\"true\">// communicate-and-wait pattern, this schedules that set as a</span>\n    <span class=\"token comment\" spellcheck=\"true\">// unit and eliminates the (potentially large) scheduling</span>\n    <span class=\"token comment\" spellcheck=\"true\">// latency that otherwise arises from adding the ready'd</span>\n    <span class=\"token comment\" spellcheck=\"true\">// goroutines to the end of the run queue.</span>\n    runnext guintptr\n\n    <span class=\"token comment\" spellcheck=\"true\">// Available G's (status == Gdead)</span>\n    gFree <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n        gList\n        n <span class=\"token builtin\">int32</span>\n    <span class=\"token punctuation\">}</span>\n\n    sudogcache <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token operator\">*</span>sudog     <span class=\"token comment\" spellcheck=\"true\">// 本地G的队列</span>\n    sudogbuf   <span class=\"token punctuation\">[</span><span class=\"token number\">128</span><span class=\"token punctuation\">]</span><span class=\"token operator\">*</span>sudog\n\n    <span class=\"token comment\" spellcheck=\"true\">// Cache of mspan objects from the heap.</span>\n    mspancache <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// We need an explicit length here because this field is used</span>\n        <span class=\"token comment\" spellcheck=\"true\">// in allocation codepaths where write barriers are not allowed,</span>\n        <span class=\"token comment\" spellcheck=\"true\">// and eliminating the write barrier/keeping it eliminated from</span>\n        <span class=\"token comment\" spellcheck=\"true\">// slice updates is tricky, moreso than just managing the length</span>\n        <span class=\"token comment\" spellcheck=\"true\">// ourselves.</span>\n        <span class=\"token builtin\">len</span> <span class=\"token builtin\">int</span>\n        buf <span class=\"token punctuation\">[</span><span class=\"token number\">128</span><span class=\"token punctuation\">]</span><span class=\"token operator\">*</span>mspan\n    <span class=\"token punctuation\">}</span>\n\n    tracebuf traceBufPtr\n\n    <span class=\"token comment\" spellcheck=\"true\">// traceSweep indicates the sweep events should be traced.</span>\n    <span class=\"token comment\" spellcheck=\"true\">// This is used to defer the sweep start event until a span</span>\n    <span class=\"token comment\" spellcheck=\"true\">// has actually been swept.</span>\n    traceSweep <span class=\"token builtin\">bool</span>\n    <span class=\"token comment\" spellcheck=\"true\">// traceSwept and traceReclaimed track the number of bytes</span>\n    <span class=\"token comment\" spellcheck=\"true\">// swept and reclaimed by sweeping in the current sweep loop.</span>\n    traceSwept<span class=\"token punctuation\">,</span> traceReclaimed <span class=\"token builtin\">uintptr</span>\n\n    palloc persistentAlloc <span class=\"token comment\" spellcheck=\"true\">// per-P to avoid mutex</span>\n\n    <span class=\"token boolean\">_</span> <span class=\"token builtin\">uint32</span> <span class=\"token comment\" spellcheck=\"true\">// Alignment for atomic fields below</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// The when field of the first entry on the timer heap.</span>\n    <span class=\"token comment\" spellcheck=\"true\">// This is updated using atomic functions.</span>\n    <span class=\"token comment\" spellcheck=\"true\">// This is 0 if the timer heap is empty.</span>\n    timer0When <span class=\"token builtin\">uint64</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Per-P GC state</span>\n    gcAssistTime         <span class=\"token builtin\">int64</span>    <span class=\"token comment\" spellcheck=\"true\">// Nanoseconds in assistAlloc</span>\n    gcFractionalMarkTime <span class=\"token builtin\">int64</span>    <span class=\"token comment\" spellcheck=\"true\">// Nanoseconds in fractional mark worker (atomic)</span>\n    gcBgMarkWorker       guintptr <span class=\"token comment\" spellcheck=\"true\">// (atomic)</span>\n    gcMarkWorkerMode     gcMarkWorkerMode\n\n    <span class=\"token comment\" spellcheck=\"true\">// gcMarkWorkerStartTime is the nanotime() at which this mark</span>\n    <span class=\"token comment\" spellcheck=\"true\">// worker started.</span>\n    gcMarkWorkerStartTime <span class=\"token builtin\">int64</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// gcw is this P's GC work buffer cache. The work buffer is</span>\n    <span class=\"token comment\" spellcheck=\"true\">// filled by write barriers, drained by mutator assists, and</span>\n    <span class=\"token comment\" spellcheck=\"true\">// disposed on certain GC state transitions.</span>\n    gcw gcWork\n\n    <span class=\"token comment\" spellcheck=\"true\">// wbBuf is this P's GC write barrier buffer.</span>\n    <span class=\"token comment\" spellcheck=\"true\">//</span>\n    <span class=\"token comment\" spellcheck=\"true\">// TODO: Consider caching this in the running G.</span>\n    wbBuf wbBuf\n\n    runSafePointFn <span class=\"token builtin\">uint32</span> <span class=\"token comment\" spellcheck=\"true\">// if 1, run sched.safePointFn at next safe point</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Lock for timers. We normally access the timers while running</span>\n    <span class=\"token comment\" spellcheck=\"true\">// on this P, but the scheduler can also do it from a different P.</span>\n    timersLock mutex\n\n    <span class=\"token comment\" spellcheck=\"true\">// Actions to take at some time. This is used to implement the</span>\n    <span class=\"token comment\" spellcheck=\"true\">// standard library's time package.</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Must hold timersLock to access.</span>\n    timers <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token operator\">*</span>timer\n\n    <span class=\"token comment\" spellcheck=\"true\">// Number of timers in P's heap.</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Modified using atomic instructions.</span>\n    numTimers <span class=\"token builtin\">uint32</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Number of timerModifiedEarlier timers on P's heap.</span>\n    <span class=\"token comment\" spellcheck=\"true\">// This should only be modified while holding timersLock,</span>\n    <span class=\"token comment\" spellcheck=\"true\">// or while the timer status is in a transient state</span>\n    <span class=\"token comment\" spellcheck=\"true\">// such as timerModifying.</span>\n    adjustTimers <span class=\"token builtin\">uint32</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Number of timerDeleted timers in P's heap.</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Modified using atomic instructions.</span>\n    deletedTimers <span class=\"token builtin\">uint32</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Race context used while executing timer functions.</span>\n    timerRaceCtx <span class=\"token builtin\">uintptr</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// preempt is set to indicate that this P should be enter the</span>\n    <span class=\"token comment\" spellcheck=\"true\">// scheduler ASAP (regardless of what G is running on it).</span>\n    preempt <span class=\"token builtin\">bool</span>\n\n    pad cpu<span class=\"token punctuation\">.</span>CacheLinePad\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"G\"><a href=\"#G\" class=\"headerlink\" title=\"G\"></a>G</h2><pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> g <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Stack parameters.</span>\n    <span class=\"token comment\" spellcheck=\"true\">// stack describes the actual stack memory: [stack.lo, stack.hi).</span>\n    <span class=\"token comment\" spellcheck=\"true\">// stackguard0 is the stack pointer compared in the Go stack growth prologue.</span>\n    <span class=\"token comment\" spellcheck=\"true\">// It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption.</span>\n    <span class=\"token comment\" spellcheck=\"true\">// stackguard1 is the stack pointer compared in the C stack growth prologue.</span>\n    <span class=\"token comment\" spellcheck=\"true\">// It is stack.lo+StackGuard on g0 and gsignal stacks.</span>\n    <span class=\"token comment\" spellcheck=\"true\">// It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash).</span>\n    stack       stack   <span class=\"token comment\" spellcheck=\"true\">// offset known to runtime/cgo</span>\n    stackguard0 <span class=\"token builtin\">uintptr</span> <span class=\"token comment\" spellcheck=\"true\">// offset known to liblink</span>\n    stackguard1 <span class=\"token builtin\">uintptr</span> <span class=\"token comment\" spellcheck=\"true\">// offset known to liblink</span>\n\n    _panic       <span class=\"token operator\">*</span>_panic <span class=\"token comment\" spellcheck=\"true\">// innermost panic - offset known to liblink</span>\n    _defer       <span class=\"token operator\">*</span>_defer <span class=\"token comment\" spellcheck=\"true\">// innermost defer</span>\n    m            <span class=\"token operator\">*</span>m      <span class=\"token comment\" spellcheck=\"true\">// 当前M；offset known to arm liblink</span>\n    sched        gobuf\n    syscallsp    <span class=\"token builtin\">uintptr</span>        <span class=\"token comment\" spellcheck=\"true\">// if status==Gsyscall, syscallsp = sched.sp to use during gc</span>\n    syscallpc    <span class=\"token builtin\">uintptr</span>        <span class=\"token comment\" spellcheck=\"true\">// if status==Gsyscall, syscallpc = sched.pc to use during gc</span>\n    stktopsp     <span class=\"token builtin\">uintptr</span>        <span class=\"token comment\" spellcheck=\"true\">// expected sp at top of stack, to check in traceback</span>\n    param        unsafe<span class=\"token punctuation\">.</span>Pointer <span class=\"token comment\" spellcheck=\"true\">// passed parameter on wakeup</span>\n    atomicstatus <span class=\"token builtin\">uint32</span>     <span class=\"token comment\" spellcheck=\"true\">// G的状态</span>\n    stackLock    <span class=\"token builtin\">uint32</span>     <span class=\"token comment\" spellcheck=\"true\">// sigprof/scang lock; TODO: fold in to atomicstatus</span>\n    goid         <span class=\"token builtin\">int64</span>      <span class=\"token comment\" spellcheck=\"true\">// goroutine id</span>\n    schedlink    guintptr   <span class=\"token comment\" spellcheck=\"true\">// 下一个G的地址</span>\n    waitsince    <span class=\"token builtin\">int64</span>      <span class=\"token comment\" spellcheck=\"true\">// approx time when the g become blocked</span>\n    waitreason   waitReason <span class=\"token comment\" spellcheck=\"true\">// if status==Gwaiting</span>\n\n    preempt       <span class=\"token builtin\">bool</span> <span class=\"token comment\" spellcheck=\"true\">// preemption signal, duplicates stackguard0 = stackpreempt</span>\n    preemptStop   <span class=\"token builtin\">bool</span> <span class=\"token comment\" spellcheck=\"true\">// transition to _Gpreempted on preemption; otherwise, just deschedule</span>\n    preemptShrink <span class=\"token builtin\">bool</span> <span class=\"token comment\" spellcheck=\"true\">// shrink stack at synchronous safe point</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// asyncSafePoint is set if g is stopped at an asynchronous</span>\n    <span class=\"token comment\" spellcheck=\"true\">// safe point. This means there are frames on the stack</span>\n    <span class=\"token comment\" spellcheck=\"true\">// without precise pointer information.</span>\n    asyncSafePoint <span class=\"token builtin\">bool</span>\n\n    paniconfault <span class=\"token builtin\">bool</span> <span class=\"token comment\" spellcheck=\"true\">// panic (instead of crash) on unexpected fault address</span>\n    gcscandone   <span class=\"token builtin\">bool</span> <span class=\"token comment\" spellcheck=\"true\">// g has scanned stack; protected by _Gscan bit in status</span>\n    throwsplit   <span class=\"token builtin\">bool</span> <span class=\"token comment\" spellcheck=\"true\">// must not split stack</span>\n    <span class=\"token comment\" spellcheck=\"true\">// activeStackChans indicates that there are unlocked channels</span>\n    <span class=\"token comment\" spellcheck=\"true\">// pointing into this goroutine's stack. If true, stack</span>\n    <span class=\"token comment\" spellcheck=\"true\">// copying needs to acquire channel locks to protect these</span>\n    <span class=\"token comment\" spellcheck=\"true\">// areas of the stack.</span>\n    activeStackChans <span class=\"token builtin\">bool</span>\n\n    raceignore     <span class=\"token builtin\">int8</span>     <span class=\"token comment\" spellcheck=\"true\">// ignore race detection events</span>\n    sysblocktraced <span class=\"token builtin\">bool</span>     <span class=\"token comment\" spellcheck=\"true\">// StartTrace has emitted EvGoInSyscall about this goroutine</span>\n    sysexitticks   <span class=\"token builtin\">int64</span>    <span class=\"token comment\" spellcheck=\"true\">// cputicks when syscall has returned (for tracing)</span>\n    traceseq       <span class=\"token builtin\">uint64</span>   <span class=\"token comment\" spellcheck=\"true\">// trace event sequencer</span>\n    tracelastp     puintptr <span class=\"token comment\" spellcheck=\"true\">// last P emitted an event for this goroutine</span>\n    lockedm        muintptr\n    sig            <span class=\"token builtin\">uint32</span>\n    writebuf       <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">byte</span>\n    sigcode0       <span class=\"token builtin\">uintptr</span>\n    sigcode1       <span class=\"token builtin\">uintptr</span>\n    sigpc          <span class=\"token builtin\">uintptr</span>\n    gopc           <span class=\"token builtin\">uintptr</span>         <span class=\"token comment\" spellcheck=\"true\">// pc of go statement that created this goroutine</span>\n    ancestors      <span class=\"token operator\">*</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>ancestorInfo <span class=\"token comment\" spellcheck=\"true\">// ancestor information goroutine(s) that created this goroutine (only used if debug.tracebackancestors)</span>\n    startpc        <span class=\"token builtin\">uintptr</span>         <span class=\"token comment\" spellcheck=\"true\">// pc of goroutine function</span>\n    racectx        <span class=\"token builtin\">uintptr</span>\n    waiting        <span class=\"token operator\">*</span>sudog         <span class=\"token comment\" spellcheck=\"true\">// sudog structures this g is waiting on (that have a valid elem ptr); in lock order</span>\n    cgoCtxt        <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">uintptr</span>      <span class=\"token comment\" spellcheck=\"true\">// cgo traceback context</span>\n    labels         unsafe<span class=\"token punctuation\">.</span>Pointer <span class=\"token comment\" spellcheck=\"true\">// profiler labels</span>\n    timer          <span class=\"token operator\">*</span>timer         <span class=\"token comment\" spellcheck=\"true\">// cached timer for time.Sleep</span>\n    selectDone     <span class=\"token builtin\">uint32</span>         <span class=\"token comment\" spellcheck=\"true\">// are we participating in a select and did someone win the race?</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Per-G GC state</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// gcAssistBytes is this G's GC assist credit in terms of</span>\n    <span class=\"token comment\" spellcheck=\"true\">// bytes allocated. If this is positive, then the G has credit</span>\n    <span class=\"token comment\" spellcheck=\"true\">// to allocate gcAssistBytes bytes without assisting. If this</span>\n    <span class=\"token comment\" spellcheck=\"true\">// is negative, then the G must correct this by performing</span>\n    <span class=\"token comment\" spellcheck=\"true\">// scan work. We track this in bytes to make it fast to update</span>\n    <span class=\"token comment\" spellcheck=\"true\">// and check for debt in the malloc hot path. The assist ratio</span>\n    <span class=\"token comment\" spellcheck=\"true\">// determines how this corresponds to scan work debt.</span>\n    gcAssistBytes <span class=\"token builtin\">int64</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"Sched\"><a href=\"#Sched\" class=\"headerlink\" title=\"Sched\"></a>Sched</h2><pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> schedt <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// accessed atomically. keep at top to ensure alignment on 32-bit systems.</span>\n    goidgen   <span class=\"token builtin\">uint64</span>\n    lastpoll  <span class=\"token builtin\">uint64</span> <span class=\"token comment\" spellcheck=\"true\">// time of last network poll, 0 if currently polling</span>\n    pollUntil <span class=\"token builtin\">uint64</span> <span class=\"token comment\" spellcheck=\"true\">// time to which current poll is sleeping</span>\n\n    lock mutex <span class=\"token comment\" spellcheck=\"true\">// 操作锁，锁定schedt</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// When increasing nmidle, nmidlelocked, nmsys, or nmfreed, be</span>\n    <span class=\"token comment\" spellcheck=\"true\">// sure to call checkdead().</span>\n\n    midle        muintptr <span class=\"token comment\" spellcheck=\"true\">// 空闲M单链表</span>\n    nmidle       <span class=\"token builtin\">int32</span>    <span class=\"token comment\" spellcheck=\"true\">// 空闲M的个数</span>\n    nmidlelocked <span class=\"token builtin\">int32</span>    <span class=\"token comment\" spellcheck=\"true\">// number of locked m's waiting for work</span>\n    mnext        <span class=\"token builtin\">int64</span>    <span class=\"token comment\" spellcheck=\"true\">// number of m's that have been created and next M ID</span>\n    maxmcount    <span class=\"token builtin\">int32</span>    <span class=\"token comment\" spellcheck=\"true\">// maximum number of m's allowed (or die)</span>\n    nmsys        <span class=\"token builtin\">int32</span>    <span class=\"token comment\" spellcheck=\"true\">// number of system m's not counted for deadlock</span>\n    nmfreed      <span class=\"token builtin\">int64</span>    <span class=\"token comment\" spellcheck=\"true\">// cumulative number of freed m's</span>\n\n    ngsys <span class=\"token builtin\">uint32</span> <span class=\"token comment\" spellcheck=\"true\">// number of system goroutines; updated atomically</span>\n\n    pidle      puintptr <span class=\"token comment\" spellcheck=\"true\">// 空闲的P</span>\n    npidle     <span class=\"token builtin\">uint32</span>\n    nmspinning <span class=\"token builtin\">uint32</span> <span class=\"token comment\" spellcheck=\"true\">// See \"Worker thread parking/unparking\" comment in proc.go.</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Global runnable queue.</span>\n    runq     gQueue  <span class=\"token comment\" spellcheck=\"true\">// 全局可执行队列</span>\n    runqsize <span class=\"token builtin\">int32</span>   <span class=\"token comment\" spellcheck=\"true\">// 全局队列大小</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// disable控制有选择的禁用调度</span>\n    <span class=\"token comment\" spellcheck=\"true\">//</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 使用schedEnableUser(enable bool)进行控制</span>\n    <span class=\"token comment\" spellcheck=\"true\">//</span>\n    <span class=\"token comment\" spellcheck=\"true\">// disable需要被sched.lock保护</span>\n    disable <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// user是否禁止调度goroutines.</span>\n        user     <span class=\"token builtin\">bool</span>\n        runnable gQueue <span class=\"token comment\" spellcheck=\"true\">// pending runnable Gs</span>\n        n        <span class=\"token builtin\">int32</span>  <span class=\"token comment\" spellcheck=\"true\">// length of runnable</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Global cache of dead G's.</span>\n    gFree <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n        lock    mutex\n        stack   gList <span class=\"token comment\" spellcheck=\"true\">// Gs with stacks</span>\n        noStack gList <span class=\"token comment\" spellcheck=\"true\">// Gs without stacks</span>\n        n       <span class=\"token builtin\">int32</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Central cache of sudog structs.</span>\n    sudoglock  mutex  <span class=\"token comment\" spellcheck=\"true\">// 全局空闲G队列锁</span>\n    sudogcache <span class=\"token operator\">*</span>sudog <span class=\"token comment\" spellcheck=\"true\">// 全局空闲G队列</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Central pool of available defer structs of different sizes.</span>\n    deferlock mutex\n    deferpool <span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token operator\">*</span>_defer\n\n    <span class=\"token comment\" spellcheck=\"true\">// freem is the list of m's waiting to be freed when their</span>\n    <span class=\"token comment\" spellcheck=\"true\">// m.exited is set. Linked through m.freelink.</span>\n    freem <span class=\"token operator\">*</span>m <span class=\"token comment\" spellcheck=\"true\">// 全局休眠M队列</span>\n\n    gcwaiting  <span class=\"token builtin\">uint32</span> <span class=\"token comment\" spellcheck=\"true\">// gc is waiting to run</span>\n    stopwait   <span class=\"token builtin\">int32</span>\n    stopnote   note\n    sysmonwait <span class=\"token builtin\">uint32</span>\n    sysmonnote note\n\n    <span class=\"token comment\" spellcheck=\"true\">// safepointFn should be called on each P at the next GC</span>\n    <span class=\"token comment\" spellcheck=\"true\">// safepoint if p.runSafePointFn is set.</span>\n    safePointFn   <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>p<span class=\"token punctuation\">)</span>\n    safePointWait <span class=\"token builtin\">int32</span>\n    safePointNote note\n\n    profilehz <span class=\"token builtin\">int32</span> <span class=\"token comment\" spellcheck=\"true\">// cpu profiling rate</span>\n\n    procresizetime <span class=\"token builtin\">int64</span> <span class=\"token comment\" spellcheck=\"true\">// nanotime() of last change to gomaxprocs</span>\n    totaltime      <span class=\"token builtin\">int64</span> <span class=\"token comment\" spellcheck=\"true\">// ∫gomaxprocs dt up to procresizetime</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// sysmonlock protects sysmon's actions on the runtime.</span>\n    <span class=\"token comment\" spellcheck=\"true\">//</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Acquire and hold this mutex to block sysmon from interacting</span>\n    <span class=\"token comment\" spellcheck=\"true\">// with the rest of the runtime.</span>\n    sysmonlock mutex\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"字段和结构体\"><a href=\"#字段和结构体\" class=\"headerlink\" title=\"字段和结构体\"></a>字段和结构体</h1><h2 id=\"G状态\"><a href=\"#G状态\" class=\"headerlink\" title=\"G状态\"></a>G状态</h2><pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">const</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token comment\" spellcheck=\"true\">// G status</span>\n    <span class=\"token comment\" spellcheck=\"true\">//</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 除了指示G的一般状态外，G状态还像goroutine堆栈上的锁一样（因此具有执行用户代码的能力）。</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// _Gidle表示此goroutine已分配，尚未初始化。</span>\n    _Gidle <span class=\"token operator\">=</span> <span class=\"token boolean\">iota</span> <span class=\"token comment\" spellcheck=\"true\">// 0</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// _Grunnable表示此goroutine在运行队列中，当前未执行用户代码，没有堆栈。</span>\n    _Grunnable <span class=\"token comment\" spellcheck=\"true\">// 1</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// _Grunning表示此goroutine可以执行用户代码。</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 该goroutine拥有堆栈，且不在运行队列中。</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 它已分配一个M和一个P。</span>\n    _Grunning <span class=\"token comment\" spellcheck=\"true\">// 2</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// _Gsyscall表示此goroutine正在执行系统调用。</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 它不执行用户代码，堆栈由该goroutine拥有，它不在运行队列中。</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 它被分配了一个M。</span>\n    _Gsyscall <span class=\"token comment\" spellcheck=\"true\">// 3</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// _Gwaiting 意味着goroutine被runtime阻止。</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 它不执行用户代码，它也不再运行队列，但应该被记录下来（例如：等待chan中的数据），必要时可以调用ready()恢复。</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 除chan操作可以在适当的锁下读取或写入堆栈的某些部分外，不应该拥有该堆栈。</span>\n    _Gwaiting <span class=\"token comment\" spellcheck=\"true\">// 4</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// _Gmoribund_unused当前未使用，但已在gdb脚本中进行了硬编码。</span>\n    _Gmoribund_unused <span class=\"token comment\" spellcheck=\"true\">// 5</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// _Gdead表示此goroutine当前未使用。</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 它有可能已退出，在空闲列表或刚被初始化。它不能执行用户代码。它可能拥有堆栈也可能不拥有堆栈。</span>\n    <span class=\"token comment\" spellcheck=\"true\">// G及其堆栈（如果有）由退出G或从空闲列表中获得G的M拥有。</span>\n    _Gdead <span class=\"token comment\" spellcheck=\"true\">// 6</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// _Genqueue_unused当前未使用。</span>\n    _Genqueue_unused <span class=\"token comment\" spellcheck=\"true\">// 7</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// _Gcopystack表示此goroutine的堆栈正在迁移。</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 它不能执行用户代码，并且不再运行队列中。</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 堆栈由将其放入_Gcopystack的goroutine拥有。</span>\n    _Gcopystack <span class=\"token comment\" spellcheck=\"true\">// 8</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// _Gscan与上述状态之一组合表示GC正在扫描堆栈（除_Grunning）。</span>\n    <span class=\"token comment\" spellcheck=\"true\">// goroutine未执行用户代码，并且堆栈由设置_Gscan位的goroutine拥有。</span>\n    <span class=\"token comment\" spellcheck=\"true\">// _Gscanrunning不同: 它用于短暂阻止状态转换，而GC则通知G扫描其自身的堆栈。否则就像_Grunning。</span>\n    <span class=\"token comment\" spellcheck=\"true\">// atomicstatus&amp;~Gscan 给出goroutine将在扫描完成时返回的状态。</span>\n    _Gscan         <span class=\"token operator\">=</span> <span class=\"token number\">0x1000</span>\n    _Gscanrunnable <span class=\"token operator\">=</span> _Gscan <span class=\"token operator\">+</span> _Grunnable <span class=\"token comment\" spellcheck=\"true\">// 0x1001</span>\n    _Gscanrunning  <span class=\"token operator\">=</span> _Gscan <span class=\"token operator\">+</span> _Grunning  <span class=\"token comment\" spellcheck=\"true\">// 0x1002</span>\n    _Gscansyscall  <span class=\"token operator\">=</span> _Gscan <span class=\"token operator\">+</span> _Gsyscall  <span class=\"token comment\" spellcheck=\"true\">// 0x1003</span>\n    _Gscanwaiting  <span class=\"token operator\">=</span> _Gscan <span class=\"token operator\">+</span> _Gwaiting  <span class=\"token comment\" spellcheck=\"true\">// 0x1004</span>\n<span class=\"token punctuation\">)</span></code></pre>\n<h2 id=\"P状态\"><a href=\"#P状态\" class=\"headerlink\" title=\"P状态\"></a>P状态</h2><pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">const</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token comment\" spellcheck=\"true\">// P status</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// _Pidle表示不使用P来运行用户代码或调度程序。</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 它在空闲的P列表中，可供调度程序使用，但可能只是在其他状态之间转换。</span>\n    <span class=\"token comment\" spellcheck=\"true\">//</span>\n    <span class=\"token comment\" spellcheck=\"true\">// P由空闲列表或转换其状态的任何内容所拥有。它的运行队列为空。</span>\n    _Pidle <span class=\"token operator\">=</span> <span class=\"token boolean\">iota</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// _Prunning表示P由M拥有，并用于运行用户代码或调度程序。</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 仅拥有此P的M允许从_Prunning更改P的状态。</span>\n    <span class=\"token comment\" spellcheck=\"true\">// M可以将P转换为_Pidle（如果没有更多工作要做），_Psyscall（进入系统调用时）或_Pgcstop（以停止GC）。</span>\n    <span class=\"token comment\" spellcheck=\"true\">// M也可以将P的所有权直接移交给另一个M（例如，调度锁定的G）。</span>\n    _Prunning\n\n    <span class=\"token comment\" spellcheck=\"true\">// _Psyscall表示P没有运行用户代码。</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 它与系统调用中的M有亲缘关系，但不归其所有，并且可能被另一个M窃取。</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 这类似于_Pidle，但使用轻量级转换并保持M相似性。</span>\n    <span class=\"token comment\" spellcheck=\"true\">//</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 必须通过CAS离开_Psyscall才能窃取或重新获得P。</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 注意ABA危害：</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 即使M在系统调用后成功将其原始P恢复为_Prunning，它也必须了解该P在此期间可能已被另一个M使用。</span>\n    _Psyscall\n\n    <span class=\"token comment\" spellcheck=\"true\">// _Pgcstop表示对STW(stop the world)暂停P并由STW的M拥有。</span>\n    <span class=\"token comment\" spellcheck=\"true\">// STW的M甚至在_Pgcstop中也继续使用其P。</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 从_Prunning过渡到_Pgcstop会导致M释放其P并停放。</span>\n    <span class=\"token comment\" spellcheck=\"true\">//</span>\n    <span class=\"token comment\" spellcheck=\"true\">// P保留其运行队列，STW将使用非空运行队列在P上重新启动调度程序。</span>\n    _Pgcstop\n\n    <span class=\"token comment\" spellcheck=\"true\">// _Pdead表示不再使用P（GOMAXPROCS缩小），如果P的数量增加将会复用P。</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 一个死掉的P大部分被剥夺了其资源，尽管还剩下一些东西（例如跟踪缓冲区）。</span>\n    _Pdead\n<span class=\"token punctuation\">)</span></code></pre>\n<h2 id=\"runtime2-go-全局变量\"><a href=\"#runtime2-go-全局变量\" class=\"headerlink\" title=\"runtime2.go 全局变量\"></a>runtime2.go 全局变量</h2><pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> <span class=\"token punctuation\">(</span>\n    allglen    <span class=\"token builtin\">uintptr</span> <span class=\"token comment\" spellcheck=\"true\">// allgs的长度</span>\n    allm       <span class=\"token operator\">*</span>m      <span class=\"token comment\" spellcheck=\"true\">// 所有m的单链表</span>\n    allp       <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token operator\">*</span>p    <span class=\"token comment\" spellcheck=\"true\">// 所有的P列表，len(allp) == gomaxprocs，只能通过GOMAXPROCS()修改</span>\n    allpLock   mutex   <span class=\"token comment\" spellcheck=\"true\">// Protects P-less reads of allp and all writes</span>\n    gomaxprocs <span class=\"token builtin\">int32</span>         <span class=\"token comment\" spellcheck=\"true\">// 最大P的数量</span>\n    ncpu       <span class=\"token builtin\">int32</span>         <span class=\"token comment\" spellcheck=\"true\">// CPU数</span>\n    forcegc    forcegcstate\n    sched      schedt        <span class=\"token comment\" spellcheck=\"true\">// 调度者</span>\n    newprocs   <span class=\"token builtin\">int32</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Information about what cpu features are available.</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Packages outside the runtime should not use these</span>\n    <span class=\"token comment\" spellcheck=\"true\">// as they are not an external api.</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Set on startup in asm_{386,amd64}.s</span>\n    processorVersionInfo <span class=\"token builtin\">uint32</span>\n    isIntel              <span class=\"token builtin\">bool</span>\n    lfenceBeforeRdtsc    <span class=\"token builtin\">bool</span>\n\n    goarm                <span class=\"token builtin\">uint8</span> <span class=\"token comment\" spellcheck=\"true\">// set by cmd/link on arm systems</span>\n    framepointer_enabled <span class=\"token builtin\">bool</span>  <span class=\"token comment\" spellcheck=\"true\">// set by cmd/link</span>\n<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">var</span> <span class=\"token punctuation\">(</span>\n    allgs    <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token operator\">*</span>g  <span class=\"token comment\" spellcheck=\"true\">// 所有g的单链表</span>\n    allglock mutex <span class=\"token comment\" spellcheck=\"true\">// 修改单链表锁</span>\n<span class=\"token punctuation\">)</span></code></pre>\n<h2 id=\"sodug\"><a href=\"#sodug\" class=\"headerlink\" title=\"sodug\"></a>sodug</h2><pre><code>type hchan struct {\n    qcount   uint           // 队列元素总数\n    dataqsiz uint           // 循环队列的大小\n    buf      unsafe.Pointer // 指向dataqsiz元素数组\n    elemsize uint16\n    closed   uint32\n    elemtype *_type // element type\n    sendx    uint   // send index\n    recvx    uint   // receive index\n    recvq    waitq  // list of recv waiters\n    sendq    waitq  // list of send waiters\n\n    // lock保护hchan的所有字段，也保护sudog的所有字段在这个channel。\n    //\n    // 锁住此锁时，请勿更改另一个G的状态（特别是不要对G调用ready），因为这会因堆栈收缩而死锁。\n    lock mutex\n}\n\ntype waitq struct {\n    first *sudog\n    last  *sudog\n}\n\n// sudog 表示可执行G的列表，一个G可能在多个sudog中，\n// 并且许多G可能正在等待同一个同步对象，因此一个对象可能有许多sudog。\n// \n// sudog 由特殊的池分配，所以只能通过acquireSudog和releaseSudog来分配和释放sudog。\ntype sudog struct {\n    // 由hchan.lock来保护以下字段，收缩栈依赖sudog的操作\n\n    g *g\n\n    next *sudog\n    prev *sudog\n    elem unsafe.Pointer // data element (may point to stack)\n\n    // 以下字段永远不能同时访问\n    // 对于channel，waitlink仅由g访问。\n    // 对于信号量，仅在持有semaRoot锁时才能访问所有字段（包括上述字段）。\n\n    acquiretime int64\n    releasetime int64\n    ticket      uint32\n\n    // isSelect表示g正在参与选择，因此必须对g.selectDone进行CAS操作才能wake-up竞争。\n    isSelect bool\n\n    parent   *sudog // semaRoot binary tree\n    waitlink *sudog // g.waiting list or semaRoot\n    waittail *sudog // semaRoot\n    c        *hchan // channel，引用chan的底层实现\n}</code></pre><h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ul>\n<li><a href=\"https://learnku.com/articles/41728\" target=\"_blank\" rel=\"noopener\">[典藏版] Golang 调度器 GMP 原理与调度全分析</a></li>\n<li><a href=\"http://ga0.github.io/golang/2015/09/20/golang-runtime-scheduler.html\" target=\"_blank\" rel=\"noopener\">Golang调度器源码分析</a></li>\n</ul>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"friends":[{"avatar":"https://img-1251474779.cos.ap-beijing.myqcloud.com/icon.png","name":"djaigo","introduction":"好好学习，天天向上","url":"/","title":"前去学习"},{"avatar":"https://awps-assets.meituan.net/mit/blog/v20190629/asset/icon/favicon.ico?v=Whistle&t=20181017-1r","name":"美团技术团队","introduction":"一行代码，亿万生活。","url":"https://tech.meituan.com/","title":"点个外卖-->"},{"avatar":"","name":"鸟窝","introduction":"rpcx作者","url":"https://colobu.com/","title":"进个鸟窝-->"},{"avatar":"https://d1j8pt39hxlh3d.cloudfront.net/emoji/emojione/5.0/png/unicode/32/1f92a.png","name":"labuladong的算法小抄","introduction":"算法大神","url":"https://labuladong.gitbook.io/algo/","title":"学个算法-->"}]}},"excerpt":"","more":"<h1 id=\"MPG\"><a href=\"#MPG\" class=\"headerlink\" title=\"MPG\"></a>MPG</h1><p>MPG是golang的并发模型，结构源码在<code>runtime/runtime2.go</code>里面，主体逻辑结构在<code>runtime/proc.go</code>里，是golang可以高并发的根本。</p>\n<ul>\n<li>M，连接一个内核态的线程，goroutine跑在M上，每个M都会有一个g0的G，用于协调P队列里的G，在调度或系统调用时会用到g0的栈</li>\n<li>P，维护执行G队列，管理G上下文</li>\n<li>G，代表goroutine的元数据，包括栈信息，M信息，计数器等</li>\n</ul>\n<p>除了MPG之外，还有Sched来负责全局队列的处理。<br>四者协同完成整个golang的高并发处理的主要逻辑，还有其他小的结构进行辅助，例如：sudog（G队列）、stack（栈信息）等。</p>\n<p>M、P数量：</p>\n<ul>\n<li>P的数量可以在启动时通过环境变量<code>$GOMAXPROCS</code>，或在代码中通过<code>runtime</code>包的<code>GOMAXPROCS()</code>设置。P的数量限制了最大goroutine并发执行数。</li>\n<li>M的数量在启动时会被<code>schedinit()</code>设置成<code>sched.maxmcount = 10000</code>，可在代码中调用<code>runtime/debug</code>包的<code>SetMaxThreads()</code>。M的数量限制了最大可用的系统线程数。</li>\n</ul>\n<p>M、P创建：</p>\n<ul>\n<li>P，在系统确定了P的数量后就会创建指定个数的P</li>\n<li>M，如果P没有M，则会去全局休眠M队列中找，如果还没有则会创建M</li>\n</ul>\n<p>M调度策略：</p>\n<ul>\n<li>work stealing，当M执行G结束后，会从绑定P中获取G，而不是销毁当前M</li>\n<li>hand off，当G调用阻塞系统调用时，M释放绑定的P，将P交给空闲的M</li>\n</ul>\n<h2 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h2><p>程序启动第一时间都会调用<code>runtime.main()</code>，进行相关值的初始化。</p>\n<pre><code>// The main goroutine.\nfunc main() {\n    g := getg()\n\n    // Racectx of m0-&gt;g0 is used only as the parent of the main goroutine.\n    // It must not be used for anything else.\n    g.m.g0.racectx = 0\n\n    // Max stack size is 1 GB on 64-bit, 250 MB on 32-bit.\n    // Using decimal instead of binary GB and MB because\n    // they look nicer in the stack overflow failure message.\n    // 设置栈的最大值\n    if sys.PtrSize == 8 {\n        maxstacksize = 1000000000\n    } else {\n        maxstacksize = 250000000\n    }\n\n    // Allow newproc to start new Ms.\n    // 允许新P创建M\n    mainStarted = true\n\n    if GOARCH != &quot;wasm&quot; { // no threads on wasm yet, so no sysmon\n        systemstack(func() {\n            newm(sysmon, nil, -1)\n        })\n    }\n\n    // Lock the main goroutine onto this, the main OS thread,\n    // during initialization. Most programs won&#39;t care, but a few\n    // do require certain calls to be made by the main thread.\n    // Those can arrange for main.main to run in the main thread\n    // by calling runtime.LockOSThread during initialization\n    // to preserve the lock.\n    lockOSThread()\n\n    if g.m != &amp;m0 {\n        throw(&quot;runtime.main not on m0&quot;)\n    }\n\n    doInit(&amp;runtime_inittask) // must be before defer\n    if nanotime() == 0 {\n        throw(&quot;nanotime returning zero&quot;)\n    }\n\n    // Defer unlock so that runtime.Goexit during init does the unlock too.\n    needUnlock := true\n    defer func() {\n        if needUnlock {\n            unlockOSThread()\n        }\n    }()\n\n    // Record when the world started.\n    // 记录启动时间\n    runtimeInitTime = nanotime()\n\n    gcenable() // 开启GC\n    ...\n    needUnlock = false\n    unlockOSThread()\n\n    if isarchive || islibrary {\n        // A program compiled with -buildmode=c-archive or c-shared\n        // has a main, but it is not executed.\n        return\n    }\n\n    // 执行main包的main函数\n    fn := main_main // make an indirect call, as the linker doesn&#39;t know the address of the main package when laying down the runtime\n    fn()\n    if raceenabled {\n        racefini() // 竞态检测\n    }\n\n    // Make racy client program work: if panicking on\n    // another goroutine at the same time as main returns,\n    // let the other goroutine finish printing the panic trace.\n    // Once it does, it will exit. See issues 3934 and 20018.\n    // 如果goroutine panic了则创建另一个goroutine打印相关信息，完成之后新建goroutine将退出\n    if atomic.Load(&amp;runningPanicDefers) != 0 {\n        // Running deferred functions should not take long.\n        for c := 0; c &lt; 1000; c++ {\n            if atomic.Load(&amp;runningPanicDefers) == 0 {\n                break\n            }\n            Gosched()\n        }\n    }\n    if atomic.Load(&amp;panicking) != 0 {\n        gopark(nil, nil, waitReasonPanicWait, traceEvGoStop, 1)\n    }\n\n    exit(0) // 退出进程\n    for {\n        var x *int32\n        *x = 0\n    }\n}</code></pre><p>在程序启动时会创建m0，同时创建g0，在<code>runtime/proc.go</code>声明：</p>\n<pre><code class=\"go\">var (\n    m0 m\n    g0 g\n)</code></pre>\n<blockquote>\n<p>特殊的m0，是启动程序后的编号为0的主线程，这个M对应的实例会在全局变量<code>runtime.m0</code>中，不需要在heap上分配，m0负责执行初始化操作和启动第一个G，在之后M0就和其他的一样了。</p>\n</blockquote>\n<p>初始化P，创建<code>main()</code>的g1，将g1存放于p的本地G队列中，启动m0，m0绑定p，如果绑定不成功就会进入全局休眠M队列等待被唤醒，从p中获取可执行的G，如果没有课执行的G则会进入自旋状态，如果获取到g1，设置g1的运行环境，运行g1，g1退出，m0继续通过p获取G。</p>\n<blockquote>\n<p>自旋状态，是指M绑定的P没有可以执行的G，此时M执行的g0，轮询P的本地空闲G队列有没有可执行的G</p>\n</blockquote>\n<h2 id=\"三者关系\"><a href=\"#三者关系\" class=\"headerlink\" title=\"三者关系\"></a>三者关系</h2><ul>\n<li><p><code>G</code>需要绑定在<code>M</code>上才能运行；</p>\n</li>\n<li><p><code>M</code>需要绑定<code>P</code>才能运行；</p>\n</li>\n<li><p>程序中的多个<code>M</code>并不会同时都处于执行状态，最多只有<code>GOMAXPROCS</code>个<code>M</code>在执行。</p>\n<p>早期版本的Golang是没有<code>P</code>的，调度是由<code>G</code>与<code>M</code>完成。 这样的问题在于每当创建、终止Goroutine或者需要调度时，需要一个全局的锁来保护调度的相关对象(sched)。 全局锁严重影响Goroutine的并发性能。<br>通过引入<code>P</code>，实现了一种叫做<code>work-stealing</code>的调度算法：</p>\n</li>\n<li><p>每个<code>P</code>维护一个<code>G</code>队列；</p>\n</li>\n<li><p>当一个<code>G</code>被创建出来，或者变为可执行状态时，就把他放到<code>P</code>的可执行队列中；</p>\n</li>\n<li><p>当一个<code>G</code>执行结束时，<code>P</code>会从队列中把该<code>G</code>取出；如果此时<code>P</code>的队列为空，即没有其他<code>G</code>可以执行， 就随机选择另外一个<code>P</code>，从其可执行的<code>G</code>队列中偷取一半。</p>\n</li>\n</ul>\n<p>该算法避免了在Goroutine调度时使用全局锁。</p>\n<h1 id=\"可视化\"><a href=\"#可视化\" class=\"headerlink\" title=\"可视化\"></a>可视化</h1><h2 id=\"trace\"><a href=\"#trace\" class=\"headerlink\" title=\"trace\"></a>trace</h2><p>代码：</p>\n<pre><code>package main\n\nimport (\n    &quot;fmt&quot;\n    &quot;os&quot;\n    &quot;runtime/trace&quot;\n)\n\nfunc main() {\n    f, err := os.Create(&quot;trace.out&quot;)\n    if err != nil {\n        panic(err)\n    }\n\n    defer f.Close()\n\n    err = trace.Start(f)\n    if err != nil {\n        panic(err)\n    }\n    defer trace.Stop()\n\n    fmt.Println(&quot;Hello world!&quot;)\n}</code></pre><p>运行程序会生成一个trace.out的文件，可以通过tool工具将其可视化</p>\n<pre><code>➜ go tool trace trace.out</code></pre><p>这样写会对代码侵入太强，可以写成测试文件，在test的时候生成trace.out文件，在<code>Test()</code>不需要显式的调用上面的代码，代码如下：</p>\n<pre><code>package main\n\nimport (\n    &quot;fmt&quot;\n    &quot;testing&quot;\n)\n\nfunc Test(t *testing.T) {\n    fmt.Println(&quot;Hello world!&quot;)\n}</code></pre><p>执行代码</p>\n<pre><code>go test -trace trace.out -run Test</code></pre><p>也可以生成trace.out文件。<br>在有了trace.out文件后，执行<code>go tool trace trace.out</code>，启动http服务可视化查看MPG的相关信息。</p>\n<h2 id=\"debug\"><a href=\"#debug\" class=\"headerlink\" title=\"debug\"></a>debug</h2><p>代码：</p>\n<pre><code class=\"go\">package main\n\nimport (\n    &quot;fmt&quot;\n)\n\nfunc main() {\n    fmt.Println(&quot;Hello world!&quot;)\n}</code></pre>\n<p>在执行之前设置<code>GODEBUG=schedtrace=10</code>，单位毫秒<br>执行结果</p>\n<pre><code class=\"sh\">GODEBUG=schedtrace=10 go run main.go \nSCHED 0ms: gomaxprocs=4 idleprocs=1 threads=6 spinningthreads=1 idlethreads=0 runqueue=0 [1 0 0 0]\nSCHED 18ms: gomaxprocs=4 idleprocs=0 threads=9 spinningthreads=1 idlethreads=2 runqueue=1 [0 4 0 0]\nSCHED 30ms: gomaxprocs=4 idleprocs=1 threads=9 spinningthreads=1 idlethreads=2 runqueue=0 [0 0 0 0]\nSCHED 42ms: gomaxprocs=4 idleprocs=2 threads=9 spinningthreads=0 idlethreads=3 runqueue=1 [0 0 0 0]\nSCHED 53ms: gomaxprocs=4 idleprocs=4 threads=9 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]\nSCHED 66ms: gomaxprocs=4 idleprocs=0 threads=9 spinningthreads=1 idlethreads=2 runqueue=1 [0 0 0 0]\nSCHED 79ms: gomaxprocs=4 idleprocs=3 threads=9 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]</code></pre>\n<ul>\n<li><code>SCHED 0ms</code>：调试信息输出标志字符串，后面是执行的时间戳</li>\n<li><code>gomaxprocs</code>：P的数量，本例有4个P，默认与cpu核心数量一致，可以通过GOMAXPROCS来设置</li>\n<li><code>idleprocs</code>：处于idle状态P的数量</li>\n<li><code>threads</code>：M的数量，包含scheduler使用的M数量，加上runtime自用的类似sysmon这样的thread的数量</li>\n<li><code>spinningthreads</code>: 处于自旋状态M数量</li>\n<li><code>idlethread</code>: 处于idle状态的M的数量</li>\n<li><code>runqueue=0</code>：Scheduler全局队列中G的数量</li>\n<li><code>[0 0 0 0]</code>: 分别为4个的<code>local queue</code>中的G的数量</li>\n</ul>\n<h1 id=\"关键字段说明\"><a href=\"#关键字段说明\" class=\"headerlink\" title=\"关键字段说明\"></a>关键字段说明</h1><h2 id=\"M\"><a href=\"#M\" class=\"headerlink\" title=\"M\"></a>M</h2><pre><code class=\"go\">type m struct {\n    g0      *g     // goroutine with scheduling stack\n    morebuf gobuf  // gobuf arg to morestack\n    divmod  uint32 // div/mod denominator for arm - known to liblink\n\n    // Fields not known to debuggers.\n    procid        uint64       // for debuggers, but offset not hard-coded\n    gsignal       *g           // signal-handling g\n    goSigStack    gsignalStack // Go-allocated signal handling stack\n    sigmask       sigset       // storage for saved signal mask\n    tls           [6]uintptr   // thread-local storage (for x86 extern register)\n    mstartfn      func()\n    curg          *g       // 当前执行的G，检测gp\n    caughtsig     guintptr // goroutine running during fatal signal\n    p             puintptr // 绑定的P执行go代码 (如果没有执行go代码则为nil)\n    nextp         puintptr\n    oldp          puintptr // 执行系统调用之前的P\n    id            int64\n    mallocing     int32\n    throwing      int32\n    preemptoff    string // if != &quot;&quot;, keep curg running on this m\n    locks         int32  // m的引用计数 \n    dying         int32\n    profilehz     int32\n    spinning      bool // m is out of work and is actively looking for work\n    blocked       bool // m is blocked on a note\n    newSigstack   bool // minit on C thread called sigaltstack\n    printlock     int8\n    incgo         bool   // m is executing a cgo call\n    freeWait      uint32 // if == 0, safe to free g0 and delete m (atomic)\n    fastrand      [2]uint32 // 两个随机值，不能同时为0\n    needextram    bool\n    traceback     uint8\n    ncgocall      uint64      // number of cgo calls in total\n    ncgo          int32       // number of cgo calls currently in progress\n    cgoCallersUse uint32      // if non-zero, cgoCallers in use temporarily\n    cgoCallers    *cgoCallers // cgo traceback if crashing in cgo call\n    park          note\n    alllink       *m // on allm\n    schedlink     muintptr    // M的单链表\n    lockedg       guintptr    // M锁定的G\n    createstack   [32]uintptr // stack that created this thread.\n    lockedExt     uint32      // tracking for external LockOSThread\n    lockedInt     uint32      // tracking for internal lockOSThread\n    nextwaitm     muintptr    // next m waiting for lock\n    waitunlockf   func(*g, unsafe.Pointer) bool\n    waitlock      unsafe.Pointer\n    waittraceev   byte\n    waittraceskip int\n    startingtrace bool\n    syscalltick   uint32\n    freelink      *m // 对应全局休眠M队列\n\n    // these are here because they are too large to be on the stack\n    // of low-level NOSPLIT functions.\n    libcall   libcall\n    libcallpc uintptr // for cpu profiler\n    libcallsp uintptr\n    libcallg  guintptr\n    syscall   libcall // stores syscall parameters on windows\n\n    vdsoSP uintptr // SP for traceback while in VDSO call (0 if not in call)\n    vdsoPC uintptr // PC for traceback while in VDSO call\n\n    // preemptGen counts the number of completed preemption\n    // signals. This is used to detect when a preemption is\n    // requested, but fails. Accessed atomically.\n    preemptGen uint32\n\n    // Whether this is a pending preemption signal on this M.\n    // Accessed atomically.\n    signalPending uint32\n\n    dlogPerM\n\n    mOS\n\n    // Up to 10 locks held by this m, maintained by the lock ranking code.\n    locksHeldLen int\n    locksHeld    [10]heldLockInfo\n}</code></pre>\n<h2 id=\"P\"><a href=\"#P\" class=\"headerlink\" title=\"P\"></a>P</h2><pre><code class=\"go\">type p struct {\n    id          int32\n    status      uint32 // one of pidle/prunning/...\n    link        puintptr   // P的单链表\n    schedtick   uint32     // incremented on every scheduler call\n    syscalltick uint32     // incremented on every system call\n    sysmontick  sysmontick // last tick observed by sysmon\n    m           muintptr   // 当前的M，如果空闲则为nil\n    mcache      *mcache\n    pcache      pageCache\n    raceprocctx uintptr\n\n    deferpool    [5][]*_defer // pool of available defer structs of different sizes (see panic.go)\n    deferpoolbuf [5][32]*_defer\n\n    // Cache of goroutine ids, amortizes accesses to runtime·sched.goidgen.\n    goidcache    uint64\n    goidcacheend uint64\n\n    // Queue of runnable goroutines. Accessed without lock.\n    runqhead uint32         // 队首下标\n    runqtail uint32         // 队尾下标\n    runq     [256]guintptr  // 可执行队列，最多256个\n    // runnext, if non-nil, is a runnable G that was ready&#39;d by\n    // the current G and should be run next instead of what&#39;s in\n    // runq if there&#39;s time remaining in the running G&#39;s time\n    // slice. It will inherit the time left in the current time\n    // slice. If a set of goroutines is locked in a\n    // communicate-and-wait pattern, this schedules that set as a\n    // unit and eliminates the (potentially large) scheduling\n    // latency that otherwise arises from adding the ready&#39;d\n    // goroutines to the end of the run queue.\n    runnext guintptr\n\n    // Available G&#39;s (status == Gdead)\n    gFree struct {\n        gList\n        n int32\n    }\n\n    sudogcache []*sudog     // 本地G的队列\n    sudogbuf   [128]*sudog\n\n    // Cache of mspan objects from the heap.\n    mspancache struct {\n        // We need an explicit length here because this field is used\n        // in allocation codepaths where write barriers are not allowed,\n        // and eliminating the write barrier/keeping it eliminated from\n        // slice updates is tricky, moreso than just managing the length\n        // ourselves.\n        len int\n        buf [128]*mspan\n    }\n\n    tracebuf traceBufPtr\n\n    // traceSweep indicates the sweep events should be traced.\n    // This is used to defer the sweep start event until a span\n    // has actually been swept.\n    traceSweep bool\n    // traceSwept and traceReclaimed track the number of bytes\n    // swept and reclaimed by sweeping in the current sweep loop.\n    traceSwept, traceReclaimed uintptr\n\n    palloc persistentAlloc // per-P to avoid mutex\n\n    _ uint32 // Alignment for atomic fields below\n\n    // The when field of the first entry on the timer heap.\n    // This is updated using atomic functions.\n    // This is 0 if the timer heap is empty.\n    timer0When uint64\n\n    // Per-P GC state\n    gcAssistTime         int64    // Nanoseconds in assistAlloc\n    gcFractionalMarkTime int64    // Nanoseconds in fractional mark worker (atomic)\n    gcBgMarkWorker       guintptr // (atomic)\n    gcMarkWorkerMode     gcMarkWorkerMode\n\n    // gcMarkWorkerStartTime is the nanotime() at which this mark\n    // worker started.\n    gcMarkWorkerStartTime int64\n\n    // gcw is this P&#39;s GC work buffer cache. The work buffer is\n    // filled by write barriers, drained by mutator assists, and\n    // disposed on certain GC state transitions.\n    gcw gcWork\n\n    // wbBuf is this P&#39;s GC write barrier buffer.\n    //\n    // TODO: Consider caching this in the running G.\n    wbBuf wbBuf\n\n    runSafePointFn uint32 // if 1, run sched.safePointFn at next safe point\n\n    // Lock for timers. We normally access the timers while running\n    // on this P, but the scheduler can also do it from a different P.\n    timersLock mutex\n\n    // Actions to take at some time. This is used to implement the\n    // standard library&#39;s time package.\n    // Must hold timersLock to access.\n    timers []*timer\n\n    // Number of timers in P&#39;s heap.\n    // Modified using atomic instructions.\n    numTimers uint32\n\n    // Number of timerModifiedEarlier timers on P&#39;s heap.\n    // This should only be modified while holding timersLock,\n    // or while the timer status is in a transient state\n    // such as timerModifying.\n    adjustTimers uint32\n\n    // Number of timerDeleted timers in P&#39;s heap.\n    // Modified using atomic instructions.\n    deletedTimers uint32\n\n    // Race context used while executing timer functions.\n    timerRaceCtx uintptr\n\n    // preempt is set to indicate that this P should be enter the\n    // scheduler ASAP (regardless of what G is running on it).\n    preempt bool\n\n    pad cpu.CacheLinePad\n}</code></pre>\n<h2 id=\"G\"><a href=\"#G\" class=\"headerlink\" title=\"G\"></a>G</h2><pre><code class=\"go\">type g struct {\n    // Stack parameters.\n    // stack describes the actual stack memory: [stack.lo, stack.hi).\n    // stackguard0 is the stack pointer compared in the Go stack growth prologue.\n    // It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption.\n    // stackguard1 is the stack pointer compared in the C stack growth prologue.\n    // It is stack.lo+StackGuard on g0 and gsignal stacks.\n    // It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash).\n    stack       stack   // offset known to runtime/cgo\n    stackguard0 uintptr // offset known to liblink\n    stackguard1 uintptr // offset known to liblink\n\n    _panic       *_panic // innermost panic - offset known to liblink\n    _defer       *_defer // innermost defer\n    m            *m      // 当前M；offset known to arm liblink\n    sched        gobuf\n    syscallsp    uintptr        // if status==Gsyscall, syscallsp = sched.sp to use during gc\n    syscallpc    uintptr        // if status==Gsyscall, syscallpc = sched.pc to use during gc\n    stktopsp     uintptr        // expected sp at top of stack, to check in traceback\n    param        unsafe.Pointer // passed parameter on wakeup\n    atomicstatus uint32     // G的状态\n    stackLock    uint32     // sigprof/scang lock; TODO: fold in to atomicstatus\n    goid         int64      // goroutine id\n    schedlink    guintptr   // 下一个G的地址\n    waitsince    int64      // approx time when the g become blocked\n    waitreason   waitReason // if status==Gwaiting\n\n    preempt       bool // preemption signal, duplicates stackguard0 = stackpreempt\n    preemptStop   bool // transition to _Gpreempted on preemption; otherwise, just deschedule\n    preemptShrink bool // shrink stack at synchronous safe point\n\n    // asyncSafePoint is set if g is stopped at an asynchronous\n    // safe point. This means there are frames on the stack\n    // without precise pointer information.\n    asyncSafePoint bool\n\n    paniconfault bool // panic (instead of crash) on unexpected fault address\n    gcscandone   bool // g has scanned stack; protected by _Gscan bit in status\n    throwsplit   bool // must not split stack\n    // activeStackChans indicates that there are unlocked channels\n    // pointing into this goroutine&#39;s stack. If true, stack\n    // copying needs to acquire channel locks to protect these\n    // areas of the stack.\n    activeStackChans bool\n\n    raceignore     int8     // ignore race detection events\n    sysblocktraced bool     // StartTrace has emitted EvGoInSyscall about this goroutine\n    sysexitticks   int64    // cputicks when syscall has returned (for tracing)\n    traceseq       uint64   // trace event sequencer\n    tracelastp     puintptr // last P emitted an event for this goroutine\n    lockedm        muintptr\n    sig            uint32\n    writebuf       []byte\n    sigcode0       uintptr\n    sigcode1       uintptr\n    sigpc          uintptr\n    gopc           uintptr         // pc of go statement that created this goroutine\n    ancestors      *[]ancestorInfo // ancestor information goroutine(s) that created this goroutine (only used if debug.tracebackancestors)\n    startpc        uintptr         // pc of goroutine function\n    racectx        uintptr\n    waiting        *sudog         // sudog structures this g is waiting on (that have a valid elem ptr); in lock order\n    cgoCtxt        []uintptr      // cgo traceback context\n    labels         unsafe.Pointer // profiler labels\n    timer          *timer         // cached timer for time.Sleep\n    selectDone     uint32         // are we participating in a select and did someone win the race?\n\n    // Per-G GC state\n\n    // gcAssistBytes is this G&#39;s GC assist credit in terms of\n    // bytes allocated. If this is positive, then the G has credit\n    // to allocate gcAssistBytes bytes without assisting. If this\n    // is negative, then the G must correct this by performing\n    // scan work. We track this in bytes to make it fast to update\n    // and check for debt in the malloc hot path. The assist ratio\n    // determines how this corresponds to scan work debt.\n    gcAssistBytes int64\n}</code></pre>\n<h2 id=\"Sched\"><a href=\"#Sched\" class=\"headerlink\" title=\"Sched\"></a>Sched</h2><pre><code class=\"go\">type schedt struct {\n    // accessed atomically. keep at top to ensure alignment on 32-bit systems.\n    goidgen   uint64\n    lastpoll  uint64 // time of last network poll, 0 if currently polling\n    pollUntil uint64 // time to which current poll is sleeping\n\n    lock mutex // 操作锁，锁定schedt\n\n    // When increasing nmidle, nmidlelocked, nmsys, or nmfreed, be\n    // sure to call checkdead().\n\n    midle        muintptr // 空闲M单链表\n    nmidle       int32    // 空闲M的个数\n    nmidlelocked int32    // number of locked m&#39;s waiting for work\n    mnext        int64    // number of m&#39;s that have been created and next M ID\n    maxmcount    int32    // maximum number of m&#39;s allowed (or die)\n    nmsys        int32    // number of system m&#39;s not counted for deadlock\n    nmfreed      int64    // cumulative number of freed m&#39;s\n\n    ngsys uint32 // number of system goroutines; updated atomically\n\n    pidle      puintptr // 空闲的P\n    npidle     uint32\n    nmspinning uint32 // See &quot;Worker thread parking/unparking&quot; comment in proc.go.\n\n    // Global runnable queue.\n    runq     gQueue  // 全局可执行队列\n    runqsize int32   // 全局队列大小\n\n    // disable控制有选择的禁用调度\n    //\n    // 使用schedEnableUser(enable bool)进行控制\n    //\n    // disable需要被sched.lock保护\n    disable struct {\n        // user是否禁止调度goroutines.\n        user     bool\n        runnable gQueue // pending runnable Gs\n        n        int32  // length of runnable\n    }\n\n    // Global cache of dead G&#39;s.\n    gFree struct {\n        lock    mutex\n        stack   gList // Gs with stacks\n        noStack gList // Gs without stacks\n        n       int32\n    }\n\n    // Central cache of sudog structs.\n    sudoglock  mutex  // 全局空闲G队列锁\n    sudogcache *sudog // 全局空闲G队列\n\n    // Central pool of available defer structs of different sizes.\n    deferlock mutex\n    deferpool [5]*_defer\n\n    // freem is the list of m&#39;s waiting to be freed when their\n    // m.exited is set. Linked through m.freelink.\n    freem *m // 全局休眠M队列\n\n    gcwaiting  uint32 // gc is waiting to run\n    stopwait   int32\n    stopnote   note\n    sysmonwait uint32\n    sysmonnote note\n\n    // safepointFn should be called on each P at the next GC\n    // safepoint if p.runSafePointFn is set.\n    safePointFn   func(*p)\n    safePointWait int32\n    safePointNote note\n\n    profilehz int32 // cpu profiling rate\n\n    procresizetime int64 // nanotime() of last change to gomaxprocs\n    totaltime      int64 // ∫gomaxprocs dt up to procresizetime\n\n    // sysmonlock protects sysmon&#39;s actions on the runtime.\n    //\n    // Acquire and hold this mutex to block sysmon from interacting\n    // with the rest of the runtime.\n    sysmonlock mutex\n}</code></pre>\n<h1 id=\"字段和结构体\"><a href=\"#字段和结构体\" class=\"headerlink\" title=\"字段和结构体\"></a>字段和结构体</h1><h2 id=\"G状态\"><a href=\"#G状态\" class=\"headerlink\" title=\"G状态\"></a>G状态</h2><pre><code class=\"go\">const (\n    // G status\n    //\n    // 除了指示G的一般状态外，G状态还像goroutine堆栈上的锁一样（因此具有执行用户代码的能力）。\n\n    // _Gidle表示此goroutine已分配，尚未初始化。\n    _Gidle = iota // 0\n\n    // _Grunnable表示此goroutine在运行队列中，当前未执行用户代码，没有堆栈。\n    _Grunnable // 1\n\n    // _Grunning表示此goroutine可以执行用户代码。\n    // 该goroutine拥有堆栈，且不在运行队列中。\n    // 它已分配一个M和一个P。\n    _Grunning // 2\n\n    // _Gsyscall表示此goroutine正在执行系统调用。\n    // 它不执行用户代码，堆栈由该goroutine拥有，它不在运行队列中。\n    // 它被分配了一个M。\n    _Gsyscall // 3\n\n    // _Gwaiting 意味着goroutine被runtime阻止。\n    // 它不执行用户代码，它也不再运行队列，但应该被记录下来（例如：等待chan中的数据），必要时可以调用ready()恢复。\n    // 除chan操作可以在适当的锁下读取或写入堆栈的某些部分外，不应该拥有该堆栈。\n    _Gwaiting // 4\n\n    // _Gmoribund_unused当前未使用，但已在gdb脚本中进行了硬编码。\n    _Gmoribund_unused // 5\n\n    // _Gdead表示此goroutine当前未使用。\n    // 它有可能已退出，在空闲列表或刚被初始化。它不能执行用户代码。它可能拥有堆栈也可能不拥有堆栈。\n    // G及其堆栈（如果有）由退出G或从空闲列表中获得G的M拥有。\n    _Gdead // 6\n\n    // _Genqueue_unused当前未使用。\n    _Genqueue_unused // 7\n\n    // _Gcopystack表示此goroutine的堆栈正在迁移。\n    // 它不能执行用户代码，并且不再运行队列中。\n    // 堆栈由将其放入_Gcopystack的goroutine拥有。\n    _Gcopystack // 8\n\n    // _Gscan与上述状态之一组合表示GC正在扫描堆栈（除_Grunning）。\n    // goroutine未执行用户代码，并且堆栈由设置_Gscan位的goroutine拥有。\n    // _Gscanrunning不同: 它用于短暂阻止状态转换，而GC则通知G扫描其自身的堆栈。否则就像_Grunning。\n    // atomicstatus&amp;~Gscan 给出goroutine将在扫描完成时返回的状态。\n    _Gscan         = 0x1000\n    _Gscanrunnable = _Gscan + _Grunnable // 0x1001\n    _Gscanrunning  = _Gscan + _Grunning  // 0x1002\n    _Gscansyscall  = _Gscan + _Gsyscall  // 0x1003\n    _Gscanwaiting  = _Gscan + _Gwaiting  // 0x1004\n)</code></pre>\n<h2 id=\"P状态\"><a href=\"#P状态\" class=\"headerlink\" title=\"P状态\"></a>P状态</h2><pre><code class=\"go\">const (\n    // P status\n\n    // _Pidle表示不使用P来运行用户代码或调度程序。\n    // 它在空闲的P列表中，可供调度程序使用，但可能只是在其他状态之间转换。\n    //\n    // P由空闲列表或转换其状态的任何内容所拥有。它的运行队列为空。\n    _Pidle = iota\n\n    // _Prunning表示P由M拥有，并用于运行用户代码或调度程序。\n    // 仅拥有此P的M允许从_Prunning更改P的状态。\n    // M可以将P转换为_Pidle（如果没有更多工作要做），_Psyscall（进入系统调用时）或_Pgcstop（以停止GC）。\n    // M也可以将P的所有权直接移交给另一个M（例如，调度锁定的G）。\n    _Prunning\n\n    // _Psyscall表示P没有运行用户代码。\n    // 它与系统调用中的M有亲缘关系，但不归其所有，并且可能被另一个M窃取。\n    // 这类似于_Pidle，但使用轻量级转换并保持M相似性。\n    //\n    // 必须通过CAS离开_Psyscall才能窃取或重新获得P。\n    // 注意ABA危害：\n    // 即使M在系统调用后成功将其原始P恢复为_Prunning，它也必须了解该P在此期间可能已被另一个M使用。\n    _Psyscall\n\n    // _Pgcstop表示对STW(stop the world)暂停P并由STW的M拥有。\n    // STW的M甚至在_Pgcstop中也继续使用其P。\n    // 从_Prunning过渡到_Pgcstop会导致M释放其P并停放。\n    //\n    // P保留其运行队列，STW将使用非空运行队列在P上重新启动调度程序。\n    _Pgcstop\n\n    // _Pdead表示不再使用P（GOMAXPROCS缩小），如果P的数量增加将会复用P。\n    // 一个死掉的P大部分被剥夺了其资源，尽管还剩下一些东西（例如跟踪缓冲区）。\n    _Pdead\n)</code></pre>\n<h2 id=\"runtime2-go-全局变量\"><a href=\"#runtime2-go-全局变量\" class=\"headerlink\" title=\"runtime2.go 全局变量\"></a>runtime2.go 全局变量</h2><pre><code class=\"go\">var (\n    allglen    uintptr // allgs的长度\n    allm       *m      // 所有m的单链表\n    allp       []*p    // 所有的P列表，len(allp) == gomaxprocs，只能通过GOMAXPROCS()修改\n    allpLock   mutex   // Protects P-less reads of allp and all writes\n    gomaxprocs int32         // 最大P的数量\n    ncpu       int32         // CPU数\n    forcegc    forcegcstate\n    sched      schedt        // 调度者\n    newprocs   int32\n\n    // Information about what cpu features are available.\n    // Packages outside the runtime should not use these\n    // as they are not an external api.\n    // Set on startup in asm_{386,amd64}.s\n    processorVersionInfo uint32\n    isIntel              bool\n    lfenceBeforeRdtsc    bool\n\n    goarm                uint8 // set by cmd/link on arm systems\n    framepointer_enabled bool  // set by cmd/link\n)\n\nvar (\n    allgs    []*g  // 所有g的单链表\n    allglock mutex // 修改单链表锁\n)</code></pre>\n<h2 id=\"sodug\"><a href=\"#sodug\" class=\"headerlink\" title=\"sodug\"></a>sodug</h2><pre><code>type hchan struct {\n    qcount   uint           // 队列元素总数\n    dataqsiz uint           // 循环队列的大小\n    buf      unsafe.Pointer // 指向dataqsiz元素数组\n    elemsize uint16\n    closed   uint32\n    elemtype *_type // element type\n    sendx    uint   // send index\n    recvx    uint   // receive index\n    recvq    waitq  // list of recv waiters\n    sendq    waitq  // list of send waiters\n\n    // lock保护hchan的所有字段，也保护sudog的所有字段在这个channel。\n    //\n    // 锁住此锁时，请勿更改另一个G的状态（特别是不要对G调用ready），因为这会因堆栈收缩而死锁。\n    lock mutex\n}\n\ntype waitq struct {\n    first *sudog\n    last  *sudog\n}\n\n// sudog 表示可执行G的列表，一个G可能在多个sudog中，\n// 并且许多G可能正在等待同一个同步对象，因此一个对象可能有许多sudog。\n// \n// sudog 由特殊的池分配，所以只能通过acquireSudog和releaseSudog来分配和释放sudog。\ntype sudog struct {\n    // 由hchan.lock来保护以下字段，收缩栈依赖sudog的操作\n\n    g *g\n\n    next *sudog\n    prev *sudog\n    elem unsafe.Pointer // data element (may point to stack)\n\n    // 以下字段永远不能同时访问\n    // 对于channel，waitlink仅由g访问。\n    // 对于信号量，仅在持有semaRoot锁时才能访问所有字段（包括上述字段）。\n\n    acquiretime int64\n    releasetime int64\n    ticket      uint32\n\n    // isSelect表示g正在参与选择，因此必须对g.selectDone进行CAS操作才能wake-up竞争。\n    isSelect bool\n\n    parent   *sudog // semaRoot binary tree\n    waitlink *sudog // g.waiting list or semaRoot\n    waittail *sudog // semaRoot\n    c        *hchan // channel，引用chan的底层实现\n}</code></pre><h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ul>\n<li><a href=\"https://learnku.com/articles/41728\" target=\"_blank\" rel=\"noopener\">[典藏版] Golang 调度器 GMP 原理与调度全分析</a></li>\n<li><a href=\"http://ga0.github.io/golang/2015/09/20/golang-runtime-scheduler.html\" target=\"_blank\" rel=\"noopener\">Golang调度器源码分析</a></li>\n</ul>\n"},{"author":"djaigo","title":"golang内存管理","img":"https://img-1251474779.cos.ap-beijing.myqcloud.com/golang.png","date":"2020-09-21T12:17:14.000Z","updated":"2020-09-21T12:17:14.000Z","_content":"\n\n","source":"_posts/golang内存管理.md","raw":"---\nauthor: djaigo\ntitle: golang内存管理\nimg: 'https://img-1251474779.cos.ap-beijing.myqcloud.com/golang.png'\ncategories:\n  - golang\ntags:\n  - memory\n  - infra\ndate: 2020-09-21 20:17:14\nupdated: 2020-09-21 20:17:14\n---\n\n\n","slug":"golang内存管理","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckh351dug001019z49vu98bwk","content":"<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"friends":[{"avatar":"https://img-1251474779.cos.ap-beijing.myqcloud.com/icon.png","name":"djaigo","introduction":"好好学习，天天向上","url":"/","title":"前去学习"},{"avatar":"https://awps-assets.meituan.net/mit/blog/v20190629/asset/icon/favicon.ico?v=Whistle&t=20181017-1r","name":"美团技术团队","introduction":"一行代码，亿万生活。","url":"https://tech.meituan.com/","title":"点个外卖-->"},{"avatar":"","name":"鸟窝","introduction":"rpcx作者","url":"https://colobu.com/","title":"进个鸟窝-->"},{"avatar":"https://d1j8pt39hxlh3d.cloudfront.net/emoji/emojione/5.0/png/unicode/32/1f92a.png","name":"labuladong的算法小抄","introduction":"算法大神","url":"https://labuladong.gitbook.io/algo/","title":"学个算法-->"}]}},"excerpt":"","more":""},{"author":"djaigo","title":"golang TCP Socket编程","img":"https://img-1251474779.cos.ap-beijing.myqcloud.com/golang.png","date":"2020-04-09T04:22:55.000Z","updated":"2020-04-09T04:22:55.000Z","_content":"\ngolang版本：1.14.1\n主要是对golang net包的Conn接口函数进行测试，这里只是分析常见的几个错误，如果要了解详细的错误可以查看man手册。\n\n# Dial\nDial主要实现了TCP三次握手的环节。握手环节中有很多种情况：网络不可达，服务器backlog满了，网络超时等。\n## network is unreachable\n会返回`connect: network is unreachable`\n\n## connection refused\n目标服务器的指定端口未被监听。\nTCP层发送完第一次握手后就会收到目标主机返回的RST包，golang会返回`connect: connection refused`。\n示例：\n```go\nfunc main() {\n    conn, err := net.Dial(\"tcp\", \":8080\")\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n    defer conn.Close()\n}\n```\n\n对应控制台输出\n```sh\ndial tcp :8080: connect: connection refused\n```\n\n## connection timed out\nDial是阻塞的，如果不设置超时，协程会长时间阻塞（golang tcp超时是3分钟），这样很影响程序运行。\n如果网络环境不好情况下经常有丢包发生，我们也可以手动设置超时时间来控制超时时间。\nTCP会一直重传第一次握手的包，直到设置的超时时间后还没有收到第二次握手，网络状态一直是`SYN_SENT`，golang返回`i/o timeout`。还有连接时超时返回`connect: connection timed out`错误\n示例：\n```go\nfunc main() {\n    conn, err := net.DialTimeout(\"tcp\", \"google.com:443\", 1*time.Second)\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n    defer conn.Close()\n}\n```\n\n对应控制台输出\n```sh\ndial tcp 172.217.160.78:443: i/o timeout\n```\n\n\n# Read\n## EOF\n当前连接处于`CLOSE_WAIT`是调用`Read`会返回`EOF`\n\n## i/o timeout\n调用`Read`函数时间超过设置`SetReadDeadline`时会返回`i/o timeout`\n\n## connection reset by peer\n在`Read`函数阻塞期间收到对端发送的`RST`包时会返回`read: connection reset by peer`\n向一个对端已关闭本端未关闭的连接（即本端处于`CLOSE_WAIT`）调用`Write`函数后再调用`Read`函数可以模拟这一个场景。\n\n## use of closed network connection\n对已关闭的连接进行`Read`时会返回`use of closed network connection`\n\n## connection timed out\n试图读取连接时超时\n\n## network is down\n读取一个未连接socket\n\n# Write\n## 无错误\n当前连接处于对端已关闭本端未关闭（即本端处于`CLOSE_WAIT`）状态时调用`Write`函数，golang不会返回error，在TCP层面会收到`RST`包。当调用`Close`函数时，系统会标记连接为全关闭，禁止在该连接上读写，所以会返回`RST`包，如果要进入半关闭需要调用`Shutdown`函数。\n\n## use of closed network connection\n当前连接处于`FIN_WAIT_2`状态和已经完全关闭的连接调用`Write`会返回`use of closed network connection`\n\n## broken pipe\n当连接收到`RST`包后，连接已断开，此时调用`Write`会返回`write: broken pipe`\n\n## connection timed out\n\n# Close\n## use of closed network connection\n当前连接关闭多次\n\n## socket is not connected\n多次关闭socket\n\n# 总结\n1. 对**本端关闭的连接**进行`Read`、`Write`和`Close`都会返回`use of closed network connection`\n2. 对**对端关闭本端未关闭的连接**进行`Write`时对端会返回`RST`包（重置连接但golang不会返回错误），进行`Read`时会返回`EOF`错误\n3. 对**重置连接（收到RST包的连接）**进行`Write`会返回`write: broken pipe`错误，进行`Read`会返回`read: connection reset by peer`\n4. 未在规定的时间完成`Read`和`Write`会返回`i/o timeout`错误\n\n# 测试代码\n## syscall server\n```go\nfunc socketServer() {\n    fd, err := syscall.Socket(syscall.AF_INET, syscall.SOCK_STREAM, syscall.IPPROTO_TCP)\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n    defer func() {\n        err = syscall.Close(fd)\n        if err != nil {\n            fmt.Println(err.Error())\n            return\n        }\n    }()\n    sa := &syscall.SockaddrInet4{\n        Port: 8080,\n        Addr: [4]byte{127, 0, 0, 1},\n    }\n    err = syscall.Bind(fd, sa)\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n    err = syscall.Listen(fd, 2)\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n    for {\n        nfd, csa, err := syscall.Accept(fd)\n        if err != nil {\n            fmt.Println(err.Error())\n            return\n        }\n        fmt.Printf(\"fd %d sa %#v\\n\", nfd, csa)\n        \n        buf := make([]byte, 1024)\n        n, err := syscall.Read(nfd, buf)\n        if err != nil {\n            fmt.Println(err.Error())\n            return\n        }\n        fmt.Println(\"read data:\", string(buf[:n]))\n        n, err = syscall.Write(fd, buf)\n        if err != nil {\n            fmt.Println(err.Error())\n            return\n        }\n        err = syscall.Close(nfd)\n        if err != nil {\n            fmt.Println(err.Error())\n            return\n        }\n        break\n    }\n}\n\n```\n\n## syscall client\n```go\nfunc socketClient() {\n    fd, err := syscall.Socket(syscall.AF_INET, syscall.SOCK_STREAM, syscall.IPPROTO_TCP)\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n    defer func() {\n        err = syscall.Close(fd)\n        if err != nil {\n            fmt.Println(err.Error())\n            return\n        }\n    }()\n    sa := &syscall.SockaddrInet4{\n        Port: 8080,\n        Addr: [4]byte{127, 0, 0, 1},\n    }\n    err = syscall.Connect(fd, sa)\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n    buf := []byte(\"1234567890\")\n    n, err := syscall.Write(fd, buf)\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n    fmt.Println(\"send data\", n, string(buf))\n}\n```\n\n## net server\n```go\nfunc netServer() {\n    l, err := net.Listen(\"tcp\", \":8080\")\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n    conn, err := l.Accept()\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n    \n    buf := make([]byte, 1024)\n    n, err := conn.Write(buf)\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n    n, err = conn.Read(buf)\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n    fmt.Println(n)\n    \n    err = conn.Close()\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n}\n```\n\n## net client\n```go\nfunc netClient() {\n    conn, err := net.Dial(\"tcp\", \"127.0.0.1:8080\")\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n    defer func() {\n        err = conn.Close()\n        if err != nil {\n            fmt.Println(err.Error())\n            return\n        }\n    }()\n\n    buf := make([]byte, 1024)\n    conn.SetWriteDeadline(time.Now().Add(5 * time.Second))\n    n, err := conn.Write(buf)\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n    conn.SetReadDeadline(time.Now().Add(5 * time.Second))\n    n, err = conn.Read(buf)\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n    fmt.Println(string(buf[:n]))\n}\n```\n\n\n# 参考文献\n[Go语言TCP Socket编程](https://tonybai.com/2015/11/17/tcp-programming-in-golang/)\n[TCP连接异常：broken pipe 和EOF](https://blog.csdn.net/lanyang123456/article/details/89288824)\n","source":"_posts/golang的TCPSocket编程.md","raw":"---\nauthor: djaigo\ntitle: golang TCP Socket编程\nimg: 'https://img-1251474779.cos.ap-beijing.myqcloud.com/golang.png'\ncategories:\n  - golang\ntags:\n  - net\n  - tcp\ndate: 2020-04-09 12:22:55\nupdated: 2020-04-09 12:22:55\n---\n\ngolang版本：1.14.1\n主要是对golang net包的Conn接口函数进行测试，这里只是分析常见的几个错误，如果要了解详细的错误可以查看man手册。\n\n# Dial\nDial主要实现了TCP三次握手的环节。握手环节中有很多种情况：网络不可达，服务器backlog满了，网络超时等。\n## network is unreachable\n会返回`connect: network is unreachable`\n\n## connection refused\n目标服务器的指定端口未被监听。\nTCP层发送完第一次握手后就会收到目标主机返回的RST包，golang会返回`connect: connection refused`。\n示例：\n```go\nfunc main() {\n    conn, err := net.Dial(\"tcp\", \":8080\")\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n    defer conn.Close()\n}\n```\n\n对应控制台输出\n```sh\ndial tcp :8080: connect: connection refused\n```\n\n## connection timed out\nDial是阻塞的，如果不设置超时，协程会长时间阻塞（golang tcp超时是3分钟），这样很影响程序运行。\n如果网络环境不好情况下经常有丢包发生，我们也可以手动设置超时时间来控制超时时间。\nTCP会一直重传第一次握手的包，直到设置的超时时间后还没有收到第二次握手，网络状态一直是`SYN_SENT`，golang返回`i/o timeout`。还有连接时超时返回`connect: connection timed out`错误\n示例：\n```go\nfunc main() {\n    conn, err := net.DialTimeout(\"tcp\", \"google.com:443\", 1*time.Second)\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n    defer conn.Close()\n}\n```\n\n对应控制台输出\n```sh\ndial tcp 172.217.160.78:443: i/o timeout\n```\n\n\n# Read\n## EOF\n当前连接处于`CLOSE_WAIT`是调用`Read`会返回`EOF`\n\n## i/o timeout\n调用`Read`函数时间超过设置`SetReadDeadline`时会返回`i/o timeout`\n\n## connection reset by peer\n在`Read`函数阻塞期间收到对端发送的`RST`包时会返回`read: connection reset by peer`\n向一个对端已关闭本端未关闭的连接（即本端处于`CLOSE_WAIT`）调用`Write`函数后再调用`Read`函数可以模拟这一个场景。\n\n## use of closed network connection\n对已关闭的连接进行`Read`时会返回`use of closed network connection`\n\n## connection timed out\n试图读取连接时超时\n\n## network is down\n读取一个未连接socket\n\n# Write\n## 无错误\n当前连接处于对端已关闭本端未关闭（即本端处于`CLOSE_WAIT`）状态时调用`Write`函数，golang不会返回error，在TCP层面会收到`RST`包。当调用`Close`函数时，系统会标记连接为全关闭，禁止在该连接上读写，所以会返回`RST`包，如果要进入半关闭需要调用`Shutdown`函数。\n\n## use of closed network connection\n当前连接处于`FIN_WAIT_2`状态和已经完全关闭的连接调用`Write`会返回`use of closed network connection`\n\n## broken pipe\n当连接收到`RST`包后，连接已断开，此时调用`Write`会返回`write: broken pipe`\n\n## connection timed out\n\n# Close\n## use of closed network connection\n当前连接关闭多次\n\n## socket is not connected\n多次关闭socket\n\n# 总结\n1. 对**本端关闭的连接**进行`Read`、`Write`和`Close`都会返回`use of closed network connection`\n2. 对**对端关闭本端未关闭的连接**进行`Write`时对端会返回`RST`包（重置连接但golang不会返回错误），进行`Read`时会返回`EOF`错误\n3. 对**重置连接（收到RST包的连接）**进行`Write`会返回`write: broken pipe`错误，进行`Read`会返回`read: connection reset by peer`\n4. 未在规定的时间完成`Read`和`Write`会返回`i/o timeout`错误\n\n# 测试代码\n## syscall server\n```go\nfunc socketServer() {\n    fd, err := syscall.Socket(syscall.AF_INET, syscall.SOCK_STREAM, syscall.IPPROTO_TCP)\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n    defer func() {\n        err = syscall.Close(fd)\n        if err != nil {\n            fmt.Println(err.Error())\n            return\n        }\n    }()\n    sa := &syscall.SockaddrInet4{\n        Port: 8080,\n        Addr: [4]byte{127, 0, 0, 1},\n    }\n    err = syscall.Bind(fd, sa)\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n    err = syscall.Listen(fd, 2)\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n    for {\n        nfd, csa, err := syscall.Accept(fd)\n        if err != nil {\n            fmt.Println(err.Error())\n            return\n        }\n        fmt.Printf(\"fd %d sa %#v\\n\", nfd, csa)\n        \n        buf := make([]byte, 1024)\n        n, err := syscall.Read(nfd, buf)\n        if err != nil {\n            fmt.Println(err.Error())\n            return\n        }\n        fmt.Println(\"read data:\", string(buf[:n]))\n        n, err = syscall.Write(fd, buf)\n        if err != nil {\n            fmt.Println(err.Error())\n            return\n        }\n        err = syscall.Close(nfd)\n        if err != nil {\n            fmt.Println(err.Error())\n            return\n        }\n        break\n    }\n}\n\n```\n\n## syscall client\n```go\nfunc socketClient() {\n    fd, err := syscall.Socket(syscall.AF_INET, syscall.SOCK_STREAM, syscall.IPPROTO_TCP)\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n    defer func() {\n        err = syscall.Close(fd)\n        if err != nil {\n            fmt.Println(err.Error())\n            return\n        }\n    }()\n    sa := &syscall.SockaddrInet4{\n        Port: 8080,\n        Addr: [4]byte{127, 0, 0, 1},\n    }\n    err = syscall.Connect(fd, sa)\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n    buf := []byte(\"1234567890\")\n    n, err := syscall.Write(fd, buf)\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n    fmt.Println(\"send data\", n, string(buf))\n}\n```\n\n## net server\n```go\nfunc netServer() {\n    l, err := net.Listen(\"tcp\", \":8080\")\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n    conn, err := l.Accept()\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n    \n    buf := make([]byte, 1024)\n    n, err := conn.Write(buf)\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n    n, err = conn.Read(buf)\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n    fmt.Println(n)\n    \n    err = conn.Close()\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n}\n```\n\n## net client\n```go\nfunc netClient() {\n    conn, err := net.Dial(\"tcp\", \"127.0.0.1:8080\")\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n    defer func() {\n        err = conn.Close()\n        if err != nil {\n            fmt.Println(err.Error())\n            return\n        }\n    }()\n\n    buf := make([]byte, 1024)\n    conn.SetWriteDeadline(time.Now().Add(5 * time.Second))\n    n, err := conn.Write(buf)\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n    conn.SetReadDeadline(time.Now().Add(5 * time.Second))\n    n, err = conn.Read(buf)\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n    fmt.Println(string(buf[:n]))\n}\n```\n\n\n# 参考文献\n[Go语言TCP Socket编程](https://tonybai.com/2015/11/17/tcp-programming-in-golang/)\n[TCP连接异常：broken pipe 和EOF](https://blog.csdn.net/lanyang123456/article/details/89288824)\n","slug":"golang的TCPSocket编程","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckh351duh001319z442gz1pbq","content":"<p>golang版本：1.14.1<br>主要是对golang net包的Conn接口函数进行测试，这里只是分析常见的几个错误，如果要了解详细的错误可以查看man手册。</p>\n<h1 id=\"Dial\"><a href=\"#Dial\" class=\"headerlink\" title=\"Dial\"></a>Dial</h1><p>Dial主要实现了TCP三次握手的环节。握手环节中有很多种情况：网络不可达，服务器backlog满了，网络超时等。</p>\n<h2 id=\"network-is-unreachable\"><a href=\"#network-is-unreachable\" class=\"headerlink\" title=\"network is unreachable\"></a>network is unreachable</h2><p>会返回<code>connect: network is unreachable</code></p>\n<h2 id=\"connection-refused\"><a href=\"#connection-refused\" class=\"headerlink\" title=\"connection refused\"></a>connection refused</h2><p>目标服务器的指定端口未被监听。<br>TCP层发送完第一次握手后就会收到目标主机返回的RST包，golang会返回<code>connect: connection refused</code>。<br>示例：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    conn<span class=\"token punctuation\">,</span> err <span class=\"token operator\">:=</span> net<span class=\"token punctuation\">.</span><span class=\"token function\">Dial</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"tcp\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\":8080\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">.</span><span class=\"token function\">Error</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">defer</span> conn<span class=\"token punctuation\">.</span><span class=\"token function\">Close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>对应控制台输出</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">dial tcp :8080: connect: connection refused</code></pre>\n<h2 id=\"connection-timed-out\"><a href=\"#connection-timed-out\" class=\"headerlink\" title=\"connection timed out\"></a>connection timed out</h2><p>Dial是阻塞的，如果不设置超时，协程会长时间阻塞（golang tcp超时是3分钟），这样很影响程序运行。<br>如果网络环境不好情况下经常有丢包发生，我们也可以手动设置超时时间来控制超时时间。<br>TCP会一直重传第一次握手的包，直到设置的超时时间后还没有收到第二次握手，网络状态一直是<code>SYN_SENT</code>，golang返回<code>i/o timeout</code>。还有连接时超时返回<code>connect: connection timed out</code>错误<br>示例：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    conn<span class=\"token punctuation\">,</span> err <span class=\"token operator\">:=</span> net<span class=\"token punctuation\">.</span><span class=\"token function\">DialTimeout</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"tcp\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"google.com:443\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token operator\">*</span>time<span class=\"token punctuation\">.</span>Second<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">.</span><span class=\"token function\">Error</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">defer</span> conn<span class=\"token punctuation\">.</span><span class=\"token function\">Close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>对应控制台输出</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">dial tcp 172.217.160.78:443: i/o timeout</code></pre>\n<h1 id=\"Read\"><a href=\"#Read\" class=\"headerlink\" title=\"Read\"></a>Read</h1><h2 id=\"EOF\"><a href=\"#EOF\" class=\"headerlink\" title=\"EOF\"></a>EOF</h2><p>当前连接处于<code>CLOSE_WAIT</code>是调用<code>Read</code>会返回<code>EOF</code></p>\n<h2 id=\"i-o-timeout\"><a href=\"#i-o-timeout\" class=\"headerlink\" title=\"i/o timeout\"></a>i/o timeout</h2><p>调用<code>Read</code>函数时间超过设置<code>SetReadDeadline</code>时会返回<code>i/o timeout</code></p>\n<h2 id=\"connection-reset-by-peer\"><a href=\"#connection-reset-by-peer\" class=\"headerlink\" title=\"connection reset by peer\"></a>connection reset by peer</h2><p>在<code>Read</code>函数阻塞期间收到对端发送的<code>RST</code>包时会返回<code>read: connection reset by peer</code><br>向一个对端已关闭本端未关闭的连接（即本端处于<code>CLOSE_WAIT</code>）调用<code>Write</code>函数后再调用<code>Read</code>函数可以模拟这一个场景。</p>\n<h2 id=\"use-of-closed-network-connection\"><a href=\"#use-of-closed-network-connection\" class=\"headerlink\" title=\"use of closed network connection\"></a>use of closed network connection</h2><p>对已关闭的连接进行<code>Read</code>时会返回<code>use of closed network connection</code></p>\n<h2 id=\"connection-timed-out-1\"><a href=\"#connection-timed-out-1\" class=\"headerlink\" title=\"connection timed out\"></a>connection timed out</h2><p>试图读取连接时超时</p>\n<h2 id=\"network-is-down\"><a href=\"#network-is-down\" class=\"headerlink\" title=\"network is down\"></a>network is down</h2><p>读取一个未连接socket</p>\n<h1 id=\"Write\"><a href=\"#Write\" class=\"headerlink\" title=\"Write\"></a>Write</h1><h2 id=\"无错误\"><a href=\"#无错误\" class=\"headerlink\" title=\"无错误\"></a>无错误</h2><p>当前连接处于对端已关闭本端未关闭（即本端处于<code>CLOSE_WAIT</code>）状态时调用<code>Write</code>函数，golang不会返回error，在TCP层面会收到<code>RST</code>包。当调用<code>Close</code>函数时，系统会标记连接为全关闭，禁止在该连接上读写，所以会返回<code>RST</code>包，如果要进入半关闭需要调用<code>Shutdown</code>函数。</p>\n<h2 id=\"use-of-closed-network-connection-1\"><a href=\"#use-of-closed-network-connection-1\" class=\"headerlink\" title=\"use of closed network connection\"></a>use of closed network connection</h2><p>当前连接处于<code>FIN_WAIT_2</code>状态和已经完全关闭的连接调用<code>Write</code>会返回<code>use of closed network connection</code></p>\n<h2 id=\"broken-pipe\"><a href=\"#broken-pipe\" class=\"headerlink\" title=\"broken pipe\"></a>broken pipe</h2><p>当连接收到<code>RST</code>包后，连接已断开，此时调用<code>Write</code>会返回<code>write: broken pipe</code></p>\n<h2 id=\"connection-timed-out-2\"><a href=\"#connection-timed-out-2\" class=\"headerlink\" title=\"connection timed out\"></a>connection timed out</h2><h1 id=\"Close\"><a href=\"#Close\" class=\"headerlink\" title=\"Close\"></a>Close</h1><h2 id=\"use-of-closed-network-connection-2\"><a href=\"#use-of-closed-network-connection-2\" class=\"headerlink\" title=\"use of closed network connection\"></a>use of closed network connection</h2><p>当前连接关闭多次</p>\n<h2 id=\"socket-is-not-connected\"><a href=\"#socket-is-not-connected\" class=\"headerlink\" title=\"socket is not connected\"></a>socket is not connected</h2><p>多次关闭socket</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ol>\n<li>对<strong>本端关闭的连接</strong>进行<code>Read</code>、<code>Write</code>和<code>Close</code>都会返回<code>use of closed network connection</code></li>\n<li>对<strong>对端关闭本端未关闭的连接</strong>进行<code>Write</code>时对端会返回<code>RST</code>包（重置连接但golang不会返回错误），进行<code>Read</code>时会返回<code>EOF</code>错误</li>\n<li>对<strong>重置连接（收到RST包的连接）</strong>进行<code>Write</code>会返回<code>write: broken pipe</code>错误，进行<code>Read</code>会返回<code>read: connection reset by peer</code></li>\n<li>未在规定的时间完成<code>Read</code>和<code>Write</code>会返回<code>i/o timeout</code>错误</li>\n</ol>\n<h1 id=\"测试代码\"><a href=\"#测试代码\" class=\"headerlink\" title=\"测试代码\"></a>测试代码</h1><h2 id=\"syscall-server\"><a href=\"#syscall-server\" class=\"headerlink\" title=\"syscall server\"></a>syscall server</h2><pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">socketServer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    fd<span class=\"token punctuation\">,</span> err <span class=\"token operator\">:=</span> syscall<span class=\"token punctuation\">.</span><span class=\"token function\">Socket</span><span class=\"token punctuation\">(</span>syscall<span class=\"token punctuation\">.</span>AF_INET<span class=\"token punctuation\">,</span> syscall<span class=\"token punctuation\">.</span>SOCK_STREAM<span class=\"token punctuation\">,</span> syscall<span class=\"token punctuation\">.</span>IPPROTO_TCP<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">.</span><span class=\"token function\">Error</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">defer</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        err <span class=\"token operator\">=</span> syscall<span class=\"token punctuation\">.</span><span class=\"token function\">Close</span><span class=\"token punctuation\">(</span>fd<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n            fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">.</span><span class=\"token function\">Error</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    sa <span class=\"token operator\">:=</span> <span class=\"token operator\">&amp;</span>syscall<span class=\"token punctuation\">.</span>SockaddrInet4<span class=\"token punctuation\">{</span>\n        Port<span class=\"token punctuation\">:</span> <span class=\"token number\">8080</span><span class=\"token punctuation\">,</span>\n        Addr<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">byte</span><span class=\"token punctuation\">{</span><span class=\"token number\">127</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span>\n    err <span class=\"token operator\">=</span> syscall<span class=\"token punctuation\">.</span><span class=\"token function\">Bind</span><span class=\"token punctuation\">(</span>fd<span class=\"token punctuation\">,</span> sa<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">.</span><span class=\"token function\">Error</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span>\n    <span class=\"token punctuation\">}</span>\n    err <span class=\"token operator\">=</span> syscall<span class=\"token punctuation\">.</span><span class=\"token function\">Listen</span><span class=\"token punctuation\">(</span>fd<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">.</span><span class=\"token function\">Error</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">{</span>\n        nfd<span class=\"token punctuation\">,</span> csa<span class=\"token punctuation\">,</span> err <span class=\"token operator\">:=</span> syscall<span class=\"token punctuation\">.</span><span class=\"token function\">Accept</span><span class=\"token punctuation\">(</span>fd<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n            fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">.</span><span class=\"token function\">Error</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span>\n        <span class=\"token punctuation\">}</span>\n        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"fd %d sa %#v\\n\"</span><span class=\"token punctuation\">,</span> nfd<span class=\"token punctuation\">,</span> csa<span class=\"token punctuation\">)</span>\n\n        buf <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">byte</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1024</span><span class=\"token punctuation\">)</span>\n        n<span class=\"token punctuation\">,</span> err <span class=\"token operator\">:=</span> syscall<span class=\"token punctuation\">.</span><span class=\"token function\">Read</span><span class=\"token punctuation\">(</span>nfd<span class=\"token punctuation\">,</span> buf<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n            fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">.</span><span class=\"token function\">Error</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span>\n        <span class=\"token punctuation\">}</span>\n        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"read data:\"</span><span class=\"token punctuation\">,</span> <span class=\"token function\">string</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        n<span class=\"token punctuation\">,</span> err <span class=\"token operator\">=</span> syscall<span class=\"token punctuation\">.</span><span class=\"token function\">Write</span><span class=\"token punctuation\">(</span>fd<span class=\"token punctuation\">,</span> buf<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n            fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">.</span><span class=\"token function\">Error</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span>\n        <span class=\"token punctuation\">}</span>\n        err <span class=\"token operator\">=</span> syscall<span class=\"token punctuation\">.</span><span class=\"token function\">Close</span><span class=\"token punctuation\">(</span>nfd<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n            fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">.</span><span class=\"token function\">Error</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">break</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h2 id=\"syscall-client\"><a href=\"#syscall-client\" class=\"headerlink\" title=\"syscall client\"></a>syscall client</h2><pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">socketClient</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    fd<span class=\"token punctuation\">,</span> err <span class=\"token operator\">:=</span> syscall<span class=\"token punctuation\">.</span><span class=\"token function\">Socket</span><span class=\"token punctuation\">(</span>syscall<span class=\"token punctuation\">.</span>AF_INET<span class=\"token punctuation\">,</span> syscall<span class=\"token punctuation\">.</span>SOCK_STREAM<span class=\"token punctuation\">,</span> syscall<span class=\"token punctuation\">.</span>IPPROTO_TCP<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">.</span><span class=\"token function\">Error</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">defer</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        err <span class=\"token operator\">=</span> syscall<span class=\"token punctuation\">.</span><span class=\"token function\">Close</span><span class=\"token punctuation\">(</span>fd<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n            fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">.</span><span class=\"token function\">Error</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    sa <span class=\"token operator\">:=</span> <span class=\"token operator\">&amp;</span>syscall<span class=\"token punctuation\">.</span>SockaddrInet4<span class=\"token punctuation\">{</span>\n        Port<span class=\"token punctuation\">:</span> <span class=\"token number\">8080</span><span class=\"token punctuation\">,</span>\n        Addr<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">byte</span><span class=\"token punctuation\">{</span><span class=\"token number\">127</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span>\n    err <span class=\"token operator\">=</span> syscall<span class=\"token punctuation\">.</span><span class=\"token function\">Connect</span><span class=\"token punctuation\">(</span>fd<span class=\"token punctuation\">,</span> sa<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">.</span><span class=\"token function\">Error</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span>\n    <span class=\"token punctuation\">}</span>\n    buf <span class=\"token operator\">:=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token function\">byte</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"1234567890\"</span><span class=\"token punctuation\">)</span>\n    n<span class=\"token punctuation\">,</span> err <span class=\"token operator\">:=</span> syscall<span class=\"token punctuation\">.</span><span class=\"token function\">Write</span><span class=\"token punctuation\">(</span>fd<span class=\"token punctuation\">,</span> buf<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">.</span><span class=\"token function\">Error</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span>\n    <span class=\"token punctuation\">}</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"send data\"</span><span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">,</span> <span class=\"token function\">string</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"net-server\"><a href=\"#net-server\" class=\"headerlink\" title=\"net server\"></a>net server</h2><pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">netServer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    l<span class=\"token punctuation\">,</span> err <span class=\"token operator\">:=</span> net<span class=\"token punctuation\">.</span><span class=\"token function\">Listen</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"tcp\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\":8080\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">.</span><span class=\"token function\">Error</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span>\n    <span class=\"token punctuation\">}</span>\n    conn<span class=\"token punctuation\">,</span> err <span class=\"token operator\">:=</span> l<span class=\"token punctuation\">.</span><span class=\"token function\">Accept</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">.</span><span class=\"token function\">Error</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span>\n    <span class=\"token punctuation\">}</span>\n\n    buf <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">byte</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1024</span><span class=\"token punctuation\">)</span>\n    n<span class=\"token punctuation\">,</span> err <span class=\"token operator\">:=</span> conn<span class=\"token punctuation\">.</span><span class=\"token function\">Write</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">.</span><span class=\"token function\">Error</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span>\n    <span class=\"token punctuation\">}</span>\n    n<span class=\"token punctuation\">,</span> err <span class=\"token operator\">=</span> conn<span class=\"token punctuation\">.</span><span class=\"token function\">Read</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">.</span><span class=\"token function\">Error</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span>\n    <span class=\"token punctuation\">}</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span>\n\n    err <span class=\"token operator\">=</span> conn<span class=\"token punctuation\">.</span><span class=\"token function\">Close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">.</span><span class=\"token function\">Error</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"net-client\"><a href=\"#net-client\" class=\"headerlink\" title=\"net client\"></a>net client</h2><pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">netClient</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    conn<span class=\"token punctuation\">,</span> err <span class=\"token operator\">:=</span> net<span class=\"token punctuation\">.</span><span class=\"token function\">Dial</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"tcp\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"127.0.0.1:8080\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">.</span><span class=\"token function\">Error</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">defer</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        err <span class=\"token operator\">=</span> conn<span class=\"token punctuation\">.</span><span class=\"token function\">Close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n            fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">.</span><span class=\"token function\">Error</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    buf <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">byte</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1024</span><span class=\"token punctuation\">)</span>\n    conn<span class=\"token punctuation\">.</span><span class=\"token function\">SetWriteDeadline</span><span class=\"token punctuation\">(</span>time<span class=\"token punctuation\">.</span><span class=\"token function\">Now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">Add</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span> <span class=\"token operator\">*</span> time<span class=\"token punctuation\">.</span>Second<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    n<span class=\"token punctuation\">,</span> err <span class=\"token operator\">:=</span> conn<span class=\"token punctuation\">.</span><span class=\"token function\">Write</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">.</span><span class=\"token function\">Error</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span>\n    <span class=\"token punctuation\">}</span>\n    conn<span class=\"token punctuation\">.</span><span class=\"token function\">SetReadDeadline</span><span class=\"token punctuation\">(</span>time<span class=\"token punctuation\">.</span><span class=\"token function\">Now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">Add</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span> <span class=\"token operator\">*</span> time<span class=\"token punctuation\">.</span>Second<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    n<span class=\"token punctuation\">,</span> err <span class=\"token operator\">=</span> conn<span class=\"token punctuation\">.</span><span class=\"token function\">Read</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">.</span><span class=\"token function\">Error</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span>\n    <span class=\"token punctuation\">}</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token function\">string</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p><a href=\"https://tonybai.com/2015/11/17/tcp-programming-in-golang/\" target=\"_blank\" rel=\"noopener\">Go语言TCP Socket编程</a><br><a href=\"https://blog.csdn.net/lanyang123456/article/details/89288824\" target=\"_blank\" rel=\"noopener\">TCP连接异常：broken pipe 和EOF</a></p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"friends":[{"avatar":"https://img-1251474779.cos.ap-beijing.myqcloud.com/icon.png","name":"djaigo","introduction":"好好学习，天天向上","url":"/","title":"前去学习"},{"avatar":"https://awps-assets.meituan.net/mit/blog/v20190629/asset/icon/favicon.ico?v=Whistle&t=20181017-1r","name":"美团技术团队","introduction":"一行代码，亿万生活。","url":"https://tech.meituan.com/","title":"点个外卖-->"},{"avatar":"","name":"鸟窝","introduction":"rpcx作者","url":"https://colobu.com/","title":"进个鸟窝-->"},{"avatar":"https://d1j8pt39hxlh3d.cloudfront.net/emoji/emojione/5.0/png/unicode/32/1f92a.png","name":"labuladong的算法小抄","introduction":"算法大神","url":"https://labuladong.gitbook.io/algo/","title":"学个算法-->"}]}},"excerpt":"","more":"<p>golang版本：1.14.1<br>主要是对golang net包的Conn接口函数进行测试，这里只是分析常见的几个错误，如果要了解详细的错误可以查看man手册。</p>\n<h1 id=\"Dial\"><a href=\"#Dial\" class=\"headerlink\" title=\"Dial\"></a>Dial</h1><p>Dial主要实现了TCP三次握手的环节。握手环节中有很多种情况：网络不可达，服务器backlog满了，网络超时等。</p>\n<h2 id=\"network-is-unreachable\"><a href=\"#network-is-unreachable\" class=\"headerlink\" title=\"network is unreachable\"></a>network is unreachable</h2><p>会返回<code>connect: network is unreachable</code></p>\n<h2 id=\"connection-refused\"><a href=\"#connection-refused\" class=\"headerlink\" title=\"connection refused\"></a>connection refused</h2><p>目标服务器的指定端口未被监听。<br>TCP层发送完第一次握手后就会收到目标主机返回的RST包，golang会返回<code>connect: connection refused</code>。<br>示例：</p>\n<pre><code class=\"go\">func main() {\n    conn, err := net.Dial(&quot;tcp&quot;, &quot;:8080&quot;)\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n    defer conn.Close()\n}</code></pre>\n<p>对应控制台输出</p>\n<pre><code class=\"sh\">dial tcp :8080: connect: connection refused</code></pre>\n<h2 id=\"connection-timed-out\"><a href=\"#connection-timed-out\" class=\"headerlink\" title=\"connection timed out\"></a>connection timed out</h2><p>Dial是阻塞的，如果不设置超时，协程会长时间阻塞（golang tcp超时是3分钟），这样很影响程序运行。<br>如果网络环境不好情况下经常有丢包发生，我们也可以手动设置超时时间来控制超时时间。<br>TCP会一直重传第一次握手的包，直到设置的超时时间后还没有收到第二次握手，网络状态一直是<code>SYN_SENT</code>，golang返回<code>i/o timeout</code>。还有连接时超时返回<code>connect: connection timed out</code>错误<br>示例：</p>\n<pre><code class=\"go\">func main() {\n    conn, err := net.DialTimeout(&quot;tcp&quot;, &quot;google.com:443&quot;, 1*time.Second)\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n    defer conn.Close()\n}</code></pre>\n<p>对应控制台输出</p>\n<pre><code class=\"sh\">dial tcp 172.217.160.78:443: i/o timeout</code></pre>\n<h1 id=\"Read\"><a href=\"#Read\" class=\"headerlink\" title=\"Read\"></a>Read</h1><h2 id=\"EOF\"><a href=\"#EOF\" class=\"headerlink\" title=\"EOF\"></a>EOF</h2><p>当前连接处于<code>CLOSE_WAIT</code>是调用<code>Read</code>会返回<code>EOF</code></p>\n<h2 id=\"i-o-timeout\"><a href=\"#i-o-timeout\" class=\"headerlink\" title=\"i/o timeout\"></a>i/o timeout</h2><p>调用<code>Read</code>函数时间超过设置<code>SetReadDeadline</code>时会返回<code>i/o timeout</code></p>\n<h2 id=\"connection-reset-by-peer\"><a href=\"#connection-reset-by-peer\" class=\"headerlink\" title=\"connection reset by peer\"></a>connection reset by peer</h2><p>在<code>Read</code>函数阻塞期间收到对端发送的<code>RST</code>包时会返回<code>read: connection reset by peer</code><br>向一个对端已关闭本端未关闭的连接（即本端处于<code>CLOSE_WAIT</code>）调用<code>Write</code>函数后再调用<code>Read</code>函数可以模拟这一个场景。</p>\n<h2 id=\"use-of-closed-network-connection\"><a href=\"#use-of-closed-network-connection\" class=\"headerlink\" title=\"use of closed network connection\"></a>use of closed network connection</h2><p>对已关闭的连接进行<code>Read</code>时会返回<code>use of closed network connection</code></p>\n<h2 id=\"connection-timed-out-1\"><a href=\"#connection-timed-out-1\" class=\"headerlink\" title=\"connection timed out\"></a>connection timed out</h2><p>试图读取连接时超时</p>\n<h2 id=\"network-is-down\"><a href=\"#network-is-down\" class=\"headerlink\" title=\"network is down\"></a>network is down</h2><p>读取一个未连接socket</p>\n<h1 id=\"Write\"><a href=\"#Write\" class=\"headerlink\" title=\"Write\"></a>Write</h1><h2 id=\"无错误\"><a href=\"#无错误\" class=\"headerlink\" title=\"无错误\"></a>无错误</h2><p>当前连接处于对端已关闭本端未关闭（即本端处于<code>CLOSE_WAIT</code>）状态时调用<code>Write</code>函数，golang不会返回error，在TCP层面会收到<code>RST</code>包。当调用<code>Close</code>函数时，系统会标记连接为全关闭，禁止在该连接上读写，所以会返回<code>RST</code>包，如果要进入半关闭需要调用<code>Shutdown</code>函数。</p>\n<h2 id=\"use-of-closed-network-connection-1\"><a href=\"#use-of-closed-network-connection-1\" class=\"headerlink\" title=\"use of closed network connection\"></a>use of closed network connection</h2><p>当前连接处于<code>FIN_WAIT_2</code>状态和已经完全关闭的连接调用<code>Write</code>会返回<code>use of closed network connection</code></p>\n<h2 id=\"broken-pipe\"><a href=\"#broken-pipe\" class=\"headerlink\" title=\"broken pipe\"></a>broken pipe</h2><p>当连接收到<code>RST</code>包后，连接已断开，此时调用<code>Write</code>会返回<code>write: broken pipe</code></p>\n<h2 id=\"connection-timed-out-2\"><a href=\"#connection-timed-out-2\" class=\"headerlink\" title=\"connection timed out\"></a>connection timed out</h2><h1 id=\"Close\"><a href=\"#Close\" class=\"headerlink\" title=\"Close\"></a>Close</h1><h2 id=\"use-of-closed-network-connection-2\"><a href=\"#use-of-closed-network-connection-2\" class=\"headerlink\" title=\"use of closed network connection\"></a>use of closed network connection</h2><p>当前连接关闭多次</p>\n<h2 id=\"socket-is-not-connected\"><a href=\"#socket-is-not-connected\" class=\"headerlink\" title=\"socket is not connected\"></a>socket is not connected</h2><p>多次关闭socket</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ol>\n<li>对<strong>本端关闭的连接</strong>进行<code>Read</code>、<code>Write</code>和<code>Close</code>都会返回<code>use of closed network connection</code></li>\n<li>对<strong>对端关闭本端未关闭的连接</strong>进行<code>Write</code>时对端会返回<code>RST</code>包（重置连接但golang不会返回错误），进行<code>Read</code>时会返回<code>EOF</code>错误</li>\n<li>对<strong>重置连接（收到RST包的连接）</strong>进行<code>Write</code>会返回<code>write: broken pipe</code>错误，进行<code>Read</code>会返回<code>read: connection reset by peer</code></li>\n<li>未在规定的时间完成<code>Read</code>和<code>Write</code>会返回<code>i/o timeout</code>错误</li>\n</ol>\n<h1 id=\"测试代码\"><a href=\"#测试代码\" class=\"headerlink\" title=\"测试代码\"></a>测试代码</h1><h2 id=\"syscall-server\"><a href=\"#syscall-server\" class=\"headerlink\" title=\"syscall server\"></a>syscall server</h2><pre><code class=\"go\">func socketServer() {\n    fd, err := syscall.Socket(syscall.AF_INET, syscall.SOCK_STREAM, syscall.IPPROTO_TCP)\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n    defer func() {\n        err = syscall.Close(fd)\n        if err != nil {\n            fmt.Println(err.Error())\n            return\n        }\n    }()\n    sa := &amp;syscall.SockaddrInet4{\n        Port: 8080,\n        Addr: [4]byte{127, 0, 0, 1},\n    }\n    err = syscall.Bind(fd, sa)\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n    err = syscall.Listen(fd, 2)\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n    for {\n        nfd, csa, err := syscall.Accept(fd)\n        if err != nil {\n            fmt.Println(err.Error())\n            return\n        }\n        fmt.Printf(&quot;fd %d sa %#v\\n&quot;, nfd, csa)\n\n        buf := make([]byte, 1024)\n        n, err := syscall.Read(nfd, buf)\n        if err != nil {\n            fmt.Println(err.Error())\n            return\n        }\n        fmt.Println(&quot;read data:&quot;, string(buf[:n]))\n        n, err = syscall.Write(fd, buf)\n        if err != nil {\n            fmt.Println(err.Error())\n            return\n        }\n        err = syscall.Close(nfd)\n        if err != nil {\n            fmt.Println(err.Error())\n            return\n        }\n        break\n    }\n}\n</code></pre>\n<h2 id=\"syscall-client\"><a href=\"#syscall-client\" class=\"headerlink\" title=\"syscall client\"></a>syscall client</h2><pre><code class=\"go\">func socketClient() {\n    fd, err := syscall.Socket(syscall.AF_INET, syscall.SOCK_STREAM, syscall.IPPROTO_TCP)\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n    defer func() {\n        err = syscall.Close(fd)\n        if err != nil {\n            fmt.Println(err.Error())\n            return\n        }\n    }()\n    sa := &amp;syscall.SockaddrInet4{\n        Port: 8080,\n        Addr: [4]byte{127, 0, 0, 1},\n    }\n    err = syscall.Connect(fd, sa)\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n    buf := []byte(&quot;1234567890&quot;)\n    n, err := syscall.Write(fd, buf)\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n    fmt.Println(&quot;send data&quot;, n, string(buf))\n}</code></pre>\n<h2 id=\"net-server\"><a href=\"#net-server\" class=\"headerlink\" title=\"net server\"></a>net server</h2><pre><code class=\"go\">func netServer() {\n    l, err := net.Listen(&quot;tcp&quot;, &quot;:8080&quot;)\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n    conn, err := l.Accept()\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n\n    buf := make([]byte, 1024)\n    n, err := conn.Write(buf)\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n    n, err = conn.Read(buf)\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n    fmt.Println(n)\n\n    err = conn.Close()\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n}</code></pre>\n<h2 id=\"net-client\"><a href=\"#net-client\" class=\"headerlink\" title=\"net client\"></a>net client</h2><pre><code class=\"go\">func netClient() {\n    conn, err := net.Dial(&quot;tcp&quot;, &quot;127.0.0.1:8080&quot;)\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n    defer func() {\n        err = conn.Close()\n        if err != nil {\n            fmt.Println(err.Error())\n            return\n        }\n    }()\n\n    buf := make([]byte, 1024)\n    conn.SetWriteDeadline(time.Now().Add(5 * time.Second))\n    n, err := conn.Write(buf)\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n    conn.SetReadDeadline(time.Now().Add(5 * time.Second))\n    n, err = conn.Read(buf)\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n    fmt.Println(string(buf[:n]))\n}</code></pre>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p><a href=\"https://tonybai.com/2015/11/17/tcp-programming-in-golang/\" target=\"_blank\" rel=\"noopener\">Go语言TCP Socket编程</a><br><a href=\"https://blog.csdn.net/lanyang123456/article/details/89288824\" target=\"_blank\" rel=\"noopener\">TCP连接异常：broken pipe 和EOF</a></p>\n"},{"author":"djaigo","title":"golang 调度过程源码分析","img":"https://img-1251474779.cos.ap-beijing.myqcloud.com/golang.png","date":"2020-10-12T08:15:17.000Z","_content":"\ngolang 版本：go version go1.15.2 darwin/amd64\n\n根据启动函数来分析golang MPG的生存周期，忽略cgo相关代码。\n\n# MPG\nMPG是golang调度的重要对象：\n* M，表示一个内核线程，是执行用户代码的实际场所\n* P，表示一个处理器，管理M需要运行G的相关资源，如内存分配，G的可执行列表，G的空闲列表等\n* G，表示一个goroutine，调度基本单元，维护goroutine内部资源，如栈信息，defer列表等\n\n# 启动\n启动汇编函数\n```asm\n// runtime/asm_amd64.s\n\nTEXT runtime·rt0_go(SB),NOSPLIT,$0\n    // ... 省略 ...\n\n\t// create istack out of the given (operating system) stack.\n\t// _cgo_init may update stackguard.\n\t// 给 runtime.g0 创建栈\n\tMOVQ\t$runtime·g0(SB), DI\n\tLEAQ\t(-64*1024+104)(SP), BX\n\tMOVQ\tBX, g_stackguard0(DI)\n\tMOVQ\tBX, g_stackguard1(DI)\n\tMOVQ\tBX, (g_stack+stack_lo)(DI)\n\tMOVQ\tSP, (g_stack+stack_hi)(DI)\n\n    // ... 省略 ...\n\n\t// set the per-goroutine and per-mach \"registers\"\n\tget_tls(BX)\n\tLEAQ\truntime·g0(SB), CX\n\tMOVQ\tCX, g(BX)\n\tLEAQ\truntime·m0(SB), AX\n\n\t// save m->g0 = g0\n\t// 绑定 m0 和 g0\n\tMOVQ\tCX, m_g0(AX)\n\t// save m0 to g0->m\n\tMOVQ\tAX, g_m(CX)\n\n\tCLD\t\t\t\t// convention is D is always left cleared\n\tCALL\truntime·check(SB)\n\n\tMOVL\t16(SP), AX\t\t// copy argc\n\tMOVL\tAX, 0(SP)\n\tMOVQ\t24(SP), AX\t\t// copy argv\n\tMOVQ\tAX, 8(SP)\n\tCALL\truntime·args(SB)       // 解析命令行参数\n\tCALL\truntime·osinit(SB)     // 获取CPU核数\n\tCALL\truntime·schedinit(SB)  // 初始化调度\n\n\t// create a new goroutine to start program\n\tMOVQ\t$runtime·mainPC(SB), AX\t\t// entry\n\tPUSHQ\tAX\n\tPUSHQ\t$0\t\t\t// arg size\n\tCALL\truntime·newproc(SB)// 执行runtime.main\n\tPOPQ\tAX\n\tPOPQ\tAX\n\n\t// start this M\n\tCALL\truntime·mstart(SB) // 启动m0\n\n\tCALL\truntime·abort(SB)\t// mstart should never return\n\tRET\n```\n\n`rt0_go`函数主要流程：\n* 初始化`g0`、`m0`\n* `g0`和`m0`互相绑定\n* 初始化相关数据，初始化指定个数的`p`\n* 创建新`g`绑定`runtime.main`函数，加入`p`的可执行列表中\n* 启动`m0`开始循环调度。\n\n## schedinit\n```go\n// runtime/proc.go\n\nfunc schedinit() {\n\t// ... 省略 ...\n\t\n\t_g_ := getg() // 获取当前绑定的g\n\t\n\t// 限制M的数量\n\tsched.maxmcount = 10000\n\n\t// ... 省略 ...\n\n    // 创建 p\n\tlock(&sched.lock)\n\tsched.lastpoll = uint64(nanotime())\n\tprocs := ncpu\n\tif n, ok := atoi32(gogetenv(\"GOMAXPROCS\")); ok && n > 0 {\n\t\tprocs = n\n\t}\n\tif procresize(procs) != nil {\n\t\tthrow(\"unknown runnable goroutine during bootstrap\")\n\t}\n\tunlock(&sched.lock)\n}\n```\n\n`schedinit`函数主要流程：\n* 初始化全局调度相关值\n* 限制`m`的最多个数\n* 初始化指定个数的`p`\n\n## newproc\n```go\n// runtime/proc.go\n\nfunc newproc(siz int32, fn *funcval) {\n\targp := add(unsafe.Pointer(&fn), sys.PtrSize)\n\tgp := getg()\n\tpc := getcallerpc()\n\tsystemstack(func() {\n\t\tnewg := newproc1(fn, argp, siz, gp, pc)\n\n\t\t_p_ := getg().m.p.ptr()\n\t\trunqput(_p_, newg, true)\n\n\t\tif mainStarted { // mainStarted 是在 runtime.main 中设置为 true \n\t\t\twakep() // 尝试找一个p绑定m\n\t\t}\n\t})\n}\n```\n\n`newproc`函数主要流程：\n* 创建栈大小为`siz`的新`g`，并关联`fn`\n* 将新`g`存放于`_p_`的可执行队列中\n* 此时刚初始化，并没有执行`runtime.main`所以不会执行`wakep`\n\n```go\n// runtime/proc.go\n\nfunc newproc1(fn *funcval, argp unsafe.Pointer, narg int32, callergp *g, callerpc uintptr) *g {\n\t_g_ := getg()\n\n\tacquirem() // disable preemption because it can be holding p in a local var\n\tsiz := narg\n\tsiz = (siz + 7) &^ 7\n\t\n\t_p_ := _g_.m.p.ptr() // 获取 p\n\tnewg := gfget(_p_)   // 从 p 的空闲 g 列表中获取 g\n\tif newg == nil {     // 没有空闲的 g\n\t\tnewg = malg(_StackMin)           // 创建一个拥有最小栈的 g\n\t\tcasgstatus(newg, _Gidle, _Gdead) // 转换状态\n\t\tallgadd(newg)                    // 向全局 g 列表中添加 g\n\t}\n\n\t// ... 省略 ...\n\n    // 填充 g\n\tmemclrNoHeapPointers(unsafe.Pointer(&newg.sched), unsafe.Sizeof(newg.sched))\n\tnewg.sched.sp = sp\n\tnewg.stktopsp = sp\n\tnewg.sched.pc = funcPC(goexit) + sys.PCQuantum // 当g执行完后的处理函数\n\tnewg.sched.g = guintptr(unsafe.Pointer(newg))\n\tgostartcallfn(&newg.sched, fn)\n\tnewg.gopc = callerpc\n\tnewg.ancestors = saveAncestors(callergp)\n\tnewg.startpc = fn.fn\n\tif _g_.m.curg != nil {\n\t\tnewg.labels = _g_.m.curg.labels\n\t}\n\tif isSystemGoroutine(newg, false) {\n\t\tatomic.Xadd(&sched.ngsys, +1)\n\t}\n\tcasgstatus(newg, _Gdead, _Grunnable) // 切换成可执行状态\n\n    // 分配goid，如果没有则向p批量获取\n\tif _p_.goidcache == _p_.goidcacheend {\n\t\t_p_.goidcache = atomic.Xadd64(&sched.goidgen, _GoidCacheBatch)\n\t\t_p_.goidcache -= _GoidCacheBatch - 1\n\t\t_p_.goidcacheend = _p_.goidcache + _GoidCacheBatch\n\t}\n\tnewg.goid = int64(_p_.goidcache)\n\t_p_.goidcache++\n\n\treleasem(_g_.m)\n\n\treturn newg\n}\n```\n\n`newproc1`函数主要流程：\n* 从空闲`g`列表中获取或新建`g`，将`g`的信息填充\n\n## mstart\n```go\n// runtime/proc.go\n\nfunc mstart() {\n\t_g_ := getg()\n\n    // 设置 _g_ 的栈信息\n\tosStack := _g_.stack.lo == 0\n\tif osStack {\n\t\tsize := _g_.stack.hi\n\t\tif size == 0 {\n\t\t\tsize = 8192 * sys.StackGuardMultiplier\n\t\t}\n\t\t_g_.stack.hi = uintptr(noescape(unsafe.Pointer(&size)))\n\t\t_g_.stack.lo = _g_.stack.hi - size + 1024\n\t}\n\t_g_.stackguard0 = _g_.stack.lo + _StackGuard\n\t_g_.stackguard1 = _g_.stackguard0\n\t\n\tmstart1() // 不会返回\n}\n```\n\n`mstart`函数主要流程：\n* 填充`g`的栈信息\n* 让`m`开始执行`g`上的代码\n\n```go\n// runtime/proc.go\n\nfunc mstart1() {\n\t_g_ := getg()\n\n\t// ... 省略 ...\n\t\n\tif _g_.m == &m0 {\n\t\tmstartm0() // 启动 m0 初始化信号处理\n\t}\n\n\tif fn := _g_.m.mstartfn; fn != nil {\n\t\tfn() // 执行m绑定的启动时调用的函数\n\t}\n\n\tif _g_.m != &m0 {\n\t\tacquirep(_g_.m.nextp.ptr())\n\t\t_g_.m.nextp = 0\n\t}\n\tschedule() // 开始调度\n}\n```\n\n`mstart1`函数主要流程：\n* 如果是`m0`，则初始化信号处理\n* 如果有`mstartfn`，则执行\n* 如果不是`m0`，则绑定`p`\n* 调用`schedule`启动golang进程的调度。\n\n## runtime.main\n```go\n// runtime/proc.go\n\nfunc main() {\n\tg := getg()\n\n    // 确认栈的最大值\n\tif sys.PtrSize == 8 {\n\t\tmaxstacksize = 1000000000\n\t} else {\n\t\tmaxstacksize = 250000000\n\t}\n\n\t// Allow newproc to start new Ms.\n\tmainStarted = true // 标志 newproc 时可以启动 m\n\n\tif GOARCH != \"wasm\" { // no threads on wasm yet, so no sysmon\n\t\tsystemstack(func() {\n\t\t\tnewm(sysmon, nil, -1) // 新建 m 去执行 sysmon\n\t\t})\n\t}\n\n\tlockOSThread()\n\t\n\tdoInit(&runtime_inittask) // 执行runtime包中的init函数\n\n\t// Record when the world started.\n\truntimeInitTime = nanotime()\n\n\tgcenable() // 开启GC\n\n\tmain_init_done = make(chan bool)\n\tdoInit(&main_inittask) // 执行main包中的init函数\n\tclose(main_init_done)\n\t\n\tunlockOSThread()\n\n\tfn := main_main // fn 指向main包的main函数\n\tfn() // 执行main包的main函数\n\n\texit(0)\n}\n```\n\nruntime.main函数主要功能：\n* 设置了栈的最大值\n* 创建m去执行sysmon\n* 调用runtime包的init函数\n* 启动GC\n* 执行main包的init函数\n* 退出\n\n## startm\n除了m0是汇编初始化的，其他的m都是由startm创建的。\n```go\nfunc startm(_p_ *p, spinning bool) {\n\tlock(&sched.lock)\n\tif _p_ == nil { // _p_ 为空\n\t\t_p_ = pidleget() // 从p空闲列表中获取一个\n\t\tif _p_ == nil {  // 获取失败\n\t\t\tunlock(&sched.lock)\n\t\t\tif spinning {\n\t\t\t\t// 如果是自旋状态，调用方增加了nmspinning，但是没有空闲的P，因此可以取消增量并放弃\n\t\t\t\tif int32(atomic.Xadd(&sched.nmspinning, -1)) < 0 {\n\t\t\t\t\tthrow(\"startm: negative nmspinning\")\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n\tmp := mget() // 从m空闲列表中获取m\n\tif mp == nil { // 如果空闲列表没有\n\t\tid := mReserveID() // 获取 m id\n\t\tunlock(&sched.lock)\n\n\t\tvar fn func()\n\t\tif spinning {\n\t\t\tfn = mspinning // 设置 m 的自旋状态函数\n\t\t}\n\t\tnewm(fn, _p_, id) // 创建一个m对象\n\t\treturn\n\t}\n\tunlock(&sched.lock)\n\tif mp.spinning {\n\t\tthrow(\"startm: m is spinning\")\n\t}\n\tif mp.nextp != 0 {\n\t\tthrow(\"startm: m has p\")\n\t}\n\tif spinning && !runqempty(_p_) {\n\t\tthrow(\"startm: p has runnable gs\")\n\t}\n\t// 由调用者确定是否自旋，并将m.nextp设置为p\n\tmp.spinning = spinning\n\tmp.nextp.set(_p_)\n\tnotewakeup(&mp.park)\n}\n```\n\n`startm`函数主要流程：\n* 获取一个`p`，失败则返回\n  * 获取一个`m`，如果失败就创建`m`并返回\n* `m`暂存`p`\n\n### newm\n\n```go\nfunc newm(fn func(), _p_ *p, id int64) {\n\tmp := allocm(_p_, fn, id) // 创建新m\n\tmp.nextp.set(_p_) // 暂存p\n\tmp.sigmask = initSigmask // 信号掩码\n\tnewm1(mp) // 绑定操作系统线程\n}\n```\n\n```go\nfunc allocm(_p_ *p, fn func(), id int64) *m {\n\t_g_ := getg()\n\tacquirem() // disable GC because it can be called from sysmon\n\tif _g_.m.p == 0 {\n\t\tacquirep(_p_) // 临时绑定p\n\t}\n\n    // 清理可以安全删除的m的g0栈信息\n\tif sched.freem != nil { \n\t\tlock(&sched.lock)\n\t\tvar newList *m\n\t\tfor freem := sched.freem; freem != nil; {\n\t\t\tif freem.freeWait != 0 {\n\t\t\t\tnext := freem.freelink\n\t\t\t\tfreem.freelink = newList\n\t\t\t\tnewList = freem\n\t\t\t\tfreem = next\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tstackfree(freem.g0.stack) // 清空freem.g0的栈信息\n\t\t\tfreem = freem.freelink\n\t\t}\n\t\tsched.freem = newList // 更新已被释放的m列表\n\t\tunlock(&sched.lock)\n\t}\n\n\tmp := new(m)\n\tmp.mstartfn = fn // 绑定m启动函数\n\tmcommoninit(mp, id) // 绑定mp的id\n\n\t// 初始化g0栈信息\n\tif iscgo || GOOS == \"solaris\" || GOOS == \"illumos\" || GOOS == \"windows\" || GOOS == \"plan9\" || GOOS == \"darwin\" || GOOS == \"ios\" {\n\t\tmp.g0 = malg(-1)\n\t} else {\n\t\tmp.g0 = malg(8192 * sys.StackGuardMultiplier)\n\t}\n\tmp.g0.m = mp\n\n\tif _p_ == _g_.m.p.ptr() {\n\t\treleasep() // 解绑p\n\t}\n\treleasem(_g_.m)\n\n\treturn mp\n}\n```\n\n```go\nfunc newm1(mp *m) {\n\texecLock.rlock() // Prevent process clone.\n\tnewosproc(mp) // 绑定操作系统线程\n\texecLock.runlock()\n}\n```\n\n`newm`函数主要流程：\n* 释放可以清理的`m`的`g0`栈空间\n* 新建`m`，绑定`id`和启动函数，申请`g0`栈空间\n* `m`暂存当前`p`\n* 创建与`m`对应的操作系统线程\n\n\n## netpoll\n`netpoll`可以让调度器从就绪的网络事件中获取可执行的goroutine。\n由于golang对每个系统的netpoll做了条件编译，这里就拿linux的实现来说明。\n```go\nfunc netpoll(delay int64) gList {\n\tvar events [128]epollevent\nretry:\n\tn := epollwait(epfd, &events[0], int32(len(events)), waitms)\n\t\n\tvar toRun gList\n\tfor i := int32(0); i < n; i++ {\n\t\tev := &events[i]\n\t\tvar mode int32\n\t\tif ev.events&(_EPOLLIN|_EPOLLRDHUP|_EPOLLHUP|_EPOLLERR) != 0 {\n\t\t\tmode += 'r'\n\t\t}\n\t\tif ev.events&(_EPOLLOUT|_EPOLLHUP|_EPOLLERR) != 0 {\n\t\t\tmode += 'w'\n\t\t}\n\t\tif mode != 0 {\n\t\t\tpd := *(**pollDesc)(unsafe.Pointer(&ev.data))\n\t\t\tpd.everr = false\n\t\t\tif ev.events == _EPOLLERR {\n\t\t\t\tpd.everr = true\n\t\t\t}\n\t\t\tnetpollready(&toRun, pd, mode) // 将符合的g填充进toRun中\n\t\t}\n\t}\n\treturn toRun\n}\n```\n\n`netpoll`函数主要流程：\n* 调用`epollwait`获取就绪的文件描述符\n* 将`pd`中的就绪`g`追加进`toRun`里面\n* 返回`toRun`\n\n# 调度\n```go\n// runtime/proc.go\n\nfunc schedule() {\n\t_g_ := getg()\n\n\t// 如果_g_绑定的m有锁定的g，则抛弃_g_，转而执行锁定的g\n\tif _g_.m.lockedg != 0 {\n\t\tstoplockedm()\n\t\texecute(_g_.m.lockedg.ptr(), false) // Never returns.\n\t}\n\ntop:\n\tpp := _g_.m.p.ptr()\n\tpp.preempt = false\n\n\t// 如果准备GC，则休眠当前m，直到被唤醒\n\tif sched.gcwaiting != 0 {\n\t\tgcstopm()\n\t\tgoto top\n\t}\n\tif pp.runSafePointFn != 0 {\n\t\trunSafePointFn()\n\t}\n\n\tcheckTimers(pp, 0)\n\n\tvar gp *g\n\tvar inheritTime bool\n\n\ttryWakeP := false\n\tif trace.enabled || trace.shutdown {\n\t\tgp = traceReader()\n\t\tif gp != nil {\n\t\t\tcasgstatus(gp, _Gwaiting, _Grunnable)\n\t\t\ttraceGoUnpark(gp, 0)\n\t\t\ttryWakeP = true\n\t\t}\n\t}\n\tif gp == nil && gcBlackenEnabled != 0 {\n\t\t// 找GCWorker\n\t\tgp = gcController.findRunnableGCWorker(_g_.m.p.ptr())\n\t\ttryWakeP = tryWakeP || gp != nil\n\t}\n\tif gp == nil {\n\t\t// 为了让全局可执行队列的g能够运行，这里每操作一定次数就从全局队列中获取\n\t\tif _g_.m.p.ptr().schedtick%61 == 0 && sched.runqsize > 0 {\n\t\t\tlock(&sched.lock)\n\t\t\tgp = globrunqget(_g_.m.p.ptr(), 1)\n\t\t\tunlock(&sched.lock)\n\t\t}\n\t}\n\tif gp == nil {\n\t\t// 从本地可执行队列中获取\n\t\tgp, inheritTime = runqget(_g_.m.p.ptr())\n\t}\n\tif gp == nil {\n\t\t// 从其他地方找一个g来执行，如果没有则阻塞在这里\n\t\tgp, inheritTime = findrunnable() // blocks until work is available\n\t}\n\n\t// This thread is going to run a goroutine and is not spinning anymore,\n\t// so if it was marked as spinning we need to reset it now and potentially\n\t// start a new spinning M.\n\tif _g_.m.spinning {\n\t\t// 如果当前m正在自旋，则重置自旋状态\n\t\tresetspinning()\n\t}\n\t\n\tif tryWakeP {\n\t\twakep() // GCworker 或 tracereader 需要唤醒p\n\t}\n\tif gp.lockedm != 0 {\n\t\t// m将自己的p让给gp锁定的m，自己阻塞等待新p\n\t\tstartlockedm(gp)\n\t\tgoto top\n\t}\n\n\texecute(gp, inheritTime) // 执行gp\n}\n```\n\n`schedule`函数主要流程：\n* 如果`g`有绑定的`m`，则直接让绑定`m`执行`g`\n* 如果要GC，则休眠当前`m`，等待唤醒\n* 从`traceReader`、`GCWorker`、`globrunqget`、`runqget`、`findrunnable`函数中获取一个可执行gp\n* 重置自旋状态\n* 如果需要唤醒`p`，则尝试唤醒`p`\n* 如果获取的`gp`有锁定的`m`，则让出自己的`p`给`gp`锁定的`m`，自己则阻塞等待被唤醒\n* 执行`gp`\n\n## findrunnable\n```go\n// runtime/proc.go\n\nfunc findrunnable() (gp *g, inheritTime bool) {\n\t_g_ := getg()\n\ntop:\n\t_p_ := _g_.m.p.ptr()\n\tif sched.gcwaiting != 0 {\n\t\tgcstopm()\n\t\tgoto top\n\t}\n\tif _p_.runSafePointFn != 0 {\n\t\trunSafePointFn()\n\t}\n\n\tnow, pollUntil, _ := checkTimers(_p_, 0)\n\n    // 如果有finalizer可用，直接唤醒\n\tif fingwait && fingwake {\n\t\tif gp := wakefing(); gp != nil {\n\t\t\tready(gp, 0, true)\n\t\t}\n\t}\n\n\t// 本地获取\n\tif gp, inheritTime := runqget(_p_); gp != nil {\n\t\treturn gp, inheritTime\n\t}\n\n\t// 全局获取\n\t// global runq\n\tif sched.runqsize != 0 {\n\t\tlock(&sched.lock)\n\t\tgp := globrunqget(_p_, 0)\n\t\tunlock(&sched.lock)\n\t\tif gp != nil {\n\t\t\treturn gp, false\n\t\t}\n\t}\n\n\t// 没有可以执行的goroutine\n\n\t// 获取网络事件完成的gp，优化\n\tif netpollinited() && atomic.Load(&netpollWaiters) > 0 && atomic.Load64(&sched.lastpoll) != 0 {\n\t\tif list := netpoll(0); !list.empty() { // non-blocking\n\t\t\tgp := list.pop()\n\t\t\tinjectglist(&list)\n\t\t\tcasgstatus(gp, _Gwaiting, _Grunnable)\n\t\t\tif trace.enabled {\n\t\t\t\ttraceGoUnpark(gp, 0)\n\t\t\t}\n\t\t\treturn gp, false\n\t\t}\n\t}\n\n\t// 从其他的P偷取\n\t// Steal work from other P's.\n\tprocs := uint32(gomaxprocs)\n\tranTimer := false\n\t\n    // 将m置为自旋状态\n\tif !_g_.m.spinning {\n\t\t_g_.m.spinning = true\n\t\tatomic.Xadd(&sched.nmspinning, 1)\n\t}\n\n    // 随机从别的p中偷取4次\n\tfor i := 0; i < 4; i++ {\n\t\tfor enum := stealOrder.start(fastrand()); !enum.done(); enum.next() {\n\t\t\tif sched.gcwaiting != 0 {\n\t\t\t\tgoto top\n\t\t\t}\n\t\t\tstealRunNextG := i > 2 // first look for ready queues with more than 1 g\n\t\t\tp2 := allp[enum.position()]\n\t\t\tif _p_ == p2 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif gp := runqsteal(_p_, p2, stealRunNextG); gp != nil {\n\t\t\t\treturn gp, false\n\t\t\t}\n\n\t\t\tif i > 2 || (i > 1 && shouldStealTimers(p2)) {\n\t\t\t\ttnow, w, ran := checkTimers(p2, now)\n\t\t\t\tnow = tnow\n\t\t\t\tif w != 0 && (pollUntil == 0 || w < pollUntil) {\n\t\t\t\t\tpollUntil = w\n\t\t\t\t}\n\t\t\t\tif ran {\n\t\t\t\t\tif gp, inheritTime := runqget(_p_); gp != nil {\n\t\t\t\t\t\treturn gp, inheritTime\n\t\t\t\t\t}\n\t\t\t\t\tranTimer = true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif ranTimer {\n\t\t// Running a timer may have made some goroutine ready.\n\t\tgoto top\n\t}\n\t// ... 省略 ...    \n}\n```\n\n`findrunnable`函数主要流程：\n* 如果有`finalizer`可执行`gp`，直接唤醒\n* 如果从本地可执行队列中获取可执行`gp`，返回`gp`\n* 如果从全局可执行队列中获取可执行`gp`，返回`gp`\n* 如果有就绪的网络事件的`gp`，返回`gp`\n* 从其他的`p`中偷取部分`gp`，返回`gp`\n\n### runqsteal\n```go\n// runtime/proc.go\n\nfunc runqsteal(_p_, p2 *p, stealRunNextG bool) *g {\n\tt := _p_.runqtail\n\tn := runqgrab(p2, &_p_.runq, t, stealRunNextG)\n\tif n == 0 {\n\t\treturn nil\n\t}\n\tn--\n\tgp := _p_.runq[(t+n)%uint32(len(_p_.runq))].ptr()\n\tif n == 0 {\n\t\treturn gp\n\t}\n\th := atomic.LoadAcq(&_p_.runqhead)\n\tatomic.StoreRel(&_p_.runqtail, t+n)\n\treturn gp\n}\n```\n\n`runqsteal`函数主要流程：\n* 获取本地队列队尾坐标\n* 从`p2`中获取部分可执行队列\n* 如果只偷取了一个，直接返回\n* 否则需要原子修改可执行队列的首尾指针\n\n#### runqgrab\n```\n// runtime/proc.go\n\nfunc runqgrab(_p_ *p, batch *[256]guintptr, batchHead uint32, stealRunNextG bool) uint32 {\n\tfor {\n\t\th := atomic.LoadAcq(&_p_.runqhead)\n\t\tt := atomic.LoadAcq(&_p_.runqtail) \n\t\tn := t - h\n\t\tn = n - n/2\n\t\tif n == 0 {\n\t\t\tif stealRunNextG {\n\t\t\t\t// Try to steal from _p_.runnext.\n\t\t\t\tif next := _p_.runnext; next != 0 {\n\t\t\t\t\t// 休眠让p不会执行将要偷取的\n\t\t\t\t\tif _p_.status == _Prunning {\n\t\t\t\t\t\tif GOOS != \"windows\" {\n\t\t\t\t\t\t\tusleep(3)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tosyield()\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif !_p_.runnext.cas(next, 0) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tbatch[batchHead%uint32(len(batch))] = next\n\t\t\t\t\treturn 1\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0\n\t\t}\n\t\tif n > uint32(len(_p_.runq)/2) { // 保证队列没有改动\n\t\t\tcontinue\n\t\t}\n\t\t// 偷取前半g可执行队列\n\t\tfor i := uint32(0); i < n; i++ {\n\t\t\tg := _p_.runq[(h+i)%uint32(len(_p_.runq))]\n\t\t\tbatch[(batchHead+i)%uint32(len(batch))] = g\n\t\t}\n\t\t// 提交本次消费，如果失败则从新再试一次\n\t\tif atomic.CasRel(&_p_.runqhead, h, h+n) {\n\t\t\treturn n\n\t\t}\n\t}\n}\n```\n\nrunqgrab函数主要流程：\n* 原子获取待偷取`p`可执行队列首尾位置\n* 如果没有，则判断是否需要偷取`next`指针的`gp`\n* 复制`p`的前半部分可执行队列\n* 原子的修改`p`的可执行队列的首尾指针位置\n\n## execute\n```go\n// runtime/proc.go\n\nfunc execute(gp *g, inheritTime bool) {\n\t_g_ := getg()\n\n    // 互相绑定 _g_.m.curg = gp\n    gp.m = _g_.m\n    casgstatus(gp, _Grunnable, _Grunning) // 转换状态\n\tgp.waitsince = 0\n\tgp.preempt = false\n\tgp.stackguard0 = gp.stack.lo + _StackGuard\n\tif !inheritTime {\n\t\t_g_.m.p.ptr().schedtick++\n\t}\n\n\tgogo(&gp.sched)\n}\n```\n\n`execute`函数主要流程：\n* `m`和`g`相互绑定\n* 设置相关值\n* 调用`gogo`函数执行`gp`\n\n### gogo\n```asm\n// runtime/asm_amd64.s\n\nTEXT runtime·gogo(SB), NOSPLIT, $16-8\n\tMOVQ\tbuf+0(FP), BX\t\t// gobuf\n\tMOVQ\tgobuf_g(BX), DX\n\tMOVQ\t0(DX), CX\t\t// make sure g != nil\n\tget_tls(CX)\n\tMOVQ\tDX, g(CX)\n\tMOVQ\tgobuf_sp(BX), SP\t// restore SP\n\tMOVQ\tgobuf_ret(BX), AX\n\tMOVQ\tgobuf_ctxt(BX), DX\n\tMOVQ\tgobuf_bp(BX), BP\n\tMOVQ\t$0, gobuf_sp(BX)\t// clear to help garbage collector\n\tMOVQ\t$0, gobuf_ret(BX)\n\tMOVQ\t$0, gobuf_ctxt(BX)\n\tMOVQ\t$0, gobuf_bp(BX)\n\tMOVQ\tgobuf_pc(BX), BX\n\tJMP\tBX\n```\n\n`gogo`函数主要流程：\n* 将`gobuf`的内容存放到相关寄存器中\n* 将`gobuf`的内容清空\n* 执行`gobuf.pc`\n\n## Gosched\n除了上述的通过运行时启动调度之外，golang还提供了手动的调度函数`Gosched`函数，该函数在运行时内外都可以触发下一次调度。\n```go\nfunc Gosched() {\n\tcheckTimeouts()\n\tmcall(gosched_m)\n}\n```\n\n```go\nfunc gosched_m(gp *g) {\n\tgoschedImpl(gp)\n}\n```\n\n```go\nfunc goschedImpl(gp *g) {\n\tstatus := readgstatus(gp)\n\tif status&^_Gscan != _Grunning {\n\t\tdumpgstatus(gp)\n\t\tthrow(\"bad g status\")\n\t}\n\tcasgstatus(gp, _Grunning, _Grunnable)\n\tdropg() // 解绑g和m\n\tlock(&sched.lock)\n\tglobrunqput(gp) // 放入全局可执行队列\n\tunlock(&sched.lock)\n\n\tschedule() // 下一次调度\n}\n```\n\nGosched函数主要流程：\n* 获取gp的状态\n* 切换gp的状态为_Grunnable\n* 解绑g和m\n* 将g存入全局可执行队列中\n* 启动下一次调度\n\n# 销毁\n```asm\nTEXT runtime·goexit(SB),NOSPLIT,$0-0\n\tBYTE\t$0x90\t// NOP\n\tCALL\truntime·goexit1(SB)\t// does not return\n\t// traceback from goexit1 must hit code range of goexit\n\tBYTE\t$0x90\t// NOP\n```\n\n```go\nfunc goexit1() {\n   if raceenabled {\n      racegoend()\n   }\n   if trace.enabled {\n      traceGoEnd()\n   }\n   mcall(goexit0)\n}\n```\n\n```go\nfunc goexit0(gp *g) {\n\t_g_ := getg()\n\n    // 切换g的状态 \n    casgstatus(gp, _Grunning, _Gdead)\n    // 标记系统goroutine \n    if isSystemGoroutine(gp, false) {\n       atomic.Xadd(&sched.ngsys, -1)\n    }\n\t// 清理gp相关的数据\n\tgp.m = nil\n\tlocked := gp.lockedm != 0\n\tgp.lockedm = 0\n\t_g_.m.lockedg = 0\n\tgp.preemptStop = false\n\tgp.paniconfault = false\n\tgp._defer = nil // should be true already but just in case.\n\tgp._panic = nil // non-nil for Goexit during panic. points at stack-allocated data.\n\tgp.writebuf = nil\n\tgp.waitreason = 0\n\tgp.param = nil\n\tgp.labels = nil\n\tgp.timer = nil\n\n\tdropg() // 解绑当前m和gp\n\n\tif GOARCH == \"wasm\" { // no threads yet on wasm\n\t\tgfput(_g_.m.p.ptr(), gp) // 将gp存放到p的空闲列表中\n\t\tschedule() // 下一次调度\n\t}\n\n\tgfput(_g_.m.p.ptr(), gp) // 将gp存放到p的空闲列表中\n\tif locked {\n\t\t// 如果gp锁定了m，则将这个m杀死\n\t\tif GOOS != \"plan9\" { \n\t\t\tgogo(&_g_.m.g0.sched)\n\t\t} else {\n\t\t\t_g_.m.lockedExt = 0\n\t\t}\n\t}\n\tschedule() // 下一次调度\n}\n```\n\n`goexit0`函数主要流程：\n* 切换`g`的状态\n* 解绑`g`所有绑定的数据\n* 如果是`wasm`架构，直接将`g`存于空闲列表中，并开始下一次调度\n* 否则，直接将`g`存于空闲列表中，如果`g`有锁定的`m`，则将`m`杀死，开始下一次调度\n\n# 切换\n## 执行完毕切换\n上面说到，当goroutine执行完毕时，会执行goexit0函数，进而执行下一次调度\n## 主动切换\n当goroutine中阻塞的操作时，就需要让出CPU，让其他的goroutine执行。所有主动切换都是调用gopark函数来实现的。\n### gopark\n```go\nfunc gopark(unlockf func(*g, unsafe.Pointer) bool, lock unsafe.Pointer, reason waitReason, traceEv byte, traceskip int) {\n\tif reason != waitReasonSleep {\n\t\tcheckTimeouts()\n\t}\n\tmp := acquirem()\n\tgp := mp.curg\n\tstatus := readgstatus(gp)\n\tif status != _Grunning && status != _Gscanrunning {\n\t\tthrow(\"gopark: bad g status\")\n\t}\n\t// 填充相关参数\n\tmp.waitlock = lock\n\tmp.waitunlockf = unlockf\n\tgp.waitreason = reason\n\tmp.waittraceev = traceEv\n\tmp.waittraceskip = traceskip\n\treleasem(mp)\n\t// can't do anything that might move the G between Ms here.\n\tmcall(park_m)\n}\n```\n\n`gopark`函数主要流程：\n* 获取当前`m`绑定的`gp`\n* 填充相关参数\n* 利用`g0`调用`park_m`函数\n\n```go\nfunc park_m(gp *g) {\n\t_g_ := getg()\n\n\tcasgstatus(gp, _Grunning, _Gwaiting)\n\tdropg() // 解绑g和m\n\n\tif fn := _g_.m.waitunlockf; fn != nil {\n\t\tok := fn(gp, _g_.m.waitlock) // 尝试调用解锁函数\n\t\t_g_.m.waitunlockf = nil\n\t\t_g_.m.waitlock = nil\n\t\tif !ok {\n\t\t\t// 如果解锁成功\n\t\t\tcasgstatus(gp, _Gwaiting, _Grunnable)\n\t\t\texecute(gp, true) // 直接执行gp\n\t\t}\n\t}\n\tschedule() // 下一次调度\n}\n```\n\n`park_m`函数主要流程：\n* 切换`g`的状态为等待\n* 尝试解锁，如果成功则切换状态为可执行，直接调用`execute`函数执行\n* 否则，进入下一个调度\n\n### goready\n当goroutine通过`gopark`函数由`_Grunning`到`_Gwaiting`，反向操作`goready`函数则是将`_Gwaiting`到`_Grunnable`。\n```go\nfunc goready(gp *g, traceskip int) {\n\tsystemstack(func() {\n\t\tready(gp, traceskip, true)\n\t})\n}\n```\n\n```go\nfunc ready(gp *g, traceskip int, next bool) {\n\tstatus := readgstatus(gp)\n\n\t_g_ := getg()\n\tmp := acquirem()\n\t// 如果不是 _Gwaiting 抛异常\n\tif status&^_Gscan != _Gwaiting {\n\t\tdumpgstatus(gp)\n\t\tthrow(\"bad g->status in ready\")\n\t}\n\n    // 切换状态\n\tcasgstatus(gp, _Gwaiting, _Grunnable)\n\trunqput(_g_.m.p.ptr(), gp, next) // 存放到本地可执行队列中\n\twakep()                          // 尝试去唤起p去执行\n\treleasem(mp)\n}\n```\n\n`ready`函数主要流程：\n* 获取`gp`的状态\n* 获取当前的`g`\n* 检测`gp`状态是不是`_Gwaiting`\n* 由`_Gwaiting`转换为`_Grunnable`状态\n* 放进当前`g`的`m`的`p`中的本地可执行队列中\n\n## 抢占切换\ngolang调度本质上是非抢占式的，golang利用标志位标志当前的goroutine是否可以被抢占，而触发时机是在栈扩容的时候。\ngolang中有个监控函数，监控着整个进程运行的相关数据，其中就包括检查某个goroutine是否占用CPU时间过长，从而进行标记抢占标记位。\n```go\nfunc sysmon() {\n    // ... 省略 ...\n    \n\tfor {\n\t\t// ... 省略 ...\n\t\t\n\t\t// 解绑在陷入系统调用中的p，和抢占长时间运行的g\n\t\tif retake(now) != 0 {\n\t\t\tidle = 0\n\t\t} else {\n\t\t\tidle++\n\t\t}\n\t\t\n\t\t// ... 省略 ...\n\t}\n}\n```\n\n\n### retake\n```go\nfunc retake(now int64) uint32 {\n\tn := 0\n\tlock(&allpLock)\n\tfor i := 0; i < len(allp); i++ {\n\t\t_p_ := allp[i]\n\t\tif _p_ == nil {\n\t\t\tcontinue\n\t\t}\n\t\tpd := &_p_.sysmontick // sysmon 信息记录\n\t\ts := _p_.status\n\t\tsysretake := false\n\t\tif s == _Prunning || s == _Psyscall {\n\t\t\t// 处于 _Prunning 或者 _Psyscall 状态时，如果上一次触发调度的时间已经过去了 10ms，\n\t\t\t// 我们就会通过 runtime.preemptone 抢占当前处理器\n\t\t\t// 如果G运行时间太长则抢占G\n\t\t\tt := int64(_p_.schedtick)\n\t\t\tif int64(pd.schedtick) != t {\n\t\t\t\tpd.schedtick = uint32(t)\n\t\t\t\tpd.schedwhen = now\n\t\t\t} else if pd.schedwhen+forcePreemptNS <= now {\n\t\t\t\tpreemptone(_p_)\n\t\t\t\t// 在_Psyscall时preemptone函数不会工作，因为m没有绑定p\n\t\t\t\tsysretake = true\n\t\t\t}\n\t\t}\n\t\tif s == _Psyscall {\n\t\t\t// 当处理器处于 _Psyscall 状态时\n\t\t\t// 当处理器的运行队列不为空或者不存在空闲处理器时并且当系统调用时间超过了 10ms 时\n\t\t\tt := int64(_p_.syscalltick)\n\t\t\tif !sysretake && int64(pd.syscalltick) != t {\n\t\t\t\tpd.syscalltick = uint32(t)\n\t\t\t\tpd.syscallwhen = now\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t\n\t\t\tif runqempty(_p_) && atomic.Load(&sched.nmspinning)+atomic.Load(&sched.npidle) > 0 && pd.syscallwhen+10*1000*1000 > now {\n\t\t\t\t// 如果_p_没有可执行的g，且有自旋的m或空闲的p，且系统调用时间没有超过10ms\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Drop allpLock so we can take sched.lock.\n\t\t\tunlock(&allpLock)\n\t\t\t\n\t\t\t// 将p的状态设置为_Pidle，计数器n加1，_p_的系统调用次数+1\n\t\t\tincidlelocked(-1)\n\t\t\tif atomic.Cas(&_p_.status, s, _Pidle) {\n\t\t\t\tn++\n\t\t\t\t_p_.syscalltick++\n\t\t\t\thandoffp(_p_) // 让 p 去找其他的事情干\n\t\t\t}\n\t\t\tincidlelocked(1)\n\t\t\tlock(&allpLock)\n\t\t}\n\t}\n\tunlock(&allpLock)\n\treturn uint32(n)\n}\n```\n\n`retake`函数主要流程：\n* 遍历所有的`p`\n* 如果`p`长时间没有调度则标记抢占标志位\n* 如果`p`在系统调用中，且超过阈值时间，则解绑`p`\n* 返回解绑`p`的个数\n\n### preemptone\n```go\nfunc preemptone(_p_ *p) bool {\n\tmp := _p_.m.ptr()\n\tif mp == nil || mp == getg().m {\n\t\t// 如果mp为空，或mp是当前运行的m\n\t\treturn false\n\t}\n\tgp := mp.curg\n\tif gp == nil || gp == mp.g0 {\n\t\t// gp 不能使 g0\n\t\treturn false\n\t}\n\n\tgp.preempt = true // 标志gp可以被抢占\n\n\tgp.stackguard0 = stackPreempt // 直接设置为栈顶，方便触发栈扩容\n\n\t// Request an async preemption of this P.\n\tif preemptMSupported && debug.asyncpreemptoff == 0 {\n\t\t_p_.preempt = true // 标记p快速调度\n\t\tpreemptM(mp)       // 向mp发送抢占信号\n\t}\n\n\treturn true\n}\n```\n\n### handoffp\n```go\nfunc handoffp(_p_ *p) {\n\t// 如果本地有可执行的G或全局可执行队列长度不为0，则直接开始执行\n\tif !runqempty(_p_) || sched.runqsize != 0 {\n\t\tstartm(_p_, false)\n\t\treturn\n\t}\n\t// 如果可以执行GC，则立即执行\n\tif gcBlackenEnabled != 0 && gcMarkWorkAvailable(_p_) {\n\t\tstartm(_p_, false)\n\t\treturn\n\t}\n\t// 如果没有自旋的m和空闲的p，并且增加自旋数成功，则让_p_绑定一个m进入自旋\n\tif atomic.Load(&sched.nmspinning)+atomic.Load(&sched.npidle) == 0 && atomic.Cas(&sched.nmspinning, 0, 1) {\n\t\tstartm(_p_, true)\n\t\treturn\n\t}\n\tlock(&sched.lock)\n\tif sched.gcwaiting != 0 { // 即将GC\n\t\t_p_.status = _Pgcstop\n\t\tsched.stopwait--\n\t\tif sched.stopwait == 0 {\n\t\t\tnotewakeup(&sched.stopnote)\n\t\t}\n\t\tunlock(&sched.lock)\n\t\treturn\n\t}\n\tif _p_.runSafePointFn != 0 && atomic.Cas(&_p_.runSafePointFn, 1, 0) {\n\t\tsched.safePointFn(_p_)\n\t\tsched.safePointWait--\n\t\tif sched.safePointWait == 0 {\n\t\t\tnotewakeup(&sched.safePointNote)\n\t\t}\n\t}\n\t// 此时如果全局队列有可执行的g，则执行\n\tif sched.runqsize != 0 {\n\t\tunlock(&sched.lock)\n\t\tstartm(_p_, false)\n\t\treturn\n\t}\n\t// 如果这是最后运行的P并且没有人正在轮询网络，则需要唤醒另一个M来轮询网络。\n\tif sched.npidle == uint32(gomaxprocs-1) && atomic.Load64(&sched.lastpoll) != 0 {\n\t\tunlock(&sched.lock)\n\t\tstartm(_p_, false)\n\t\treturn\n\t}\n\tif when := nobarrierWakeTime(_p_); when != 0 {\n\t\twakeNetPoller(when)\n\t}\n\t// 都没有则将_p_存放到空闲P列表中\n\tpidleput(_p_)\n\tunlock(&sched.lock)\n}\n```\n\n`retake`函数主要流程：\n* 如果`p`的本地可执行队列不为空，或全局可执行队列不为空，则绑定`m`去执行\n* 如果`p`可以执行GC工作，则绑定m去执行\n* 如果没有m在自旋且没有空闲的`p`，且成功设置自旋值，则获取一个`m`，进入自旋\n* 如果此时在检测全局可执行队列是否为空，有则绑定`m`去执行\n* 如果是最后一个正在运行的`p`，则绑定`m`去轮询网络\n* 都没有则将`p`存放进空闲`p`列表\n\n### newstack\n```go\nfunc newstack() {\n\tthisg := getg() // 当前执行的g\n\t\n\tgp := thisg.m.curg // m绑定的g\n\n\t// 判断是否抢占触发的栈扩张\n\tpreempt := atomic.Loaduintptr(&gp.stackguard0) == stackPreempt\n\n    // ... 省略 ...\n\n\tif preempt {\n\t\t// Act like goroutine called runtime.Gosched.\n\t\tgopreempt_m(gp) // never return\n\t}\n    // ... 省略 ...\n}\n```\n\n```go\nfunc gopreempt_m(gp *g) {\n\tif trace.enabled {\n\t\ttraceGoPreempt()\n\t}\n\tgoschedImpl(gp)\n}\n```\n\n`goschedImpl`函数就是上述Gosched函数的主要执行实体了。\n\n如果检测到是抢占，则将m绑定的g放入全局可执行队列中。\n\n\n## 系统调用切换\ngolang提供了系统调用接口：\n```go\nfunc Syscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno)\nfunc RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno)\n```\n\n更多参数可以调用Syscall6或Syscall9。\n\n### Syscall\n```asm\nTEXT\t·Syscall(SB),NOSPLIT,$0-56\n\tCALL\truntime·entersyscall(SB)\n\tMOVQ\ta1+8(FP), DI\n\tMOVQ\ta2+16(FP), SI\n\tMOVQ\ta3+24(FP), DX\n\tMOVQ\ttrap+0(FP), AX\t// syscall entry\n\tADDQ\t$0x2000000, AX\n\tSYSCALL\n\tJCC\tok\n\tMOVQ\t$-1, r1+32(FP)\n\tMOVQ\t$0, r2+40(FP)\n\tMOVQ\tAX, err+48(FP)\n\tCALL\truntime·exitsyscall(SB)\n\tRET\nok:\n\tMOVQ\tAX, r1+32(FP)\n\tMOVQ\tDX, r2+40(FP)\n\tMOVQ\t$0, err+48(FP)\n\tCALL\truntime·exitsyscall(SB)\n\tRET\n```\n\n`Syscall`函数主要流程：\n* 调用`runtime.entersyscall`\n* 将参数存至寄存器\n* 执行系统调用\n* 将返回值压栈\n* 调用`runtime.exitsyscall`\n\n#### entersyscall\n```go\nfunc entersyscall() {\n   reentersyscall(getcallerpc(), getcallersp())\n}\n```\n\n```go\nfunc reentersyscall(pc, sp uintptr) {\n\t_g_ := getg()\n\t_g_.m.locks++\n\n\t_g_.stackguard0 = stackPreempt // 等待被抢占\n\t_g_.throwsplit = true\n\n\t// Leave SP around for GC and traceback.\n\tsave(pc, sp) // 保存现场\n\t_g_.syscallsp = sp\n\t_g_.syscallpc = pc\n\tcasgstatus(_g_, _Grunning, _Gsyscall) // 切换状态\n\tif _g_.syscallsp < _g_.stack.lo || _g_.stack.hi < _g_.syscallsp {\n\t\tsystemstack(func() {\n\t\t\tprint(\"entersyscall inconsistent \", hex(_g_.syscallsp), \" [\", hex(_g_.stack.lo), \",\", hex(_g_.stack.hi), \"]\\n\")\n\t\t\tthrow(\"entersyscall\")\n\t\t})\n\t}\n\n\tif trace.enabled {\n\t\tsystemstack(traceGoSysCall)\n\t\t// systemstack itself clobbers g.sched.{pc,sp} and we might\n\t\t// need them later when the G is genuinely blocked in a\n\t\t// syscall\n\t\tsave(pc, sp)\n\t}\n\n\tif atomic.Load(&sched.sysmonwait) != 0 {\n\t\tsystemstack(entersyscall_sysmon)\n\t\tsave(pc, sp)\n\t}\n\n\tif _g_.m.p.ptr().runSafePointFn != 0 {\n\t\t// runSafePointFn may stack split if run on this stack\n\t\tsystemstack(runSafePointFn)\n\t\tsave(pc, sp)\n\t}\n\n\t_g_.m.syscalltick = _g_.m.p.ptr().syscalltick\n\t_g_.sysblocktraced = true\n\tpp := _g_.m.p.ptr()\n\tpp.m = 0\n\t_g_.m.oldp.set(pp)\n\t_g_.m.p = 0\n\tatomic.Store(&pp.status, _Psyscall) // 切换p的状态\n\tif sched.gcwaiting != 0 {\n\t\tsystemstack(entersyscall_gcwait)\n\t\tsave(pc, sp)\n\t}\n\n\t_g_.m.locks--\n}\n```\n\n#### exitsyscall\n```go\nfunc exitsyscall() {\n\t_g_ := getg()\n\n\t_g_.m.locks++ \n\n\toldp := _g_.m.oldp.ptr()\n\t_g_.m.oldp = 0\n\tif exitsyscallfast(oldp) { // 尝试获取系统调用前绑定的p\n\t\t_g_.m.p.ptr().syscalltick++\n\t\tcasgstatus(_g_, _Gsyscall, _Grunning)\n\t\t_g_.syscallsp = 0\n\t\t_g_.m.locks--\n\t\tif _g_.preempt {\n\t\t\t// 如果抢占，就设置stackguard0为stackPreempt\n\t\t\t_g_.stackguard0 = stackPreempt\n\t\t} else {\n\t\t\t// 否则恢复真实栈帧\n\t\t\t_g_.stackguard0 = _g_.stack.lo + _StackGuard\n\t\t}\n\t\t_g_.throwsplit = false\n\n\t\tif sched.disable.user && !schedEnabled(_g_) {\n\t\t\t// Scheduling of this goroutine is disabled.\n\t\t\tGosched() // 开始调度\n\t\t}\n\n\t\treturn\n\t}\n\n\t// 没有p被绑定的情况\n\t_g_.sysexitticks = 0\n\t_g_.m.locks--\n\n\t// Call the scheduler.\n\tmcall(exitsyscall0)\n\n\t_g_.syscallsp = 0\n\t_g_.m.p.ptr().syscalltick++\n\t_g_.throwsplit = false\n}\n```\n\n`exitsyscall`函数主要流程：\n* 获取系统调用前绑定的`oldp`\n* 尝试获取`oldp`或从空闲列表获取`p`\n* 如果成功获取`p`，改变相关设置，开始下一轮调度\n* 如果没有获取，则调用`exitsyscall0`\n\n```go\nfunc exitsyscall0(gp *g) {\n\t_g_ := getg()\n\n\tcasgstatus(gp, _Gsyscall, _Grunnable)\n\tdropg()\n\tlock(&sched.lock)\n\tvar _p_ *p\n\tif schedEnabled(_g_) { // 如果可以调度_g_\n\t\t_p_ = pidleget() // 从p空闲列表中获取p\n\t}\n\tif _p_ == nil {\n\t\tglobrunqput(gp) // 没有可用的p，就将gp存放于全局可执行列表中\n\t} else if atomic.Load(&sched.sysmonwait) != 0 {\n\t\tatomic.Store(&sched.sysmonwait, 0)\n\t\tnotewakeup(&sched.sysmonnote)\n\t}\n\tunlock(&sched.lock)\n\tif _p_ != nil { // 如果有可用的p\n\t\tacquirep(_p_) // 直接绑定当前的m\n\t\texecute(gp, false) // 执行gp\n\t}\n\tif _g_.m.lockedg != 0 { // 如果m有锁定的g\n\t\t// Wait until another thread schedules gp and so m again.\n\t\tstoplockedm()   // 释放p，休眠m，会阻塞\n\t\texecute(gp, false) // 执行gp\n\t}\n\tstopm() // 将m休眠，并存于m空闲列表中，会阻塞\n\tschedule() // 下一次调度\n}\n```\n\n`exitsyscall0`函数主要流程：\n* 切换`gp`状态为`_Grunnable`\n* 解绑`g`和`m`\n* 尝试获取一个空闲的`_p_`\n* 如果没有获取到就把`gp`放到全局可执行列表中\n* 如果获取到了，就直接绑定当前的`m`，执行`gp`\n* 如果有`m`有锁定的`g`，释放p，休眠m，等待被唤醒\n* 否则`m`将放置与全局`m`空闲列表中，等待下一次调度\n\nexitsyscall0函数如果没有p则会将m休眠\n\n### RawSyscall\n```asm\nTEXT ·RawSyscall(SB),NOSPLIT,$0-56\n\tMOVQ\ta1+8(FP), DI\n\tMOVQ\ta2+16(FP), SI\n\tMOVQ\ta3+24(FP), DX\n\tMOVQ\ttrap+0(FP), AX\t// syscall entry\n\tADDQ\t$0x2000000, AX\n\tSYSCALL\n\tJCC\tok1\n\tMOVQ\t$-1, r1+32(FP)\n\tMOVQ\t$0, r2+40(FP)\n\tMOVQ\tAX, err+48(FP)\n\tRET\nok1:\n\tMOVQ\tAX, r1+32(FP)\n\tMOVQ\tDX, r2+40(FP)\n\tMOVQ\t$0, err+48(FP)\n\tRET\n```\n\n`RawSyscall`函数主要流程：\n* 将参数存至寄存器\n* 执行系统调用\n* 将返回值压栈\n\n`RawSyscall`函数并没有执行`runtime.entersyscall`和`runtime.exitsyscall`函数，由于没有执行相关操作导致golang无法准确的调度，可能会导致长时间系统调用，其他的goroutine无法得到执行。\n\n\n\n# 辅助函数\n## getg\n获取当前的`g`，由于是编译器填充的，所以没有源码。\n一般都是从TLS寄存器获取的。\n## mcall\n```asm\nTEXT runtime·mcall(SB), NOSPLIT, $0-8\n\tMOVQ\tfn+0(FP), DI\n\n\tget_tls(CX)\n\tMOVQ\tg(CX), AX\t// save state in g->sched\n\tMOVQ\t0(SP), BX\t// caller's PC\n\tMOVQ\tBX, (g_sched+gobuf_pc)(AX)\n\tLEAQ\tfn+0(FP), BX\t// caller's SP\n\tMOVQ\tBX, (g_sched+gobuf_sp)(AX)\n\tMOVQ\tAX, (g_sched+gobuf_g)(AX)\n\tMOVQ\tBP, (g_sched+gobuf_bp)(AX)\n\n\t// switch to m->g0 & its stack, call fn\n\tMOVQ\tg(CX), BX\n\tMOVQ\tg_m(BX), BX\n\tMOVQ\tm_g0(BX), SI\n\tCMPQ\tSI, AX\t// if g == m->g0 call badmcall\n\tJNE\t3(PC)\n\tMOVQ\t$runtime·badmcall(SB), AX\n\tJMP\tAX\n\tMOVQ\tSI, g(CX)\t// g = m->g0\n\tMOVQ\t(g_sched+gobuf_sp)(SI), SP\t// sp = m->g0->sched.sp\n\tPUSHQ\tAX\n\tMOVQ\tDI, DX\n\tMOVQ\t0(DI), DI\n\tCALL\tDI // 执行fn，不能返回\n\tPOPQ\tAX\n\tMOVQ\t$runtime·badmcall2(SB), AX\n\tJMP\tAX\n\tRET\n```\n\n`mcall`函数切换到`m`的`g0`调用`fn(g)`，`fn`是不能返回的。\n\n## systemstack\n```asm\nTEXT runtime·systemstack(SB), NOSPLIT, $0-8\n\tMOVQ\tfn+0(FP), DI\t// DI = fn\n\tget_tls(CX)\n\tMOVQ\tg(CX), AX\t// AX = g\n\tMOVQ\tg_m(AX), BX\t// BX = m\n\n\tCMPQ\tAX, m_gsignal(BX) // g == m.gsignal\n\tJEQ\tnoswitch\n\n\tMOVQ\tm_g0(BX), DX\t// DX = g0\n\tCMPQ\tAX, DX // g == g0\n\tJEQ\tnoswitch\n\n\tCMPQ\tAX, m_curg(BX) // g == m.curg\n\tJNE\tbad\n\n\t// 保存当前g的栈信息\n\tMOVQ\t$runtime·systemstack_switch(SB), SI\n\tMOVQ\tSI, (g_sched+gobuf_pc)(AX)\n\tMOVQ\tSP, (g_sched+gobuf_sp)(AX)\n\tMOVQ\tAX, (g_sched+gobuf_g)(AX)\n\tMOVQ\tBP, (g_sched+gobuf_bp)(AX)\n\n\t// 切换到g0\n\tMOVQ\tDX, g(CX)\n\tMOVQ\t(g_sched+gobuf_sp)(DX), BX\n\t// make it look like mstart called systemstack on g0, to stop traceback\n\tSUBQ\t$8, BX\n\tMOVQ\t$runtime·mstart(SB), DX\n\tMOVQ\tDX, 0(BX)\n\tMOVQ\tBX, SP\n\n\t// call target function\n\tMOVQ\tDI, DX\n\tMOVQ\t0(DI), DI\n\tCALL\tDI // 执行目标函数\n\n\t// 恢复原有g\n\tget_tls(CX)\n\tMOVQ\tg(CX), AX\n\tMOVQ\tg_m(AX), BX\n\tMOVQ\tm_curg(BX), AX\n\tMOVQ\tAX, g(CX)\n\tMOVQ\t(g_sched+gobuf_sp)(AX), SP\n\tMOVQ\t$0, (g_sched+gobuf_sp)(AX)\n\tRET\n```\n\nsystemstack函数主要流程：\n* 检测相关参数\n* 保存g现场\n* 切换到g0，并执行fn(g)\n* 恢复原有g\n\n## acquirem\n```go\nfunc acquirem() *m {\n\t_g_ := getg()\n\t_g_.m.locks++\n\treturn _g_.m\n}\n```\n`acquirem`函数主要是增加`locks`引用计数，并返回当前的m。主要是防止GC回收m。\n\n## releasem\n```go\nfunc releasem(mp *m) {\n\t_g_ := getg()\n\tmp.locks--\n\tif mp.locks == 0 && _g_.preempt {\n\t\t_g_.stackguard0 = stackPreempt\n\t}\n}\n```\n\n`releasem`函数主要是减少`locks`引用计数，并判断是否需要`g`被抢占\n\n## acquirep\n```go\nfunc acquirep(_p_ *p) {\n\twirep(_p_)\n}\n```\n\n```go\nfunc wirep(_p_ *p) {\n\t_g_ := getg()\n\t_g_.m.p.set(_p_)\n\t_p_.m.set(_g_.m)\n\t_p_.status = _Prunning\n}\n```\n\n`acquirep`函数主要流程：\n* 绑定`p`和`m`\n* 将`p`的状态置为`_Prunning`\n\n## releasep\n```go\nfunc releasep() *p {\n\t_g_ := getg()\n\t_p_ := _g_.m.p.ptr()\n\t_g_.m.p = 0\n\t_p_.m = 0\n\t_p_.status = _Pidle\n\treturn _p_\n}\n```\n\n`releasep`函数主要流程：\n* 解绑`m`和`p`\n* 将`p`的状态置为`_Pidle`\n* 返回`p`\n\n# 疑问\n## p的本地可执行列表无锁，其他p怎么偷取可执行列表\n通过原子cas的方式提交列表头尾位置，如果失败则重新偷取。\n\n## g进入_Gwaiting状态后去哪里了\n\n* 如果`g`是被抢占了，则将g的状态改为`_Grunnable`，放入全局可执行队列中\n* 如果是主动切换，调用`gopark`的调用者需要维护`sudog`列表（`sudog`用于保存调用`gopark`的`g`），接收已完成的`goroutine`，然后调用`goready`，将他们状态置为`_Grunnable`，存入本地的可执行队列中。\n\n## m进入自旋，在干嘛\n`m`自旋，即`m`阻塞于`schedule()`的`findrunnable()`，`m`会一直尝试获取可执行的`g`去工作。\n\n## g0栈复用\n`g0`的栈在golang中不同系统采用不同的初始化方式。\n```go\nif iscgo || GOOS == \"solaris\" || GOOS == \"illumos\" || GOOS == \"windows\" || GOOS == \"plan9\" || GOOS == \"darwin\" || GOOS == \"ios\" {\n\t\t// 如果是上面的情况 g0栈是用的 pthread_create 线程栈\n\t\tmp.g0 = malg(-1)\n\t} else {\n\t\tmp.g0 = malg(8192 * sys.StackGuardMultiplier)\n\t}\n```\n\n\n每次切到`g0`栈执行指令时，`g0->sched.sp`在初始化后没有修改该过，所以每次切换到g0时栈起始值相同，每次调用`mcall`都会从指定栈位置开始执行相关操作，以此来复用g0栈。\n\n# 参考文献\n* [详尽干货！从源码角度看 Golang 的调度](https://mp.weixin.qq.com/s?__biz=MzU1ODEzNjI2NA==&mid=2247487178&amp;idx=2&amp;sn=121f293c1502b10e7569a0e7216de79e&source=41#wechat_redirect)\n* [深入golang runtime的调度](https://zboya.github.io/post/go_scheduler/)","source":"_posts/golang-协程调度管理源码分析.md","raw":"---\nauthor: djaigo\ntitle: golang 调度过程源码分析\nimg: 'https://img-1251474779.cos.ap-beijing.myqcloud.com/golang.png'\ncategories:\n  - golang\ntags:\n  - runtime\ndate: 2020-10-12 16:15:17\n---\n\ngolang 版本：go version go1.15.2 darwin/amd64\n\n根据启动函数来分析golang MPG的生存周期，忽略cgo相关代码。\n\n# MPG\nMPG是golang调度的重要对象：\n* M，表示一个内核线程，是执行用户代码的实际场所\n* P，表示一个处理器，管理M需要运行G的相关资源，如内存分配，G的可执行列表，G的空闲列表等\n* G，表示一个goroutine，调度基本单元，维护goroutine内部资源，如栈信息，defer列表等\n\n# 启动\n启动汇编函数\n```asm\n// runtime/asm_amd64.s\n\nTEXT runtime·rt0_go(SB),NOSPLIT,$0\n    // ... 省略 ...\n\n\t// create istack out of the given (operating system) stack.\n\t// _cgo_init may update stackguard.\n\t// 给 runtime.g0 创建栈\n\tMOVQ\t$runtime·g0(SB), DI\n\tLEAQ\t(-64*1024+104)(SP), BX\n\tMOVQ\tBX, g_stackguard0(DI)\n\tMOVQ\tBX, g_stackguard1(DI)\n\tMOVQ\tBX, (g_stack+stack_lo)(DI)\n\tMOVQ\tSP, (g_stack+stack_hi)(DI)\n\n    // ... 省略 ...\n\n\t// set the per-goroutine and per-mach \"registers\"\n\tget_tls(BX)\n\tLEAQ\truntime·g0(SB), CX\n\tMOVQ\tCX, g(BX)\n\tLEAQ\truntime·m0(SB), AX\n\n\t// save m->g0 = g0\n\t// 绑定 m0 和 g0\n\tMOVQ\tCX, m_g0(AX)\n\t// save m0 to g0->m\n\tMOVQ\tAX, g_m(CX)\n\n\tCLD\t\t\t\t// convention is D is always left cleared\n\tCALL\truntime·check(SB)\n\n\tMOVL\t16(SP), AX\t\t// copy argc\n\tMOVL\tAX, 0(SP)\n\tMOVQ\t24(SP), AX\t\t// copy argv\n\tMOVQ\tAX, 8(SP)\n\tCALL\truntime·args(SB)       // 解析命令行参数\n\tCALL\truntime·osinit(SB)     // 获取CPU核数\n\tCALL\truntime·schedinit(SB)  // 初始化调度\n\n\t// create a new goroutine to start program\n\tMOVQ\t$runtime·mainPC(SB), AX\t\t// entry\n\tPUSHQ\tAX\n\tPUSHQ\t$0\t\t\t// arg size\n\tCALL\truntime·newproc(SB)// 执行runtime.main\n\tPOPQ\tAX\n\tPOPQ\tAX\n\n\t// start this M\n\tCALL\truntime·mstart(SB) // 启动m0\n\n\tCALL\truntime·abort(SB)\t// mstart should never return\n\tRET\n```\n\n`rt0_go`函数主要流程：\n* 初始化`g0`、`m0`\n* `g0`和`m0`互相绑定\n* 初始化相关数据，初始化指定个数的`p`\n* 创建新`g`绑定`runtime.main`函数，加入`p`的可执行列表中\n* 启动`m0`开始循环调度。\n\n## schedinit\n```go\n// runtime/proc.go\n\nfunc schedinit() {\n\t// ... 省略 ...\n\t\n\t_g_ := getg() // 获取当前绑定的g\n\t\n\t// 限制M的数量\n\tsched.maxmcount = 10000\n\n\t// ... 省略 ...\n\n    // 创建 p\n\tlock(&sched.lock)\n\tsched.lastpoll = uint64(nanotime())\n\tprocs := ncpu\n\tif n, ok := atoi32(gogetenv(\"GOMAXPROCS\")); ok && n > 0 {\n\t\tprocs = n\n\t}\n\tif procresize(procs) != nil {\n\t\tthrow(\"unknown runnable goroutine during bootstrap\")\n\t}\n\tunlock(&sched.lock)\n}\n```\n\n`schedinit`函数主要流程：\n* 初始化全局调度相关值\n* 限制`m`的最多个数\n* 初始化指定个数的`p`\n\n## newproc\n```go\n// runtime/proc.go\n\nfunc newproc(siz int32, fn *funcval) {\n\targp := add(unsafe.Pointer(&fn), sys.PtrSize)\n\tgp := getg()\n\tpc := getcallerpc()\n\tsystemstack(func() {\n\t\tnewg := newproc1(fn, argp, siz, gp, pc)\n\n\t\t_p_ := getg().m.p.ptr()\n\t\trunqput(_p_, newg, true)\n\n\t\tif mainStarted { // mainStarted 是在 runtime.main 中设置为 true \n\t\t\twakep() // 尝试找一个p绑定m\n\t\t}\n\t})\n}\n```\n\n`newproc`函数主要流程：\n* 创建栈大小为`siz`的新`g`，并关联`fn`\n* 将新`g`存放于`_p_`的可执行队列中\n* 此时刚初始化，并没有执行`runtime.main`所以不会执行`wakep`\n\n```go\n// runtime/proc.go\n\nfunc newproc1(fn *funcval, argp unsafe.Pointer, narg int32, callergp *g, callerpc uintptr) *g {\n\t_g_ := getg()\n\n\tacquirem() // disable preemption because it can be holding p in a local var\n\tsiz := narg\n\tsiz = (siz + 7) &^ 7\n\t\n\t_p_ := _g_.m.p.ptr() // 获取 p\n\tnewg := gfget(_p_)   // 从 p 的空闲 g 列表中获取 g\n\tif newg == nil {     // 没有空闲的 g\n\t\tnewg = malg(_StackMin)           // 创建一个拥有最小栈的 g\n\t\tcasgstatus(newg, _Gidle, _Gdead) // 转换状态\n\t\tallgadd(newg)                    // 向全局 g 列表中添加 g\n\t}\n\n\t// ... 省略 ...\n\n    // 填充 g\n\tmemclrNoHeapPointers(unsafe.Pointer(&newg.sched), unsafe.Sizeof(newg.sched))\n\tnewg.sched.sp = sp\n\tnewg.stktopsp = sp\n\tnewg.sched.pc = funcPC(goexit) + sys.PCQuantum // 当g执行完后的处理函数\n\tnewg.sched.g = guintptr(unsafe.Pointer(newg))\n\tgostartcallfn(&newg.sched, fn)\n\tnewg.gopc = callerpc\n\tnewg.ancestors = saveAncestors(callergp)\n\tnewg.startpc = fn.fn\n\tif _g_.m.curg != nil {\n\t\tnewg.labels = _g_.m.curg.labels\n\t}\n\tif isSystemGoroutine(newg, false) {\n\t\tatomic.Xadd(&sched.ngsys, +1)\n\t}\n\tcasgstatus(newg, _Gdead, _Grunnable) // 切换成可执行状态\n\n    // 分配goid，如果没有则向p批量获取\n\tif _p_.goidcache == _p_.goidcacheend {\n\t\t_p_.goidcache = atomic.Xadd64(&sched.goidgen, _GoidCacheBatch)\n\t\t_p_.goidcache -= _GoidCacheBatch - 1\n\t\t_p_.goidcacheend = _p_.goidcache + _GoidCacheBatch\n\t}\n\tnewg.goid = int64(_p_.goidcache)\n\t_p_.goidcache++\n\n\treleasem(_g_.m)\n\n\treturn newg\n}\n```\n\n`newproc1`函数主要流程：\n* 从空闲`g`列表中获取或新建`g`，将`g`的信息填充\n\n## mstart\n```go\n// runtime/proc.go\n\nfunc mstart() {\n\t_g_ := getg()\n\n    // 设置 _g_ 的栈信息\n\tosStack := _g_.stack.lo == 0\n\tif osStack {\n\t\tsize := _g_.stack.hi\n\t\tif size == 0 {\n\t\t\tsize = 8192 * sys.StackGuardMultiplier\n\t\t}\n\t\t_g_.stack.hi = uintptr(noescape(unsafe.Pointer(&size)))\n\t\t_g_.stack.lo = _g_.stack.hi - size + 1024\n\t}\n\t_g_.stackguard0 = _g_.stack.lo + _StackGuard\n\t_g_.stackguard1 = _g_.stackguard0\n\t\n\tmstart1() // 不会返回\n}\n```\n\n`mstart`函数主要流程：\n* 填充`g`的栈信息\n* 让`m`开始执行`g`上的代码\n\n```go\n// runtime/proc.go\n\nfunc mstart1() {\n\t_g_ := getg()\n\n\t// ... 省略 ...\n\t\n\tif _g_.m == &m0 {\n\t\tmstartm0() // 启动 m0 初始化信号处理\n\t}\n\n\tif fn := _g_.m.mstartfn; fn != nil {\n\t\tfn() // 执行m绑定的启动时调用的函数\n\t}\n\n\tif _g_.m != &m0 {\n\t\tacquirep(_g_.m.nextp.ptr())\n\t\t_g_.m.nextp = 0\n\t}\n\tschedule() // 开始调度\n}\n```\n\n`mstart1`函数主要流程：\n* 如果是`m0`，则初始化信号处理\n* 如果有`mstartfn`，则执行\n* 如果不是`m0`，则绑定`p`\n* 调用`schedule`启动golang进程的调度。\n\n## runtime.main\n```go\n// runtime/proc.go\n\nfunc main() {\n\tg := getg()\n\n    // 确认栈的最大值\n\tif sys.PtrSize == 8 {\n\t\tmaxstacksize = 1000000000\n\t} else {\n\t\tmaxstacksize = 250000000\n\t}\n\n\t// Allow newproc to start new Ms.\n\tmainStarted = true // 标志 newproc 时可以启动 m\n\n\tif GOARCH != \"wasm\" { // no threads on wasm yet, so no sysmon\n\t\tsystemstack(func() {\n\t\t\tnewm(sysmon, nil, -1) // 新建 m 去执行 sysmon\n\t\t})\n\t}\n\n\tlockOSThread()\n\t\n\tdoInit(&runtime_inittask) // 执行runtime包中的init函数\n\n\t// Record when the world started.\n\truntimeInitTime = nanotime()\n\n\tgcenable() // 开启GC\n\n\tmain_init_done = make(chan bool)\n\tdoInit(&main_inittask) // 执行main包中的init函数\n\tclose(main_init_done)\n\t\n\tunlockOSThread()\n\n\tfn := main_main // fn 指向main包的main函数\n\tfn() // 执行main包的main函数\n\n\texit(0)\n}\n```\n\nruntime.main函数主要功能：\n* 设置了栈的最大值\n* 创建m去执行sysmon\n* 调用runtime包的init函数\n* 启动GC\n* 执行main包的init函数\n* 退出\n\n## startm\n除了m0是汇编初始化的，其他的m都是由startm创建的。\n```go\nfunc startm(_p_ *p, spinning bool) {\n\tlock(&sched.lock)\n\tif _p_ == nil { // _p_ 为空\n\t\t_p_ = pidleget() // 从p空闲列表中获取一个\n\t\tif _p_ == nil {  // 获取失败\n\t\t\tunlock(&sched.lock)\n\t\t\tif spinning {\n\t\t\t\t// 如果是自旋状态，调用方增加了nmspinning，但是没有空闲的P，因此可以取消增量并放弃\n\t\t\t\tif int32(atomic.Xadd(&sched.nmspinning, -1)) < 0 {\n\t\t\t\t\tthrow(\"startm: negative nmspinning\")\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n\tmp := mget() // 从m空闲列表中获取m\n\tif mp == nil { // 如果空闲列表没有\n\t\tid := mReserveID() // 获取 m id\n\t\tunlock(&sched.lock)\n\n\t\tvar fn func()\n\t\tif spinning {\n\t\t\tfn = mspinning // 设置 m 的自旋状态函数\n\t\t}\n\t\tnewm(fn, _p_, id) // 创建一个m对象\n\t\treturn\n\t}\n\tunlock(&sched.lock)\n\tif mp.spinning {\n\t\tthrow(\"startm: m is spinning\")\n\t}\n\tif mp.nextp != 0 {\n\t\tthrow(\"startm: m has p\")\n\t}\n\tif spinning && !runqempty(_p_) {\n\t\tthrow(\"startm: p has runnable gs\")\n\t}\n\t// 由调用者确定是否自旋，并将m.nextp设置为p\n\tmp.spinning = spinning\n\tmp.nextp.set(_p_)\n\tnotewakeup(&mp.park)\n}\n```\n\n`startm`函数主要流程：\n* 获取一个`p`，失败则返回\n  * 获取一个`m`，如果失败就创建`m`并返回\n* `m`暂存`p`\n\n### newm\n\n```go\nfunc newm(fn func(), _p_ *p, id int64) {\n\tmp := allocm(_p_, fn, id) // 创建新m\n\tmp.nextp.set(_p_) // 暂存p\n\tmp.sigmask = initSigmask // 信号掩码\n\tnewm1(mp) // 绑定操作系统线程\n}\n```\n\n```go\nfunc allocm(_p_ *p, fn func(), id int64) *m {\n\t_g_ := getg()\n\tacquirem() // disable GC because it can be called from sysmon\n\tif _g_.m.p == 0 {\n\t\tacquirep(_p_) // 临时绑定p\n\t}\n\n    // 清理可以安全删除的m的g0栈信息\n\tif sched.freem != nil { \n\t\tlock(&sched.lock)\n\t\tvar newList *m\n\t\tfor freem := sched.freem; freem != nil; {\n\t\t\tif freem.freeWait != 0 {\n\t\t\t\tnext := freem.freelink\n\t\t\t\tfreem.freelink = newList\n\t\t\t\tnewList = freem\n\t\t\t\tfreem = next\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tstackfree(freem.g0.stack) // 清空freem.g0的栈信息\n\t\t\tfreem = freem.freelink\n\t\t}\n\t\tsched.freem = newList // 更新已被释放的m列表\n\t\tunlock(&sched.lock)\n\t}\n\n\tmp := new(m)\n\tmp.mstartfn = fn // 绑定m启动函数\n\tmcommoninit(mp, id) // 绑定mp的id\n\n\t// 初始化g0栈信息\n\tif iscgo || GOOS == \"solaris\" || GOOS == \"illumos\" || GOOS == \"windows\" || GOOS == \"plan9\" || GOOS == \"darwin\" || GOOS == \"ios\" {\n\t\tmp.g0 = malg(-1)\n\t} else {\n\t\tmp.g0 = malg(8192 * sys.StackGuardMultiplier)\n\t}\n\tmp.g0.m = mp\n\n\tif _p_ == _g_.m.p.ptr() {\n\t\treleasep() // 解绑p\n\t}\n\treleasem(_g_.m)\n\n\treturn mp\n}\n```\n\n```go\nfunc newm1(mp *m) {\n\texecLock.rlock() // Prevent process clone.\n\tnewosproc(mp) // 绑定操作系统线程\n\texecLock.runlock()\n}\n```\n\n`newm`函数主要流程：\n* 释放可以清理的`m`的`g0`栈空间\n* 新建`m`，绑定`id`和启动函数，申请`g0`栈空间\n* `m`暂存当前`p`\n* 创建与`m`对应的操作系统线程\n\n\n## netpoll\n`netpoll`可以让调度器从就绪的网络事件中获取可执行的goroutine。\n由于golang对每个系统的netpoll做了条件编译，这里就拿linux的实现来说明。\n```go\nfunc netpoll(delay int64) gList {\n\tvar events [128]epollevent\nretry:\n\tn := epollwait(epfd, &events[0], int32(len(events)), waitms)\n\t\n\tvar toRun gList\n\tfor i := int32(0); i < n; i++ {\n\t\tev := &events[i]\n\t\tvar mode int32\n\t\tif ev.events&(_EPOLLIN|_EPOLLRDHUP|_EPOLLHUP|_EPOLLERR) != 0 {\n\t\t\tmode += 'r'\n\t\t}\n\t\tif ev.events&(_EPOLLOUT|_EPOLLHUP|_EPOLLERR) != 0 {\n\t\t\tmode += 'w'\n\t\t}\n\t\tif mode != 0 {\n\t\t\tpd := *(**pollDesc)(unsafe.Pointer(&ev.data))\n\t\t\tpd.everr = false\n\t\t\tif ev.events == _EPOLLERR {\n\t\t\t\tpd.everr = true\n\t\t\t}\n\t\t\tnetpollready(&toRun, pd, mode) // 将符合的g填充进toRun中\n\t\t}\n\t}\n\treturn toRun\n}\n```\n\n`netpoll`函数主要流程：\n* 调用`epollwait`获取就绪的文件描述符\n* 将`pd`中的就绪`g`追加进`toRun`里面\n* 返回`toRun`\n\n# 调度\n```go\n// runtime/proc.go\n\nfunc schedule() {\n\t_g_ := getg()\n\n\t// 如果_g_绑定的m有锁定的g，则抛弃_g_，转而执行锁定的g\n\tif _g_.m.lockedg != 0 {\n\t\tstoplockedm()\n\t\texecute(_g_.m.lockedg.ptr(), false) // Never returns.\n\t}\n\ntop:\n\tpp := _g_.m.p.ptr()\n\tpp.preempt = false\n\n\t// 如果准备GC，则休眠当前m，直到被唤醒\n\tif sched.gcwaiting != 0 {\n\t\tgcstopm()\n\t\tgoto top\n\t}\n\tif pp.runSafePointFn != 0 {\n\t\trunSafePointFn()\n\t}\n\n\tcheckTimers(pp, 0)\n\n\tvar gp *g\n\tvar inheritTime bool\n\n\ttryWakeP := false\n\tif trace.enabled || trace.shutdown {\n\t\tgp = traceReader()\n\t\tif gp != nil {\n\t\t\tcasgstatus(gp, _Gwaiting, _Grunnable)\n\t\t\ttraceGoUnpark(gp, 0)\n\t\t\ttryWakeP = true\n\t\t}\n\t}\n\tif gp == nil && gcBlackenEnabled != 0 {\n\t\t// 找GCWorker\n\t\tgp = gcController.findRunnableGCWorker(_g_.m.p.ptr())\n\t\ttryWakeP = tryWakeP || gp != nil\n\t}\n\tif gp == nil {\n\t\t// 为了让全局可执行队列的g能够运行，这里每操作一定次数就从全局队列中获取\n\t\tif _g_.m.p.ptr().schedtick%61 == 0 && sched.runqsize > 0 {\n\t\t\tlock(&sched.lock)\n\t\t\tgp = globrunqget(_g_.m.p.ptr(), 1)\n\t\t\tunlock(&sched.lock)\n\t\t}\n\t}\n\tif gp == nil {\n\t\t// 从本地可执行队列中获取\n\t\tgp, inheritTime = runqget(_g_.m.p.ptr())\n\t}\n\tif gp == nil {\n\t\t// 从其他地方找一个g来执行，如果没有则阻塞在这里\n\t\tgp, inheritTime = findrunnable() // blocks until work is available\n\t}\n\n\t// This thread is going to run a goroutine and is not spinning anymore,\n\t// so if it was marked as spinning we need to reset it now and potentially\n\t// start a new spinning M.\n\tif _g_.m.spinning {\n\t\t// 如果当前m正在自旋，则重置自旋状态\n\t\tresetspinning()\n\t}\n\t\n\tif tryWakeP {\n\t\twakep() // GCworker 或 tracereader 需要唤醒p\n\t}\n\tif gp.lockedm != 0 {\n\t\t// m将自己的p让给gp锁定的m，自己阻塞等待新p\n\t\tstartlockedm(gp)\n\t\tgoto top\n\t}\n\n\texecute(gp, inheritTime) // 执行gp\n}\n```\n\n`schedule`函数主要流程：\n* 如果`g`有绑定的`m`，则直接让绑定`m`执行`g`\n* 如果要GC，则休眠当前`m`，等待唤醒\n* 从`traceReader`、`GCWorker`、`globrunqget`、`runqget`、`findrunnable`函数中获取一个可执行gp\n* 重置自旋状态\n* 如果需要唤醒`p`，则尝试唤醒`p`\n* 如果获取的`gp`有锁定的`m`，则让出自己的`p`给`gp`锁定的`m`，自己则阻塞等待被唤醒\n* 执行`gp`\n\n## findrunnable\n```go\n// runtime/proc.go\n\nfunc findrunnable() (gp *g, inheritTime bool) {\n\t_g_ := getg()\n\ntop:\n\t_p_ := _g_.m.p.ptr()\n\tif sched.gcwaiting != 0 {\n\t\tgcstopm()\n\t\tgoto top\n\t}\n\tif _p_.runSafePointFn != 0 {\n\t\trunSafePointFn()\n\t}\n\n\tnow, pollUntil, _ := checkTimers(_p_, 0)\n\n    // 如果有finalizer可用，直接唤醒\n\tif fingwait && fingwake {\n\t\tif gp := wakefing(); gp != nil {\n\t\t\tready(gp, 0, true)\n\t\t}\n\t}\n\n\t// 本地获取\n\tif gp, inheritTime := runqget(_p_); gp != nil {\n\t\treturn gp, inheritTime\n\t}\n\n\t// 全局获取\n\t// global runq\n\tif sched.runqsize != 0 {\n\t\tlock(&sched.lock)\n\t\tgp := globrunqget(_p_, 0)\n\t\tunlock(&sched.lock)\n\t\tif gp != nil {\n\t\t\treturn gp, false\n\t\t}\n\t}\n\n\t// 没有可以执行的goroutine\n\n\t// 获取网络事件完成的gp，优化\n\tif netpollinited() && atomic.Load(&netpollWaiters) > 0 && atomic.Load64(&sched.lastpoll) != 0 {\n\t\tif list := netpoll(0); !list.empty() { // non-blocking\n\t\t\tgp := list.pop()\n\t\t\tinjectglist(&list)\n\t\t\tcasgstatus(gp, _Gwaiting, _Grunnable)\n\t\t\tif trace.enabled {\n\t\t\t\ttraceGoUnpark(gp, 0)\n\t\t\t}\n\t\t\treturn gp, false\n\t\t}\n\t}\n\n\t// 从其他的P偷取\n\t// Steal work from other P's.\n\tprocs := uint32(gomaxprocs)\n\tranTimer := false\n\t\n    // 将m置为自旋状态\n\tif !_g_.m.spinning {\n\t\t_g_.m.spinning = true\n\t\tatomic.Xadd(&sched.nmspinning, 1)\n\t}\n\n    // 随机从别的p中偷取4次\n\tfor i := 0; i < 4; i++ {\n\t\tfor enum := stealOrder.start(fastrand()); !enum.done(); enum.next() {\n\t\t\tif sched.gcwaiting != 0 {\n\t\t\t\tgoto top\n\t\t\t}\n\t\t\tstealRunNextG := i > 2 // first look for ready queues with more than 1 g\n\t\t\tp2 := allp[enum.position()]\n\t\t\tif _p_ == p2 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif gp := runqsteal(_p_, p2, stealRunNextG); gp != nil {\n\t\t\t\treturn gp, false\n\t\t\t}\n\n\t\t\tif i > 2 || (i > 1 && shouldStealTimers(p2)) {\n\t\t\t\ttnow, w, ran := checkTimers(p2, now)\n\t\t\t\tnow = tnow\n\t\t\t\tif w != 0 && (pollUntil == 0 || w < pollUntil) {\n\t\t\t\t\tpollUntil = w\n\t\t\t\t}\n\t\t\t\tif ran {\n\t\t\t\t\tif gp, inheritTime := runqget(_p_); gp != nil {\n\t\t\t\t\t\treturn gp, inheritTime\n\t\t\t\t\t}\n\t\t\t\t\tranTimer = true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif ranTimer {\n\t\t// Running a timer may have made some goroutine ready.\n\t\tgoto top\n\t}\n\t// ... 省略 ...    \n}\n```\n\n`findrunnable`函数主要流程：\n* 如果有`finalizer`可执行`gp`，直接唤醒\n* 如果从本地可执行队列中获取可执行`gp`，返回`gp`\n* 如果从全局可执行队列中获取可执行`gp`，返回`gp`\n* 如果有就绪的网络事件的`gp`，返回`gp`\n* 从其他的`p`中偷取部分`gp`，返回`gp`\n\n### runqsteal\n```go\n// runtime/proc.go\n\nfunc runqsteal(_p_, p2 *p, stealRunNextG bool) *g {\n\tt := _p_.runqtail\n\tn := runqgrab(p2, &_p_.runq, t, stealRunNextG)\n\tif n == 0 {\n\t\treturn nil\n\t}\n\tn--\n\tgp := _p_.runq[(t+n)%uint32(len(_p_.runq))].ptr()\n\tif n == 0 {\n\t\treturn gp\n\t}\n\th := atomic.LoadAcq(&_p_.runqhead)\n\tatomic.StoreRel(&_p_.runqtail, t+n)\n\treturn gp\n}\n```\n\n`runqsteal`函数主要流程：\n* 获取本地队列队尾坐标\n* 从`p2`中获取部分可执行队列\n* 如果只偷取了一个，直接返回\n* 否则需要原子修改可执行队列的首尾指针\n\n#### runqgrab\n```\n// runtime/proc.go\n\nfunc runqgrab(_p_ *p, batch *[256]guintptr, batchHead uint32, stealRunNextG bool) uint32 {\n\tfor {\n\t\th := atomic.LoadAcq(&_p_.runqhead)\n\t\tt := atomic.LoadAcq(&_p_.runqtail) \n\t\tn := t - h\n\t\tn = n - n/2\n\t\tif n == 0 {\n\t\t\tif stealRunNextG {\n\t\t\t\t// Try to steal from _p_.runnext.\n\t\t\t\tif next := _p_.runnext; next != 0 {\n\t\t\t\t\t// 休眠让p不会执行将要偷取的\n\t\t\t\t\tif _p_.status == _Prunning {\n\t\t\t\t\t\tif GOOS != \"windows\" {\n\t\t\t\t\t\t\tusleep(3)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tosyield()\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif !_p_.runnext.cas(next, 0) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tbatch[batchHead%uint32(len(batch))] = next\n\t\t\t\t\treturn 1\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0\n\t\t}\n\t\tif n > uint32(len(_p_.runq)/2) { // 保证队列没有改动\n\t\t\tcontinue\n\t\t}\n\t\t// 偷取前半g可执行队列\n\t\tfor i := uint32(0); i < n; i++ {\n\t\t\tg := _p_.runq[(h+i)%uint32(len(_p_.runq))]\n\t\t\tbatch[(batchHead+i)%uint32(len(batch))] = g\n\t\t}\n\t\t// 提交本次消费，如果失败则从新再试一次\n\t\tif atomic.CasRel(&_p_.runqhead, h, h+n) {\n\t\t\treturn n\n\t\t}\n\t}\n}\n```\n\nrunqgrab函数主要流程：\n* 原子获取待偷取`p`可执行队列首尾位置\n* 如果没有，则判断是否需要偷取`next`指针的`gp`\n* 复制`p`的前半部分可执行队列\n* 原子的修改`p`的可执行队列的首尾指针位置\n\n## execute\n```go\n// runtime/proc.go\n\nfunc execute(gp *g, inheritTime bool) {\n\t_g_ := getg()\n\n    // 互相绑定 _g_.m.curg = gp\n    gp.m = _g_.m\n    casgstatus(gp, _Grunnable, _Grunning) // 转换状态\n\tgp.waitsince = 0\n\tgp.preempt = false\n\tgp.stackguard0 = gp.stack.lo + _StackGuard\n\tif !inheritTime {\n\t\t_g_.m.p.ptr().schedtick++\n\t}\n\n\tgogo(&gp.sched)\n}\n```\n\n`execute`函数主要流程：\n* `m`和`g`相互绑定\n* 设置相关值\n* 调用`gogo`函数执行`gp`\n\n### gogo\n```asm\n// runtime/asm_amd64.s\n\nTEXT runtime·gogo(SB), NOSPLIT, $16-8\n\tMOVQ\tbuf+0(FP), BX\t\t// gobuf\n\tMOVQ\tgobuf_g(BX), DX\n\tMOVQ\t0(DX), CX\t\t// make sure g != nil\n\tget_tls(CX)\n\tMOVQ\tDX, g(CX)\n\tMOVQ\tgobuf_sp(BX), SP\t// restore SP\n\tMOVQ\tgobuf_ret(BX), AX\n\tMOVQ\tgobuf_ctxt(BX), DX\n\tMOVQ\tgobuf_bp(BX), BP\n\tMOVQ\t$0, gobuf_sp(BX)\t// clear to help garbage collector\n\tMOVQ\t$0, gobuf_ret(BX)\n\tMOVQ\t$0, gobuf_ctxt(BX)\n\tMOVQ\t$0, gobuf_bp(BX)\n\tMOVQ\tgobuf_pc(BX), BX\n\tJMP\tBX\n```\n\n`gogo`函数主要流程：\n* 将`gobuf`的内容存放到相关寄存器中\n* 将`gobuf`的内容清空\n* 执行`gobuf.pc`\n\n## Gosched\n除了上述的通过运行时启动调度之外，golang还提供了手动的调度函数`Gosched`函数，该函数在运行时内外都可以触发下一次调度。\n```go\nfunc Gosched() {\n\tcheckTimeouts()\n\tmcall(gosched_m)\n}\n```\n\n```go\nfunc gosched_m(gp *g) {\n\tgoschedImpl(gp)\n}\n```\n\n```go\nfunc goschedImpl(gp *g) {\n\tstatus := readgstatus(gp)\n\tif status&^_Gscan != _Grunning {\n\t\tdumpgstatus(gp)\n\t\tthrow(\"bad g status\")\n\t}\n\tcasgstatus(gp, _Grunning, _Grunnable)\n\tdropg() // 解绑g和m\n\tlock(&sched.lock)\n\tglobrunqput(gp) // 放入全局可执行队列\n\tunlock(&sched.lock)\n\n\tschedule() // 下一次调度\n}\n```\n\nGosched函数主要流程：\n* 获取gp的状态\n* 切换gp的状态为_Grunnable\n* 解绑g和m\n* 将g存入全局可执行队列中\n* 启动下一次调度\n\n# 销毁\n```asm\nTEXT runtime·goexit(SB),NOSPLIT,$0-0\n\tBYTE\t$0x90\t// NOP\n\tCALL\truntime·goexit1(SB)\t// does not return\n\t// traceback from goexit1 must hit code range of goexit\n\tBYTE\t$0x90\t// NOP\n```\n\n```go\nfunc goexit1() {\n   if raceenabled {\n      racegoend()\n   }\n   if trace.enabled {\n      traceGoEnd()\n   }\n   mcall(goexit0)\n}\n```\n\n```go\nfunc goexit0(gp *g) {\n\t_g_ := getg()\n\n    // 切换g的状态 \n    casgstatus(gp, _Grunning, _Gdead)\n    // 标记系统goroutine \n    if isSystemGoroutine(gp, false) {\n       atomic.Xadd(&sched.ngsys, -1)\n    }\n\t// 清理gp相关的数据\n\tgp.m = nil\n\tlocked := gp.lockedm != 0\n\tgp.lockedm = 0\n\t_g_.m.lockedg = 0\n\tgp.preemptStop = false\n\tgp.paniconfault = false\n\tgp._defer = nil // should be true already but just in case.\n\tgp._panic = nil // non-nil for Goexit during panic. points at stack-allocated data.\n\tgp.writebuf = nil\n\tgp.waitreason = 0\n\tgp.param = nil\n\tgp.labels = nil\n\tgp.timer = nil\n\n\tdropg() // 解绑当前m和gp\n\n\tif GOARCH == \"wasm\" { // no threads yet on wasm\n\t\tgfput(_g_.m.p.ptr(), gp) // 将gp存放到p的空闲列表中\n\t\tschedule() // 下一次调度\n\t}\n\n\tgfput(_g_.m.p.ptr(), gp) // 将gp存放到p的空闲列表中\n\tif locked {\n\t\t// 如果gp锁定了m，则将这个m杀死\n\t\tif GOOS != \"plan9\" { \n\t\t\tgogo(&_g_.m.g0.sched)\n\t\t} else {\n\t\t\t_g_.m.lockedExt = 0\n\t\t}\n\t}\n\tschedule() // 下一次调度\n}\n```\n\n`goexit0`函数主要流程：\n* 切换`g`的状态\n* 解绑`g`所有绑定的数据\n* 如果是`wasm`架构，直接将`g`存于空闲列表中，并开始下一次调度\n* 否则，直接将`g`存于空闲列表中，如果`g`有锁定的`m`，则将`m`杀死，开始下一次调度\n\n# 切换\n## 执行完毕切换\n上面说到，当goroutine执行完毕时，会执行goexit0函数，进而执行下一次调度\n## 主动切换\n当goroutine中阻塞的操作时，就需要让出CPU，让其他的goroutine执行。所有主动切换都是调用gopark函数来实现的。\n### gopark\n```go\nfunc gopark(unlockf func(*g, unsafe.Pointer) bool, lock unsafe.Pointer, reason waitReason, traceEv byte, traceskip int) {\n\tif reason != waitReasonSleep {\n\t\tcheckTimeouts()\n\t}\n\tmp := acquirem()\n\tgp := mp.curg\n\tstatus := readgstatus(gp)\n\tif status != _Grunning && status != _Gscanrunning {\n\t\tthrow(\"gopark: bad g status\")\n\t}\n\t// 填充相关参数\n\tmp.waitlock = lock\n\tmp.waitunlockf = unlockf\n\tgp.waitreason = reason\n\tmp.waittraceev = traceEv\n\tmp.waittraceskip = traceskip\n\treleasem(mp)\n\t// can't do anything that might move the G between Ms here.\n\tmcall(park_m)\n}\n```\n\n`gopark`函数主要流程：\n* 获取当前`m`绑定的`gp`\n* 填充相关参数\n* 利用`g0`调用`park_m`函数\n\n```go\nfunc park_m(gp *g) {\n\t_g_ := getg()\n\n\tcasgstatus(gp, _Grunning, _Gwaiting)\n\tdropg() // 解绑g和m\n\n\tif fn := _g_.m.waitunlockf; fn != nil {\n\t\tok := fn(gp, _g_.m.waitlock) // 尝试调用解锁函数\n\t\t_g_.m.waitunlockf = nil\n\t\t_g_.m.waitlock = nil\n\t\tif !ok {\n\t\t\t// 如果解锁成功\n\t\t\tcasgstatus(gp, _Gwaiting, _Grunnable)\n\t\t\texecute(gp, true) // 直接执行gp\n\t\t}\n\t}\n\tschedule() // 下一次调度\n}\n```\n\n`park_m`函数主要流程：\n* 切换`g`的状态为等待\n* 尝试解锁，如果成功则切换状态为可执行，直接调用`execute`函数执行\n* 否则，进入下一个调度\n\n### goready\n当goroutine通过`gopark`函数由`_Grunning`到`_Gwaiting`，反向操作`goready`函数则是将`_Gwaiting`到`_Grunnable`。\n```go\nfunc goready(gp *g, traceskip int) {\n\tsystemstack(func() {\n\t\tready(gp, traceskip, true)\n\t})\n}\n```\n\n```go\nfunc ready(gp *g, traceskip int, next bool) {\n\tstatus := readgstatus(gp)\n\n\t_g_ := getg()\n\tmp := acquirem()\n\t// 如果不是 _Gwaiting 抛异常\n\tif status&^_Gscan != _Gwaiting {\n\t\tdumpgstatus(gp)\n\t\tthrow(\"bad g->status in ready\")\n\t}\n\n    // 切换状态\n\tcasgstatus(gp, _Gwaiting, _Grunnable)\n\trunqput(_g_.m.p.ptr(), gp, next) // 存放到本地可执行队列中\n\twakep()                          // 尝试去唤起p去执行\n\treleasem(mp)\n}\n```\n\n`ready`函数主要流程：\n* 获取`gp`的状态\n* 获取当前的`g`\n* 检测`gp`状态是不是`_Gwaiting`\n* 由`_Gwaiting`转换为`_Grunnable`状态\n* 放进当前`g`的`m`的`p`中的本地可执行队列中\n\n## 抢占切换\ngolang调度本质上是非抢占式的，golang利用标志位标志当前的goroutine是否可以被抢占，而触发时机是在栈扩容的时候。\ngolang中有个监控函数，监控着整个进程运行的相关数据，其中就包括检查某个goroutine是否占用CPU时间过长，从而进行标记抢占标记位。\n```go\nfunc sysmon() {\n    // ... 省略 ...\n    \n\tfor {\n\t\t// ... 省略 ...\n\t\t\n\t\t// 解绑在陷入系统调用中的p，和抢占长时间运行的g\n\t\tif retake(now) != 0 {\n\t\t\tidle = 0\n\t\t} else {\n\t\t\tidle++\n\t\t}\n\t\t\n\t\t// ... 省略 ...\n\t}\n}\n```\n\n\n### retake\n```go\nfunc retake(now int64) uint32 {\n\tn := 0\n\tlock(&allpLock)\n\tfor i := 0; i < len(allp); i++ {\n\t\t_p_ := allp[i]\n\t\tif _p_ == nil {\n\t\t\tcontinue\n\t\t}\n\t\tpd := &_p_.sysmontick // sysmon 信息记录\n\t\ts := _p_.status\n\t\tsysretake := false\n\t\tif s == _Prunning || s == _Psyscall {\n\t\t\t// 处于 _Prunning 或者 _Psyscall 状态时，如果上一次触发调度的时间已经过去了 10ms，\n\t\t\t// 我们就会通过 runtime.preemptone 抢占当前处理器\n\t\t\t// 如果G运行时间太长则抢占G\n\t\t\tt := int64(_p_.schedtick)\n\t\t\tif int64(pd.schedtick) != t {\n\t\t\t\tpd.schedtick = uint32(t)\n\t\t\t\tpd.schedwhen = now\n\t\t\t} else if pd.schedwhen+forcePreemptNS <= now {\n\t\t\t\tpreemptone(_p_)\n\t\t\t\t// 在_Psyscall时preemptone函数不会工作，因为m没有绑定p\n\t\t\t\tsysretake = true\n\t\t\t}\n\t\t}\n\t\tif s == _Psyscall {\n\t\t\t// 当处理器处于 _Psyscall 状态时\n\t\t\t// 当处理器的运行队列不为空或者不存在空闲处理器时并且当系统调用时间超过了 10ms 时\n\t\t\tt := int64(_p_.syscalltick)\n\t\t\tif !sysretake && int64(pd.syscalltick) != t {\n\t\t\t\tpd.syscalltick = uint32(t)\n\t\t\t\tpd.syscallwhen = now\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t\n\t\t\tif runqempty(_p_) && atomic.Load(&sched.nmspinning)+atomic.Load(&sched.npidle) > 0 && pd.syscallwhen+10*1000*1000 > now {\n\t\t\t\t// 如果_p_没有可执行的g，且有自旋的m或空闲的p，且系统调用时间没有超过10ms\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Drop allpLock so we can take sched.lock.\n\t\t\tunlock(&allpLock)\n\t\t\t\n\t\t\t// 将p的状态设置为_Pidle，计数器n加1，_p_的系统调用次数+1\n\t\t\tincidlelocked(-1)\n\t\t\tif atomic.Cas(&_p_.status, s, _Pidle) {\n\t\t\t\tn++\n\t\t\t\t_p_.syscalltick++\n\t\t\t\thandoffp(_p_) // 让 p 去找其他的事情干\n\t\t\t}\n\t\t\tincidlelocked(1)\n\t\t\tlock(&allpLock)\n\t\t}\n\t}\n\tunlock(&allpLock)\n\treturn uint32(n)\n}\n```\n\n`retake`函数主要流程：\n* 遍历所有的`p`\n* 如果`p`长时间没有调度则标记抢占标志位\n* 如果`p`在系统调用中，且超过阈值时间，则解绑`p`\n* 返回解绑`p`的个数\n\n### preemptone\n```go\nfunc preemptone(_p_ *p) bool {\n\tmp := _p_.m.ptr()\n\tif mp == nil || mp == getg().m {\n\t\t// 如果mp为空，或mp是当前运行的m\n\t\treturn false\n\t}\n\tgp := mp.curg\n\tif gp == nil || gp == mp.g0 {\n\t\t// gp 不能使 g0\n\t\treturn false\n\t}\n\n\tgp.preempt = true // 标志gp可以被抢占\n\n\tgp.stackguard0 = stackPreempt // 直接设置为栈顶，方便触发栈扩容\n\n\t// Request an async preemption of this P.\n\tif preemptMSupported && debug.asyncpreemptoff == 0 {\n\t\t_p_.preempt = true // 标记p快速调度\n\t\tpreemptM(mp)       // 向mp发送抢占信号\n\t}\n\n\treturn true\n}\n```\n\n### handoffp\n```go\nfunc handoffp(_p_ *p) {\n\t// 如果本地有可执行的G或全局可执行队列长度不为0，则直接开始执行\n\tif !runqempty(_p_) || sched.runqsize != 0 {\n\t\tstartm(_p_, false)\n\t\treturn\n\t}\n\t// 如果可以执行GC，则立即执行\n\tif gcBlackenEnabled != 0 && gcMarkWorkAvailable(_p_) {\n\t\tstartm(_p_, false)\n\t\treturn\n\t}\n\t// 如果没有自旋的m和空闲的p，并且增加自旋数成功，则让_p_绑定一个m进入自旋\n\tif atomic.Load(&sched.nmspinning)+atomic.Load(&sched.npidle) == 0 && atomic.Cas(&sched.nmspinning, 0, 1) {\n\t\tstartm(_p_, true)\n\t\treturn\n\t}\n\tlock(&sched.lock)\n\tif sched.gcwaiting != 0 { // 即将GC\n\t\t_p_.status = _Pgcstop\n\t\tsched.stopwait--\n\t\tif sched.stopwait == 0 {\n\t\t\tnotewakeup(&sched.stopnote)\n\t\t}\n\t\tunlock(&sched.lock)\n\t\treturn\n\t}\n\tif _p_.runSafePointFn != 0 && atomic.Cas(&_p_.runSafePointFn, 1, 0) {\n\t\tsched.safePointFn(_p_)\n\t\tsched.safePointWait--\n\t\tif sched.safePointWait == 0 {\n\t\t\tnotewakeup(&sched.safePointNote)\n\t\t}\n\t}\n\t// 此时如果全局队列有可执行的g，则执行\n\tif sched.runqsize != 0 {\n\t\tunlock(&sched.lock)\n\t\tstartm(_p_, false)\n\t\treturn\n\t}\n\t// 如果这是最后运行的P并且没有人正在轮询网络，则需要唤醒另一个M来轮询网络。\n\tif sched.npidle == uint32(gomaxprocs-1) && atomic.Load64(&sched.lastpoll) != 0 {\n\t\tunlock(&sched.lock)\n\t\tstartm(_p_, false)\n\t\treturn\n\t}\n\tif when := nobarrierWakeTime(_p_); when != 0 {\n\t\twakeNetPoller(when)\n\t}\n\t// 都没有则将_p_存放到空闲P列表中\n\tpidleput(_p_)\n\tunlock(&sched.lock)\n}\n```\n\n`retake`函数主要流程：\n* 如果`p`的本地可执行队列不为空，或全局可执行队列不为空，则绑定`m`去执行\n* 如果`p`可以执行GC工作，则绑定m去执行\n* 如果没有m在自旋且没有空闲的`p`，且成功设置自旋值，则获取一个`m`，进入自旋\n* 如果此时在检测全局可执行队列是否为空，有则绑定`m`去执行\n* 如果是最后一个正在运行的`p`，则绑定`m`去轮询网络\n* 都没有则将`p`存放进空闲`p`列表\n\n### newstack\n```go\nfunc newstack() {\n\tthisg := getg() // 当前执行的g\n\t\n\tgp := thisg.m.curg // m绑定的g\n\n\t// 判断是否抢占触发的栈扩张\n\tpreempt := atomic.Loaduintptr(&gp.stackguard0) == stackPreempt\n\n    // ... 省略 ...\n\n\tif preempt {\n\t\t// Act like goroutine called runtime.Gosched.\n\t\tgopreempt_m(gp) // never return\n\t}\n    // ... 省略 ...\n}\n```\n\n```go\nfunc gopreempt_m(gp *g) {\n\tif trace.enabled {\n\t\ttraceGoPreempt()\n\t}\n\tgoschedImpl(gp)\n}\n```\n\n`goschedImpl`函数就是上述Gosched函数的主要执行实体了。\n\n如果检测到是抢占，则将m绑定的g放入全局可执行队列中。\n\n\n## 系统调用切换\ngolang提供了系统调用接口：\n```go\nfunc Syscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno)\nfunc RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno)\n```\n\n更多参数可以调用Syscall6或Syscall9。\n\n### Syscall\n```asm\nTEXT\t·Syscall(SB),NOSPLIT,$0-56\n\tCALL\truntime·entersyscall(SB)\n\tMOVQ\ta1+8(FP), DI\n\tMOVQ\ta2+16(FP), SI\n\tMOVQ\ta3+24(FP), DX\n\tMOVQ\ttrap+0(FP), AX\t// syscall entry\n\tADDQ\t$0x2000000, AX\n\tSYSCALL\n\tJCC\tok\n\tMOVQ\t$-1, r1+32(FP)\n\tMOVQ\t$0, r2+40(FP)\n\tMOVQ\tAX, err+48(FP)\n\tCALL\truntime·exitsyscall(SB)\n\tRET\nok:\n\tMOVQ\tAX, r1+32(FP)\n\tMOVQ\tDX, r2+40(FP)\n\tMOVQ\t$0, err+48(FP)\n\tCALL\truntime·exitsyscall(SB)\n\tRET\n```\n\n`Syscall`函数主要流程：\n* 调用`runtime.entersyscall`\n* 将参数存至寄存器\n* 执行系统调用\n* 将返回值压栈\n* 调用`runtime.exitsyscall`\n\n#### entersyscall\n```go\nfunc entersyscall() {\n   reentersyscall(getcallerpc(), getcallersp())\n}\n```\n\n```go\nfunc reentersyscall(pc, sp uintptr) {\n\t_g_ := getg()\n\t_g_.m.locks++\n\n\t_g_.stackguard0 = stackPreempt // 等待被抢占\n\t_g_.throwsplit = true\n\n\t// Leave SP around for GC and traceback.\n\tsave(pc, sp) // 保存现场\n\t_g_.syscallsp = sp\n\t_g_.syscallpc = pc\n\tcasgstatus(_g_, _Grunning, _Gsyscall) // 切换状态\n\tif _g_.syscallsp < _g_.stack.lo || _g_.stack.hi < _g_.syscallsp {\n\t\tsystemstack(func() {\n\t\t\tprint(\"entersyscall inconsistent \", hex(_g_.syscallsp), \" [\", hex(_g_.stack.lo), \",\", hex(_g_.stack.hi), \"]\\n\")\n\t\t\tthrow(\"entersyscall\")\n\t\t})\n\t}\n\n\tif trace.enabled {\n\t\tsystemstack(traceGoSysCall)\n\t\t// systemstack itself clobbers g.sched.{pc,sp} and we might\n\t\t// need them later when the G is genuinely blocked in a\n\t\t// syscall\n\t\tsave(pc, sp)\n\t}\n\n\tif atomic.Load(&sched.sysmonwait) != 0 {\n\t\tsystemstack(entersyscall_sysmon)\n\t\tsave(pc, sp)\n\t}\n\n\tif _g_.m.p.ptr().runSafePointFn != 0 {\n\t\t// runSafePointFn may stack split if run on this stack\n\t\tsystemstack(runSafePointFn)\n\t\tsave(pc, sp)\n\t}\n\n\t_g_.m.syscalltick = _g_.m.p.ptr().syscalltick\n\t_g_.sysblocktraced = true\n\tpp := _g_.m.p.ptr()\n\tpp.m = 0\n\t_g_.m.oldp.set(pp)\n\t_g_.m.p = 0\n\tatomic.Store(&pp.status, _Psyscall) // 切换p的状态\n\tif sched.gcwaiting != 0 {\n\t\tsystemstack(entersyscall_gcwait)\n\t\tsave(pc, sp)\n\t}\n\n\t_g_.m.locks--\n}\n```\n\n#### exitsyscall\n```go\nfunc exitsyscall() {\n\t_g_ := getg()\n\n\t_g_.m.locks++ \n\n\toldp := _g_.m.oldp.ptr()\n\t_g_.m.oldp = 0\n\tif exitsyscallfast(oldp) { // 尝试获取系统调用前绑定的p\n\t\t_g_.m.p.ptr().syscalltick++\n\t\tcasgstatus(_g_, _Gsyscall, _Grunning)\n\t\t_g_.syscallsp = 0\n\t\t_g_.m.locks--\n\t\tif _g_.preempt {\n\t\t\t// 如果抢占，就设置stackguard0为stackPreempt\n\t\t\t_g_.stackguard0 = stackPreempt\n\t\t} else {\n\t\t\t// 否则恢复真实栈帧\n\t\t\t_g_.stackguard0 = _g_.stack.lo + _StackGuard\n\t\t}\n\t\t_g_.throwsplit = false\n\n\t\tif sched.disable.user && !schedEnabled(_g_) {\n\t\t\t// Scheduling of this goroutine is disabled.\n\t\t\tGosched() // 开始调度\n\t\t}\n\n\t\treturn\n\t}\n\n\t// 没有p被绑定的情况\n\t_g_.sysexitticks = 0\n\t_g_.m.locks--\n\n\t// Call the scheduler.\n\tmcall(exitsyscall0)\n\n\t_g_.syscallsp = 0\n\t_g_.m.p.ptr().syscalltick++\n\t_g_.throwsplit = false\n}\n```\n\n`exitsyscall`函数主要流程：\n* 获取系统调用前绑定的`oldp`\n* 尝试获取`oldp`或从空闲列表获取`p`\n* 如果成功获取`p`，改变相关设置，开始下一轮调度\n* 如果没有获取，则调用`exitsyscall0`\n\n```go\nfunc exitsyscall0(gp *g) {\n\t_g_ := getg()\n\n\tcasgstatus(gp, _Gsyscall, _Grunnable)\n\tdropg()\n\tlock(&sched.lock)\n\tvar _p_ *p\n\tif schedEnabled(_g_) { // 如果可以调度_g_\n\t\t_p_ = pidleget() // 从p空闲列表中获取p\n\t}\n\tif _p_ == nil {\n\t\tglobrunqput(gp) // 没有可用的p，就将gp存放于全局可执行列表中\n\t} else if atomic.Load(&sched.sysmonwait) != 0 {\n\t\tatomic.Store(&sched.sysmonwait, 0)\n\t\tnotewakeup(&sched.sysmonnote)\n\t}\n\tunlock(&sched.lock)\n\tif _p_ != nil { // 如果有可用的p\n\t\tacquirep(_p_) // 直接绑定当前的m\n\t\texecute(gp, false) // 执行gp\n\t}\n\tif _g_.m.lockedg != 0 { // 如果m有锁定的g\n\t\t// Wait until another thread schedules gp and so m again.\n\t\tstoplockedm()   // 释放p，休眠m，会阻塞\n\t\texecute(gp, false) // 执行gp\n\t}\n\tstopm() // 将m休眠，并存于m空闲列表中，会阻塞\n\tschedule() // 下一次调度\n}\n```\n\n`exitsyscall0`函数主要流程：\n* 切换`gp`状态为`_Grunnable`\n* 解绑`g`和`m`\n* 尝试获取一个空闲的`_p_`\n* 如果没有获取到就把`gp`放到全局可执行列表中\n* 如果获取到了，就直接绑定当前的`m`，执行`gp`\n* 如果有`m`有锁定的`g`，释放p，休眠m，等待被唤醒\n* 否则`m`将放置与全局`m`空闲列表中，等待下一次调度\n\nexitsyscall0函数如果没有p则会将m休眠\n\n### RawSyscall\n```asm\nTEXT ·RawSyscall(SB),NOSPLIT,$0-56\n\tMOVQ\ta1+8(FP), DI\n\tMOVQ\ta2+16(FP), SI\n\tMOVQ\ta3+24(FP), DX\n\tMOVQ\ttrap+0(FP), AX\t// syscall entry\n\tADDQ\t$0x2000000, AX\n\tSYSCALL\n\tJCC\tok1\n\tMOVQ\t$-1, r1+32(FP)\n\tMOVQ\t$0, r2+40(FP)\n\tMOVQ\tAX, err+48(FP)\n\tRET\nok1:\n\tMOVQ\tAX, r1+32(FP)\n\tMOVQ\tDX, r2+40(FP)\n\tMOVQ\t$0, err+48(FP)\n\tRET\n```\n\n`RawSyscall`函数主要流程：\n* 将参数存至寄存器\n* 执行系统调用\n* 将返回值压栈\n\n`RawSyscall`函数并没有执行`runtime.entersyscall`和`runtime.exitsyscall`函数，由于没有执行相关操作导致golang无法准确的调度，可能会导致长时间系统调用，其他的goroutine无法得到执行。\n\n\n\n# 辅助函数\n## getg\n获取当前的`g`，由于是编译器填充的，所以没有源码。\n一般都是从TLS寄存器获取的。\n## mcall\n```asm\nTEXT runtime·mcall(SB), NOSPLIT, $0-8\n\tMOVQ\tfn+0(FP), DI\n\n\tget_tls(CX)\n\tMOVQ\tg(CX), AX\t// save state in g->sched\n\tMOVQ\t0(SP), BX\t// caller's PC\n\tMOVQ\tBX, (g_sched+gobuf_pc)(AX)\n\tLEAQ\tfn+0(FP), BX\t// caller's SP\n\tMOVQ\tBX, (g_sched+gobuf_sp)(AX)\n\tMOVQ\tAX, (g_sched+gobuf_g)(AX)\n\tMOVQ\tBP, (g_sched+gobuf_bp)(AX)\n\n\t// switch to m->g0 & its stack, call fn\n\tMOVQ\tg(CX), BX\n\tMOVQ\tg_m(BX), BX\n\tMOVQ\tm_g0(BX), SI\n\tCMPQ\tSI, AX\t// if g == m->g0 call badmcall\n\tJNE\t3(PC)\n\tMOVQ\t$runtime·badmcall(SB), AX\n\tJMP\tAX\n\tMOVQ\tSI, g(CX)\t// g = m->g0\n\tMOVQ\t(g_sched+gobuf_sp)(SI), SP\t// sp = m->g0->sched.sp\n\tPUSHQ\tAX\n\tMOVQ\tDI, DX\n\tMOVQ\t0(DI), DI\n\tCALL\tDI // 执行fn，不能返回\n\tPOPQ\tAX\n\tMOVQ\t$runtime·badmcall2(SB), AX\n\tJMP\tAX\n\tRET\n```\n\n`mcall`函数切换到`m`的`g0`调用`fn(g)`，`fn`是不能返回的。\n\n## systemstack\n```asm\nTEXT runtime·systemstack(SB), NOSPLIT, $0-8\n\tMOVQ\tfn+0(FP), DI\t// DI = fn\n\tget_tls(CX)\n\tMOVQ\tg(CX), AX\t// AX = g\n\tMOVQ\tg_m(AX), BX\t// BX = m\n\n\tCMPQ\tAX, m_gsignal(BX) // g == m.gsignal\n\tJEQ\tnoswitch\n\n\tMOVQ\tm_g0(BX), DX\t// DX = g0\n\tCMPQ\tAX, DX // g == g0\n\tJEQ\tnoswitch\n\n\tCMPQ\tAX, m_curg(BX) // g == m.curg\n\tJNE\tbad\n\n\t// 保存当前g的栈信息\n\tMOVQ\t$runtime·systemstack_switch(SB), SI\n\tMOVQ\tSI, (g_sched+gobuf_pc)(AX)\n\tMOVQ\tSP, (g_sched+gobuf_sp)(AX)\n\tMOVQ\tAX, (g_sched+gobuf_g)(AX)\n\tMOVQ\tBP, (g_sched+gobuf_bp)(AX)\n\n\t// 切换到g0\n\tMOVQ\tDX, g(CX)\n\tMOVQ\t(g_sched+gobuf_sp)(DX), BX\n\t// make it look like mstart called systemstack on g0, to stop traceback\n\tSUBQ\t$8, BX\n\tMOVQ\t$runtime·mstart(SB), DX\n\tMOVQ\tDX, 0(BX)\n\tMOVQ\tBX, SP\n\n\t// call target function\n\tMOVQ\tDI, DX\n\tMOVQ\t0(DI), DI\n\tCALL\tDI // 执行目标函数\n\n\t// 恢复原有g\n\tget_tls(CX)\n\tMOVQ\tg(CX), AX\n\tMOVQ\tg_m(AX), BX\n\tMOVQ\tm_curg(BX), AX\n\tMOVQ\tAX, g(CX)\n\tMOVQ\t(g_sched+gobuf_sp)(AX), SP\n\tMOVQ\t$0, (g_sched+gobuf_sp)(AX)\n\tRET\n```\n\nsystemstack函数主要流程：\n* 检测相关参数\n* 保存g现场\n* 切换到g0，并执行fn(g)\n* 恢复原有g\n\n## acquirem\n```go\nfunc acquirem() *m {\n\t_g_ := getg()\n\t_g_.m.locks++\n\treturn _g_.m\n}\n```\n`acquirem`函数主要是增加`locks`引用计数，并返回当前的m。主要是防止GC回收m。\n\n## releasem\n```go\nfunc releasem(mp *m) {\n\t_g_ := getg()\n\tmp.locks--\n\tif mp.locks == 0 && _g_.preempt {\n\t\t_g_.stackguard0 = stackPreempt\n\t}\n}\n```\n\n`releasem`函数主要是减少`locks`引用计数，并判断是否需要`g`被抢占\n\n## acquirep\n```go\nfunc acquirep(_p_ *p) {\n\twirep(_p_)\n}\n```\n\n```go\nfunc wirep(_p_ *p) {\n\t_g_ := getg()\n\t_g_.m.p.set(_p_)\n\t_p_.m.set(_g_.m)\n\t_p_.status = _Prunning\n}\n```\n\n`acquirep`函数主要流程：\n* 绑定`p`和`m`\n* 将`p`的状态置为`_Prunning`\n\n## releasep\n```go\nfunc releasep() *p {\n\t_g_ := getg()\n\t_p_ := _g_.m.p.ptr()\n\t_g_.m.p = 0\n\t_p_.m = 0\n\t_p_.status = _Pidle\n\treturn _p_\n}\n```\n\n`releasep`函数主要流程：\n* 解绑`m`和`p`\n* 将`p`的状态置为`_Pidle`\n* 返回`p`\n\n# 疑问\n## p的本地可执行列表无锁，其他p怎么偷取可执行列表\n通过原子cas的方式提交列表头尾位置，如果失败则重新偷取。\n\n## g进入_Gwaiting状态后去哪里了\n\n* 如果`g`是被抢占了，则将g的状态改为`_Grunnable`，放入全局可执行队列中\n* 如果是主动切换，调用`gopark`的调用者需要维护`sudog`列表（`sudog`用于保存调用`gopark`的`g`），接收已完成的`goroutine`，然后调用`goready`，将他们状态置为`_Grunnable`，存入本地的可执行队列中。\n\n## m进入自旋，在干嘛\n`m`自旋，即`m`阻塞于`schedule()`的`findrunnable()`，`m`会一直尝试获取可执行的`g`去工作。\n\n## g0栈复用\n`g0`的栈在golang中不同系统采用不同的初始化方式。\n```go\nif iscgo || GOOS == \"solaris\" || GOOS == \"illumos\" || GOOS == \"windows\" || GOOS == \"plan9\" || GOOS == \"darwin\" || GOOS == \"ios\" {\n\t\t// 如果是上面的情况 g0栈是用的 pthread_create 线程栈\n\t\tmp.g0 = malg(-1)\n\t} else {\n\t\tmp.g0 = malg(8192 * sys.StackGuardMultiplier)\n\t}\n```\n\n\n每次切到`g0`栈执行指令时，`g0->sched.sp`在初始化后没有修改该过，所以每次切换到g0时栈起始值相同，每次调用`mcall`都会从指定栈位置开始执行相关操作，以此来复用g0栈。\n\n# 参考文献\n* [详尽干货！从源码角度看 Golang 的调度](https://mp.weixin.qq.com/s?__biz=MzU1ODEzNjI2NA==&mid=2247487178&amp;idx=2&amp;sn=121f293c1502b10e7569a0e7216de79e&source=41#wechat_redirect)\n* [深入golang runtime的调度](https://zboya.github.io/post/go_scheduler/)","slug":"golang-协程调度管理源码分析","published":1,"updated":"2020-10-12T08:15:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh351dul001719z49za51u1k","content":"<p>golang 版本：go version go1.15.2 darwin/amd64</p>\n<p>根据启动函数来分析golang MPG的生存周期，忽略cgo相关代码。</p>\n<h1 id=\"MPG\"><a href=\"#MPG\" class=\"headerlink\" title=\"MPG\"></a>MPG</h1><p>MPG是golang调度的重要对象：</p>\n<ul>\n<li>M，表示一个内核线程，是执行用户代码的实际场所</li>\n<li>P，表示一个处理器，管理M需要运行G的相关资源，如内存分配，G的可执行列表，G的空闲列表等</li>\n<li>G，表示一个goroutine，调度基本单元，维护goroutine内部资源，如栈信息，defer列表等</li>\n</ul>\n<h1 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h1><p>启动汇编函数</p>\n<pre class=\" language-asm\"><code class=\"language-asm\">// runtime/asm_amd64.s\n\nTEXT runtime·rt0_go(SB),NOSPLIT,$0\n    // ... 省略 ...\n\n    // create istack out of the given (operating system) stack.\n    // _cgo_init may update stackguard.\n    // 给 runtime.g0 创建栈\n    MOVQ    $runtime·g0(SB), DI\n    LEAQ    (-64*1024+104)(SP), BX\n    MOVQ    BX, g_stackguard0(DI)\n    MOVQ    BX, g_stackguard1(DI)\n    MOVQ    BX, (g_stack+stack_lo)(DI)\n    MOVQ    SP, (g_stack+stack_hi)(DI)\n\n    // ... 省略 ...\n\n    // set the per-goroutine and per-mach \"registers\"\n    get_tls(BX)\n    LEAQ    runtime·g0(SB), CX\n    MOVQ    CX, g(BX)\n    LEAQ    runtime·m0(SB), AX\n\n    // save m->g0 = g0\n    // 绑定 m0 和 g0\n    MOVQ    CX, m_g0(AX)\n    // save m0 to g0->m\n    MOVQ    AX, g_m(CX)\n\n    CLD                // convention is D is always left cleared\n    CALL    runtime·check(SB)\n\n    MOVL    16(SP), AX        // copy argc\n    MOVL    AX, 0(SP)\n    MOVQ    24(SP), AX        // copy argv\n    MOVQ    AX, 8(SP)\n    CALL    runtime·args(SB)       // 解析命令行参数\n    CALL    runtime·osinit(SB)     // 获取CPU核数\n    CALL    runtime·schedinit(SB)  // 初始化调度\n\n    // create a new goroutine to start program\n    MOVQ    $runtime·mainPC(SB), AX        // entry\n    PUSHQ    AX\n    PUSHQ    $0            // arg size\n    CALL    runtime·newproc(SB)// 执行runtime.main\n    POPQ    AX\n    POPQ    AX\n\n    // start this M\n    CALL    runtime·mstart(SB) // 启动m0\n\n    CALL    runtime·abort(SB)    // mstart should never return\n    RET</code></pre>\n<p><code>rt0_go</code>函数主要流程：</p>\n<ul>\n<li>初始化<code>g0</code>、<code>m0</code></li>\n<li><code>g0</code>和<code>m0</code>互相绑定</li>\n<li>初始化相关数据，初始化指定个数的<code>p</code></li>\n<li>创建新<code>g</code>绑定<code>runtime.main</code>函数，加入<code>p</code>的可执行列表中</li>\n<li>启动<code>m0</code>开始循环调度。</li>\n</ul>\n<h2 id=\"schedinit\"><a href=\"#schedinit\" class=\"headerlink\" title=\"schedinit\"></a>schedinit</h2><pre class=\" language-go\"><code class=\"language-go\"><span class=\"token comment\" spellcheck=\"true\">// runtime/proc.go</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">schedinit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// ... 省略 ...</span>\n\n    _g_ <span class=\"token operator\">:=</span> <span class=\"token function\">getg</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 获取当前绑定的g</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 限制M的数量</span>\n    sched<span class=\"token punctuation\">.</span>maxmcount <span class=\"token operator\">=</span> <span class=\"token number\">10000</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// ... 省略 ...</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 创建 p</span>\n    <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>sched<span class=\"token punctuation\">.</span>lock<span class=\"token punctuation\">)</span>\n    sched<span class=\"token punctuation\">.</span>lastpoll <span class=\"token operator\">=</span> <span class=\"token function\">uint64</span><span class=\"token punctuation\">(</span><span class=\"token function\">nanotime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    procs <span class=\"token operator\">:=</span> ncpu\n    <span class=\"token keyword\">if</span> n<span class=\"token punctuation\">,</span> ok <span class=\"token operator\">:=</span> <span class=\"token function\">atoi32</span><span class=\"token punctuation\">(</span><span class=\"token function\">gogetenv</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"GOMAXPROCS\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> ok <span class=\"token operator\">&amp;&amp;</span> n <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n        procs <span class=\"token operator\">=</span> n\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token function\">procresize</span><span class=\"token punctuation\">(</span>procs<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">throw</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"unknown runnable goroutine during bootstrap\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>sched<span class=\"token punctuation\">.</span>lock<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><code>schedinit</code>函数主要流程：</p>\n<ul>\n<li>初始化全局调度相关值</li>\n<li>限制<code>m</code>的最多个数</li>\n<li>初始化指定个数的<code>p</code></li>\n</ul>\n<h2 id=\"newproc\"><a href=\"#newproc\" class=\"headerlink\" title=\"newproc\"></a>newproc</h2><pre class=\" language-go\"><code class=\"language-go\"><span class=\"token comment\" spellcheck=\"true\">// runtime/proc.go</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">newproc</span><span class=\"token punctuation\">(</span>siz <span class=\"token builtin\">int32</span><span class=\"token punctuation\">,</span> fn <span class=\"token operator\">*</span>funcval<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    argp <span class=\"token operator\">:=</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>unsafe<span class=\"token punctuation\">.</span><span class=\"token function\">Pointer</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>fn<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> sys<span class=\"token punctuation\">.</span>PtrSize<span class=\"token punctuation\">)</span>\n    gp <span class=\"token operator\">:=</span> <span class=\"token function\">getg</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    pc <span class=\"token operator\">:=</span> <span class=\"token function\">getcallerpc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">systemstack</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        newg <span class=\"token operator\">:=</span> <span class=\"token function\">newproc1</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">,</span> argp<span class=\"token punctuation\">,</span> siz<span class=\"token punctuation\">,</span> gp<span class=\"token punctuation\">,</span> pc<span class=\"token punctuation\">)</span>\n\n        _p_ <span class=\"token operator\">:=</span> <span class=\"token function\">getg</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>p<span class=\"token punctuation\">.</span><span class=\"token function\">ptr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">runqput</span><span class=\"token punctuation\">(</span>_p_<span class=\"token punctuation\">,</span> newg<span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>\n\n        <span class=\"token keyword\">if</span> mainStarted <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// mainStarted 是在 runtime.main 中设置为 true </span>\n            <span class=\"token function\">wakep</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 尝试找一个p绑定m</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><code>newproc</code>函数主要流程：</p>\n<ul>\n<li>创建栈大小为<code>siz</code>的新<code>g</code>，并关联<code>fn</code></li>\n<li>将新<code>g</code>存放于<code>_p_</code>的可执行队列中</li>\n<li>此时刚初始化，并没有执行<code>runtime.main</code>所以不会执行<code>wakep</code></li>\n</ul>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token comment\" spellcheck=\"true\">// runtime/proc.go</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">newproc1</span><span class=\"token punctuation\">(</span>fn <span class=\"token operator\">*</span>funcval<span class=\"token punctuation\">,</span> argp unsafe<span class=\"token punctuation\">.</span>Pointer<span class=\"token punctuation\">,</span> narg <span class=\"token builtin\">int32</span><span class=\"token punctuation\">,</span> callergp <span class=\"token operator\">*</span>g<span class=\"token punctuation\">,</span> callerpc <span class=\"token builtin\">uintptr</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span>g <span class=\"token punctuation\">{</span>\n    _g_ <span class=\"token operator\">:=</span> <span class=\"token function\">getg</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token function\">acquirem</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// disable preemption because it can be holding p in a local var</span>\n    siz <span class=\"token operator\">:=</span> narg\n    siz <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>siz <span class=\"token operator\">+</span> <span class=\"token number\">7</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;^</span> <span class=\"token number\">7</span>\n\n    _p_ <span class=\"token operator\">:=</span> _g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>p<span class=\"token punctuation\">.</span><span class=\"token function\">ptr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 获取 p</span>\n    newg <span class=\"token operator\">:=</span> <span class=\"token function\">gfget</span><span class=\"token punctuation\">(</span>_p_<span class=\"token punctuation\">)</span>   <span class=\"token comment\" spellcheck=\"true\">// 从 p 的空闲 g 列表中获取 g</span>\n    <span class=\"token keyword\">if</span> newg <span class=\"token operator\">==</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>     <span class=\"token comment\" spellcheck=\"true\">// 没有空闲的 g</span>\n        newg <span class=\"token operator\">=</span> <span class=\"token function\">malg</span><span class=\"token punctuation\">(</span>_StackMin<span class=\"token punctuation\">)</span>           <span class=\"token comment\" spellcheck=\"true\">// 创建一个拥有最小栈的 g</span>\n        <span class=\"token function\">casgstatus</span><span class=\"token punctuation\">(</span>newg<span class=\"token punctuation\">,</span> _Gidle<span class=\"token punctuation\">,</span> _Gdead<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 转换状态</span>\n        <span class=\"token function\">allgadd</span><span class=\"token punctuation\">(</span>newg<span class=\"token punctuation\">)</span>                    <span class=\"token comment\" spellcheck=\"true\">// 向全局 g 列表中添加 g</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// ... 省略 ...</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 填充 g</span>\n    <span class=\"token function\">memclrNoHeapPointers</span><span class=\"token punctuation\">(</span>unsafe<span class=\"token punctuation\">.</span><span class=\"token function\">Pointer</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>newg<span class=\"token punctuation\">.</span>sched<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> unsafe<span class=\"token punctuation\">.</span><span class=\"token function\">Sizeof</span><span class=\"token punctuation\">(</span>newg<span class=\"token punctuation\">.</span>sched<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    newg<span class=\"token punctuation\">.</span>sched<span class=\"token punctuation\">.</span>sp <span class=\"token operator\">=</span> sp\n    newg<span class=\"token punctuation\">.</span>stktopsp <span class=\"token operator\">=</span> sp\n    newg<span class=\"token punctuation\">.</span>sched<span class=\"token punctuation\">.</span>pc <span class=\"token operator\">=</span> <span class=\"token function\">funcPC</span><span class=\"token punctuation\">(</span>goexit<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> sys<span class=\"token punctuation\">.</span>PCQuantum <span class=\"token comment\" spellcheck=\"true\">// 当g执行完后的处理函数</span>\n    newg<span class=\"token punctuation\">.</span>sched<span class=\"token punctuation\">.</span>g <span class=\"token operator\">=</span> <span class=\"token function\">guintptr</span><span class=\"token punctuation\">(</span>unsafe<span class=\"token punctuation\">.</span><span class=\"token function\">Pointer</span><span class=\"token punctuation\">(</span>newg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">gostartcallfn</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>newg<span class=\"token punctuation\">.</span>sched<span class=\"token punctuation\">,</span> fn<span class=\"token punctuation\">)</span>\n    newg<span class=\"token punctuation\">.</span>gopc <span class=\"token operator\">=</span> callerpc\n    newg<span class=\"token punctuation\">.</span>ancestors <span class=\"token operator\">=</span> <span class=\"token function\">saveAncestors</span><span class=\"token punctuation\">(</span>callergp<span class=\"token punctuation\">)</span>\n    newg<span class=\"token punctuation\">.</span>startpc <span class=\"token operator\">=</span> fn<span class=\"token punctuation\">.</span>fn\n    <span class=\"token keyword\">if</span> _g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>curg <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n        newg<span class=\"token punctuation\">.</span>labels <span class=\"token operator\">=</span> _g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>curg<span class=\"token punctuation\">.</span>labels\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token function\">isSystemGoroutine</span><span class=\"token punctuation\">(</span>newg<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        atomic<span class=\"token punctuation\">.</span><span class=\"token function\">Xadd</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>sched<span class=\"token punctuation\">.</span>ngsys<span class=\"token punctuation\">,</span> <span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">casgstatus</span><span class=\"token punctuation\">(</span>newg<span class=\"token punctuation\">,</span> _Gdead<span class=\"token punctuation\">,</span> _Grunnable<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 切换成可执行状态</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 分配goid，如果没有则向p批量获取</span>\n    <span class=\"token keyword\">if</span> _p_<span class=\"token punctuation\">.</span>goidcache <span class=\"token operator\">==</span> _p_<span class=\"token punctuation\">.</span>goidcacheend <span class=\"token punctuation\">{</span>\n        _p_<span class=\"token punctuation\">.</span>goidcache <span class=\"token operator\">=</span> atomic<span class=\"token punctuation\">.</span><span class=\"token function\">Xadd64</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>sched<span class=\"token punctuation\">.</span>goidgen<span class=\"token punctuation\">,</span> _GoidCacheBatch<span class=\"token punctuation\">)</span>\n        _p_<span class=\"token punctuation\">.</span>goidcache <span class=\"token operator\">-=</span> _GoidCacheBatch <span class=\"token operator\">-</span> <span class=\"token number\">1</span>\n        _p_<span class=\"token punctuation\">.</span>goidcacheend <span class=\"token operator\">=</span> _p_<span class=\"token punctuation\">.</span>goidcache <span class=\"token operator\">+</span> _GoidCacheBatch\n    <span class=\"token punctuation\">}</span>\n    newg<span class=\"token punctuation\">.</span>goid <span class=\"token operator\">=</span> <span class=\"token function\">int64</span><span class=\"token punctuation\">(</span>_p_<span class=\"token punctuation\">.</span>goidcache<span class=\"token punctuation\">)</span>\n    _p_<span class=\"token punctuation\">.</span>goidcache<span class=\"token operator\">++</span>\n\n    <span class=\"token function\">releasem</span><span class=\"token punctuation\">(</span>_g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">return</span> newg\n<span class=\"token punctuation\">}</span></code></pre>\n<p><code>newproc1</code>函数主要流程：</p>\n<ul>\n<li>从空闲<code>g</code>列表中获取或新建<code>g</code>，将<code>g</code>的信息填充</li>\n</ul>\n<h2 id=\"mstart\"><a href=\"#mstart\" class=\"headerlink\" title=\"mstart\"></a>mstart</h2><pre class=\" language-go\"><code class=\"language-go\"><span class=\"token comment\" spellcheck=\"true\">// runtime/proc.go</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">mstart</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    _g_ <span class=\"token operator\">:=</span> <span class=\"token function\">getg</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 设置 _g_ 的栈信息</span>\n    osStack <span class=\"token operator\">:=</span> _g_<span class=\"token punctuation\">.</span>stack<span class=\"token punctuation\">.</span>lo <span class=\"token operator\">==</span> <span class=\"token number\">0</span>\n    <span class=\"token keyword\">if</span> osStack <span class=\"token punctuation\">{</span>\n        size <span class=\"token operator\">:=</span> _g_<span class=\"token punctuation\">.</span>stack<span class=\"token punctuation\">.</span>hi\n        <span class=\"token keyword\">if</span> size <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n            size <span class=\"token operator\">=</span> <span class=\"token number\">8192</span> <span class=\"token operator\">*</span> sys<span class=\"token punctuation\">.</span>StackGuardMultiplier\n        <span class=\"token punctuation\">}</span>\n        _g_<span class=\"token punctuation\">.</span>stack<span class=\"token punctuation\">.</span>hi <span class=\"token operator\">=</span> <span class=\"token function\">uintptr</span><span class=\"token punctuation\">(</span><span class=\"token function\">noescape</span><span class=\"token punctuation\">(</span>unsafe<span class=\"token punctuation\">.</span><span class=\"token function\">Pointer</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        _g_<span class=\"token punctuation\">.</span>stack<span class=\"token punctuation\">.</span>lo <span class=\"token operator\">=</span> _g_<span class=\"token punctuation\">.</span>stack<span class=\"token punctuation\">.</span>hi <span class=\"token operator\">-</span> size <span class=\"token operator\">+</span> <span class=\"token number\">1024</span>\n    <span class=\"token punctuation\">}</span>\n    _g_<span class=\"token punctuation\">.</span>stackguard0 <span class=\"token operator\">=</span> _g_<span class=\"token punctuation\">.</span>stack<span class=\"token punctuation\">.</span>lo <span class=\"token operator\">+</span> _StackGuard\n    _g_<span class=\"token punctuation\">.</span>stackguard1 <span class=\"token operator\">=</span> _g_<span class=\"token punctuation\">.</span>stackguard0\n\n    <span class=\"token function\">mstart1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 不会返回</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><code>mstart</code>函数主要流程：</p>\n<ul>\n<li>填充<code>g</code>的栈信息</li>\n<li>让<code>m</code>开始执行<code>g</code>上的代码</li>\n</ul>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token comment\" spellcheck=\"true\">// runtime/proc.go</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">mstart1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    _g_ <span class=\"token operator\">:=</span> <span class=\"token function\">getg</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// ... 省略 ...</span>\n\n    <span class=\"token keyword\">if</span> _g_<span class=\"token punctuation\">.</span>m <span class=\"token operator\">==</span> <span class=\"token operator\">&amp;</span>m0 <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">mstartm0</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 启动 m0 初始化信号处理</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span> fn <span class=\"token operator\">:=</span> _g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>mstartfn<span class=\"token punctuation\">;</span> fn <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 执行m绑定的启动时调用的函数</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span> _g_<span class=\"token punctuation\">.</span>m <span class=\"token operator\">!=</span> <span class=\"token operator\">&amp;</span>m0 <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">acquirep</span><span class=\"token punctuation\">(</span>_g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>nextp<span class=\"token punctuation\">.</span><span class=\"token function\">ptr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        _g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>nextp <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">schedule</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 开始调度</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><code>mstart1</code>函数主要流程：</p>\n<ul>\n<li>如果是<code>m0</code>，则初始化信号处理</li>\n<li>如果有<code>mstartfn</code>，则执行</li>\n<li>如果不是<code>m0</code>，则绑定<code>p</code></li>\n<li>调用<code>schedule</code>启动golang进程的调度。</li>\n</ul>\n<h2 id=\"runtime-main\"><a href=\"#runtime-main\" class=\"headerlink\" title=\"runtime.main\"></a>runtime.main</h2><pre class=\" language-go\"><code class=\"language-go\"><span class=\"token comment\" spellcheck=\"true\">// runtime/proc.go</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    g <span class=\"token operator\">:=</span> <span class=\"token function\">getg</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 确认栈的最大值</span>\n    <span class=\"token keyword\">if</span> sys<span class=\"token punctuation\">.</span>PtrSize <span class=\"token operator\">==</span> <span class=\"token number\">8</span> <span class=\"token punctuation\">{</span>\n        maxstacksize <span class=\"token operator\">=</span> <span class=\"token number\">1000000000</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        maxstacksize <span class=\"token operator\">=</span> <span class=\"token number\">250000000</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Allow newproc to start new Ms.</span>\n    mainStarted <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span> <span class=\"token comment\" spellcheck=\"true\">// 标志 newproc 时可以启动 m</span>\n\n    <span class=\"token keyword\">if</span> GOARCH <span class=\"token operator\">!=</span> <span class=\"token string\">\"wasm\"</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// no threads on wasm yet, so no sysmon</span>\n        <span class=\"token function\">systemstack</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">newm</span><span class=\"token punctuation\">(</span>sysmon<span class=\"token punctuation\">,</span> <span class=\"token boolean\">nil</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 新建 m 去执行 sysmon</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token function\">lockOSThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token function\">doInit</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>runtime_inittask<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 执行runtime包中的init函数</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Record when the world started.</span>\n    runtimeInitTime <span class=\"token operator\">=</span> <span class=\"token function\">nanotime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token function\">gcenable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 开启GC</span>\n\n    main_init_done <span class=\"token operator\">=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">bool</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">doInit</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>main_inittask<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 执行main包中的init函数</span>\n    <span class=\"token function\">close</span><span class=\"token punctuation\">(</span>main_init_done<span class=\"token punctuation\">)</span>\n\n    <span class=\"token function\">unlockOSThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    fn <span class=\"token operator\">:=</span> main_main <span class=\"token comment\" spellcheck=\"true\">// fn 指向main包的main函数</span>\n    <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 执行main包的main函数</span>\n\n    <span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>runtime.main函数主要功能：</p>\n<ul>\n<li>设置了栈的最大值</li>\n<li>创建m去执行sysmon</li>\n<li>调用runtime包的init函数</li>\n<li>启动GC</li>\n<li>执行main包的init函数</li>\n<li>退出</li>\n</ul>\n<h2 id=\"startm\"><a href=\"#startm\" class=\"headerlink\" title=\"startm\"></a>startm</h2><p>除了m0是汇编初始化的，其他的m都是由startm创建的。</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">startm</span><span class=\"token punctuation\">(</span>_p_ <span class=\"token operator\">*</span>p<span class=\"token punctuation\">,</span> spinning <span class=\"token builtin\">bool</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>sched<span class=\"token punctuation\">.</span>lock<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> _p_ <span class=\"token operator\">==</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// _p_ 为空</span>\n        _p_ <span class=\"token operator\">=</span> <span class=\"token function\">pidleget</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 从p空闲列表中获取一个</span>\n        <span class=\"token keyword\">if</span> _p_ <span class=\"token operator\">==</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>  <span class=\"token comment\" spellcheck=\"true\">// 获取失败</span>\n            <span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>sched<span class=\"token punctuation\">.</span>lock<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">if</span> spinning <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">// 如果是自旋状态，调用方增加了nmspinning，但是没有空闲的P，因此可以取消增量并放弃</span>\n                <span class=\"token keyword\">if</span> <span class=\"token function\">int32</span><span class=\"token punctuation\">(</span>atomic<span class=\"token punctuation\">.</span><span class=\"token function\">Xadd</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>sched<span class=\"token punctuation\">.</span>nmspinning<span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token function\">throw</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"startm: negative nmspinning\"</span><span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">return</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    mp <span class=\"token operator\">:=</span> <span class=\"token function\">mget</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 从m空闲列表中获取m</span>\n    <span class=\"token keyword\">if</span> mp <span class=\"token operator\">==</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// 如果空闲列表没有</span>\n        id <span class=\"token operator\">:=</span> <span class=\"token function\">mReserveID</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 获取 m id</span>\n        <span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>sched<span class=\"token punctuation\">.</span>lock<span class=\"token punctuation\">)</span>\n\n        <span class=\"token keyword\">var</span> fn <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span> spinning <span class=\"token punctuation\">{</span>\n            fn <span class=\"token operator\">=</span> mspinning <span class=\"token comment\" spellcheck=\"true\">// 设置 m 的自旋状态函数</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token function\">newm</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">,</span> _p_<span class=\"token punctuation\">,</span> id<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 创建一个m对象</span>\n        <span class=\"token keyword\">return</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>sched<span class=\"token punctuation\">.</span>lock<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> mp<span class=\"token punctuation\">.</span>spinning <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">throw</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"startm: m is spinning\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> mp<span class=\"token punctuation\">.</span>nextp <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">throw</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"startm: m has p\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> spinning <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span><span class=\"token function\">runqempty</span><span class=\"token punctuation\">(</span>_p_<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">throw</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"startm: p has runnable gs\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 由调用者确定是否自旋，并将m.nextp设置为p</span>\n    mp<span class=\"token punctuation\">.</span>spinning <span class=\"token operator\">=</span> spinning\n    mp<span class=\"token punctuation\">.</span>nextp<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span>_p_<span class=\"token punctuation\">)</span>\n    <span class=\"token function\">notewakeup</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>mp<span class=\"token punctuation\">.</span>park<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><code>startm</code>函数主要流程：</p>\n<ul>\n<li>获取一个<code>p</code>，失败则返回<ul>\n<li>获取一个<code>m</code>，如果失败就创建<code>m</code>并返回</li>\n</ul>\n</li>\n<li><code>m</code>暂存<code>p</code></li>\n</ul>\n<h3 id=\"newm\"><a href=\"#newm\" class=\"headerlink\" title=\"newm\"></a>newm</h3><pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">newm</span><span class=\"token punctuation\">(</span>fn <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> _p_ <span class=\"token operator\">*</span>p<span class=\"token punctuation\">,</span> id <span class=\"token builtin\">int64</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    mp <span class=\"token operator\">:=</span> <span class=\"token function\">allocm</span><span class=\"token punctuation\">(</span>_p_<span class=\"token punctuation\">,</span> fn<span class=\"token punctuation\">,</span> id<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 创建新m</span>\n    mp<span class=\"token punctuation\">.</span>nextp<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span>_p_<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 暂存p</span>\n    mp<span class=\"token punctuation\">.</span>sigmask <span class=\"token operator\">=</span> initSigmask <span class=\"token comment\" spellcheck=\"true\">// 信号掩码</span>\n    <span class=\"token function\">newm1</span><span class=\"token punctuation\">(</span>mp<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 绑定操作系统线程</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">allocm</span><span class=\"token punctuation\">(</span>_p_ <span class=\"token operator\">*</span>p<span class=\"token punctuation\">,</span> fn <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> id <span class=\"token builtin\">int64</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span>m <span class=\"token punctuation\">{</span>\n    _g_ <span class=\"token operator\">:=</span> <span class=\"token function\">getg</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">acquirem</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// disable GC because it can be called from sysmon</span>\n    <span class=\"token keyword\">if</span> _g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>p <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">acquirep</span><span class=\"token punctuation\">(</span>_p_<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 临时绑定p</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 清理可以安全删除的m的g0栈信息</span>\n    <span class=\"token keyword\">if</span> sched<span class=\"token punctuation\">.</span>freem <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span> \n        <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>sched<span class=\"token punctuation\">.</span>lock<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">var</span> newList <span class=\"token operator\">*</span>m\n        <span class=\"token keyword\">for</span> freem <span class=\"token operator\">:=</span> sched<span class=\"token punctuation\">.</span>freem<span class=\"token punctuation\">;</span> freem <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> freem<span class=\"token punctuation\">.</span>freeWait <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n                next <span class=\"token operator\">:=</span> freem<span class=\"token punctuation\">.</span>freelink\n                freem<span class=\"token punctuation\">.</span>freelink <span class=\"token operator\">=</span> newList\n                newList <span class=\"token operator\">=</span> freem\n                freem <span class=\"token operator\">=</span> next\n                <span class=\"token keyword\">continue</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token function\">stackfree</span><span class=\"token punctuation\">(</span>freem<span class=\"token punctuation\">.</span>g0<span class=\"token punctuation\">.</span>stack<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 清空freem.g0的栈信息</span>\n            freem <span class=\"token operator\">=</span> freem<span class=\"token punctuation\">.</span>freelink\n        <span class=\"token punctuation\">}</span>\n        sched<span class=\"token punctuation\">.</span>freem <span class=\"token operator\">=</span> newList <span class=\"token comment\" spellcheck=\"true\">// 更新已被释放的m列表</span>\n        <span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>sched<span class=\"token punctuation\">.</span>lock<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    mp <span class=\"token operator\">:=</span> <span class=\"token function\">new</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span>\n    mp<span class=\"token punctuation\">.</span>mstartfn <span class=\"token operator\">=</span> fn <span class=\"token comment\" spellcheck=\"true\">// 绑定m启动函数</span>\n    <span class=\"token function\">mcommoninit</span><span class=\"token punctuation\">(</span>mp<span class=\"token punctuation\">,</span> id<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 绑定mp的id</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 初始化g0栈信息</span>\n    <span class=\"token keyword\">if</span> iscgo <span class=\"token operator\">||</span> GOOS <span class=\"token operator\">==</span> <span class=\"token string\">\"solaris\"</span> <span class=\"token operator\">||</span> GOOS <span class=\"token operator\">==</span> <span class=\"token string\">\"illumos\"</span> <span class=\"token operator\">||</span> GOOS <span class=\"token operator\">==</span> <span class=\"token string\">\"windows\"</span> <span class=\"token operator\">||</span> GOOS <span class=\"token operator\">==</span> <span class=\"token string\">\"plan9\"</span> <span class=\"token operator\">||</span> GOOS <span class=\"token operator\">==</span> <span class=\"token string\">\"darwin\"</span> <span class=\"token operator\">||</span> GOOS <span class=\"token operator\">==</span> <span class=\"token string\">\"ios\"</span> <span class=\"token punctuation\">{</span>\n        mp<span class=\"token punctuation\">.</span>g0 <span class=\"token operator\">=</span> <span class=\"token function\">malg</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        mp<span class=\"token punctuation\">.</span>g0 <span class=\"token operator\">=</span> <span class=\"token function\">malg</span><span class=\"token punctuation\">(</span><span class=\"token number\">8192</span> <span class=\"token operator\">*</span> sys<span class=\"token punctuation\">.</span>StackGuardMultiplier<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    mp<span class=\"token punctuation\">.</span>g0<span class=\"token punctuation\">.</span>m <span class=\"token operator\">=</span> mp\n\n    <span class=\"token keyword\">if</span> _p_ <span class=\"token operator\">==</span> _g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>p<span class=\"token punctuation\">.</span><span class=\"token function\">ptr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">releasep</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 解绑p</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">releasem</span><span class=\"token punctuation\">(</span>_g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">return</span> mp\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">newm1</span><span class=\"token punctuation\">(</span>mp <span class=\"token operator\">*</span>m<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    execLock<span class=\"token punctuation\">.</span><span class=\"token function\">rlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// Prevent process clone.</span>\n    <span class=\"token function\">newosproc</span><span class=\"token punctuation\">(</span>mp<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 绑定操作系统线程</span>\n    execLock<span class=\"token punctuation\">.</span><span class=\"token function\">runlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><code>newm</code>函数主要流程：</p>\n<ul>\n<li>释放可以清理的<code>m</code>的<code>g0</code>栈空间</li>\n<li>新建<code>m</code>，绑定<code>id</code>和启动函数，申请<code>g0</code>栈空间</li>\n<li><code>m</code>暂存当前<code>p</code></li>\n<li>创建与<code>m</code>对应的操作系统线程</li>\n</ul>\n<h2 id=\"netpoll\"><a href=\"#netpoll\" class=\"headerlink\" title=\"netpoll\"></a>netpoll</h2><p><code>netpoll</code>可以让调度器从就绪的网络事件中获取可执行的goroutine。<br>由于golang对每个系统的netpoll做了条件编译，这里就拿linux的实现来说明。</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">netpoll</span><span class=\"token punctuation\">(</span>delay <span class=\"token builtin\">int64</span><span class=\"token punctuation\">)</span> gList <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> events <span class=\"token punctuation\">[</span><span class=\"token number\">128</span><span class=\"token punctuation\">]</span>epollevent\nretry<span class=\"token punctuation\">:</span>\n    n <span class=\"token operator\">:=</span> <span class=\"token function\">epollwait</span><span class=\"token punctuation\">(</span>epfd<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>events<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token function\">int32</span><span class=\"token punctuation\">(</span><span class=\"token function\">len</span><span class=\"token punctuation\">(</span>events<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> waitms<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">var</span> toRun gList\n    <span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token function\">int32</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span>\n        ev <span class=\"token operator\">:=</span> <span class=\"token operator\">&amp;</span>events<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n        <span class=\"token keyword\">var</span> mode <span class=\"token builtin\">int32</span>\n        <span class=\"token keyword\">if</span> ev<span class=\"token punctuation\">.</span>events<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">(</span>_EPOLLIN<span class=\"token operator\">|</span>_EPOLLRDHUP<span class=\"token operator\">|</span>_EPOLLHUP<span class=\"token operator\">|</span>_EPOLLERR<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n            mode <span class=\"token operator\">+=</span> <span class=\"token string\">'r'</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> ev<span class=\"token punctuation\">.</span>events<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">(</span>_EPOLLOUT<span class=\"token operator\">|</span>_EPOLLHUP<span class=\"token operator\">|</span>_EPOLLERR<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n            mode <span class=\"token operator\">+=</span> <span class=\"token string\">'w'</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> mode <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n            pd <span class=\"token operator\">:=</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span>pollDesc<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>unsafe<span class=\"token punctuation\">.</span><span class=\"token function\">Pointer</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>ev<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            pd<span class=\"token punctuation\">.</span>everr <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n            <span class=\"token keyword\">if</span> ev<span class=\"token punctuation\">.</span>events <span class=\"token operator\">==</span> _EPOLLERR <span class=\"token punctuation\">{</span>\n                pd<span class=\"token punctuation\">.</span>everr <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token function\">netpollready</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>toRun<span class=\"token punctuation\">,</span> pd<span class=\"token punctuation\">,</span> mode<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 将符合的g填充进toRun中</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> toRun\n<span class=\"token punctuation\">}</span></code></pre>\n<p><code>netpoll</code>函数主要流程：</p>\n<ul>\n<li>调用<code>epollwait</code>获取就绪的文件描述符</li>\n<li>将<code>pd</code>中的就绪<code>g</code>追加进<code>toRun</code>里面</li>\n<li>返回<code>toRun</code></li>\n</ul>\n<h1 id=\"调度\"><a href=\"#调度\" class=\"headerlink\" title=\"调度\"></a>调度</h1><pre class=\" language-go\"><code class=\"language-go\"><span class=\"token comment\" spellcheck=\"true\">// runtime/proc.go</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">schedule</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    _g_ <span class=\"token operator\">:=</span> <span class=\"token function\">getg</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 如果_g_绑定的m有锁定的g，则抛弃_g_，转而执行锁定的g</span>\n    <span class=\"token keyword\">if</span> _g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>lockedg <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">stoplockedm</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">execute</span><span class=\"token punctuation\">(</span>_g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>lockedg<span class=\"token punctuation\">.</span><span class=\"token function\">ptr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// Never returns.</span>\n    <span class=\"token punctuation\">}</span>\n\ntop<span class=\"token punctuation\">:</span>\n    pp <span class=\"token operator\">:=</span> _g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>p<span class=\"token punctuation\">.</span><span class=\"token function\">ptr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    pp<span class=\"token punctuation\">.</span>preempt <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 如果准备GC，则休眠当前m，直到被唤醒</span>\n    <span class=\"token keyword\">if</span> sched<span class=\"token punctuation\">.</span>gcwaiting <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">gcstopm</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">goto</span> top\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> pp<span class=\"token punctuation\">.</span>runSafePointFn <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">runSafePointFn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token function\">checkTimers</span><span class=\"token punctuation\">(</span>pp<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">var</span> gp <span class=\"token operator\">*</span>g\n    <span class=\"token keyword\">var</span> inheritTime <span class=\"token builtin\">bool</span>\n\n    tryWakeP <span class=\"token operator\">:=</span> <span class=\"token boolean\">false</span>\n    <span class=\"token keyword\">if</span> trace<span class=\"token punctuation\">.</span>enabled <span class=\"token operator\">||</span> trace<span class=\"token punctuation\">.</span>shutdown <span class=\"token punctuation\">{</span>\n        gp <span class=\"token operator\">=</span> <span class=\"token function\">traceReader</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span> gp <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">casgstatus</span><span class=\"token punctuation\">(</span>gp<span class=\"token punctuation\">,</span> _Gwaiting<span class=\"token punctuation\">,</span> _Grunnable<span class=\"token punctuation\">)</span>\n            <span class=\"token function\">traceGoUnpark</span><span class=\"token punctuation\">(</span>gp<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n            tryWakeP <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> gp <span class=\"token operator\">==</span> <span class=\"token boolean\">nil</span> <span class=\"token operator\">&amp;&amp;</span> gcBlackenEnabled <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 找GCWorker</span>\n        gp <span class=\"token operator\">=</span> gcController<span class=\"token punctuation\">.</span><span class=\"token function\">findRunnableGCWorker</span><span class=\"token punctuation\">(</span>_g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>p<span class=\"token punctuation\">.</span><span class=\"token function\">ptr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        tryWakeP <span class=\"token operator\">=</span> tryWakeP <span class=\"token operator\">||</span> gp <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> gp <span class=\"token operator\">==</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 为了让全局可执行队列的g能够运行，这里每操作一定次数就从全局队列中获取</span>\n        <span class=\"token keyword\">if</span> _g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>p<span class=\"token punctuation\">.</span><span class=\"token function\">ptr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>schedtick<span class=\"token operator\">%</span><span class=\"token number\">61</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> sched<span class=\"token punctuation\">.</span>runqsize <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>sched<span class=\"token punctuation\">.</span>lock<span class=\"token punctuation\">)</span>\n            gp <span class=\"token operator\">=</span> <span class=\"token function\">globrunqget</span><span class=\"token punctuation\">(</span>_g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>p<span class=\"token punctuation\">.</span><span class=\"token function\">ptr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n            <span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>sched<span class=\"token punctuation\">.</span>lock<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> gp <span class=\"token operator\">==</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 从本地可执行队列中获取</span>\n        gp<span class=\"token punctuation\">,</span> inheritTime <span class=\"token operator\">=</span> <span class=\"token function\">runqget</span><span class=\"token punctuation\">(</span>_g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>p<span class=\"token punctuation\">.</span><span class=\"token function\">ptr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> gp <span class=\"token operator\">==</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 从其他地方找一个g来执行，如果没有则阻塞在这里</span>\n        gp<span class=\"token punctuation\">,</span> inheritTime <span class=\"token operator\">=</span> <span class=\"token function\">findrunnable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// blocks until work is available</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// This thread is going to run a goroutine and is not spinning anymore,</span>\n    <span class=\"token comment\" spellcheck=\"true\">// so if it was marked as spinning we need to reset it now and potentially</span>\n    <span class=\"token comment\" spellcheck=\"true\">// start a new spinning M.</span>\n    <span class=\"token keyword\">if</span> _g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>spinning <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 如果当前m正在自旋，则重置自旋状态</span>\n        <span class=\"token function\">resetspinning</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span> tryWakeP <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">wakep</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// GCworker 或 tracereader 需要唤醒p</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> gp<span class=\"token punctuation\">.</span>lockedm <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// m将自己的p让给gp锁定的m，自己阻塞等待新p</span>\n        <span class=\"token function\">startlockedm</span><span class=\"token punctuation\">(</span>gp<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">goto</span> top\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token function\">execute</span><span class=\"token punctuation\">(</span>gp<span class=\"token punctuation\">,</span> inheritTime<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 执行gp</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><code>schedule</code>函数主要流程：</p>\n<ul>\n<li>如果<code>g</code>有绑定的<code>m</code>，则直接让绑定<code>m</code>执行<code>g</code></li>\n<li>如果要GC，则休眠当前<code>m</code>，等待唤醒</li>\n<li>从<code>traceReader</code>、<code>GCWorker</code>、<code>globrunqget</code>、<code>runqget</code>、<code>findrunnable</code>函数中获取一个可执行gp</li>\n<li>重置自旋状态</li>\n<li>如果需要唤醒<code>p</code>，则尝试唤醒<code>p</code></li>\n<li>如果获取的<code>gp</code>有锁定的<code>m</code>，则让出自己的<code>p</code>给<code>gp</code>锁定的<code>m</code>，自己则阻塞等待被唤醒</li>\n<li>执行<code>gp</code></li>\n</ul>\n<h2 id=\"findrunnable\"><a href=\"#findrunnable\" class=\"headerlink\" title=\"findrunnable\"></a>findrunnable</h2><pre class=\" language-go\"><code class=\"language-go\"><span class=\"token comment\" spellcheck=\"true\">// runtime/proc.go</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">findrunnable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>gp <span class=\"token operator\">*</span>g<span class=\"token punctuation\">,</span> inheritTime <span class=\"token builtin\">bool</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    _g_ <span class=\"token operator\">:=</span> <span class=\"token function\">getg</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\ntop<span class=\"token punctuation\">:</span>\n    _p_ <span class=\"token operator\">:=</span> _g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>p<span class=\"token punctuation\">.</span><span class=\"token function\">ptr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> sched<span class=\"token punctuation\">.</span>gcwaiting <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">gcstopm</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">goto</span> top\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> _p_<span class=\"token punctuation\">.</span>runSafePointFn <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">runSafePointFn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    now<span class=\"token punctuation\">,</span> pollUntil<span class=\"token punctuation\">,</span> <span class=\"token boolean\">_</span> <span class=\"token operator\">:=</span> <span class=\"token function\">checkTimers</span><span class=\"token punctuation\">(</span>_p_<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 如果有finalizer可用，直接唤醒</span>\n    <span class=\"token keyword\">if</span> fingwait <span class=\"token operator\">&amp;&amp;</span> fingwake <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> gp <span class=\"token operator\">:=</span> <span class=\"token function\">wakefing</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> gp <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">ready</span><span class=\"token punctuation\">(</span>gp<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 本地获取</span>\n    <span class=\"token keyword\">if</span> gp<span class=\"token punctuation\">,</span> inheritTime <span class=\"token operator\">:=</span> <span class=\"token function\">runqget</span><span class=\"token punctuation\">(</span>_p_<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> gp <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> gp<span class=\"token punctuation\">,</span> inheritTime\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 全局获取</span>\n    <span class=\"token comment\" spellcheck=\"true\">// global runq</span>\n    <span class=\"token keyword\">if</span> sched<span class=\"token punctuation\">.</span>runqsize <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>sched<span class=\"token punctuation\">.</span>lock<span class=\"token punctuation\">)</span>\n        gp <span class=\"token operator\">:=</span> <span class=\"token function\">globrunqget</span><span class=\"token punctuation\">(</span>_p_<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>sched<span class=\"token punctuation\">.</span>lock<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span> gp <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> gp<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 没有可以执行的goroutine</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 获取网络事件完成的gp，优化</span>\n    <span class=\"token keyword\">if</span> <span class=\"token function\">netpollinited</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> atomic<span class=\"token punctuation\">.</span><span class=\"token function\">Load</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>netpollWaiters<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> atomic<span class=\"token punctuation\">.</span><span class=\"token function\">Load64</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>sched<span class=\"token punctuation\">.</span>lastpoll<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> list <span class=\"token operator\">:=</span> <span class=\"token function\">netpoll</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">!</span>list<span class=\"token punctuation\">.</span><span class=\"token function\">empty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// non-blocking</span>\n            gp <span class=\"token operator\">:=</span> list<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n            <span class=\"token function\">injectglist</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>list<span class=\"token punctuation\">)</span>\n            <span class=\"token function\">casgstatus</span><span class=\"token punctuation\">(</span>gp<span class=\"token punctuation\">,</span> _Gwaiting<span class=\"token punctuation\">,</span> _Grunnable<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">if</span> trace<span class=\"token punctuation\">.</span>enabled <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">traceGoUnpark</span><span class=\"token punctuation\">(</span>gp<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">return</span> gp<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 从其他的P偷取</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Steal work from other P's.</span>\n    procs <span class=\"token operator\">:=</span> <span class=\"token function\">uint32</span><span class=\"token punctuation\">(</span>gomaxprocs<span class=\"token punctuation\">)</span>\n    ranTimer <span class=\"token operator\">:=</span> <span class=\"token boolean\">false</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 将m置为自旋状态</span>\n    <span class=\"token keyword\">if</span> <span class=\"token operator\">!</span>_g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>spinning <span class=\"token punctuation\">{</span>\n        _g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>spinning <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n        atomic<span class=\"token punctuation\">.</span><span class=\"token function\">Xadd</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>sched<span class=\"token punctuation\">.</span>nmspinning<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 随机从别的p中偷取4次</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> enum <span class=\"token operator\">:=</span> stealOrder<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token function\">fastrand</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">!</span>enum<span class=\"token punctuation\">.</span><span class=\"token function\">done</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> enum<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> sched<span class=\"token punctuation\">.</span>gcwaiting <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">goto</span> top\n            <span class=\"token punctuation\">}</span>\n            stealRunNextG <span class=\"token operator\">:=</span> i <span class=\"token operator\">></span> <span class=\"token number\">2</span> <span class=\"token comment\" spellcheck=\"true\">// first look for ready queues with more than 1 g</span>\n            p2 <span class=\"token operator\">:=</span> allp<span class=\"token punctuation\">[</span>enum<span class=\"token punctuation\">.</span><span class=\"token function\">position</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n            <span class=\"token keyword\">if</span> _p_ <span class=\"token operator\">==</span> p2 <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">continue</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">if</span> gp <span class=\"token operator\">:=</span> <span class=\"token function\">runqsteal</span><span class=\"token punctuation\">(</span>_p_<span class=\"token punctuation\">,</span> p2<span class=\"token punctuation\">,</span> stealRunNextG<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> gp <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">return</span> gp<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span>\n            <span class=\"token punctuation\">}</span>\n\n            <span class=\"token keyword\">if</span> i <span class=\"token operator\">></span> <span class=\"token number\">2</span> <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">></span> <span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">shouldStealTimers</span><span class=\"token punctuation\">(</span>p2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                tnow<span class=\"token punctuation\">,</span> w<span class=\"token punctuation\">,</span> ran <span class=\"token operator\">:=</span> <span class=\"token function\">checkTimers</span><span class=\"token punctuation\">(</span>p2<span class=\"token punctuation\">,</span> now<span class=\"token punctuation\">)</span>\n                now <span class=\"token operator\">=</span> tnow\n                <span class=\"token keyword\">if</span> w <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>pollUntil <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token operator\">||</span> w <span class=\"token operator\">&lt;</span> pollUntil<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    pollUntil <span class=\"token operator\">=</span> w\n                <span class=\"token punctuation\">}</span>\n                <span class=\"token keyword\">if</span> ran <span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">if</span> gp<span class=\"token punctuation\">,</span> inheritTime <span class=\"token operator\">:=</span> <span class=\"token function\">runqget</span><span class=\"token punctuation\">(</span>_p_<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> gp <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n                        <span class=\"token keyword\">return</span> gp<span class=\"token punctuation\">,</span> inheritTime\n                    <span class=\"token punctuation\">}</span>\n                    ranTimer <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> ranTimer <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// Running a timer may have made some goroutine ready.</span>\n        <span class=\"token keyword\">goto</span> top\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// ... 省略 ...    </span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><code>findrunnable</code>函数主要流程：</p>\n<ul>\n<li>如果有<code>finalizer</code>可执行<code>gp</code>，直接唤醒</li>\n<li>如果从本地可执行队列中获取可执行<code>gp</code>，返回<code>gp</code></li>\n<li>如果从全局可执行队列中获取可执行<code>gp</code>，返回<code>gp</code></li>\n<li>如果有就绪的网络事件的<code>gp</code>，返回<code>gp</code></li>\n<li>从其他的<code>p</code>中偷取部分<code>gp</code>，返回<code>gp</code></li>\n</ul>\n<h3 id=\"runqsteal\"><a href=\"#runqsteal\" class=\"headerlink\" title=\"runqsteal\"></a>runqsteal</h3><pre class=\" language-go\"><code class=\"language-go\"><span class=\"token comment\" spellcheck=\"true\">// runtime/proc.go</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">runqsteal</span><span class=\"token punctuation\">(</span>_p_<span class=\"token punctuation\">,</span> p2 <span class=\"token operator\">*</span>p<span class=\"token punctuation\">,</span> stealRunNextG <span class=\"token builtin\">bool</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span>g <span class=\"token punctuation\">{</span>\n    t <span class=\"token operator\">:=</span> _p_<span class=\"token punctuation\">.</span>runqtail\n    n <span class=\"token operator\">:=</span> <span class=\"token function\">runqgrab</span><span class=\"token punctuation\">(</span>p2<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>_p_<span class=\"token punctuation\">.</span>runq<span class=\"token punctuation\">,</span> t<span class=\"token punctuation\">,</span> stealRunNextG<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> n <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">nil</span>\n    <span class=\"token punctuation\">}</span>\n    n<span class=\"token operator\">--</span>\n    gp <span class=\"token operator\">:=</span> _p_<span class=\"token punctuation\">.</span>runq<span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span>t<span class=\"token operator\">+</span>n<span class=\"token punctuation\">)</span><span class=\"token operator\">%</span><span class=\"token function\">uint32</span><span class=\"token punctuation\">(</span><span class=\"token function\">len</span><span class=\"token punctuation\">(</span>_p_<span class=\"token punctuation\">.</span>runq<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">ptr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> n <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> gp\n    <span class=\"token punctuation\">}</span>\n    h <span class=\"token operator\">:=</span> atomic<span class=\"token punctuation\">.</span><span class=\"token function\">LoadAcq</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>_p_<span class=\"token punctuation\">.</span>runqhead<span class=\"token punctuation\">)</span>\n    atomic<span class=\"token punctuation\">.</span><span class=\"token function\">StoreRel</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>_p_<span class=\"token punctuation\">.</span>runqtail<span class=\"token punctuation\">,</span> t<span class=\"token operator\">+</span>n<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> gp\n<span class=\"token punctuation\">}</span></code></pre>\n<p><code>runqsteal</code>函数主要流程：</p>\n<ul>\n<li>获取本地队列队尾坐标</li>\n<li>从<code>p2</code>中获取部分可执行队列</li>\n<li>如果只偷取了一个，直接返回</li>\n<li>否则需要原子修改可执行队列的首尾指针</li>\n</ul>\n<h4 id=\"runqgrab\"><a href=\"#runqgrab\" class=\"headerlink\" title=\"runqgrab\"></a>runqgrab</h4><pre><code>// runtime/proc.go\n\nfunc runqgrab(_p_ *p, batch *[256]guintptr, batchHead uint32, stealRunNextG bool) uint32 {\n    for {\n        h := atomic.LoadAcq(&amp;_p_.runqhead)\n        t := atomic.LoadAcq(&amp;_p_.runqtail) \n        n := t - h\n        n = n - n/2\n        if n == 0 {\n            if stealRunNextG {\n                // Try to steal from _p_.runnext.\n                if next := _p_.runnext; next != 0 {\n                    // 休眠让p不会执行将要偷取的\n                    if _p_.status == _Prunning {\n                        if GOOS != \"windows\" {\n                            usleep(3)\n                        } else {\n                            osyield()\n                        }\n                    }\n                    if !_p_.runnext.cas(next, 0) {\n                        continue\n                    }\n                    batch[batchHead%uint32(len(batch))] = next\n                    return 1\n                }\n            }\n            return 0\n        }\n        if n &gt; uint32(len(_p_.runq)/2) { // 保证队列没有改动\n            continue\n        }\n        // 偷取前半g可执行队列\n        for i := uint32(0); i &lt; n; i++ {\n            g := _p_.runq[(h+i)%uint32(len(_p_.runq))]\n            batch[(batchHead+i)%uint32(len(batch))] = g\n        }\n        // 提交本次消费，如果失败则从新再试一次\n        if atomic.CasRel(&amp;_p_.runqhead, h, h+n) {\n            return n\n        }\n    }\n}</code></pre><p>runqgrab函数主要流程：</p>\n<ul>\n<li>原子获取待偷取<code>p</code>可执行队列首尾位置</li>\n<li>如果没有，则判断是否需要偷取<code>next</code>指针的<code>gp</code></li>\n<li>复制<code>p</code>的前半部分可执行队列</li>\n<li>原子的修改<code>p</code>的可执行队列的首尾指针位置</li>\n</ul>\n<h2 id=\"execute\"><a href=\"#execute\" class=\"headerlink\" title=\"execute\"></a>execute</h2><pre class=\" language-go\"><code class=\"language-go\"><span class=\"token comment\" spellcheck=\"true\">// runtime/proc.go</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">execute</span><span class=\"token punctuation\">(</span>gp <span class=\"token operator\">*</span>g<span class=\"token punctuation\">,</span> inheritTime <span class=\"token builtin\">bool</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    _g_ <span class=\"token operator\">:=</span> <span class=\"token function\">getg</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 互相绑定 _g_.m.curg = gp</span>\n    gp<span class=\"token punctuation\">.</span>m <span class=\"token operator\">=</span> _g_<span class=\"token punctuation\">.</span>m\n    <span class=\"token function\">casgstatus</span><span class=\"token punctuation\">(</span>gp<span class=\"token punctuation\">,</span> _Grunnable<span class=\"token punctuation\">,</span> _Grunning<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 转换状态</span>\n    gp<span class=\"token punctuation\">.</span>waitsince <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    gp<span class=\"token punctuation\">.</span>preempt <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n    gp<span class=\"token punctuation\">.</span>stackguard0 <span class=\"token operator\">=</span> gp<span class=\"token punctuation\">.</span>stack<span class=\"token punctuation\">.</span>lo <span class=\"token operator\">+</span> _StackGuard\n    <span class=\"token keyword\">if</span> <span class=\"token operator\">!</span>inheritTime <span class=\"token punctuation\">{</span>\n        _g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>p<span class=\"token punctuation\">.</span><span class=\"token function\">ptr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>schedtick<span class=\"token operator\">++</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token function\">gogo</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>gp<span class=\"token punctuation\">.</span>sched<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><code>execute</code>函数主要流程：</p>\n<ul>\n<li><code>m</code>和<code>g</code>相互绑定</li>\n<li>设置相关值</li>\n<li>调用<code>gogo</code>函数执行<code>gp</code></li>\n</ul>\n<h3 id=\"gogo\"><a href=\"#gogo\" class=\"headerlink\" title=\"gogo\"></a>gogo</h3><pre class=\" language-asm\"><code class=\"language-asm\">// runtime/asm_amd64.s\n\nTEXT runtime·gogo(SB), NOSPLIT, $16-8\n    MOVQ    buf+0(FP), BX        // gobuf\n    MOVQ    gobuf_g(BX), DX\n    MOVQ    0(DX), CX        // make sure g != nil\n    get_tls(CX)\n    MOVQ    DX, g(CX)\n    MOVQ    gobuf_sp(BX), SP    // restore SP\n    MOVQ    gobuf_ret(BX), AX\n    MOVQ    gobuf_ctxt(BX), DX\n    MOVQ    gobuf_bp(BX), BP\n    MOVQ    $0, gobuf_sp(BX)    // clear to help garbage collector\n    MOVQ    $0, gobuf_ret(BX)\n    MOVQ    $0, gobuf_ctxt(BX)\n    MOVQ    $0, gobuf_bp(BX)\n    MOVQ    gobuf_pc(BX), BX\n    JMP    BX</code></pre>\n<p><code>gogo</code>函数主要流程：</p>\n<ul>\n<li>将<code>gobuf</code>的内容存放到相关寄存器中</li>\n<li>将<code>gobuf</code>的内容清空</li>\n<li>执行<code>gobuf.pc</code></li>\n</ul>\n<h2 id=\"Gosched\"><a href=\"#Gosched\" class=\"headerlink\" title=\"Gosched\"></a>Gosched</h2><p>除了上述的通过运行时启动调度之外，golang还提供了手动的调度函数<code>Gosched</code>函数，该函数在运行时内外都可以触发下一次调度。</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">Gosched</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">checkTimeouts</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">mcall</span><span class=\"token punctuation\">(</span>gosched_m<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">gosched_m</span><span class=\"token punctuation\">(</span>gp <span class=\"token operator\">*</span>g<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">goschedImpl</span><span class=\"token punctuation\">(</span>gp<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">goschedImpl</span><span class=\"token punctuation\">(</span>gp <span class=\"token operator\">*</span>g<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    status <span class=\"token operator\">:=</span> <span class=\"token function\">readgstatus</span><span class=\"token punctuation\">(</span>gp<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> status<span class=\"token operator\">&amp;^</span>_Gscan <span class=\"token operator\">!=</span> _Grunning <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">dumpgstatus</span><span class=\"token punctuation\">(</span>gp<span class=\"token punctuation\">)</span>\n        <span class=\"token function\">throw</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"bad g status\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">casgstatus</span><span class=\"token punctuation\">(</span>gp<span class=\"token punctuation\">,</span> _Grunning<span class=\"token punctuation\">,</span> _Grunnable<span class=\"token punctuation\">)</span>\n    <span class=\"token function\">dropg</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 解绑g和m</span>\n    <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>sched<span class=\"token punctuation\">.</span>lock<span class=\"token punctuation\">)</span>\n    <span class=\"token function\">globrunqput</span><span class=\"token punctuation\">(</span>gp<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 放入全局可执行队列</span>\n    <span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>sched<span class=\"token punctuation\">.</span>lock<span class=\"token punctuation\">)</span>\n\n    <span class=\"token function\">schedule</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 下一次调度</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>Gosched函数主要流程：</p>\n<ul>\n<li>获取gp的状态</li>\n<li>切换gp的状态为_Grunnable</li>\n<li>解绑g和m</li>\n<li>将g存入全局可执行队列中</li>\n<li>启动下一次调度</li>\n</ul>\n<h1 id=\"销毁\"><a href=\"#销毁\" class=\"headerlink\" title=\"销毁\"></a>销毁</h1><pre class=\" language-asm\"><code class=\"language-asm\">TEXT runtime·goexit(SB),NOSPLIT,$0-0\n    BYTE    $0x90    // NOP\n    CALL    runtime·goexit1(SB)    // does not return\n    // traceback from goexit1 must hit code range of goexit\n    BYTE    $0x90    // NOP</code></pre>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">goexit1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n   <span class=\"token keyword\">if</span> raceenabled <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">racegoend</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n   <span class=\"token punctuation\">}</span>\n   <span class=\"token keyword\">if</span> trace<span class=\"token punctuation\">.</span>enabled <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">traceGoEnd</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n   <span class=\"token punctuation\">}</span>\n   <span class=\"token function\">mcall</span><span class=\"token punctuation\">(</span>goexit0<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">goexit0</span><span class=\"token punctuation\">(</span>gp <span class=\"token operator\">*</span>g<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    _g_ <span class=\"token operator\">:=</span> <span class=\"token function\">getg</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 切换g的状态 </span>\n    <span class=\"token function\">casgstatus</span><span class=\"token punctuation\">(</span>gp<span class=\"token punctuation\">,</span> _Grunning<span class=\"token punctuation\">,</span> _Gdead<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 标记系统goroutine </span>\n    <span class=\"token keyword\">if</span> <span class=\"token function\">isSystemGoroutine</span><span class=\"token punctuation\">(</span>gp<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n       atomic<span class=\"token punctuation\">.</span><span class=\"token function\">Xadd</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>sched<span class=\"token punctuation\">.</span>ngsys<span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 清理gp相关的数据</span>\n    gp<span class=\"token punctuation\">.</span>m <span class=\"token operator\">=</span> <span class=\"token boolean\">nil</span>\n    locked <span class=\"token operator\">:=</span> gp<span class=\"token punctuation\">.</span>lockedm <span class=\"token operator\">!=</span> <span class=\"token number\">0</span>\n    gp<span class=\"token punctuation\">.</span>lockedm <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    _g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>lockedg <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    gp<span class=\"token punctuation\">.</span>preemptStop <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n    gp<span class=\"token punctuation\">.</span>paniconfault <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n    gp<span class=\"token punctuation\">.</span>_defer <span class=\"token operator\">=</span> <span class=\"token boolean\">nil</span> <span class=\"token comment\" spellcheck=\"true\">// should be true already but just in case.</span>\n    gp<span class=\"token punctuation\">.</span>_panic <span class=\"token operator\">=</span> <span class=\"token boolean\">nil</span> <span class=\"token comment\" spellcheck=\"true\">// non-nil for Goexit during panic. points at stack-allocated data.</span>\n    gp<span class=\"token punctuation\">.</span>writebuf <span class=\"token operator\">=</span> <span class=\"token boolean\">nil</span>\n    gp<span class=\"token punctuation\">.</span>waitreason <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    gp<span class=\"token punctuation\">.</span>param <span class=\"token operator\">=</span> <span class=\"token boolean\">nil</span>\n    gp<span class=\"token punctuation\">.</span>labels <span class=\"token operator\">=</span> <span class=\"token boolean\">nil</span>\n    gp<span class=\"token punctuation\">.</span>timer <span class=\"token operator\">=</span> <span class=\"token boolean\">nil</span>\n\n    <span class=\"token function\">dropg</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 解绑当前m和gp</span>\n\n    <span class=\"token keyword\">if</span> GOARCH <span class=\"token operator\">==</span> <span class=\"token string\">\"wasm\"</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// no threads yet on wasm</span>\n        <span class=\"token function\">gfput</span><span class=\"token punctuation\">(</span>_g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>p<span class=\"token punctuation\">.</span><span class=\"token function\">ptr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> gp<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 将gp存放到p的空闲列表中</span>\n        <span class=\"token function\">schedule</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 下一次调度</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token function\">gfput</span><span class=\"token punctuation\">(</span>_g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>p<span class=\"token punctuation\">.</span><span class=\"token function\">ptr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> gp<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 将gp存放到p的空闲列表中</span>\n    <span class=\"token keyword\">if</span> locked <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 如果gp锁定了m，则将这个m杀死</span>\n        <span class=\"token keyword\">if</span> GOOS <span class=\"token operator\">!=</span> <span class=\"token string\">\"plan9\"</span> <span class=\"token punctuation\">{</span> \n            <span class=\"token function\">gogo</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>_g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>g0<span class=\"token punctuation\">.</span>sched<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            _g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>lockedExt <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">schedule</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 下一次调度</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><code>goexit0</code>函数主要流程：</p>\n<ul>\n<li>切换<code>g</code>的状态</li>\n<li>解绑<code>g</code>所有绑定的数据</li>\n<li>如果是<code>wasm</code>架构，直接将<code>g</code>存于空闲列表中，并开始下一次调度</li>\n<li>否则，直接将<code>g</code>存于空闲列表中，如果<code>g</code>有锁定的<code>m</code>，则将<code>m</code>杀死，开始下一次调度</li>\n</ul>\n<h1 id=\"切换\"><a href=\"#切换\" class=\"headerlink\" title=\"切换\"></a>切换</h1><h2 id=\"执行完毕切换\"><a href=\"#执行完毕切换\" class=\"headerlink\" title=\"执行完毕切换\"></a>执行完毕切换</h2><p>上面说到，当goroutine执行完毕时，会执行goexit0函数，进而执行下一次调度</p>\n<h2 id=\"主动切换\"><a href=\"#主动切换\" class=\"headerlink\" title=\"主动切换\"></a>主动切换</h2><p>当goroutine中阻塞的操作时，就需要让出CPU，让其他的goroutine执行。所有主动切换都是调用gopark函数来实现的。</p>\n<h3 id=\"gopark\"><a href=\"#gopark\" class=\"headerlink\" title=\"gopark\"></a>gopark</h3><pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">gopark</span><span class=\"token punctuation\">(</span>unlockf <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>g<span class=\"token punctuation\">,</span> unsafe<span class=\"token punctuation\">.</span>Pointer<span class=\"token punctuation\">)</span> <span class=\"token builtin\">bool</span><span class=\"token punctuation\">,</span> lock unsafe<span class=\"token punctuation\">.</span>Pointer<span class=\"token punctuation\">,</span> reason waitReason<span class=\"token punctuation\">,</span> traceEv <span class=\"token builtin\">byte</span><span class=\"token punctuation\">,</span> traceskip <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> reason <span class=\"token operator\">!=</span> waitReasonSleep <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">checkTimeouts</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    mp <span class=\"token operator\">:=</span> <span class=\"token function\">acquirem</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    gp <span class=\"token operator\">:=</span> mp<span class=\"token punctuation\">.</span>curg\n    status <span class=\"token operator\">:=</span> <span class=\"token function\">readgstatus</span><span class=\"token punctuation\">(</span>gp<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> status <span class=\"token operator\">!=</span> _Grunning <span class=\"token operator\">&amp;&amp;</span> status <span class=\"token operator\">!=</span> _Gscanrunning <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">throw</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"gopark: bad g status\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 填充相关参数</span>\n    mp<span class=\"token punctuation\">.</span>waitlock <span class=\"token operator\">=</span> lock\n    mp<span class=\"token punctuation\">.</span>waitunlockf <span class=\"token operator\">=</span> unlockf\n    gp<span class=\"token punctuation\">.</span>waitreason <span class=\"token operator\">=</span> reason\n    mp<span class=\"token punctuation\">.</span>waittraceev <span class=\"token operator\">=</span> traceEv\n    mp<span class=\"token punctuation\">.</span>waittraceskip <span class=\"token operator\">=</span> traceskip\n    <span class=\"token function\">releasem</span><span class=\"token punctuation\">(</span>mp<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\" spellcheck=\"true\">// can't do anything that might move the G between Ms here.</span>\n    <span class=\"token function\">mcall</span><span class=\"token punctuation\">(</span>park_m<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><code>gopark</code>函数主要流程：</p>\n<ul>\n<li>获取当前<code>m</code>绑定的<code>gp</code></li>\n<li>填充相关参数</li>\n<li>利用<code>g0</code>调用<code>park_m</code>函数</li>\n</ul>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">park_m</span><span class=\"token punctuation\">(</span>gp <span class=\"token operator\">*</span>g<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    _g_ <span class=\"token operator\">:=</span> <span class=\"token function\">getg</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token function\">casgstatus</span><span class=\"token punctuation\">(</span>gp<span class=\"token punctuation\">,</span> _Grunning<span class=\"token punctuation\">,</span> _Gwaiting<span class=\"token punctuation\">)</span>\n    <span class=\"token function\">dropg</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 解绑g和m</span>\n\n    <span class=\"token keyword\">if</span> fn <span class=\"token operator\">:=</span> _g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>waitunlockf<span class=\"token punctuation\">;</span> fn <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n        ok <span class=\"token operator\">:=</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span>gp<span class=\"token punctuation\">,</span> _g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>waitlock<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 尝试调用解锁函数</span>\n        _g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>waitunlockf <span class=\"token operator\">=</span> <span class=\"token boolean\">nil</span>\n        _g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>waitlock <span class=\"token operator\">=</span> <span class=\"token boolean\">nil</span>\n        <span class=\"token keyword\">if</span> <span class=\"token operator\">!</span>ok <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 如果解锁成功</span>\n            <span class=\"token function\">casgstatus</span><span class=\"token punctuation\">(</span>gp<span class=\"token punctuation\">,</span> _Gwaiting<span class=\"token punctuation\">,</span> _Grunnable<span class=\"token punctuation\">)</span>\n            <span class=\"token function\">execute</span><span class=\"token punctuation\">(</span>gp<span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 直接执行gp</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">schedule</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 下一次调度</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><code>park_m</code>函数主要流程：</p>\n<ul>\n<li>切换<code>g</code>的状态为等待</li>\n<li>尝试解锁，如果成功则切换状态为可执行，直接调用<code>execute</code>函数执行</li>\n<li>否则，进入下一个调度</li>\n</ul>\n<h3 id=\"goready\"><a href=\"#goready\" class=\"headerlink\" title=\"goready\"></a>goready</h3><p>当goroutine通过<code>gopark</code>函数由<code>_Grunning</code>到<code>_Gwaiting</code>，反向操作<code>goready</code>函数则是将<code>_Gwaiting</code>到<code>_Grunnable</code>。</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">goready</span><span class=\"token punctuation\">(</span>gp <span class=\"token operator\">*</span>g<span class=\"token punctuation\">,</span> traceskip <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">systemstack</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">ready</span><span class=\"token punctuation\">(</span>gp<span class=\"token punctuation\">,</span> traceskip<span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">ready</span><span class=\"token punctuation\">(</span>gp <span class=\"token operator\">*</span>g<span class=\"token punctuation\">,</span> traceskip <span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> next <span class=\"token builtin\">bool</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    status <span class=\"token operator\">:=</span> <span class=\"token function\">readgstatus</span><span class=\"token punctuation\">(</span>gp<span class=\"token punctuation\">)</span>\n\n    _g_ <span class=\"token operator\">:=</span> <span class=\"token function\">getg</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    mp <span class=\"token operator\">:=</span> <span class=\"token function\">acquirem</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 如果不是 _Gwaiting 抛异常</span>\n    <span class=\"token keyword\">if</span> status<span class=\"token operator\">&amp;^</span>_Gscan <span class=\"token operator\">!=</span> _Gwaiting <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">dumpgstatus</span><span class=\"token punctuation\">(</span>gp<span class=\"token punctuation\">)</span>\n        <span class=\"token function\">throw</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"bad g->status in ready\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 切换状态</span>\n    <span class=\"token function\">casgstatus</span><span class=\"token punctuation\">(</span>gp<span class=\"token punctuation\">,</span> _Gwaiting<span class=\"token punctuation\">,</span> _Grunnable<span class=\"token punctuation\">)</span>\n    <span class=\"token function\">runqput</span><span class=\"token punctuation\">(</span>_g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>p<span class=\"token punctuation\">.</span><span class=\"token function\">ptr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> gp<span class=\"token punctuation\">,</span> next<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 存放到本地可执行队列中</span>\n    <span class=\"token function\">wakep</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>                          <span class=\"token comment\" spellcheck=\"true\">// 尝试去唤起p去执行</span>\n    <span class=\"token function\">releasem</span><span class=\"token punctuation\">(</span>mp<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><code>ready</code>函数主要流程：</p>\n<ul>\n<li>获取<code>gp</code>的状态</li>\n<li>获取当前的<code>g</code></li>\n<li>检测<code>gp</code>状态是不是<code>_Gwaiting</code></li>\n<li>由<code>_Gwaiting</code>转换为<code>_Grunnable</code>状态</li>\n<li>放进当前<code>g</code>的<code>m</code>的<code>p</code>中的本地可执行队列中</li>\n</ul>\n<h2 id=\"抢占切换\"><a href=\"#抢占切换\" class=\"headerlink\" title=\"抢占切换\"></a>抢占切换</h2><p>golang调度本质上是非抢占式的，golang利用标志位标志当前的goroutine是否可以被抢占，而触发时机是在栈扩容的时候。<br>golang中有个监控函数，监控着整个进程运行的相关数据，其中就包括检查某个goroutine是否占用CPU时间过长，从而进行标记抢占标记位。</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">sysmon</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// ... 省略 ...</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// ... 省略 ...</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 解绑在陷入系统调用中的p，和抢占长时间运行的g</span>\n        <span class=\"token keyword\">if</span> <span class=\"token function\">retake</span><span class=\"token punctuation\">(</span>now<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n            idle <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            idle<span class=\"token operator\">++</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// ... 省略 ...</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"retake\"><a href=\"#retake\" class=\"headerlink\" title=\"retake\"></a>retake</h3><pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">retake</span><span class=\"token punctuation\">(</span>now <span class=\"token builtin\">int64</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">uint32</span> <span class=\"token punctuation\">{</span>\n    n <span class=\"token operator\">:=</span> <span class=\"token number\">0</span>\n    <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>allpLock<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>allp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span>\n        _p_ <span class=\"token operator\">:=</span> allp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n        <span class=\"token keyword\">if</span> _p_ <span class=\"token operator\">==</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">continue</span>\n        <span class=\"token punctuation\">}</span>\n        pd <span class=\"token operator\">:=</span> <span class=\"token operator\">&amp;</span>_p_<span class=\"token punctuation\">.</span>sysmontick <span class=\"token comment\" spellcheck=\"true\">// sysmon 信息记录</span>\n        s <span class=\"token operator\">:=</span> _p_<span class=\"token punctuation\">.</span>status\n        sysretake <span class=\"token operator\">:=</span> <span class=\"token boolean\">false</span>\n        <span class=\"token keyword\">if</span> s <span class=\"token operator\">==</span> _Prunning <span class=\"token operator\">||</span> s <span class=\"token operator\">==</span> _Psyscall <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 处于 _Prunning 或者 _Psyscall 状态时，如果上一次触发调度的时间已经过去了 10ms，</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 我们就会通过 runtime.preemptone 抢占当前处理器</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 如果G运行时间太长则抢占G</span>\n            t <span class=\"token operator\">:=</span> <span class=\"token function\">int64</span><span class=\"token punctuation\">(</span>_p_<span class=\"token punctuation\">.</span>schedtick<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">if</span> <span class=\"token function\">int64</span><span class=\"token punctuation\">(</span>pd<span class=\"token punctuation\">.</span>schedtick<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> t <span class=\"token punctuation\">{</span>\n                pd<span class=\"token punctuation\">.</span>schedtick <span class=\"token operator\">=</span> <span class=\"token function\">uint32</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span>\n                pd<span class=\"token punctuation\">.</span>schedwhen <span class=\"token operator\">=</span> now\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> pd<span class=\"token punctuation\">.</span>schedwhen<span class=\"token operator\">+</span>forcePreemptNS <span class=\"token operator\">&lt;=</span> now <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">preemptone</span><span class=\"token punctuation\">(</span>_p_<span class=\"token punctuation\">)</span>\n                <span class=\"token comment\" spellcheck=\"true\">// 在_Psyscall时preemptone函数不会工作，因为m没有绑定p</span>\n                sysretake <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> s <span class=\"token operator\">==</span> _Psyscall <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 当处理器处于 _Psyscall 状态时</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 当处理器的运行队列不为空或者不存在空闲处理器时并且当系统调用时间超过了 10ms 时</span>\n            t <span class=\"token operator\">:=</span> <span class=\"token function\">int64</span><span class=\"token punctuation\">(</span>_p_<span class=\"token punctuation\">.</span>syscalltick<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">if</span> <span class=\"token operator\">!</span>sysretake <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">int64</span><span class=\"token punctuation\">(</span>pd<span class=\"token punctuation\">.</span>syscalltick<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> t <span class=\"token punctuation\">{</span>\n                pd<span class=\"token punctuation\">.</span>syscalltick <span class=\"token operator\">=</span> <span class=\"token function\">uint32</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span>\n                pd<span class=\"token punctuation\">.</span>syscallwhen <span class=\"token operator\">=</span> now\n                <span class=\"token keyword\">continue</span>\n            <span class=\"token punctuation\">}</span>\n\n            <span class=\"token keyword\">if</span> <span class=\"token function\">runqempty</span><span class=\"token punctuation\">(</span>_p_<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> atomic<span class=\"token punctuation\">.</span><span class=\"token function\">Load</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>sched<span class=\"token punctuation\">.</span>nmspinning<span class=\"token punctuation\">)</span><span class=\"token operator\">+</span>atomic<span class=\"token punctuation\">.</span><span class=\"token function\">Load</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>sched<span class=\"token punctuation\">.</span>npidle<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> pd<span class=\"token punctuation\">.</span>syscallwhen<span class=\"token operator\">+</span><span class=\"token number\">10</span><span class=\"token operator\">*</span><span class=\"token number\">1000</span><span class=\"token operator\">*</span><span class=\"token number\">1000</span> <span class=\"token operator\">></span> now <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">// 如果_p_没有可执行的g，且有自旋的m或空闲的p，且系统调用时间没有超过10ms</span>\n                <span class=\"token keyword\">continue</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token comment\" spellcheck=\"true\">// Drop allpLock so we can take sched.lock.</span>\n            <span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>allpLock<span class=\"token punctuation\">)</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">// 将p的状态设置为_Pidle，计数器n加1，_p_的系统调用次数+1</span>\n            <span class=\"token function\">incidlelocked</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">if</span> atomic<span class=\"token punctuation\">.</span><span class=\"token function\">Cas</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>_p_<span class=\"token punctuation\">.</span>status<span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">,</span> _Pidle<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                n<span class=\"token operator\">++</span>\n                _p_<span class=\"token punctuation\">.</span>syscalltick<span class=\"token operator\">++</span>\n                <span class=\"token function\">handoffp</span><span class=\"token punctuation\">(</span>_p_<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 让 p 去找其他的事情干</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token function\">incidlelocked</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n            <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>allpLock<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>allpLock<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">uint32</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><code>retake</code>函数主要流程：</p>\n<ul>\n<li>遍历所有的<code>p</code></li>\n<li>如果<code>p</code>长时间没有调度则标记抢占标志位</li>\n<li>如果<code>p</code>在系统调用中，且超过阈值时间，则解绑<code>p</code></li>\n<li>返回解绑<code>p</code>的个数</li>\n</ul>\n<h3 id=\"preemptone\"><a href=\"#preemptone\" class=\"headerlink\" title=\"preemptone\"></a>preemptone</h3><pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">preemptone</span><span class=\"token punctuation\">(</span>_p_ <span class=\"token operator\">*</span>p<span class=\"token punctuation\">)</span> <span class=\"token builtin\">bool</span> <span class=\"token punctuation\">{</span>\n    mp <span class=\"token operator\">:=</span> _p_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span><span class=\"token function\">ptr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> mp <span class=\"token operator\">==</span> <span class=\"token boolean\">nil</span> <span class=\"token operator\">||</span> mp <span class=\"token operator\">==</span> <span class=\"token function\">getg</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>m <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 如果mp为空，或mp是当前运行的m</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span>\n    <span class=\"token punctuation\">}</span>\n    gp <span class=\"token operator\">:=</span> mp<span class=\"token punctuation\">.</span>curg\n    <span class=\"token keyword\">if</span> gp <span class=\"token operator\">==</span> <span class=\"token boolean\">nil</span> <span class=\"token operator\">||</span> gp <span class=\"token operator\">==</span> mp<span class=\"token punctuation\">.</span>g0 <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// gp 不能使 g0</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span>\n    <span class=\"token punctuation\">}</span>\n\n    gp<span class=\"token punctuation\">.</span>preempt <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span> <span class=\"token comment\" spellcheck=\"true\">// 标志gp可以被抢占</span>\n\n    gp<span class=\"token punctuation\">.</span>stackguard0 <span class=\"token operator\">=</span> stackPreempt <span class=\"token comment\" spellcheck=\"true\">// 直接设置为栈顶，方便触发栈扩容</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Request an async preemption of this P.</span>\n    <span class=\"token keyword\">if</span> preemptMSupported <span class=\"token operator\">&amp;&amp;</span> debug<span class=\"token punctuation\">.</span>asyncpreemptoff <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n        _p_<span class=\"token punctuation\">.</span>preempt <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span> <span class=\"token comment\" spellcheck=\"true\">// 标记p快速调度</span>\n        <span class=\"token function\">preemptM</span><span class=\"token punctuation\">(</span>mp<span class=\"token punctuation\">)</span>       <span class=\"token comment\" spellcheck=\"true\">// 向mp发送抢占信号</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"handoffp\"><a href=\"#handoffp\" class=\"headerlink\" title=\"handoffp\"></a>handoffp</h3><pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">handoffp</span><span class=\"token punctuation\">(</span>_p_ <span class=\"token operator\">*</span>p<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 如果本地有可执行的G或全局可执行队列长度不为0，则直接开始执行</span>\n    <span class=\"token keyword\">if</span> <span class=\"token operator\">!</span><span class=\"token function\">runqempty</span><span class=\"token punctuation\">(</span>_p_<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> sched<span class=\"token punctuation\">.</span>runqsize <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">startm</span><span class=\"token punctuation\">(</span>_p_<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 如果可以执行GC，则立即执行</span>\n    <span class=\"token keyword\">if</span> gcBlackenEnabled <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">gcMarkWorkAvailable</span><span class=\"token punctuation\">(</span>_p_<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">startm</span><span class=\"token punctuation\">(</span>_p_<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 如果没有自旋的m和空闲的p，并且增加自旋数成功，则让_p_绑定一个m进入自旋</span>\n    <span class=\"token keyword\">if</span> atomic<span class=\"token punctuation\">.</span><span class=\"token function\">Load</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>sched<span class=\"token punctuation\">.</span>nmspinning<span class=\"token punctuation\">)</span><span class=\"token operator\">+</span>atomic<span class=\"token punctuation\">.</span><span class=\"token function\">Load</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>sched<span class=\"token punctuation\">.</span>npidle<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> atomic<span class=\"token punctuation\">.</span><span class=\"token function\">Cas</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>sched<span class=\"token punctuation\">.</span>nmspinning<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">startm</span><span class=\"token punctuation\">(</span>_p_<span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>sched<span class=\"token punctuation\">.</span>lock<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> sched<span class=\"token punctuation\">.</span>gcwaiting <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// 即将GC</span>\n        _p_<span class=\"token punctuation\">.</span>status <span class=\"token operator\">=</span> _Pgcstop\n        sched<span class=\"token punctuation\">.</span>stopwait<span class=\"token operator\">--</span>\n        <span class=\"token keyword\">if</span> sched<span class=\"token punctuation\">.</span>stopwait <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">notewakeup</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>sched<span class=\"token punctuation\">.</span>stopnote<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>sched<span class=\"token punctuation\">.</span>lock<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> _p_<span class=\"token punctuation\">.</span>runSafePointFn <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> atomic<span class=\"token punctuation\">.</span><span class=\"token function\">Cas</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>_p_<span class=\"token punctuation\">.</span>runSafePointFn<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        sched<span class=\"token punctuation\">.</span><span class=\"token function\">safePointFn</span><span class=\"token punctuation\">(</span>_p_<span class=\"token punctuation\">)</span>\n        sched<span class=\"token punctuation\">.</span>safePointWait<span class=\"token operator\">--</span>\n        <span class=\"token keyword\">if</span> sched<span class=\"token punctuation\">.</span>safePointWait <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">notewakeup</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>sched<span class=\"token punctuation\">.</span>safePointNote<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 此时如果全局队列有可执行的g，则执行</span>\n    <span class=\"token keyword\">if</span> sched<span class=\"token punctuation\">.</span>runqsize <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>sched<span class=\"token punctuation\">.</span>lock<span class=\"token punctuation\">)</span>\n        <span class=\"token function\">startm</span><span class=\"token punctuation\">(</span>_p_<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 如果这是最后运行的P并且没有人正在轮询网络，则需要唤醒另一个M来轮询网络。</span>\n    <span class=\"token keyword\">if</span> sched<span class=\"token punctuation\">.</span>npidle <span class=\"token operator\">==</span> <span class=\"token function\">uint32</span><span class=\"token punctuation\">(</span>gomaxprocs<span class=\"token number\">-1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> atomic<span class=\"token punctuation\">.</span><span class=\"token function\">Load64</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>sched<span class=\"token punctuation\">.</span>lastpoll<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>sched<span class=\"token punctuation\">.</span>lock<span class=\"token punctuation\">)</span>\n        <span class=\"token function\">startm</span><span class=\"token punctuation\">(</span>_p_<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> when <span class=\"token operator\">:=</span> <span class=\"token function\">nobarrierWakeTime</span><span class=\"token punctuation\">(</span>_p_<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> when <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">wakeNetPoller</span><span class=\"token punctuation\">(</span>when<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 都没有则将_p_存放到空闲P列表中</span>\n    <span class=\"token function\">pidleput</span><span class=\"token punctuation\">(</span>_p_<span class=\"token punctuation\">)</span>\n    <span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>sched<span class=\"token punctuation\">.</span>lock<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><code>retake</code>函数主要流程：</p>\n<ul>\n<li>如果<code>p</code>的本地可执行队列不为空，或全局可执行队列不为空，则绑定<code>m</code>去执行</li>\n<li>如果<code>p</code>可以执行GC工作，则绑定m去执行</li>\n<li>如果没有m在自旋且没有空闲的<code>p</code>，且成功设置自旋值，则获取一个<code>m</code>，进入自旋</li>\n<li>如果此时在检测全局可执行队列是否为空，有则绑定<code>m</code>去执行</li>\n<li>如果是最后一个正在运行的<code>p</code>，则绑定<code>m</code>去轮询网络</li>\n<li>都没有则将<code>p</code>存放进空闲<code>p</code>列表</li>\n</ul>\n<h3 id=\"newstack\"><a href=\"#newstack\" class=\"headerlink\" title=\"newstack\"></a>newstack</h3><pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">newstack</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    thisg <span class=\"token operator\">:=</span> <span class=\"token function\">getg</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 当前执行的g</span>\n\n    gp <span class=\"token operator\">:=</span> thisg<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>curg <span class=\"token comment\" spellcheck=\"true\">// m绑定的g</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 判断是否抢占触发的栈扩张</span>\n    preempt <span class=\"token operator\">:=</span> atomic<span class=\"token punctuation\">.</span><span class=\"token function\">Loaduintptr</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>gp<span class=\"token punctuation\">.</span>stackguard0<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> stackPreempt\n\n    <span class=\"token comment\" spellcheck=\"true\">// ... 省略 ...</span>\n\n    <span class=\"token keyword\">if</span> preempt <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// Act like goroutine called runtime.Gosched.</span>\n        <span class=\"token function\">gopreempt_m</span><span class=\"token punctuation\">(</span>gp<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// never return</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// ... 省略 ...</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">gopreempt_m</span><span class=\"token punctuation\">(</span>gp <span class=\"token operator\">*</span>g<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> trace<span class=\"token punctuation\">.</span>enabled <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">traceGoPreempt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">goschedImpl</span><span class=\"token punctuation\">(</span>gp<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><code>goschedImpl</code>函数就是上述Gosched函数的主要执行实体了。</p>\n<p>如果检测到是抢占，则将m绑定的g放入全局可执行队列中。</p>\n<h2 id=\"系统调用切换\"><a href=\"#系统调用切换\" class=\"headerlink\" title=\"系统调用切换\"></a>系统调用切换</h2><p>golang提供了系统调用接口：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">Syscall</span><span class=\"token punctuation\">(</span>trap<span class=\"token punctuation\">,</span> a1<span class=\"token punctuation\">,</span> a2<span class=\"token punctuation\">,</span> a3 <span class=\"token builtin\">uintptr</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>r1<span class=\"token punctuation\">,</span> r2 <span class=\"token builtin\">uintptr</span><span class=\"token punctuation\">,</span> err Errno<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">RawSyscall</span><span class=\"token punctuation\">(</span>trap<span class=\"token punctuation\">,</span> a1<span class=\"token punctuation\">,</span> a2<span class=\"token punctuation\">,</span> a3 <span class=\"token builtin\">uintptr</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>r1<span class=\"token punctuation\">,</span> r2 <span class=\"token builtin\">uintptr</span><span class=\"token punctuation\">,</span> err Errno<span class=\"token punctuation\">)</span></code></pre>\n<p>更多参数可以调用Syscall6或Syscall9。</p>\n<h3 id=\"Syscall\"><a href=\"#Syscall\" class=\"headerlink\" title=\"Syscall\"></a>Syscall</h3><pre class=\" language-asm\"><code class=\"language-asm\">TEXT    ·Syscall(SB),NOSPLIT,$0-56\n    CALL    runtime·entersyscall(SB)\n    MOVQ    a1+8(FP), DI\n    MOVQ    a2+16(FP), SI\n    MOVQ    a3+24(FP), DX\n    MOVQ    trap+0(FP), AX    // syscall entry\n    ADDQ    $0x2000000, AX\n    SYSCALL\n    JCC    ok\n    MOVQ    $-1, r1+32(FP)\n    MOVQ    $0, r2+40(FP)\n    MOVQ    AX, err+48(FP)\n    CALL    runtime·exitsyscall(SB)\n    RET\nok:\n    MOVQ    AX, r1+32(FP)\n    MOVQ    DX, r2+40(FP)\n    MOVQ    $0, err+48(FP)\n    CALL    runtime·exitsyscall(SB)\n    RET</code></pre>\n<p><code>Syscall</code>函数主要流程：</p>\n<ul>\n<li>调用<code>runtime.entersyscall</code></li>\n<li>将参数存至寄存器</li>\n<li>执行系统调用</li>\n<li>将返回值压栈</li>\n<li>调用<code>runtime.exitsyscall</code></li>\n</ul>\n<h4 id=\"entersyscall\"><a href=\"#entersyscall\" class=\"headerlink\" title=\"entersyscall\"></a>entersyscall</h4><pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">entersyscall</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n   <span class=\"token function\">reentersyscall</span><span class=\"token punctuation\">(</span><span class=\"token function\">getcallerpc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">getcallersp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">reentersyscall</span><span class=\"token punctuation\">(</span>pc<span class=\"token punctuation\">,</span> sp <span class=\"token builtin\">uintptr</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    _g_ <span class=\"token operator\">:=</span> <span class=\"token function\">getg</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    _g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>locks<span class=\"token operator\">++</span>\n\n    _g_<span class=\"token punctuation\">.</span>stackguard0 <span class=\"token operator\">=</span> stackPreempt <span class=\"token comment\" spellcheck=\"true\">// 等待被抢占</span>\n    _g_<span class=\"token punctuation\">.</span>throwsplit <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Leave SP around for GC and traceback.</span>\n    <span class=\"token function\">save</span><span class=\"token punctuation\">(</span>pc<span class=\"token punctuation\">,</span> sp<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 保存现场</span>\n    _g_<span class=\"token punctuation\">.</span>syscallsp <span class=\"token operator\">=</span> sp\n    _g_<span class=\"token punctuation\">.</span>syscallpc <span class=\"token operator\">=</span> pc\n    <span class=\"token function\">casgstatus</span><span class=\"token punctuation\">(</span>_g_<span class=\"token punctuation\">,</span> _Grunning<span class=\"token punctuation\">,</span> _Gsyscall<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 切换状态</span>\n    <span class=\"token keyword\">if</span> _g_<span class=\"token punctuation\">.</span>syscallsp <span class=\"token operator\">&lt;</span> _g_<span class=\"token punctuation\">.</span>stack<span class=\"token punctuation\">.</span>lo <span class=\"token operator\">||</span> _g_<span class=\"token punctuation\">.</span>stack<span class=\"token punctuation\">.</span>hi <span class=\"token operator\">&lt;</span> _g_<span class=\"token punctuation\">.</span>syscallsp <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">systemstack</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"entersyscall inconsistent \"</span><span class=\"token punctuation\">,</span> <span class=\"token function\">hex</span><span class=\"token punctuation\">(</span>_g_<span class=\"token punctuation\">.</span>syscallsp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\" [\"</span><span class=\"token punctuation\">,</span> <span class=\"token function\">hex</span><span class=\"token punctuation\">(</span>_g_<span class=\"token punctuation\">.</span>stack<span class=\"token punctuation\">.</span>lo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\",\"</span><span class=\"token punctuation\">,</span> <span class=\"token function\">hex</span><span class=\"token punctuation\">(</span>_g_<span class=\"token punctuation\">.</span>stack<span class=\"token punctuation\">.</span>hi<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"]\\n\"</span><span class=\"token punctuation\">)</span>\n            <span class=\"token function\">throw</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"entersyscall\"</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span> trace<span class=\"token punctuation\">.</span>enabled <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">systemstack</span><span class=\"token punctuation\">(</span>traceGoSysCall<span class=\"token punctuation\">)</span>\n        <span class=\"token comment\" spellcheck=\"true\">// systemstack itself clobbers g.sched.{pc,sp} and we might</span>\n        <span class=\"token comment\" spellcheck=\"true\">// need them later when the G is genuinely blocked in a</span>\n        <span class=\"token comment\" spellcheck=\"true\">// syscall</span>\n        <span class=\"token function\">save</span><span class=\"token punctuation\">(</span>pc<span class=\"token punctuation\">,</span> sp<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span> atomic<span class=\"token punctuation\">.</span><span class=\"token function\">Load</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>sched<span class=\"token punctuation\">.</span>sysmonwait<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">systemstack</span><span class=\"token punctuation\">(</span>entersyscall_sysmon<span class=\"token punctuation\">)</span>\n        <span class=\"token function\">save</span><span class=\"token punctuation\">(</span>pc<span class=\"token punctuation\">,</span> sp<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span> _g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>p<span class=\"token punctuation\">.</span><span class=\"token function\">ptr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>runSafePointFn <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// runSafePointFn may stack split if run on this stack</span>\n        <span class=\"token function\">systemstack</span><span class=\"token punctuation\">(</span>runSafePointFn<span class=\"token punctuation\">)</span>\n        <span class=\"token function\">save</span><span class=\"token punctuation\">(</span>pc<span class=\"token punctuation\">,</span> sp<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    _g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>syscalltick <span class=\"token operator\">=</span> _g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>p<span class=\"token punctuation\">.</span><span class=\"token function\">ptr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>syscalltick\n    _g_<span class=\"token punctuation\">.</span>sysblocktraced <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n    pp <span class=\"token operator\">:=</span> _g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>p<span class=\"token punctuation\">.</span><span class=\"token function\">ptr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    pp<span class=\"token punctuation\">.</span>m <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    _g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>oldp<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span>pp<span class=\"token punctuation\">)</span>\n    _g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>p <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    atomic<span class=\"token punctuation\">.</span><span class=\"token function\">Store</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>pp<span class=\"token punctuation\">.</span>status<span class=\"token punctuation\">,</span> _Psyscall<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 切换p的状态</span>\n    <span class=\"token keyword\">if</span> sched<span class=\"token punctuation\">.</span>gcwaiting <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">systemstack</span><span class=\"token punctuation\">(</span>entersyscall_gcwait<span class=\"token punctuation\">)</span>\n        <span class=\"token function\">save</span><span class=\"token punctuation\">(</span>pc<span class=\"token punctuation\">,</span> sp<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    _g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>locks<span class=\"token operator\">--</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"exitsyscall\"><a href=\"#exitsyscall\" class=\"headerlink\" title=\"exitsyscall\"></a>exitsyscall</h4><pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">exitsyscall</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    _g_ <span class=\"token operator\">:=</span> <span class=\"token function\">getg</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    _g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>locks<span class=\"token operator\">++</span> \n\n    oldp <span class=\"token operator\">:=</span> _g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>oldp<span class=\"token punctuation\">.</span><span class=\"token function\">ptr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    _g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>oldp <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    <span class=\"token keyword\">if</span> <span class=\"token function\">exitsyscallfast</span><span class=\"token punctuation\">(</span>oldp<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// 尝试获取系统调用前绑定的p</span>\n        _g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>p<span class=\"token punctuation\">.</span><span class=\"token function\">ptr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>syscalltick<span class=\"token operator\">++</span>\n        <span class=\"token function\">casgstatus</span><span class=\"token punctuation\">(</span>_g_<span class=\"token punctuation\">,</span> _Gsyscall<span class=\"token punctuation\">,</span> _Grunning<span class=\"token punctuation\">)</span>\n        _g_<span class=\"token punctuation\">.</span>syscallsp <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n        _g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>locks<span class=\"token operator\">--</span>\n        <span class=\"token keyword\">if</span> _g_<span class=\"token punctuation\">.</span>preempt <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 如果抢占，就设置stackguard0为stackPreempt</span>\n            _g_<span class=\"token punctuation\">.</span>stackguard0 <span class=\"token operator\">=</span> stackPreempt\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 否则恢复真实栈帧</span>\n            _g_<span class=\"token punctuation\">.</span>stackguard0 <span class=\"token operator\">=</span> _g_<span class=\"token punctuation\">.</span>stack<span class=\"token punctuation\">.</span>lo <span class=\"token operator\">+</span> _StackGuard\n        <span class=\"token punctuation\">}</span>\n        _g_<span class=\"token punctuation\">.</span>throwsplit <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n\n        <span class=\"token keyword\">if</span> sched<span class=\"token punctuation\">.</span>disable<span class=\"token punctuation\">.</span>user <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span><span class=\"token function\">schedEnabled</span><span class=\"token punctuation\">(</span>_g_<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// Scheduling of this goroutine is disabled.</span>\n            <span class=\"token function\">Gosched</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 开始调度</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">return</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 没有p被绑定的情况</span>\n    _g_<span class=\"token punctuation\">.</span>sysexitticks <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    _g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>locks<span class=\"token operator\">--</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Call the scheduler.</span>\n    <span class=\"token function\">mcall</span><span class=\"token punctuation\">(</span>exitsyscall0<span class=\"token punctuation\">)</span>\n\n    _g_<span class=\"token punctuation\">.</span>syscallsp <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    _g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>p<span class=\"token punctuation\">.</span><span class=\"token function\">ptr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>syscalltick<span class=\"token operator\">++</span>\n    _g_<span class=\"token punctuation\">.</span>throwsplit <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><code>exitsyscall</code>函数主要流程：</p>\n<ul>\n<li>获取系统调用前绑定的<code>oldp</code></li>\n<li>尝试获取<code>oldp</code>或从空闲列表获取<code>p</code></li>\n<li>如果成功获取<code>p</code>，改变相关设置，开始下一轮调度</li>\n<li>如果没有获取，则调用<code>exitsyscall0</code></li>\n</ul>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">exitsyscall0</span><span class=\"token punctuation\">(</span>gp <span class=\"token operator\">*</span>g<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    _g_ <span class=\"token operator\">:=</span> <span class=\"token function\">getg</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token function\">casgstatus</span><span class=\"token punctuation\">(</span>gp<span class=\"token punctuation\">,</span> _Gsyscall<span class=\"token punctuation\">,</span> _Grunnable<span class=\"token punctuation\">)</span>\n    <span class=\"token function\">dropg</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>sched<span class=\"token punctuation\">.</span>lock<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">var</span> _p_ <span class=\"token operator\">*</span>p\n    <span class=\"token keyword\">if</span> <span class=\"token function\">schedEnabled</span><span class=\"token punctuation\">(</span>_g_<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// 如果可以调度_g_</span>\n        _p_ <span class=\"token operator\">=</span> <span class=\"token function\">pidleget</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 从p空闲列表中获取p</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> _p_ <span class=\"token operator\">==</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">globrunqput</span><span class=\"token punctuation\">(</span>gp<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 没有可用的p，就将gp存放于全局可执行列表中</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> atomic<span class=\"token punctuation\">.</span><span class=\"token function\">Load</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>sched<span class=\"token punctuation\">.</span>sysmonwait<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n        atomic<span class=\"token punctuation\">.</span><span class=\"token function\">Store</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>sched<span class=\"token punctuation\">.</span>sysmonwait<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">notewakeup</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>sched<span class=\"token punctuation\">.</span>sysmonnote<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>sched<span class=\"token punctuation\">.</span>lock<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> _p_ <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// 如果有可用的p</span>\n        <span class=\"token function\">acquirep</span><span class=\"token punctuation\">(</span>_p_<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 直接绑定当前的m</span>\n        <span class=\"token function\">execute</span><span class=\"token punctuation\">(</span>gp<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 执行gp</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> _g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>lockedg <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// 如果m有锁定的g</span>\n        <span class=\"token comment\" spellcheck=\"true\">// Wait until another thread schedules gp and so m again.</span>\n        <span class=\"token function\">stoplockedm</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>   <span class=\"token comment\" spellcheck=\"true\">// 释放p，休眠m，会阻塞</span>\n        <span class=\"token function\">execute</span><span class=\"token punctuation\">(</span>gp<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 执行gp</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">stopm</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 将m休眠，并存于m空闲列表中，会阻塞</span>\n    <span class=\"token function\">schedule</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 下一次调度</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><code>exitsyscall0</code>函数主要流程：</p>\n<ul>\n<li>切换<code>gp</code>状态为<code>_Grunnable</code></li>\n<li>解绑<code>g</code>和<code>m</code></li>\n<li>尝试获取一个空闲的<code>_p_</code></li>\n<li>如果没有获取到就把<code>gp</code>放到全局可执行列表中</li>\n<li>如果获取到了，就直接绑定当前的<code>m</code>，执行<code>gp</code></li>\n<li>如果有<code>m</code>有锁定的<code>g</code>，释放p，休眠m，等待被唤醒</li>\n<li>否则<code>m</code>将放置与全局<code>m</code>空闲列表中，等待下一次调度</li>\n</ul>\n<p>exitsyscall0函数如果没有p则会将m休眠</p>\n<h3 id=\"RawSyscall\"><a href=\"#RawSyscall\" class=\"headerlink\" title=\"RawSyscall\"></a>RawSyscall</h3><pre class=\" language-asm\"><code class=\"language-asm\">TEXT ·RawSyscall(SB),NOSPLIT,$0-56\n    MOVQ    a1+8(FP), DI\n    MOVQ    a2+16(FP), SI\n    MOVQ    a3+24(FP), DX\n    MOVQ    trap+0(FP), AX    // syscall entry\n    ADDQ    $0x2000000, AX\n    SYSCALL\n    JCC    ok1\n    MOVQ    $-1, r1+32(FP)\n    MOVQ    $0, r2+40(FP)\n    MOVQ    AX, err+48(FP)\n    RET\nok1:\n    MOVQ    AX, r1+32(FP)\n    MOVQ    DX, r2+40(FP)\n    MOVQ    $0, err+48(FP)\n    RET</code></pre>\n<p><code>RawSyscall</code>函数主要流程：</p>\n<ul>\n<li>将参数存至寄存器</li>\n<li>执行系统调用</li>\n<li>将返回值压栈</li>\n</ul>\n<p><code>RawSyscall</code>函数并没有执行<code>runtime.entersyscall</code>和<code>runtime.exitsyscall</code>函数，由于没有执行相关操作导致golang无法准确的调度，可能会导致长时间系统调用，其他的goroutine无法得到执行。</p>\n<h1 id=\"辅助函数\"><a href=\"#辅助函数\" class=\"headerlink\" title=\"辅助函数\"></a>辅助函数</h1><h2 id=\"getg\"><a href=\"#getg\" class=\"headerlink\" title=\"getg\"></a>getg</h2><p>获取当前的<code>g</code>，由于是编译器填充的，所以没有源码。<br>一般都是从TLS寄存器获取的。</p>\n<h2 id=\"mcall\"><a href=\"#mcall\" class=\"headerlink\" title=\"mcall\"></a>mcall</h2><pre class=\" language-asm\"><code class=\"language-asm\">TEXT runtime·mcall(SB), NOSPLIT, $0-8\n    MOVQ    fn+0(FP), DI\n\n    get_tls(CX)\n    MOVQ    g(CX), AX    // save state in g->sched\n    MOVQ    0(SP), BX    // caller's PC\n    MOVQ    BX, (g_sched+gobuf_pc)(AX)\n    LEAQ    fn+0(FP), BX    // caller's SP\n    MOVQ    BX, (g_sched+gobuf_sp)(AX)\n    MOVQ    AX, (g_sched+gobuf_g)(AX)\n    MOVQ    BP, (g_sched+gobuf_bp)(AX)\n\n    // switch to m->g0 & its stack, call fn\n    MOVQ    g(CX), BX\n    MOVQ    g_m(BX), BX\n    MOVQ    m_g0(BX), SI\n    CMPQ    SI, AX    // if g == m->g0 call badmcall\n    JNE    3(PC)\n    MOVQ    $runtime·badmcall(SB), AX\n    JMP    AX\n    MOVQ    SI, g(CX)    // g = m->g0\n    MOVQ    (g_sched+gobuf_sp)(SI), SP    // sp = m->g0->sched.sp\n    PUSHQ    AX\n    MOVQ    DI, DX\n    MOVQ    0(DI), DI\n    CALL    DI // 执行fn，不能返回\n    POPQ    AX\n    MOVQ    $runtime·badmcall2(SB), AX\n    JMP    AX\n    RET</code></pre>\n<p><code>mcall</code>函数切换到<code>m</code>的<code>g0</code>调用<code>fn(g)</code>，<code>fn</code>是不能返回的。</p>\n<h2 id=\"systemstack\"><a href=\"#systemstack\" class=\"headerlink\" title=\"systemstack\"></a>systemstack</h2><pre class=\" language-asm\"><code class=\"language-asm\">TEXT runtime·systemstack(SB), NOSPLIT, $0-8\n    MOVQ    fn+0(FP), DI    // DI = fn\n    get_tls(CX)\n    MOVQ    g(CX), AX    // AX = g\n    MOVQ    g_m(AX), BX    // BX = m\n\n    CMPQ    AX, m_gsignal(BX) // g == m.gsignal\n    JEQ    noswitch\n\n    MOVQ    m_g0(BX), DX    // DX = g0\n    CMPQ    AX, DX // g == g0\n    JEQ    noswitch\n\n    CMPQ    AX, m_curg(BX) // g == m.curg\n    JNE    bad\n\n    // 保存当前g的栈信息\n    MOVQ    $runtime·systemstack_switch(SB), SI\n    MOVQ    SI, (g_sched+gobuf_pc)(AX)\n    MOVQ    SP, (g_sched+gobuf_sp)(AX)\n    MOVQ    AX, (g_sched+gobuf_g)(AX)\n    MOVQ    BP, (g_sched+gobuf_bp)(AX)\n\n    // 切换到g0\n    MOVQ    DX, g(CX)\n    MOVQ    (g_sched+gobuf_sp)(DX), BX\n    // make it look like mstart called systemstack on g0, to stop traceback\n    SUBQ    $8, BX\n    MOVQ    $runtime·mstart(SB), DX\n    MOVQ    DX, 0(BX)\n    MOVQ    BX, SP\n\n    // call target function\n    MOVQ    DI, DX\n    MOVQ    0(DI), DI\n    CALL    DI // 执行目标函数\n\n    // 恢复原有g\n    get_tls(CX)\n    MOVQ    g(CX), AX\n    MOVQ    g_m(AX), BX\n    MOVQ    m_curg(BX), AX\n    MOVQ    AX, g(CX)\n    MOVQ    (g_sched+gobuf_sp)(AX), SP\n    MOVQ    $0, (g_sched+gobuf_sp)(AX)\n    RET</code></pre>\n<p>systemstack函数主要流程：</p>\n<ul>\n<li>检测相关参数</li>\n<li>保存g现场</li>\n<li>切换到g0，并执行fn(g)</li>\n<li>恢复原有g</li>\n</ul>\n<h2 id=\"acquirem\"><a href=\"#acquirem\" class=\"headerlink\" title=\"acquirem\"></a>acquirem</h2><pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">acquirem</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span>m <span class=\"token punctuation\">{</span>\n    _g_ <span class=\"token operator\">:=</span> <span class=\"token function\">getg</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    _g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>locks<span class=\"token operator\">++</span>\n    <span class=\"token keyword\">return</span> _g_<span class=\"token punctuation\">.</span>m\n<span class=\"token punctuation\">}</span></code></pre>\n<p><code>acquirem</code>函数主要是增加<code>locks</code>引用计数，并返回当前的m。主要是防止GC回收m。</p>\n<h2 id=\"releasem\"><a href=\"#releasem\" class=\"headerlink\" title=\"releasem\"></a>releasem</h2><pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">releasem</span><span class=\"token punctuation\">(</span>mp <span class=\"token operator\">*</span>m<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    _g_ <span class=\"token operator\">:=</span> <span class=\"token function\">getg</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    mp<span class=\"token punctuation\">.</span>locks<span class=\"token operator\">--</span>\n    <span class=\"token keyword\">if</span> mp<span class=\"token punctuation\">.</span>locks <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> _g_<span class=\"token punctuation\">.</span>preempt <span class=\"token punctuation\">{</span>\n        _g_<span class=\"token punctuation\">.</span>stackguard0 <span class=\"token operator\">=</span> stackPreempt\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><code>releasem</code>函数主要是减少<code>locks</code>引用计数，并判断是否需要<code>g</code>被抢占</p>\n<h2 id=\"acquirep\"><a href=\"#acquirep\" class=\"headerlink\" title=\"acquirep\"></a>acquirep</h2><pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">acquirep</span><span class=\"token punctuation\">(</span>_p_ <span class=\"token operator\">*</span>p<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">wirep</span><span class=\"token punctuation\">(</span>_p_<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">wirep</span><span class=\"token punctuation\">(</span>_p_ <span class=\"token operator\">*</span>p<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    _g_ <span class=\"token operator\">:=</span> <span class=\"token function\">getg</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    _g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>p<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span>_p_<span class=\"token punctuation\">)</span>\n    _p_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span>_g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">)</span>\n    _p_<span class=\"token punctuation\">.</span>status <span class=\"token operator\">=</span> _Prunning\n<span class=\"token punctuation\">}</span></code></pre>\n<p><code>acquirep</code>函数主要流程：</p>\n<ul>\n<li>绑定<code>p</code>和<code>m</code></li>\n<li>将<code>p</code>的状态置为<code>_Prunning</code></li>\n</ul>\n<h2 id=\"releasep\"><a href=\"#releasep\" class=\"headerlink\" title=\"releasep\"></a>releasep</h2><pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">releasep</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span>p <span class=\"token punctuation\">{</span>\n    _g_ <span class=\"token operator\">:=</span> <span class=\"token function\">getg</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    _p_ <span class=\"token operator\">:=</span> _g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>p<span class=\"token punctuation\">.</span><span class=\"token function\">ptr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    _g_<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">.</span>p <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    _p_<span class=\"token punctuation\">.</span>m <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    _p_<span class=\"token punctuation\">.</span>status <span class=\"token operator\">=</span> _Pidle\n    <span class=\"token keyword\">return</span> _p_\n<span class=\"token punctuation\">}</span></code></pre>\n<p><code>releasep</code>函数主要流程：</p>\n<ul>\n<li>解绑<code>m</code>和<code>p</code></li>\n<li>将<code>p</code>的状态置为<code>_Pidle</code></li>\n<li>返回<code>p</code></li>\n</ul>\n<h1 id=\"疑问\"><a href=\"#疑问\" class=\"headerlink\" title=\"疑问\"></a>疑问</h1><h2 id=\"p的本地可执行列表无锁，其他p怎么偷取可执行列表\"><a href=\"#p的本地可执行列表无锁，其他p怎么偷取可执行列表\" class=\"headerlink\" title=\"p的本地可执行列表无锁，其他p怎么偷取可执行列表\"></a>p的本地可执行列表无锁，其他p怎么偷取可执行列表</h2><p>通过原子cas的方式提交列表头尾位置，如果失败则重新偷取。</p>\n<h2 id=\"g进入-Gwaiting状态后去哪里了\"><a href=\"#g进入-Gwaiting状态后去哪里了\" class=\"headerlink\" title=\"g进入_Gwaiting状态后去哪里了\"></a>g进入_Gwaiting状态后去哪里了</h2><ul>\n<li>如果<code>g</code>是被抢占了，则将g的状态改为<code>_Grunnable</code>，放入全局可执行队列中</li>\n<li>如果是主动切换，调用<code>gopark</code>的调用者需要维护<code>sudog</code>列表（<code>sudog</code>用于保存调用<code>gopark</code>的<code>g</code>），接收已完成的<code>goroutine</code>，然后调用<code>goready</code>，将他们状态置为<code>_Grunnable</code>，存入本地的可执行队列中。</li>\n</ul>\n<h2 id=\"m进入自旋，在干嘛\"><a href=\"#m进入自旋，在干嘛\" class=\"headerlink\" title=\"m进入自旋，在干嘛\"></a>m进入自旋，在干嘛</h2><p><code>m</code>自旋，即<code>m</code>阻塞于<code>schedule()</code>的<code>findrunnable()</code>，<code>m</code>会一直尝试获取可执行的<code>g</code>去工作。</p>\n<h2 id=\"g0栈复用\"><a href=\"#g0栈复用\" class=\"headerlink\" title=\"g0栈复用\"></a>g0栈复用</h2><p><code>g0</code>的栈在golang中不同系统采用不同的初始化方式。</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">if</span> iscgo <span class=\"token operator\">||</span> GOOS <span class=\"token operator\">==</span> <span class=\"token string\">\"solaris\"</span> <span class=\"token operator\">||</span> GOOS <span class=\"token operator\">==</span> <span class=\"token string\">\"illumos\"</span> <span class=\"token operator\">||</span> GOOS <span class=\"token operator\">==</span> <span class=\"token string\">\"windows\"</span> <span class=\"token operator\">||</span> GOOS <span class=\"token operator\">==</span> <span class=\"token string\">\"plan9\"</span> <span class=\"token operator\">||</span> GOOS <span class=\"token operator\">==</span> <span class=\"token string\">\"darwin\"</span> <span class=\"token operator\">||</span> GOOS <span class=\"token operator\">==</span> <span class=\"token string\">\"ios\"</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 如果是上面的情况 g0栈是用的 pthread_create 线程栈</span>\n        mp<span class=\"token punctuation\">.</span>g0 <span class=\"token operator\">=</span> <span class=\"token function\">malg</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        mp<span class=\"token punctuation\">.</span>g0 <span class=\"token operator\">=</span> <span class=\"token function\">malg</span><span class=\"token punctuation\">(</span><span class=\"token number\">8192</span> <span class=\"token operator\">*</span> sys<span class=\"token punctuation\">.</span>StackGuardMultiplier<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<p>每次切到<code>g0</code>栈执行指令时，<code>g0-&gt;sched.sp</code>在初始化后没有修改该过，所以每次切换到g0时栈起始值相同，每次调用<code>mcall</code>都会从指定栈位置开始执行相关操作，以此来复用g0栈。</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ul>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODEzNjI2NA==&amp;mid=2247487178&amp;idx=2&amp;sn=121f293c1502b10e7569a0e7216de79e&amp;source=41#wechat_redirect\" target=\"_blank\" rel=\"noopener\">详尽干货！从源码角度看 Golang 的调度</a></li>\n<li><a href=\"https://zboya.github.io/post/go_scheduler/\" target=\"_blank\" rel=\"noopener\">深入golang runtime的调度</a></li>\n</ul>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"friends":[{"avatar":"https://img-1251474779.cos.ap-beijing.myqcloud.com/icon.png","name":"djaigo","introduction":"好好学习，天天向上","url":"/","title":"前去学习"},{"avatar":"https://awps-assets.meituan.net/mit/blog/v20190629/asset/icon/favicon.ico?v=Whistle&t=20181017-1r","name":"美团技术团队","introduction":"一行代码，亿万生活。","url":"https://tech.meituan.com/","title":"点个外卖-->"},{"avatar":"","name":"鸟窝","introduction":"rpcx作者","url":"https://colobu.com/","title":"进个鸟窝-->"},{"avatar":"https://d1j8pt39hxlh3d.cloudfront.net/emoji/emojione/5.0/png/unicode/32/1f92a.png","name":"labuladong的算法小抄","introduction":"算法大神","url":"https://labuladong.gitbook.io/algo/","title":"学个算法-->"}]}},"excerpt":"","more":"<p>golang 版本：go version go1.15.2 darwin/amd64</p>\n<p>根据启动函数来分析golang MPG的生存周期，忽略cgo相关代码。</p>\n<h1 id=\"MPG\"><a href=\"#MPG\" class=\"headerlink\" title=\"MPG\"></a>MPG</h1><p>MPG是golang调度的重要对象：</p>\n<ul>\n<li>M，表示一个内核线程，是执行用户代码的实际场所</li>\n<li>P，表示一个处理器，管理M需要运行G的相关资源，如内存分配，G的可执行列表，G的空闲列表等</li>\n<li>G，表示一个goroutine，调度基本单元，维护goroutine内部资源，如栈信息，defer列表等</li>\n</ul>\n<h1 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h1><p>启动汇编函数</p>\n<pre><code class=\"asm\">// runtime/asm_amd64.s\n\nTEXT runtime·rt0_go(SB),NOSPLIT,$0\n    // ... 省略 ...\n\n    // create istack out of the given (operating system) stack.\n    // _cgo_init may update stackguard.\n    // 给 runtime.g0 创建栈\n    MOVQ    $runtime·g0(SB), DI\n    LEAQ    (-64*1024+104)(SP), BX\n    MOVQ    BX, g_stackguard0(DI)\n    MOVQ    BX, g_stackguard1(DI)\n    MOVQ    BX, (g_stack+stack_lo)(DI)\n    MOVQ    SP, (g_stack+stack_hi)(DI)\n\n    // ... 省略 ...\n\n    // set the per-goroutine and per-mach &quot;registers&quot;\n    get_tls(BX)\n    LEAQ    runtime·g0(SB), CX\n    MOVQ    CX, g(BX)\n    LEAQ    runtime·m0(SB), AX\n\n    // save m-&gt;g0 = g0\n    // 绑定 m0 和 g0\n    MOVQ    CX, m_g0(AX)\n    // save m0 to g0-&gt;m\n    MOVQ    AX, g_m(CX)\n\n    CLD                // convention is D is always left cleared\n    CALL    runtime·check(SB)\n\n    MOVL    16(SP), AX        // copy argc\n    MOVL    AX, 0(SP)\n    MOVQ    24(SP), AX        // copy argv\n    MOVQ    AX, 8(SP)\n    CALL    runtime·args(SB)       // 解析命令行参数\n    CALL    runtime·osinit(SB)     // 获取CPU核数\n    CALL    runtime·schedinit(SB)  // 初始化调度\n\n    // create a new goroutine to start program\n    MOVQ    $runtime·mainPC(SB), AX        // entry\n    PUSHQ    AX\n    PUSHQ    $0            // arg size\n    CALL    runtime·newproc(SB)// 执行runtime.main\n    POPQ    AX\n    POPQ    AX\n\n    // start this M\n    CALL    runtime·mstart(SB) // 启动m0\n\n    CALL    runtime·abort(SB)    // mstart should never return\n    RET</code></pre>\n<p><code>rt0_go</code>函数主要流程：</p>\n<ul>\n<li>初始化<code>g0</code>、<code>m0</code></li>\n<li><code>g0</code>和<code>m0</code>互相绑定</li>\n<li>初始化相关数据，初始化指定个数的<code>p</code></li>\n<li>创建新<code>g</code>绑定<code>runtime.main</code>函数，加入<code>p</code>的可执行列表中</li>\n<li>启动<code>m0</code>开始循环调度。</li>\n</ul>\n<h2 id=\"schedinit\"><a href=\"#schedinit\" class=\"headerlink\" title=\"schedinit\"></a>schedinit</h2><pre><code class=\"go\">// runtime/proc.go\n\nfunc schedinit() {\n    // ... 省略 ...\n\n    _g_ := getg() // 获取当前绑定的g\n\n    // 限制M的数量\n    sched.maxmcount = 10000\n\n    // ... 省略 ...\n\n    // 创建 p\n    lock(&amp;sched.lock)\n    sched.lastpoll = uint64(nanotime())\n    procs := ncpu\n    if n, ok := atoi32(gogetenv(&quot;GOMAXPROCS&quot;)); ok &amp;&amp; n &gt; 0 {\n        procs = n\n    }\n    if procresize(procs) != nil {\n        throw(&quot;unknown runnable goroutine during bootstrap&quot;)\n    }\n    unlock(&amp;sched.lock)\n}</code></pre>\n<p><code>schedinit</code>函数主要流程：</p>\n<ul>\n<li>初始化全局调度相关值</li>\n<li>限制<code>m</code>的最多个数</li>\n<li>初始化指定个数的<code>p</code></li>\n</ul>\n<h2 id=\"newproc\"><a href=\"#newproc\" class=\"headerlink\" title=\"newproc\"></a>newproc</h2><pre><code class=\"go\">// runtime/proc.go\n\nfunc newproc(siz int32, fn *funcval) {\n    argp := add(unsafe.Pointer(&amp;fn), sys.PtrSize)\n    gp := getg()\n    pc := getcallerpc()\n    systemstack(func() {\n        newg := newproc1(fn, argp, siz, gp, pc)\n\n        _p_ := getg().m.p.ptr()\n        runqput(_p_, newg, true)\n\n        if mainStarted { // mainStarted 是在 runtime.main 中设置为 true \n            wakep() // 尝试找一个p绑定m\n        }\n    })\n}</code></pre>\n<p><code>newproc</code>函数主要流程：</p>\n<ul>\n<li>创建栈大小为<code>siz</code>的新<code>g</code>，并关联<code>fn</code></li>\n<li>将新<code>g</code>存放于<code>_p_</code>的可执行队列中</li>\n<li>此时刚初始化，并没有执行<code>runtime.main</code>所以不会执行<code>wakep</code></li>\n</ul>\n<pre><code class=\"go\">// runtime/proc.go\n\nfunc newproc1(fn *funcval, argp unsafe.Pointer, narg int32, callergp *g, callerpc uintptr) *g {\n    _g_ := getg()\n\n    acquirem() // disable preemption because it can be holding p in a local var\n    siz := narg\n    siz = (siz + 7) &amp;^ 7\n\n    _p_ := _g_.m.p.ptr() // 获取 p\n    newg := gfget(_p_)   // 从 p 的空闲 g 列表中获取 g\n    if newg == nil {     // 没有空闲的 g\n        newg = malg(_StackMin)           // 创建一个拥有最小栈的 g\n        casgstatus(newg, _Gidle, _Gdead) // 转换状态\n        allgadd(newg)                    // 向全局 g 列表中添加 g\n    }\n\n    // ... 省略 ...\n\n    // 填充 g\n    memclrNoHeapPointers(unsafe.Pointer(&amp;newg.sched), unsafe.Sizeof(newg.sched))\n    newg.sched.sp = sp\n    newg.stktopsp = sp\n    newg.sched.pc = funcPC(goexit) + sys.PCQuantum // 当g执行完后的处理函数\n    newg.sched.g = guintptr(unsafe.Pointer(newg))\n    gostartcallfn(&amp;newg.sched, fn)\n    newg.gopc = callerpc\n    newg.ancestors = saveAncestors(callergp)\n    newg.startpc = fn.fn\n    if _g_.m.curg != nil {\n        newg.labels = _g_.m.curg.labels\n    }\n    if isSystemGoroutine(newg, false) {\n        atomic.Xadd(&amp;sched.ngsys, +1)\n    }\n    casgstatus(newg, _Gdead, _Grunnable) // 切换成可执行状态\n\n    // 分配goid，如果没有则向p批量获取\n    if _p_.goidcache == _p_.goidcacheend {\n        _p_.goidcache = atomic.Xadd64(&amp;sched.goidgen, _GoidCacheBatch)\n        _p_.goidcache -= _GoidCacheBatch - 1\n        _p_.goidcacheend = _p_.goidcache + _GoidCacheBatch\n    }\n    newg.goid = int64(_p_.goidcache)\n    _p_.goidcache++\n\n    releasem(_g_.m)\n\n    return newg\n}</code></pre>\n<p><code>newproc1</code>函数主要流程：</p>\n<ul>\n<li>从空闲<code>g</code>列表中获取或新建<code>g</code>，将<code>g</code>的信息填充</li>\n</ul>\n<h2 id=\"mstart\"><a href=\"#mstart\" class=\"headerlink\" title=\"mstart\"></a>mstart</h2><pre><code class=\"go\">// runtime/proc.go\n\nfunc mstart() {\n    _g_ := getg()\n\n    // 设置 _g_ 的栈信息\n    osStack := _g_.stack.lo == 0\n    if osStack {\n        size := _g_.stack.hi\n        if size == 0 {\n            size = 8192 * sys.StackGuardMultiplier\n        }\n        _g_.stack.hi = uintptr(noescape(unsafe.Pointer(&amp;size)))\n        _g_.stack.lo = _g_.stack.hi - size + 1024\n    }\n    _g_.stackguard0 = _g_.stack.lo + _StackGuard\n    _g_.stackguard1 = _g_.stackguard0\n\n    mstart1() // 不会返回\n}</code></pre>\n<p><code>mstart</code>函数主要流程：</p>\n<ul>\n<li>填充<code>g</code>的栈信息</li>\n<li>让<code>m</code>开始执行<code>g</code>上的代码</li>\n</ul>\n<pre><code class=\"go\">// runtime/proc.go\n\nfunc mstart1() {\n    _g_ := getg()\n\n    // ... 省略 ...\n\n    if _g_.m == &amp;m0 {\n        mstartm0() // 启动 m0 初始化信号处理\n    }\n\n    if fn := _g_.m.mstartfn; fn != nil {\n        fn() // 执行m绑定的启动时调用的函数\n    }\n\n    if _g_.m != &amp;m0 {\n        acquirep(_g_.m.nextp.ptr())\n        _g_.m.nextp = 0\n    }\n    schedule() // 开始调度\n}</code></pre>\n<p><code>mstart1</code>函数主要流程：</p>\n<ul>\n<li>如果是<code>m0</code>，则初始化信号处理</li>\n<li>如果有<code>mstartfn</code>，则执行</li>\n<li>如果不是<code>m0</code>，则绑定<code>p</code></li>\n<li>调用<code>schedule</code>启动golang进程的调度。</li>\n</ul>\n<h2 id=\"runtime-main\"><a href=\"#runtime-main\" class=\"headerlink\" title=\"runtime.main\"></a>runtime.main</h2><pre><code class=\"go\">// runtime/proc.go\n\nfunc main() {\n    g := getg()\n\n    // 确认栈的最大值\n    if sys.PtrSize == 8 {\n        maxstacksize = 1000000000\n    } else {\n        maxstacksize = 250000000\n    }\n\n    // Allow newproc to start new Ms.\n    mainStarted = true // 标志 newproc 时可以启动 m\n\n    if GOARCH != &quot;wasm&quot; { // no threads on wasm yet, so no sysmon\n        systemstack(func() {\n            newm(sysmon, nil, -1) // 新建 m 去执行 sysmon\n        })\n    }\n\n    lockOSThread()\n\n    doInit(&amp;runtime_inittask) // 执行runtime包中的init函数\n\n    // Record when the world started.\n    runtimeInitTime = nanotime()\n\n    gcenable() // 开启GC\n\n    main_init_done = make(chan bool)\n    doInit(&amp;main_inittask) // 执行main包中的init函数\n    close(main_init_done)\n\n    unlockOSThread()\n\n    fn := main_main // fn 指向main包的main函数\n    fn() // 执行main包的main函数\n\n    exit(0)\n}</code></pre>\n<p>runtime.main函数主要功能：</p>\n<ul>\n<li>设置了栈的最大值</li>\n<li>创建m去执行sysmon</li>\n<li>调用runtime包的init函数</li>\n<li>启动GC</li>\n<li>执行main包的init函数</li>\n<li>退出</li>\n</ul>\n<h2 id=\"startm\"><a href=\"#startm\" class=\"headerlink\" title=\"startm\"></a>startm</h2><p>除了m0是汇编初始化的，其他的m都是由startm创建的。</p>\n<pre><code class=\"go\">func startm(_p_ *p, spinning bool) {\n    lock(&amp;sched.lock)\n    if _p_ == nil { // _p_ 为空\n        _p_ = pidleget() // 从p空闲列表中获取一个\n        if _p_ == nil {  // 获取失败\n            unlock(&amp;sched.lock)\n            if spinning {\n                // 如果是自旋状态，调用方增加了nmspinning，但是没有空闲的P，因此可以取消增量并放弃\n                if int32(atomic.Xadd(&amp;sched.nmspinning, -1)) &lt; 0 {\n                    throw(&quot;startm: negative nmspinning&quot;)\n                }\n            }\n            return\n        }\n    }\n    mp := mget() // 从m空闲列表中获取m\n    if mp == nil { // 如果空闲列表没有\n        id := mReserveID() // 获取 m id\n        unlock(&amp;sched.lock)\n\n        var fn func()\n        if spinning {\n            fn = mspinning // 设置 m 的自旋状态函数\n        }\n        newm(fn, _p_, id) // 创建一个m对象\n        return\n    }\n    unlock(&amp;sched.lock)\n    if mp.spinning {\n        throw(&quot;startm: m is spinning&quot;)\n    }\n    if mp.nextp != 0 {\n        throw(&quot;startm: m has p&quot;)\n    }\n    if spinning &amp;&amp; !runqempty(_p_) {\n        throw(&quot;startm: p has runnable gs&quot;)\n    }\n    // 由调用者确定是否自旋，并将m.nextp设置为p\n    mp.spinning = spinning\n    mp.nextp.set(_p_)\n    notewakeup(&amp;mp.park)\n}</code></pre>\n<p><code>startm</code>函数主要流程：</p>\n<ul>\n<li>获取一个<code>p</code>，失败则返回<ul>\n<li>获取一个<code>m</code>，如果失败就创建<code>m</code>并返回</li>\n</ul>\n</li>\n<li><code>m</code>暂存<code>p</code></li>\n</ul>\n<h3 id=\"newm\"><a href=\"#newm\" class=\"headerlink\" title=\"newm\"></a>newm</h3><pre><code class=\"go\">func newm(fn func(), _p_ *p, id int64) {\n    mp := allocm(_p_, fn, id) // 创建新m\n    mp.nextp.set(_p_) // 暂存p\n    mp.sigmask = initSigmask // 信号掩码\n    newm1(mp) // 绑定操作系统线程\n}</code></pre>\n<pre><code class=\"go\">func allocm(_p_ *p, fn func(), id int64) *m {\n    _g_ := getg()\n    acquirem() // disable GC because it can be called from sysmon\n    if _g_.m.p == 0 {\n        acquirep(_p_) // 临时绑定p\n    }\n\n    // 清理可以安全删除的m的g0栈信息\n    if sched.freem != nil { \n        lock(&amp;sched.lock)\n        var newList *m\n        for freem := sched.freem; freem != nil; {\n            if freem.freeWait != 0 {\n                next := freem.freelink\n                freem.freelink = newList\n                newList = freem\n                freem = next\n                continue\n            }\n            stackfree(freem.g0.stack) // 清空freem.g0的栈信息\n            freem = freem.freelink\n        }\n        sched.freem = newList // 更新已被释放的m列表\n        unlock(&amp;sched.lock)\n    }\n\n    mp := new(m)\n    mp.mstartfn = fn // 绑定m启动函数\n    mcommoninit(mp, id) // 绑定mp的id\n\n    // 初始化g0栈信息\n    if iscgo || GOOS == &quot;solaris&quot; || GOOS == &quot;illumos&quot; || GOOS == &quot;windows&quot; || GOOS == &quot;plan9&quot; || GOOS == &quot;darwin&quot; || GOOS == &quot;ios&quot; {\n        mp.g0 = malg(-1)\n    } else {\n        mp.g0 = malg(8192 * sys.StackGuardMultiplier)\n    }\n    mp.g0.m = mp\n\n    if _p_ == _g_.m.p.ptr() {\n        releasep() // 解绑p\n    }\n    releasem(_g_.m)\n\n    return mp\n}</code></pre>\n<pre><code class=\"go\">func newm1(mp *m) {\n    execLock.rlock() // Prevent process clone.\n    newosproc(mp) // 绑定操作系统线程\n    execLock.runlock()\n}</code></pre>\n<p><code>newm</code>函数主要流程：</p>\n<ul>\n<li>释放可以清理的<code>m</code>的<code>g0</code>栈空间</li>\n<li>新建<code>m</code>，绑定<code>id</code>和启动函数，申请<code>g0</code>栈空间</li>\n<li><code>m</code>暂存当前<code>p</code></li>\n<li>创建与<code>m</code>对应的操作系统线程</li>\n</ul>\n<h2 id=\"netpoll\"><a href=\"#netpoll\" class=\"headerlink\" title=\"netpoll\"></a>netpoll</h2><p><code>netpoll</code>可以让调度器从就绪的网络事件中获取可执行的goroutine。<br>由于golang对每个系统的netpoll做了条件编译，这里就拿linux的实现来说明。</p>\n<pre><code class=\"go\">func netpoll(delay int64) gList {\n    var events [128]epollevent\nretry:\n    n := epollwait(epfd, &amp;events[0], int32(len(events)), waitms)\n\n    var toRun gList\n    for i := int32(0); i &lt; n; i++ {\n        ev := &amp;events[i]\n        var mode int32\n        if ev.events&amp;(_EPOLLIN|_EPOLLRDHUP|_EPOLLHUP|_EPOLLERR) != 0 {\n            mode += &#39;r&#39;\n        }\n        if ev.events&amp;(_EPOLLOUT|_EPOLLHUP|_EPOLLERR) != 0 {\n            mode += &#39;w&#39;\n        }\n        if mode != 0 {\n            pd := *(**pollDesc)(unsafe.Pointer(&amp;ev.data))\n            pd.everr = false\n            if ev.events == _EPOLLERR {\n                pd.everr = true\n            }\n            netpollready(&amp;toRun, pd, mode) // 将符合的g填充进toRun中\n        }\n    }\n    return toRun\n}</code></pre>\n<p><code>netpoll</code>函数主要流程：</p>\n<ul>\n<li>调用<code>epollwait</code>获取就绪的文件描述符</li>\n<li>将<code>pd</code>中的就绪<code>g</code>追加进<code>toRun</code>里面</li>\n<li>返回<code>toRun</code></li>\n</ul>\n<h1 id=\"调度\"><a href=\"#调度\" class=\"headerlink\" title=\"调度\"></a>调度</h1><pre><code class=\"go\">// runtime/proc.go\n\nfunc schedule() {\n    _g_ := getg()\n\n    // 如果_g_绑定的m有锁定的g，则抛弃_g_，转而执行锁定的g\n    if _g_.m.lockedg != 0 {\n        stoplockedm()\n        execute(_g_.m.lockedg.ptr(), false) // Never returns.\n    }\n\ntop:\n    pp := _g_.m.p.ptr()\n    pp.preempt = false\n\n    // 如果准备GC，则休眠当前m，直到被唤醒\n    if sched.gcwaiting != 0 {\n        gcstopm()\n        goto top\n    }\n    if pp.runSafePointFn != 0 {\n        runSafePointFn()\n    }\n\n    checkTimers(pp, 0)\n\n    var gp *g\n    var inheritTime bool\n\n    tryWakeP := false\n    if trace.enabled || trace.shutdown {\n        gp = traceReader()\n        if gp != nil {\n            casgstatus(gp, _Gwaiting, _Grunnable)\n            traceGoUnpark(gp, 0)\n            tryWakeP = true\n        }\n    }\n    if gp == nil &amp;&amp; gcBlackenEnabled != 0 {\n        // 找GCWorker\n        gp = gcController.findRunnableGCWorker(_g_.m.p.ptr())\n        tryWakeP = tryWakeP || gp != nil\n    }\n    if gp == nil {\n        // 为了让全局可执行队列的g能够运行，这里每操作一定次数就从全局队列中获取\n        if _g_.m.p.ptr().schedtick%61 == 0 &amp;&amp; sched.runqsize &gt; 0 {\n            lock(&amp;sched.lock)\n            gp = globrunqget(_g_.m.p.ptr(), 1)\n            unlock(&amp;sched.lock)\n        }\n    }\n    if gp == nil {\n        // 从本地可执行队列中获取\n        gp, inheritTime = runqget(_g_.m.p.ptr())\n    }\n    if gp == nil {\n        // 从其他地方找一个g来执行，如果没有则阻塞在这里\n        gp, inheritTime = findrunnable() // blocks until work is available\n    }\n\n    // This thread is going to run a goroutine and is not spinning anymore,\n    // so if it was marked as spinning we need to reset it now and potentially\n    // start a new spinning M.\n    if _g_.m.spinning {\n        // 如果当前m正在自旋，则重置自旋状态\n        resetspinning()\n    }\n\n    if tryWakeP {\n        wakep() // GCworker 或 tracereader 需要唤醒p\n    }\n    if gp.lockedm != 0 {\n        // m将自己的p让给gp锁定的m，自己阻塞等待新p\n        startlockedm(gp)\n        goto top\n    }\n\n    execute(gp, inheritTime) // 执行gp\n}</code></pre>\n<p><code>schedule</code>函数主要流程：</p>\n<ul>\n<li>如果<code>g</code>有绑定的<code>m</code>，则直接让绑定<code>m</code>执行<code>g</code></li>\n<li>如果要GC，则休眠当前<code>m</code>，等待唤醒</li>\n<li>从<code>traceReader</code>、<code>GCWorker</code>、<code>globrunqget</code>、<code>runqget</code>、<code>findrunnable</code>函数中获取一个可执行gp</li>\n<li>重置自旋状态</li>\n<li>如果需要唤醒<code>p</code>，则尝试唤醒<code>p</code></li>\n<li>如果获取的<code>gp</code>有锁定的<code>m</code>，则让出自己的<code>p</code>给<code>gp</code>锁定的<code>m</code>，自己则阻塞等待被唤醒</li>\n<li>执行<code>gp</code></li>\n</ul>\n<h2 id=\"findrunnable\"><a href=\"#findrunnable\" class=\"headerlink\" title=\"findrunnable\"></a>findrunnable</h2><pre><code class=\"go\">// runtime/proc.go\n\nfunc findrunnable() (gp *g, inheritTime bool) {\n    _g_ := getg()\n\ntop:\n    _p_ := _g_.m.p.ptr()\n    if sched.gcwaiting != 0 {\n        gcstopm()\n        goto top\n    }\n    if _p_.runSafePointFn != 0 {\n        runSafePointFn()\n    }\n\n    now, pollUntil, _ := checkTimers(_p_, 0)\n\n    // 如果有finalizer可用，直接唤醒\n    if fingwait &amp;&amp; fingwake {\n        if gp := wakefing(); gp != nil {\n            ready(gp, 0, true)\n        }\n    }\n\n    // 本地获取\n    if gp, inheritTime := runqget(_p_); gp != nil {\n        return gp, inheritTime\n    }\n\n    // 全局获取\n    // global runq\n    if sched.runqsize != 0 {\n        lock(&amp;sched.lock)\n        gp := globrunqget(_p_, 0)\n        unlock(&amp;sched.lock)\n        if gp != nil {\n            return gp, false\n        }\n    }\n\n    // 没有可以执行的goroutine\n\n    // 获取网络事件完成的gp，优化\n    if netpollinited() &amp;&amp; atomic.Load(&amp;netpollWaiters) &gt; 0 &amp;&amp; atomic.Load64(&amp;sched.lastpoll) != 0 {\n        if list := netpoll(0); !list.empty() { // non-blocking\n            gp := list.pop()\n            injectglist(&amp;list)\n            casgstatus(gp, _Gwaiting, _Grunnable)\n            if trace.enabled {\n                traceGoUnpark(gp, 0)\n            }\n            return gp, false\n        }\n    }\n\n    // 从其他的P偷取\n    // Steal work from other P&#39;s.\n    procs := uint32(gomaxprocs)\n    ranTimer := false\n\n    // 将m置为自旋状态\n    if !_g_.m.spinning {\n        _g_.m.spinning = true\n        atomic.Xadd(&amp;sched.nmspinning, 1)\n    }\n\n    // 随机从别的p中偷取4次\n    for i := 0; i &lt; 4; i++ {\n        for enum := stealOrder.start(fastrand()); !enum.done(); enum.next() {\n            if sched.gcwaiting != 0 {\n                goto top\n            }\n            stealRunNextG := i &gt; 2 // first look for ready queues with more than 1 g\n            p2 := allp[enum.position()]\n            if _p_ == p2 {\n                continue\n            }\n            if gp := runqsteal(_p_, p2, stealRunNextG); gp != nil {\n                return gp, false\n            }\n\n            if i &gt; 2 || (i &gt; 1 &amp;&amp; shouldStealTimers(p2)) {\n                tnow, w, ran := checkTimers(p2, now)\n                now = tnow\n                if w != 0 &amp;&amp; (pollUntil == 0 || w &lt; pollUntil) {\n                    pollUntil = w\n                }\n                if ran {\n                    if gp, inheritTime := runqget(_p_); gp != nil {\n                        return gp, inheritTime\n                    }\n                    ranTimer = true\n                }\n            }\n        }\n    }\n    if ranTimer {\n        // Running a timer may have made some goroutine ready.\n        goto top\n    }\n    // ... 省略 ...    \n}</code></pre>\n<p><code>findrunnable</code>函数主要流程：</p>\n<ul>\n<li>如果有<code>finalizer</code>可执行<code>gp</code>，直接唤醒</li>\n<li>如果从本地可执行队列中获取可执行<code>gp</code>，返回<code>gp</code></li>\n<li>如果从全局可执行队列中获取可执行<code>gp</code>，返回<code>gp</code></li>\n<li>如果有就绪的网络事件的<code>gp</code>，返回<code>gp</code></li>\n<li>从其他的<code>p</code>中偷取部分<code>gp</code>，返回<code>gp</code></li>\n</ul>\n<h3 id=\"runqsteal\"><a href=\"#runqsteal\" class=\"headerlink\" title=\"runqsteal\"></a>runqsteal</h3><pre><code class=\"go\">// runtime/proc.go\n\nfunc runqsteal(_p_, p2 *p, stealRunNextG bool) *g {\n    t := _p_.runqtail\n    n := runqgrab(p2, &amp;_p_.runq, t, stealRunNextG)\n    if n == 0 {\n        return nil\n    }\n    n--\n    gp := _p_.runq[(t+n)%uint32(len(_p_.runq))].ptr()\n    if n == 0 {\n        return gp\n    }\n    h := atomic.LoadAcq(&amp;_p_.runqhead)\n    atomic.StoreRel(&amp;_p_.runqtail, t+n)\n    return gp\n}</code></pre>\n<p><code>runqsteal</code>函数主要流程：</p>\n<ul>\n<li>获取本地队列队尾坐标</li>\n<li>从<code>p2</code>中获取部分可执行队列</li>\n<li>如果只偷取了一个，直接返回</li>\n<li>否则需要原子修改可执行队列的首尾指针</li>\n</ul>\n<h4 id=\"runqgrab\"><a href=\"#runqgrab\" class=\"headerlink\" title=\"runqgrab\"></a>runqgrab</h4><pre><code>// runtime/proc.go\n\nfunc runqgrab(_p_ *p, batch *[256]guintptr, batchHead uint32, stealRunNextG bool) uint32 {\n    for {\n        h := atomic.LoadAcq(&amp;_p_.runqhead)\n        t := atomic.LoadAcq(&amp;_p_.runqtail) \n        n := t - h\n        n = n - n/2\n        if n == 0 {\n            if stealRunNextG {\n                // Try to steal from _p_.runnext.\n                if next := _p_.runnext; next != 0 {\n                    // 休眠让p不会执行将要偷取的\n                    if _p_.status == _Prunning {\n                        if GOOS != &quot;windows&quot; {\n                            usleep(3)\n                        } else {\n                            osyield()\n                        }\n                    }\n                    if !_p_.runnext.cas(next, 0) {\n                        continue\n                    }\n                    batch[batchHead%uint32(len(batch))] = next\n                    return 1\n                }\n            }\n            return 0\n        }\n        if n &gt; uint32(len(_p_.runq)/2) { // 保证队列没有改动\n            continue\n        }\n        // 偷取前半g可执行队列\n        for i := uint32(0); i &lt; n; i++ {\n            g := _p_.runq[(h+i)%uint32(len(_p_.runq))]\n            batch[(batchHead+i)%uint32(len(batch))] = g\n        }\n        // 提交本次消费，如果失败则从新再试一次\n        if atomic.CasRel(&amp;_p_.runqhead, h, h+n) {\n            return n\n        }\n    }\n}</code></pre><p>runqgrab函数主要流程：</p>\n<ul>\n<li>原子获取待偷取<code>p</code>可执行队列首尾位置</li>\n<li>如果没有，则判断是否需要偷取<code>next</code>指针的<code>gp</code></li>\n<li>复制<code>p</code>的前半部分可执行队列</li>\n<li>原子的修改<code>p</code>的可执行队列的首尾指针位置</li>\n</ul>\n<h2 id=\"execute\"><a href=\"#execute\" class=\"headerlink\" title=\"execute\"></a>execute</h2><pre><code class=\"go\">// runtime/proc.go\n\nfunc execute(gp *g, inheritTime bool) {\n    _g_ := getg()\n\n    // 互相绑定 _g_.m.curg = gp\n    gp.m = _g_.m\n    casgstatus(gp, _Grunnable, _Grunning) // 转换状态\n    gp.waitsince = 0\n    gp.preempt = false\n    gp.stackguard0 = gp.stack.lo + _StackGuard\n    if !inheritTime {\n        _g_.m.p.ptr().schedtick++\n    }\n\n    gogo(&amp;gp.sched)\n}</code></pre>\n<p><code>execute</code>函数主要流程：</p>\n<ul>\n<li><code>m</code>和<code>g</code>相互绑定</li>\n<li>设置相关值</li>\n<li>调用<code>gogo</code>函数执行<code>gp</code></li>\n</ul>\n<h3 id=\"gogo\"><a href=\"#gogo\" class=\"headerlink\" title=\"gogo\"></a>gogo</h3><pre><code class=\"asm\">// runtime/asm_amd64.s\n\nTEXT runtime·gogo(SB), NOSPLIT, $16-8\n    MOVQ    buf+0(FP), BX        // gobuf\n    MOVQ    gobuf_g(BX), DX\n    MOVQ    0(DX), CX        // make sure g != nil\n    get_tls(CX)\n    MOVQ    DX, g(CX)\n    MOVQ    gobuf_sp(BX), SP    // restore SP\n    MOVQ    gobuf_ret(BX), AX\n    MOVQ    gobuf_ctxt(BX), DX\n    MOVQ    gobuf_bp(BX), BP\n    MOVQ    $0, gobuf_sp(BX)    // clear to help garbage collector\n    MOVQ    $0, gobuf_ret(BX)\n    MOVQ    $0, gobuf_ctxt(BX)\n    MOVQ    $0, gobuf_bp(BX)\n    MOVQ    gobuf_pc(BX), BX\n    JMP    BX</code></pre>\n<p><code>gogo</code>函数主要流程：</p>\n<ul>\n<li>将<code>gobuf</code>的内容存放到相关寄存器中</li>\n<li>将<code>gobuf</code>的内容清空</li>\n<li>执行<code>gobuf.pc</code></li>\n</ul>\n<h2 id=\"Gosched\"><a href=\"#Gosched\" class=\"headerlink\" title=\"Gosched\"></a>Gosched</h2><p>除了上述的通过运行时启动调度之外，golang还提供了手动的调度函数<code>Gosched</code>函数，该函数在运行时内外都可以触发下一次调度。</p>\n<pre><code class=\"go\">func Gosched() {\n    checkTimeouts()\n    mcall(gosched_m)\n}</code></pre>\n<pre><code class=\"go\">func gosched_m(gp *g) {\n    goschedImpl(gp)\n}</code></pre>\n<pre><code class=\"go\">func goschedImpl(gp *g) {\n    status := readgstatus(gp)\n    if status&amp;^_Gscan != _Grunning {\n        dumpgstatus(gp)\n        throw(&quot;bad g status&quot;)\n    }\n    casgstatus(gp, _Grunning, _Grunnable)\n    dropg() // 解绑g和m\n    lock(&amp;sched.lock)\n    globrunqput(gp) // 放入全局可执行队列\n    unlock(&amp;sched.lock)\n\n    schedule() // 下一次调度\n}</code></pre>\n<p>Gosched函数主要流程：</p>\n<ul>\n<li>获取gp的状态</li>\n<li>切换gp的状态为_Grunnable</li>\n<li>解绑g和m</li>\n<li>将g存入全局可执行队列中</li>\n<li>启动下一次调度</li>\n</ul>\n<h1 id=\"销毁\"><a href=\"#销毁\" class=\"headerlink\" title=\"销毁\"></a>销毁</h1><pre><code class=\"asm\">TEXT runtime·goexit(SB),NOSPLIT,$0-0\n    BYTE    $0x90    // NOP\n    CALL    runtime·goexit1(SB)    // does not return\n    // traceback from goexit1 must hit code range of goexit\n    BYTE    $0x90    // NOP</code></pre>\n<pre><code class=\"go\">func goexit1() {\n   if raceenabled {\n      racegoend()\n   }\n   if trace.enabled {\n      traceGoEnd()\n   }\n   mcall(goexit0)\n}</code></pre>\n<pre><code class=\"go\">func goexit0(gp *g) {\n    _g_ := getg()\n\n    // 切换g的状态 \n    casgstatus(gp, _Grunning, _Gdead)\n    // 标记系统goroutine \n    if isSystemGoroutine(gp, false) {\n       atomic.Xadd(&amp;sched.ngsys, -1)\n    }\n    // 清理gp相关的数据\n    gp.m = nil\n    locked := gp.lockedm != 0\n    gp.lockedm = 0\n    _g_.m.lockedg = 0\n    gp.preemptStop = false\n    gp.paniconfault = false\n    gp._defer = nil // should be true already but just in case.\n    gp._panic = nil // non-nil for Goexit during panic. points at stack-allocated data.\n    gp.writebuf = nil\n    gp.waitreason = 0\n    gp.param = nil\n    gp.labels = nil\n    gp.timer = nil\n\n    dropg() // 解绑当前m和gp\n\n    if GOARCH == &quot;wasm&quot; { // no threads yet on wasm\n        gfput(_g_.m.p.ptr(), gp) // 将gp存放到p的空闲列表中\n        schedule() // 下一次调度\n    }\n\n    gfput(_g_.m.p.ptr(), gp) // 将gp存放到p的空闲列表中\n    if locked {\n        // 如果gp锁定了m，则将这个m杀死\n        if GOOS != &quot;plan9&quot; { \n            gogo(&amp;_g_.m.g0.sched)\n        } else {\n            _g_.m.lockedExt = 0\n        }\n    }\n    schedule() // 下一次调度\n}</code></pre>\n<p><code>goexit0</code>函数主要流程：</p>\n<ul>\n<li>切换<code>g</code>的状态</li>\n<li>解绑<code>g</code>所有绑定的数据</li>\n<li>如果是<code>wasm</code>架构，直接将<code>g</code>存于空闲列表中，并开始下一次调度</li>\n<li>否则，直接将<code>g</code>存于空闲列表中，如果<code>g</code>有锁定的<code>m</code>，则将<code>m</code>杀死，开始下一次调度</li>\n</ul>\n<h1 id=\"切换\"><a href=\"#切换\" class=\"headerlink\" title=\"切换\"></a>切换</h1><h2 id=\"执行完毕切换\"><a href=\"#执行完毕切换\" class=\"headerlink\" title=\"执行完毕切换\"></a>执行完毕切换</h2><p>上面说到，当goroutine执行完毕时，会执行goexit0函数，进而执行下一次调度</p>\n<h2 id=\"主动切换\"><a href=\"#主动切换\" class=\"headerlink\" title=\"主动切换\"></a>主动切换</h2><p>当goroutine中阻塞的操作时，就需要让出CPU，让其他的goroutine执行。所有主动切换都是调用gopark函数来实现的。</p>\n<h3 id=\"gopark\"><a href=\"#gopark\" class=\"headerlink\" title=\"gopark\"></a>gopark</h3><pre><code class=\"go\">func gopark(unlockf func(*g, unsafe.Pointer) bool, lock unsafe.Pointer, reason waitReason, traceEv byte, traceskip int) {\n    if reason != waitReasonSleep {\n        checkTimeouts()\n    }\n    mp := acquirem()\n    gp := mp.curg\n    status := readgstatus(gp)\n    if status != _Grunning &amp;&amp; status != _Gscanrunning {\n        throw(&quot;gopark: bad g status&quot;)\n    }\n    // 填充相关参数\n    mp.waitlock = lock\n    mp.waitunlockf = unlockf\n    gp.waitreason = reason\n    mp.waittraceev = traceEv\n    mp.waittraceskip = traceskip\n    releasem(mp)\n    // can&#39;t do anything that might move the G between Ms here.\n    mcall(park_m)\n}</code></pre>\n<p><code>gopark</code>函数主要流程：</p>\n<ul>\n<li>获取当前<code>m</code>绑定的<code>gp</code></li>\n<li>填充相关参数</li>\n<li>利用<code>g0</code>调用<code>park_m</code>函数</li>\n</ul>\n<pre><code class=\"go\">func park_m(gp *g) {\n    _g_ := getg()\n\n    casgstatus(gp, _Grunning, _Gwaiting)\n    dropg() // 解绑g和m\n\n    if fn := _g_.m.waitunlockf; fn != nil {\n        ok := fn(gp, _g_.m.waitlock) // 尝试调用解锁函数\n        _g_.m.waitunlockf = nil\n        _g_.m.waitlock = nil\n        if !ok {\n            // 如果解锁成功\n            casgstatus(gp, _Gwaiting, _Grunnable)\n            execute(gp, true) // 直接执行gp\n        }\n    }\n    schedule() // 下一次调度\n}</code></pre>\n<p><code>park_m</code>函数主要流程：</p>\n<ul>\n<li>切换<code>g</code>的状态为等待</li>\n<li>尝试解锁，如果成功则切换状态为可执行，直接调用<code>execute</code>函数执行</li>\n<li>否则，进入下一个调度</li>\n</ul>\n<h3 id=\"goready\"><a href=\"#goready\" class=\"headerlink\" title=\"goready\"></a>goready</h3><p>当goroutine通过<code>gopark</code>函数由<code>_Grunning</code>到<code>_Gwaiting</code>，反向操作<code>goready</code>函数则是将<code>_Gwaiting</code>到<code>_Grunnable</code>。</p>\n<pre><code class=\"go\">func goready(gp *g, traceskip int) {\n    systemstack(func() {\n        ready(gp, traceskip, true)\n    })\n}</code></pre>\n<pre><code class=\"go\">func ready(gp *g, traceskip int, next bool) {\n    status := readgstatus(gp)\n\n    _g_ := getg()\n    mp := acquirem()\n    // 如果不是 _Gwaiting 抛异常\n    if status&amp;^_Gscan != _Gwaiting {\n        dumpgstatus(gp)\n        throw(&quot;bad g-&gt;status in ready&quot;)\n    }\n\n    // 切换状态\n    casgstatus(gp, _Gwaiting, _Grunnable)\n    runqput(_g_.m.p.ptr(), gp, next) // 存放到本地可执行队列中\n    wakep()                          // 尝试去唤起p去执行\n    releasem(mp)\n}</code></pre>\n<p><code>ready</code>函数主要流程：</p>\n<ul>\n<li>获取<code>gp</code>的状态</li>\n<li>获取当前的<code>g</code></li>\n<li>检测<code>gp</code>状态是不是<code>_Gwaiting</code></li>\n<li>由<code>_Gwaiting</code>转换为<code>_Grunnable</code>状态</li>\n<li>放进当前<code>g</code>的<code>m</code>的<code>p</code>中的本地可执行队列中</li>\n</ul>\n<h2 id=\"抢占切换\"><a href=\"#抢占切换\" class=\"headerlink\" title=\"抢占切换\"></a>抢占切换</h2><p>golang调度本质上是非抢占式的，golang利用标志位标志当前的goroutine是否可以被抢占，而触发时机是在栈扩容的时候。<br>golang中有个监控函数，监控着整个进程运行的相关数据，其中就包括检查某个goroutine是否占用CPU时间过长，从而进行标记抢占标记位。</p>\n<pre><code class=\"go\">func sysmon() {\n    // ... 省略 ...\n\n    for {\n        // ... 省略 ...\n\n        // 解绑在陷入系统调用中的p，和抢占长时间运行的g\n        if retake(now) != 0 {\n            idle = 0\n        } else {\n            idle++\n        }\n\n        // ... 省略 ...\n    }\n}</code></pre>\n<h3 id=\"retake\"><a href=\"#retake\" class=\"headerlink\" title=\"retake\"></a>retake</h3><pre><code class=\"go\">func retake(now int64) uint32 {\n    n := 0\n    lock(&amp;allpLock)\n    for i := 0; i &lt; len(allp); i++ {\n        _p_ := allp[i]\n        if _p_ == nil {\n            continue\n        }\n        pd := &amp;_p_.sysmontick // sysmon 信息记录\n        s := _p_.status\n        sysretake := false\n        if s == _Prunning || s == _Psyscall {\n            // 处于 _Prunning 或者 _Psyscall 状态时，如果上一次触发调度的时间已经过去了 10ms，\n            // 我们就会通过 runtime.preemptone 抢占当前处理器\n            // 如果G运行时间太长则抢占G\n            t := int64(_p_.schedtick)\n            if int64(pd.schedtick) != t {\n                pd.schedtick = uint32(t)\n                pd.schedwhen = now\n            } else if pd.schedwhen+forcePreemptNS &lt;= now {\n                preemptone(_p_)\n                // 在_Psyscall时preemptone函数不会工作，因为m没有绑定p\n                sysretake = true\n            }\n        }\n        if s == _Psyscall {\n            // 当处理器处于 _Psyscall 状态时\n            // 当处理器的运行队列不为空或者不存在空闲处理器时并且当系统调用时间超过了 10ms 时\n            t := int64(_p_.syscalltick)\n            if !sysretake &amp;&amp; int64(pd.syscalltick) != t {\n                pd.syscalltick = uint32(t)\n                pd.syscallwhen = now\n                continue\n            }\n\n            if runqempty(_p_) &amp;&amp; atomic.Load(&amp;sched.nmspinning)+atomic.Load(&amp;sched.npidle) &gt; 0 &amp;&amp; pd.syscallwhen+10*1000*1000 &gt; now {\n                // 如果_p_没有可执行的g，且有自旋的m或空闲的p，且系统调用时间没有超过10ms\n                continue\n            }\n            // Drop allpLock so we can take sched.lock.\n            unlock(&amp;allpLock)\n\n            // 将p的状态设置为_Pidle，计数器n加1，_p_的系统调用次数+1\n            incidlelocked(-1)\n            if atomic.Cas(&amp;_p_.status, s, _Pidle) {\n                n++\n                _p_.syscalltick++\n                handoffp(_p_) // 让 p 去找其他的事情干\n            }\n            incidlelocked(1)\n            lock(&amp;allpLock)\n        }\n    }\n    unlock(&amp;allpLock)\n    return uint32(n)\n}</code></pre>\n<p><code>retake</code>函数主要流程：</p>\n<ul>\n<li>遍历所有的<code>p</code></li>\n<li>如果<code>p</code>长时间没有调度则标记抢占标志位</li>\n<li>如果<code>p</code>在系统调用中，且超过阈值时间，则解绑<code>p</code></li>\n<li>返回解绑<code>p</code>的个数</li>\n</ul>\n<h3 id=\"preemptone\"><a href=\"#preemptone\" class=\"headerlink\" title=\"preemptone\"></a>preemptone</h3><pre><code class=\"go\">func preemptone(_p_ *p) bool {\n    mp := _p_.m.ptr()\n    if mp == nil || mp == getg().m {\n        // 如果mp为空，或mp是当前运行的m\n        return false\n    }\n    gp := mp.curg\n    if gp == nil || gp == mp.g0 {\n        // gp 不能使 g0\n        return false\n    }\n\n    gp.preempt = true // 标志gp可以被抢占\n\n    gp.stackguard0 = stackPreempt // 直接设置为栈顶，方便触发栈扩容\n\n    // Request an async preemption of this P.\n    if preemptMSupported &amp;&amp; debug.asyncpreemptoff == 0 {\n        _p_.preempt = true // 标记p快速调度\n        preemptM(mp)       // 向mp发送抢占信号\n    }\n\n    return true\n}</code></pre>\n<h3 id=\"handoffp\"><a href=\"#handoffp\" class=\"headerlink\" title=\"handoffp\"></a>handoffp</h3><pre><code class=\"go\">func handoffp(_p_ *p) {\n    // 如果本地有可执行的G或全局可执行队列长度不为0，则直接开始执行\n    if !runqempty(_p_) || sched.runqsize != 0 {\n        startm(_p_, false)\n        return\n    }\n    // 如果可以执行GC，则立即执行\n    if gcBlackenEnabled != 0 &amp;&amp; gcMarkWorkAvailable(_p_) {\n        startm(_p_, false)\n        return\n    }\n    // 如果没有自旋的m和空闲的p，并且增加自旋数成功，则让_p_绑定一个m进入自旋\n    if atomic.Load(&amp;sched.nmspinning)+atomic.Load(&amp;sched.npidle) == 0 &amp;&amp; atomic.Cas(&amp;sched.nmspinning, 0, 1) {\n        startm(_p_, true)\n        return\n    }\n    lock(&amp;sched.lock)\n    if sched.gcwaiting != 0 { // 即将GC\n        _p_.status = _Pgcstop\n        sched.stopwait--\n        if sched.stopwait == 0 {\n            notewakeup(&amp;sched.stopnote)\n        }\n        unlock(&amp;sched.lock)\n        return\n    }\n    if _p_.runSafePointFn != 0 &amp;&amp; atomic.Cas(&amp;_p_.runSafePointFn, 1, 0) {\n        sched.safePointFn(_p_)\n        sched.safePointWait--\n        if sched.safePointWait == 0 {\n            notewakeup(&amp;sched.safePointNote)\n        }\n    }\n    // 此时如果全局队列有可执行的g，则执行\n    if sched.runqsize != 0 {\n        unlock(&amp;sched.lock)\n        startm(_p_, false)\n        return\n    }\n    // 如果这是最后运行的P并且没有人正在轮询网络，则需要唤醒另一个M来轮询网络。\n    if sched.npidle == uint32(gomaxprocs-1) &amp;&amp; atomic.Load64(&amp;sched.lastpoll) != 0 {\n        unlock(&amp;sched.lock)\n        startm(_p_, false)\n        return\n    }\n    if when := nobarrierWakeTime(_p_); when != 0 {\n        wakeNetPoller(when)\n    }\n    // 都没有则将_p_存放到空闲P列表中\n    pidleput(_p_)\n    unlock(&amp;sched.lock)\n}</code></pre>\n<p><code>retake</code>函数主要流程：</p>\n<ul>\n<li>如果<code>p</code>的本地可执行队列不为空，或全局可执行队列不为空，则绑定<code>m</code>去执行</li>\n<li>如果<code>p</code>可以执行GC工作，则绑定m去执行</li>\n<li>如果没有m在自旋且没有空闲的<code>p</code>，且成功设置自旋值，则获取一个<code>m</code>，进入自旋</li>\n<li>如果此时在检测全局可执行队列是否为空，有则绑定<code>m</code>去执行</li>\n<li>如果是最后一个正在运行的<code>p</code>，则绑定<code>m</code>去轮询网络</li>\n<li>都没有则将<code>p</code>存放进空闲<code>p</code>列表</li>\n</ul>\n<h3 id=\"newstack\"><a href=\"#newstack\" class=\"headerlink\" title=\"newstack\"></a>newstack</h3><pre><code class=\"go\">func newstack() {\n    thisg := getg() // 当前执行的g\n\n    gp := thisg.m.curg // m绑定的g\n\n    // 判断是否抢占触发的栈扩张\n    preempt := atomic.Loaduintptr(&amp;gp.stackguard0) == stackPreempt\n\n    // ... 省略 ...\n\n    if preempt {\n        // Act like goroutine called runtime.Gosched.\n        gopreempt_m(gp) // never return\n    }\n    // ... 省略 ...\n}</code></pre>\n<pre><code class=\"go\">func gopreempt_m(gp *g) {\n    if trace.enabled {\n        traceGoPreempt()\n    }\n    goschedImpl(gp)\n}</code></pre>\n<p><code>goschedImpl</code>函数就是上述Gosched函数的主要执行实体了。</p>\n<p>如果检测到是抢占，则将m绑定的g放入全局可执行队列中。</p>\n<h2 id=\"系统调用切换\"><a href=\"#系统调用切换\" class=\"headerlink\" title=\"系统调用切换\"></a>系统调用切换</h2><p>golang提供了系统调用接口：</p>\n<pre><code class=\"go\">func Syscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno)\nfunc RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno)</code></pre>\n<p>更多参数可以调用Syscall6或Syscall9。</p>\n<h3 id=\"Syscall\"><a href=\"#Syscall\" class=\"headerlink\" title=\"Syscall\"></a>Syscall</h3><pre><code class=\"asm\">TEXT    ·Syscall(SB),NOSPLIT,$0-56\n    CALL    runtime·entersyscall(SB)\n    MOVQ    a1+8(FP), DI\n    MOVQ    a2+16(FP), SI\n    MOVQ    a3+24(FP), DX\n    MOVQ    trap+0(FP), AX    // syscall entry\n    ADDQ    $0x2000000, AX\n    SYSCALL\n    JCC    ok\n    MOVQ    $-1, r1+32(FP)\n    MOVQ    $0, r2+40(FP)\n    MOVQ    AX, err+48(FP)\n    CALL    runtime·exitsyscall(SB)\n    RET\nok:\n    MOVQ    AX, r1+32(FP)\n    MOVQ    DX, r2+40(FP)\n    MOVQ    $0, err+48(FP)\n    CALL    runtime·exitsyscall(SB)\n    RET</code></pre>\n<p><code>Syscall</code>函数主要流程：</p>\n<ul>\n<li>调用<code>runtime.entersyscall</code></li>\n<li>将参数存至寄存器</li>\n<li>执行系统调用</li>\n<li>将返回值压栈</li>\n<li>调用<code>runtime.exitsyscall</code></li>\n</ul>\n<h4 id=\"entersyscall\"><a href=\"#entersyscall\" class=\"headerlink\" title=\"entersyscall\"></a>entersyscall</h4><pre><code class=\"go\">func entersyscall() {\n   reentersyscall(getcallerpc(), getcallersp())\n}</code></pre>\n<pre><code class=\"go\">func reentersyscall(pc, sp uintptr) {\n    _g_ := getg()\n    _g_.m.locks++\n\n    _g_.stackguard0 = stackPreempt // 等待被抢占\n    _g_.throwsplit = true\n\n    // Leave SP around for GC and traceback.\n    save(pc, sp) // 保存现场\n    _g_.syscallsp = sp\n    _g_.syscallpc = pc\n    casgstatus(_g_, _Grunning, _Gsyscall) // 切换状态\n    if _g_.syscallsp &lt; _g_.stack.lo || _g_.stack.hi &lt; _g_.syscallsp {\n        systemstack(func() {\n            print(&quot;entersyscall inconsistent &quot;, hex(_g_.syscallsp), &quot; [&quot;, hex(_g_.stack.lo), &quot;,&quot;, hex(_g_.stack.hi), &quot;]\\n&quot;)\n            throw(&quot;entersyscall&quot;)\n        })\n    }\n\n    if trace.enabled {\n        systemstack(traceGoSysCall)\n        // systemstack itself clobbers g.sched.{pc,sp} and we might\n        // need them later when the G is genuinely blocked in a\n        // syscall\n        save(pc, sp)\n    }\n\n    if atomic.Load(&amp;sched.sysmonwait) != 0 {\n        systemstack(entersyscall_sysmon)\n        save(pc, sp)\n    }\n\n    if _g_.m.p.ptr().runSafePointFn != 0 {\n        // runSafePointFn may stack split if run on this stack\n        systemstack(runSafePointFn)\n        save(pc, sp)\n    }\n\n    _g_.m.syscalltick = _g_.m.p.ptr().syscalltick\n    _g_.sysblocktraced = true\n    pp := _g_.m.p.ptr()\n    pp.m = 0\n    _g_.m.oldp.set(pp)\n    _g_.m.p = 0\n    atomic.Store(&amp;pp.status, _Psyscall) // 切换p的状态\n    if sched.gcwaiting != 0 {\n        systemstack(entersyscall_gcwait)\n        save(pc, sp)\n    }\n\n    _g_.m.locks--\n}</code></pre>\n<h4 id=\"exitsyscall\"><a href=\"#exitsyscall\" class=\"headerlink\" title=\"exitsyscall\"></a>exitsyscall</h4><pre><code class=\"go\">func exitsyscall() {\n    _g_ := getg()\n\n    _g_.m.locks++ \n\n    oldp := _g_.m.oldp.ptr()\n    _g_.m.oldp = 0\n    if exitsyscallfast(oldp) { // 尝试获取系统调用前绑定的p\n        _g_.m.p.ptr().syscalltick++\n        casgstatus(_g_, _Gsyscall, _Grunning)\n        _g_.syscallsp = 0\n        _g_.m.locks--\n        if _g_.preempt {\n            // 如果抢占，就设置stackguard0为stackPreempt\n            _g_.stackguard0 = stackPreempt\n        } else {\n            // 否则恢复真实栈帧\n            _g_.stackguard0 = _g_.stack.lo + _StackGuard\n        }\n        _g_.throwsplit = false\n\n        if sched.disable.user &amp;&amp; !schedEnabled(_g_) {\n            // Scheduling of this goroutine is disabled.\n            Gosched() // 开始调度\n        }\n\n        return\n    }\n\n    // 没有p被绑定的情况\n    _g_.sysexitticks = 0\n    _g_.m.locks--\n\n    // Call the scheduler.\n    mcall(exitsyscall0)\n\n    _g_.syscallsp = 0\n    _g_.m.p.ptr().syscalltick++\n    _g_.throwsplit = false\n}</code></pre>\n<p><code>exitsyscall</code>函数主要流程：</p>\n<ul>\n<li>获取系统调用前绑定的<code>oldp</code></li>\n<li>尝试获取<code>oldp</code>或从空闲列表获取<code>p</code></li>\n<li>如果成功获取<code>p</code>，改变相关设置，开始下一轮调度</li>\n<li>如果没有获取，则调用<code>exitsyscall0</code></li>\n</ul>\n<pre><code class=\"go\">func exitsyscall0(gp *g) {\n    _g_ := getg()\n\n    casgstatus(gp, _Gsyscall, _Grunnable)\n    dropg()\n    lock(&amp;sched.lock)\n    var _p_ *p\n    if schedEnabled(_g_) { // 如果可以调度_g_\n        _p_ = pidleget() // 从p空闲列表中获取p\n    }\n    if _p_ == nil {\n        globrunqput(gp) // 没有可用的p，就将gp存放于全局可执行列表中\n    } else if atomic.Load(&amp;sched.sysmonwait) != 0 {\n        atomic.Store(&amp;sched.sysmonwait, 0)\n        notewakeup(&amp;sched.sysmonnote)\n    }\n    unlock(&amp;sched.lock)\n    if _p_ != nil { // 如果有可用的p\n        acquirep(_p_) // 直接绑定当前的m\n        execute(gp, false) // 执行gp\n    }\n    if _g_.m.lockedg != 0 { // 如果m有锁定的g\n        // Wait until another thread schedules gp and so m again.\n        stoplockedm()   // 释放p，休眠m，会阻塞\n        execute(gp, false) // 执行gp\n    }\n    stopm() // 将m休眠，并存于m空闲列表中，会阻塞\n    schedule() // 下一次调度\n}</code></pre>\n<p><code>exitsyscall0</code>函数主要流程：</p>\n<ul>\n<li>切换<code>gp</code>状态为<code>_Grunnable</code></li>\n<li>解绑<code>g</code>和<code>m</code></li>\n<li>尝试获取一个空闲的<code>_p_</code></li>\n<li>如果没有获取到就把<code>gp</code>放到全局可执行列表中</li>\n<li>如果获取到了，就直接绑定当前的<code>m</code>，执行<code>gp</code></li>\n<li>如果有<code>m</code>有锁定的<code>g</code>，释放p，休眠m，等待被唤醒</li>\n<li>否则<code>m</code>将放置与全局<code>m</code>空闲列表中，等待下一次调度</li>\n</ul>\n<p>exitsyscall0函数如果没有p则会将m休眠</p>\n<h3 id=\"RawSyscall\"><a href=\"#RawSyscall\" class=\"headerlink\" title=\"RawSyscall\"></a>RawSyscall</h3><pre><code class=\"asm\">TEXT ·RawSyscall(SB),NOSPLIT,$0-56\n    MOVQ    a1+8(FP), DI\n    MOVQ    a2+16(FP), SI\n    MOVQ    a3+24(FP), DX\n    MOVQ    trap+0(FP), AX    // syscall entry\n    ADDQ    $0x2000000, AX\n    SYSCALL\n    JCC    ok1\n    MOVQ    $-1, r1+32(FP)\n    MOVQ    $0, r2+40(FP)\n    MOVQ    AX, err+48(FP)\n    RET\nok1:\n    MOVQ    AX, r1+32(FP)\n    MOVQ    DX, r2+40(FP)\n    MOVQ    $0, err+48(FP)\n    RET</code></pre>\n<p><code>RawSyscall</code>函数主要流程：</p>\n<ul>\n<li>将参数存至寄存器</li>\n<li>执行系统调用</li>\n<li>将返回值压栈</li>\n</ul>\n<p><code>RawSyscall</code>函数并没有执行<code>runtime.entersyscall</code>和<code>runtime.exitsyscall</code>函数，由于没有执行相关操作导致golang无法准确的调度，可能会导致长时间系统调用，其他的goroutine无法得到执行。</p>\n<h1 id=\"辅助函数\"><a href=\"#辅助函数\" class=\"headerlink\" title=\"辅助函数\"></a>辅助函数</h1><h2 id=\"getg\"><a href=\"#getg\" class=\"headerlink\" title=\"getg\"></a>getg</h2><p>获取当前的<code>g</code>，由于是编译器填充的，所以没有源码。<br>一般都是从TLS寄存器获取的。</p>\n<h2 id=\"mcall\"><a href=\"#mcall\" class=\"headerlink\" title=\"mcall\"></a>mcall</h2><pre><code class=\"asm\">TEXT runtime·mcall(SB), NOSPLIT, $0-8\n    MOVQ    fn+0(FP), DI\n\n    get_tls(CX)\n    MOVQ    g(CX), AX    // save state in g-&gt;sched\n    MOVQ    0(SP), BX    // caller&#39;s PC\n    MOVQ    BX, (g_sched+gobuf_pc)(AX)\n    LEAQ    fn+0(FP), BX    // caller&#39;s SP\n    MOVQ    BX, (g_sched+gobuf_sp)(AX)\n    MOVQ    AX, (g_sched+gobuf_g)(AX)\n    MOVQ    BP, (g_sched+gobuf_bp)(AX)\n\n    // switch to m-&gt;g0 &amp; its stack, call fn\n    MOVQ    g(CX), BX\n    MOVQ    g_m(BX), BX\n    MOVQ    m_g0(BX), SI\n    CMPQ    SI, AX    // if g == m-&gt;g0 call badmcall\n    JNE    3(PC)\n    MOVQ    $runtime·badmcall(SB), AX\n    JMP    AX\n    MOVQ    SI, g(CX)    // g = m-&gt;g0\n    MOVQ    (g_sched+gobuf_sp)(SI), SP    // sp = m-&gt;g0-&gt;sched.sp\n    PUSHQ    AX\n    MOVQ    DI, DX\n    MOVQ    0(DI), DI\n    CALL    DI // 执行fn，不能返回\n    POPQ    AX\n    MOVQ    $runtime·badmcall2(SB), AX\n    JMP    AX\n    RET</code></pre>\n<p><code>mcall</code>函数切换到<code>m</code>的<code>g0</code>调用<code>fn(g)</code>，<code>fn</code>是不能返回的。</p>\n<h2 id=\"systemstack\"><a href=\"#systemstack\" class=\"headerlink\" title=\"systemstack\"></a>systemstack</h2><pre><code class=\"asm\">TEXT runtime·systemstack(SB), NOSPLIT, $0-8\n    MOVQ    fn+0(FP), DI    // DI = fn\n    get_tls(CX)\n    MOVQ    g(CX), AX    // AX = g\n    MOVQ    g_m(AX), BX    // BX = m\n\n    CMPQ    AX, m_gsignal(BX) // g == m.gsignal\n    JEQ    noswitch\n\n    MOVQ    m_g0(BX), DX    // DX = g0\n    CMPQ    AX, DX // g == g0\n    JEQ    noswitch\n\n    CMPQ    AX, m_curg(BX) // g == m.curg\n    JNE    bad\n\n    // 保存当前g的栈信息\n    MOVQ    $runtime·systemstack_switch(SB), SI\n    MOVQ    SI, (g_sched+gobuf_pc)(AX)\n    MOVQ    SP, (g_sched+gobuf_sp)(AX)\n    MOVQ    AX, (g_sched+gobuf_g)(AX)\n    MOVQ    BP, (g_sched+gobuf_bp)(AX)\n\n    // 切换到g0\n    MOVQ    DX, g(CX)\n    MOVQ    (g_sched+gobuf_sp)(DX), BX\n    // make it look like mstart called systemstack on g0, to stop traceback\n    SUBQ    $8, BX\n    MOVQ    $runtime·mstart(SB), DX\n    MOVQ    DX, 0(BX)\n    MOVQ    BX, SP\n\n    // call target function\n    MOVQ    DI, DX\n    MOVQ    0(DI), DI\n    CALL    DI // 执行目标函数\n\n    // 恢复原有g\n    get_tls(CX)\n    MOVQ    g(CX), AX\n    MOVQ    g_m(AX), BX\n    MOVQ    m_curg(BX), AX\n    MOVQ    AX, g(CX)\n    MOVQ    (g_sched+gobuf_sp)(AX), SP\n    MOVQ    $0, (g_sched+gobuf_sp)(AX)\n    RET</code></pre>\n<p>systemstack函数主要流程：</p>\n<ul>\n<li>检测相关参数</li>\n<li>保存g现场</li>\n<li>切换到g0，并执行fn(g)</li>\n<li>恢复原有g</li>\n</ul>\n<h2 id=\"acquirem\"><a href=\"#acquirem\" class=\"headerlink\" title=\"acquirem\"></a>acquirem</h2><pre><code class=\"go\">func acquirem() *m {\n    _g_ := getg()\n    _g_.m.locks++\n    return _g_.m\n}</code></pre>\n<p><code>acquirem</code>函数主要是增加<code>locks</code>引用计数，并返回当前的m。主要是防止GC回收m。</p>\n<h2 id=\"releasem\"><a href=\"#releasem\" class=\"headerlink\" title=\"releasem\"></a>releasem</h2><pre><code class=\"go\">func releasem(mp *m) {\n    _g_ := getg()\n    mp.locks--\n    if mp.locks == 0 &amp;&amp; _g_.preempt {\n        _g_.stackguard0 = stackPreempt\n    }\n}</code></pre>\n<p><code>releasem</code>函数主要是减少<code>locks</code>引用计数，并判断是否需要<code>g</code>被抢占</p>\n<h2 id=\"acquirep\"><a href=\"#acquirep\" class=\"headerlink\" title=\"acquirep\"></a>acquirep</h2><pre><code class=\"go\">func acquirep(_p_ *p) {\n    wirep(_p_)\n}</code></pre>\n<pre><code class=\"go\">func wirep(_p_ *p) {\n    _g_ := getg()\n    _g_.m.p.set(_p_)\n    _p_.m.set(_g_.m)\n    _p_.status = _Prunning\n}</code></pre>\n<p><code>acquirep</code>函数主要流程：</p>\n<ul>\n<li>绑定<code>p</code>和<code>m</code></li>\n<li>将<code>p</code>的状态置为<code>_Prunning</code></li>\n</ul>\n<h2 id=\"releasep\"><a href=\"#releasep\" class=\"headerlink\" title=\"releasep\"></a>releasep</h2><pre><code class=\"go\">func releasep() *p {\n    _g_ := getg()\n    _p_ := _g_.m.p.ptr()\n    _g_.m.p = 0\n    _p_.m = 0\n    _p_.status = _Pidle\n    return _p_\n}</code></pre>\n<p><code>releasep</code>函数主要流程：</p>\n<ul>\n<li>解绑<code>m</code>和<code>p</code></li>\n<li>将<code>p</code>的状态置为<code>_Pidle</code></li>\n<li>返回<code>p</code></li>\n</ul>\n<h1 id=\"疑问\"><a href=\"#疑问\" class=\"headerlink\" title=\"疑问\"></a>疑问</h1><h2 id=\"p的本地可执行列表无锁，其他p怎么偷取可执行列表\"><a href=\"#p的本地可执行列表无锁，其他p怎么偷取可执行列表\" class=\"headerlink\" title=\"p的本地可执行列表无锁，其他p怎么偷取可执行列表\"></a>p的本地可执行列表无锁，其他p怎么偷取可执行列表</h2><p>通过原子cas的方式提交列表头尾位置，如果失败则重新偷取。</p>\n<h2 id=\"g进入-Gwaiting状态后去哪里了\"><a href=\"#g进入-Gwaiting状态后去哪里了\" class=\"headerlink\" title=\"g进入_Gwaiting状态后去哪里了\"></a>g进入_Gwaiting状态后去哪里了</h2><ul>\n<li>如果<code>g</code>是被抢占了，则将g的状态改为<code>_Grunnable</code>，放入全局可执行队列中</li>\n<li>如果是主动切换，调用<code>gopark</code>的调用者需要维护<code>sudog</code>列表（<code>sudog</code>用于保存调用<code>gopark</code>的<code>g</code>），接收已完成的<code>goroutine</code>，然后调用<code>goready</code>，将他们状态置为<code>_Grunnable</code>，存入本地的可执行队列中。</li>\n</ul>\n<h2 id=\"m进入自旋，在干嘛\"><a href=\"#m进入自旋，在干嘛\" class=\"headerlink\" title=\"m进入自旋，在干嘛\"></a>m进入自旋，在干嘛</h2><p><code>m</code>自旋，即<code>m</code>阻塞于<code>schedule()</code>的<code>findrunnable()</code>，<code>m</code>会一直尝试获取可执行的<code>g</code>去工作。</p>\n<h2 id=\"g0栈复用\"><a href=\"#g0栈复用\" class=\"headerlink\" title=\"g0栈复用\"></a>g0栈复用</h2><p><code>g0</code>的栈在golang中不同系统采用不同的初始化方式。</p>\n<pre><code class=\"go\">if iscgo || GOOS == &quot;solaris&quot; || GOOS == &quot;illumos&quot; || GOOS == &quot;windows&quot; || GOOS == &quot;plan9&quot; || GOOS == &quot;darwin&quot; || GOOS == &quot;ios&quot; {\n        // 如果是上面的情况 g0栈是用的 pthread_create 线程栈\n        mp.g0 = malg(-1)\n    } else {\n        mp.g0 = malg(8192 * sys.StackGuardMultiplier)\n    }</code></pre>\n<p>每次切到<code>g0</code>栈执行指令时，<code>g0-&gt;sched.sp</code>在初始化后没有修改该过，所以每次切换到g0时栈起始值相同，每次调用<code>mcall</code>都会从指定栈位置开始执行相关操作，以此来复用g0栈。</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ul>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODEzNjI2NA==&mid=2247487178&amp;idx=2&amp;sn=121f293c1502b10e7569a0e7216de79e&source=41#wechat_redirect\" target=\"_blank\" rel=\"noopener\">详尽干货！从源码角度看 Golang 的调度</a></li>\n<li><a href=\"https://zboya.github.io/post/go_scheduler/\" target=\"_blank\" rel=\"noopener\">深入golang runtime的调度</a></li>\n</ul>\n"},{"author":"djaigo","title":"golang 编译指示","img":"https://img-1251474779.cos.ap-beijing.myqcloud.com/golang.png","date":"2020-03-15T02:09:36.000Z","updated":"2020-11-03T16:00:00.000Z","enable html":false,"_content":"\n# 编译指示\n函数声明前一行写上`//go:`后面跟上编译指示，在编译的时候，go编译器会进行指定的操作\n\n\n```go\n// cmd/compile/internal/gc/lex.go\n\nconst (\n\t// Func pragmas.\n\tNointerface    PragmaFlag = 1 << iota\n\tNoescape                  // func parameters don't escape\n\tNorace                    // func must not have race detector annotations\n\tNosplit                   // func should not execute on separate stack\n\tNoinline                  // func should not be inlined\n\tNoCheckPtr                // func should not be instrumented by checkptr\n\tCgoUnsafeArgs             // treat a pointer to one arg as a pointer to them all\n\tUintptrEscapes            // pointers converted to uintptr escape\n\n\t// Runtime-only func pragmas.\n\t// See ../../../../runtime/README.md for detailed descriptions.\n\tSystemstack        // func must run on system stack\n\tNowritebarrier     // emit compiler error instead of write barrier\n\tNowritebarrierrec  // error on write barrier in this or recursive callees\n\tYeswritebarrierrec // cancels Nowritebarrierrec in this function and callees\n\n\t// Runtime and cgo type pragmas\n\tNotInHeap // values of this type must not be heap allocated\n\n\t// Go command pragmas\n\tGoBuildPragma\n)\n\nfunc pragmaFlag(verb string) PragmaFlag {\n\tswitch verb {\n\tcase \"go:build\":\n\t\treturn GoBuildPragma\n\tcase \"go:nointerface\":\n\t\tif objabi.Fieldtrack_enabled != 0 {\n\t\t\treturn Nointerface\n\t\t}\n\tcase \"go:noescape\":\n\t\treturn Noescape\n\tcase \"go:norace\":\n\t\treturn Norace\n\tcase \"go:nosplit\":\n\t\treturn Nosplit | NoCheckPtr // implies NoCheckPtr (see #34972)\n\tcase \"go:noinline\":\n\t\treturn Noinline\n\tcase \"go:nocheckptr\":\n\t\treturn NoCheckPtr\n\tcase \"go:systemstack\":\n\t\treturn Systemstack\n\tcase \"go:nowritebarrier\":\n\t\treturn Nowritebarrier\n\tcase \"go:nowritebarrierrec\":\n\t\treturn Nowritebarrierrec | Nowritebarrier // implies Nowritebarrier\n\tcase \"go:yeswritebarrierrec\":\n\t\treturn Yeswritebarrierrec\n\tcase \"go:cgo_unsafe_args\":\n\t\treturn CgoUnsafeArgs | NoCheckPtr // implies NoCheckPtr (see #34968)\n\tcase \"go:uintptrescapes\":\n\t\t// For the next function declared in the file\n\t\t// any uintptr arguments may be pointer values\n\t\t// converted to uintptr. This directive\n\t\t// ensures that the referenced allocated\n\t\t// object, if any, is retained and not moved\n\t\t// until the call completes, even though from\n\t\t// the types alone it would appear that the\n\t\t// object is no longer needed during the\n\t\t// call. The conversion to uintptr must appear\n\t\t// in the argument list.\n\t\t// Used in syscall/dll_windows.go.\n\t\treturn UintptrEscapes\n\tcase \"go:notinheap\":\n\t\treturn NotInHeap\n\t}\n\treturn 0\n}\n```\n\n# 通用标签\n## noescape\n`//go:noescape`表示当前函数的局部变量不能逃逸，它只能指示一个只有声明没有主体的函数。\n例如：在原子操作，函数内创建的变量是不能向外传递指针，只能传递值\n```go\n//go:noescape\nfunc Xadd(ptr *uint32, delta int32) uint32\n```\n\n## norace\n`//go:norace`表示当前函数不需要竞态检测。\n例如：处理错误信号时，在没有m或g的外部堆栈上运行，所以没有竞争\n```go\n//go:norace\nfunc badsignal(sig uintptr, c *sigctxt) {\n    ......\n}\n```\n\n## nosplit\n`//go:nosplit`表示当前函数不需要栈溢出检测。\n例如：当创建新的协程的函数是在`g0`栈上执行的，`g0`栈是不需要栈溢出检测的，所以就使用`nosplit`进行标记。\n```go\n//go:nosplit\nfunc newproc(siz int32, fn *funcval) {\n\t......\n}\n```\n\n\n## noinline\n`//go:noinline`表示当前函数不需要内联。\n例如：原子获取`uint32`指针指向的值\n```go\n//go:noinline\nfunc Load(ptr *uint32) uint32 {\n\treturn *ptr\n}\n```\n\n\n## linkname\n`//go:linkname`表示函数之间的链接，可以将不可导出函数通过链接方式指向另一个包外的函数。\n例如：将`runtime/timestub.go`的`time_now()`链接到`time/time.go`的`time.now()`\n```go\nimport _ \"unsafe\" // for go:linkname\n\n//go:linkname time_now time.now\nfunc time_now() (sec int64, nsec int32, mono int64) {\n\tsec, nsec = walltime()\n\treturn sec, nsec, nanotime()\n}\n```\n\n# 仅运行时可用标签\n## systemstack\n`//go:systemstack`表示当前函数只能在系统栈上运行，即`m->g0`的栈上运行。进入该标签函数必须要在`func systemstack(fn func())`作为参数fn的一部分。\n例如：创建新协程时需要使用系统栈进行创建相关操作\n```go\nsystemstack(func() {\n\tnewg := newproc1(fn, argp, siz, gp, pc) // 创建新g\n})\n\n//go:systemstack\nfunc newproc1(fn *funcval, argp unsafe.Pointer, narg int32, callergp *g, callerpc uintptr) *g {\n    ......\n}\n```\n\n## nowritebarrier\n`//go:nowritebarrier`表示允许编译器用错误替换写屏障\n\n## nowritebarrierrec\n`//go:nowritebarrierrec`表示允许编译器用错误替换写屏障，并允许递归\n\n## yeswritebarrierrec\n`//go:yeswritebarrierrec`表示编译器遇到写屏障时停止\n\n# 运行时或cgo标签\n\n## notinheap\n`//go:notinheap`表示当前对象不能使用堆内存进行分配\n例如：`mcache`不是由GC内存分配的，所以需要标记\n```go\n//go:notinheap\ntype mcache struct {\n\t......\n}\n```\n\n\n# 命令标签\n## build\n`//go:build`\n","source":"_posts/golang编译指示.md","raw":"---\nauthor: djaigo\ntitle: golang 编译指示\nimg: 'https://img-1251474779.cos.ap-beijing.myqcloud.com/golang.png'\ncategories:\n  - golang\ntags:\n  - compile\ndate: 2020-03-15 10:09:36\nupdated: 2020-11-04\nenable html: false\n---\n\n# 编译指示\n函数声明前一行写上`//go:`后面跟上编译指示，在编译的时候，go编译器会进行指定的操作\n\n\n```go\n// cmd/compile/internal/gc/lex.go\n\nconst (\n\t// Func pragmas.\n\tNointerface    PragmaFlag = 1 << iota\n\tNoescape                  // func parameters don't escape\n\tNorace                    // func must not have race detector annotations\n\tNosplit                   // func should not execute on separate stack\n\tNoinline                  // func should not be inlined\n\tNoCheckPtr                // func should not be instrumented by checkptr\n\tCgoUnsafeArgs             // treat a pointer to one arg as a pointer to them all\n\tUintptrEscapes            // pointers converted to uintptr escape\n\n\t// Runtime-only func pragmas.\n\t// See ../../../../runtime/README.md for detailed descriptions.\n\tSystemstack        // func must run on system stack\n\tNowritebarrier     // emit compiler error instead of write barrier\n\tNowritebarrierrec  // error on write barrier in this or recursive callees\n\tYeswritebarrierrec // cancels Nowritebarrierrec in this function and callees\n\n\t// Runtime and cgo type pragmas\n\tNotInHeap // values of this type must not be heap allocated\n\n\t// Go command pragmas\n\tGoBuildPragma\n)\n\nfunc pragmaFlag(verb string) PragmaFlag {\n\tswitch verb {\n\tcase \"go:build\":\n\t\treturn GoBuildPragma\n\tcase \"go:nointerface\":\n\t\tif objabi.Fieldtrack_enabled != 0 {\n\t\t\treturn Nointerface\n\t\t}\n\tcase \"go:noescape\":\n\t\treturn Noescape\n\tcase \"go:norace\":\n\t\treturn Norace\n\tcase \"go:nosplit\":\n\t\treturn Nosplit | NoCheckPtr // implies NoCheckPtr (see #34972)\n\tcase \"go:noinline\":\n\t\treturn Noinline\n\tcase \"go:nocheckptr\":\n\t\treturn NoCheckPtr\n\tcase \"go:systemstack\":\n\t\treturn Systemstack\n\tcase \"go:nowritebarrier\":\n\t\treturn Nowritebarrier\n\tcase \"go:nowritebarrierrec\":\n\t\treturn Nowritebarrierrec | Nowritebarrier // implies Nowritebarrier\n\tcase \"go:yeswritebarrierrec\":\n\t\treturn Yeswritebarrierrec\n\tcase \"go:cgo_unsafe_args\":\n\t\treturn CgoUnsafeArgs | NoCheckPtr // implies NoCheckPtr (see #34968)\n\tcase \"go:uintptrescapes\":\n\t\t// For the next function declared in the file\n\t\t// any uintptr arguments may be pointer values\n\t\t// converted to uintptr. This directive\n\t\t// ensures that the referenced allocated\n\t\t// object, if any, is retained and not moved\n\t\t// until the call completes, even though from\n\t\t// the types alone it would appear that the\n\t\t// object is no longer needed during the\n\t\t// call. The conversion to uintptr must appear\n\t\t// in the argument list.\n\t\t// Used in syscall/dll_windows.go.\n\t\treturn UintptrEscapes\n\tcase \"go:notinheap\":\n\t\treturn NotInHeap\n\t}\n\treturn 0\n}\n```\n\n# 通用标签\n## noescape\n`//go:noescape`表示当前函数的局部变量不能逃逸，它只能指示一个只有声明没有主体的函数。\n例如：在原子操作，函数内创建的变量是不能向外传递指针，只能传递值\n```go\n//go:noescape\nfunc Xadd(ptr *uint32, delta int32) uint32\n```\n\n## norace\n`//go:norace`表示当前函数不需要竞态检测。\n例如：处理错误信号时，在没有m或g的外部堆栈上运行，所以没有竞争\n```go\n//go:norace\nfunc badsignal(sig uintptr, c *sigctxt) {\n    ......\n}\n```\n\n## nosplit\n`//go:nosplit`表示当前函数不需要栈溢出检测。\n例如：当创建新的协程的函数是在`g0`栈上执行的，`g0`栈是不需要栈溢出检测的，所以就使用`nosplit`进行标记。\n```go\n//go:nosplit\nfunc newproc(siz int32, fn *funcval) {\n\t......\n}\n```\n\n\n## noinline\n`//go:noinline`表示当前函数不需要内联。\n例如：原子获取`uint32`指针指向的值\n```go\n//go:noinline\nfunc Load(ptr *uint32) uint32 {\n\treturn *ptr\n}\n```\n\n\n## linkname\n`//go:linkname`表示函数之间的链接，可以将不可导出函数通过链接方式指向另一个包外的函数。\n例如：将`runtime/timestub.go`的`time_now()`链接到`time/time.go`的`time.now()`\n```go\nimport _ \"unsafe\" // for go:linkname\n\n//go:linkname time_now time.now\nfunc time_now() (sec int64, nsec int32, mono int64) {\n\tsec, nsec = walltime()\n\treturn sec, nsec, nanotime()\n}\n```\n\n# 仅运行时可用标签\n## systemstack\n`//go:systemstack`表示当前函数只能在系统栈上运行，即`m->g0`的栈上运行。进入该标签函数必须要在`func systemstack(fn func())`作为参数fn的一部分。\n例如：创建新协程时需要使用系统栈进行创建相关操作\n```go\nsystemstack(func() {\n\tnewg := newproc1(fn, argp, siz, gp, pc) // 创建新g\n})\n\n//go:systemstack\nfunc newproc1(fn *funcval, argp unsafe.Pointer, narg int32, callergp *g, callerpc uintptr) *g {\n    ......\n}\n```\n\n## nowritebarrier\n`//go:nowritebarrier`表示允许编译器用错误替换写屏障\n\n## nowritebarrierrec\n`//go:nowritebarrierrec`表示允许编译器用错误替换写屏障，并允许递归\n\n## yeswritebarrierrec\n`//go:yeswritebarrierrec`表示编译器遇到写屏障时停止\n\n# 运行时或cgo标签\n\n## notinheap\n`//go:notinheap`表示当前对象不能使用堆内存进行分配\n例如：`mcache`不是由GC内存分配的，所以需要标记\n```go\n//go:notinheap\ntype mcache struct {\n\t......\n}\n```\n\n\n# 命令标签\n## build\n`//go:build`\n","slug":"golang编译指示","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckh351dun001919z412iudta4","content":"<h1 id=\"编译指示\"><a href=\"#编译指示\" class=\"headerlink\" title=\"编译指示\"></a>编译指示</h1><p>函数声明前一行写上<code>//go:</code>后面跟上编译指示，在编译的时候，go编译器会进行指定的操作</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token comment\" spellcheck=\"true\">// cmd/compile/internal/gc/lex.go</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Func pragmas.</span>\n    Nointerface    PragmaFlag <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token boolean\">iota</span>\n    Noescape                  <span class=\"token comment\" spellcheck=\"true\">// func parameters don't escape</span>\n    Norace                    <span class=\"token comment\" spellcheck=\"true\">// func must not have race detector annotations</span>\n    Nosplit                   <span class=\"token comment\" spellcheck=\"true\">// func should not execute on separate stack</span>\n    Noinline                  <span class=\"token comment\" spellcheck=\"true\">// func should not be inlined</span>\n    NoCheckPtr                <span class=\"token comment\" spellcheck=\"true\">// func should not be instrumented by checkptr</span>\n    CgoUnsafeArgs             <span class=\"token comment\" spellcheck=\"true\">// treat a pointer to one arg as a pointer to them all</span>\n    UintptrEscapes            <span class=\"token comment\" spellcheck=\"true\">// pointers converted to uintptr escape</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Runtime-only func pragmas.</span>\n    <span class=\"token comment\" spellcheck=\"true\">// See ../../../../runtime/README.md for detailed descriptions.</span>\n    Systemstack        <span class=\"token comment\" spellcheck=\"true\">// func must run on system stack</span>\n    Nowritebarrier     <span class=\"token comment\" spellcheck=\"true\">// emit compiler error instead of write barrier</span>\n    Nowritebarrierrec  <span class=\"token comment\" spellcheck=\"true\">// error on write barrier in this or recursive callees</span>\n    Yeswritebarrierrec <span class=\"token comment\" spellcheck=\"true\">// cancels Nowritebarrierrec in this function and callees</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Runtime and cgo type pragmas</span>\n    NotInHeap <span class=\"token comment\" spellcheck=\"true\">// values of this type must not be heap allocated</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Go command pragmas</span>\n    GoBuildPragma\n<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">pragmaFlag</span><span class=\"token punctuation\">(</span>verb <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> PragmaFlag <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">switch</span> verb <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">case</span> <span class=\"token string\">\"go:build\"</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> GoBuildPragma\n    <span class=\"token keyword\">case</span> <span class=\"token string\">\"go:nointerface\"</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> objabi<span class=\"token punctuation\">.</span>Fieldtrack_enabled <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> Nointerface\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">case</span> <span class=\"token string\">\"go:noescape\"</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> Noescape\n    <span class=\"token keyword\">case</span> <span class=\"token string\">\"go:norace\"</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> Norace\n    <span class=\"token keyword\">case</span> <span class=\"token string\">\"go:nosplit\"</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> Nosplit <span class=\"token operator\">|</span> NoCheckPtr <span class=\"token comment\" spellcheck=\"true\">// implies NoCheckPtr (see #34972)</span>\n    <span class=\"token keyword\">case</span> <span class=\"token string\">\"go:noinline\"</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> Noinline\n    <span class=\"token keyword\">case</span> <span class=\"token string\">\"go:nocheckptr\"</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> NoCheckPtr\n    <span class=\"token keyword\">case</span> <span class=\"token string\">\"go:systemstack\"</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> Systemstack\n    <span class=\"token keyword\">case</span> <span class=\"token string\">\"go:nowritebarrier\"</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> Nowritebarrier\n    <span class=\"token keyword\">case</span> <span class=\"token string\">\"go:nowritebarrierrec\"</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> Nowritebarrierrec <span class=\"token operator\">|</span> Nowritebarrier <span class=\"token comment\" spellcheck=\"true\">// implies Nowritebarrier</span>\n    <span class=\"token keyword\">case</span> <span class=\"token string\">\"go:yeswritebarrierrec\"</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> Yeswritebarrierrec\n    <span class=\"token keyword\">case</span> <span class=\"token string\">\"go:cgo_unsafe_args\"</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> CgoUnsafeArgs <span class=\"token operator\">|</span> NoCheckPtr <span class=\"token comment\" spellcheck=\"true\">// implies NoCheckPtr (see #34968)</span>\n    <span class=\"token keyword\">case</span> <span class=\"token string\">\"go:uintptrescapes\"</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\" spellcheck=\"true\">// For the next function declared in the file</span>\n        <span class=\"token comment\" spellcheck=\"true\">// any uintptr arguments may be pointer values</span>\n        <span class=\"token comment\" spellcheck=\"true\">// converted to uintptr. This directive</span>\n        <span class=\"token comment\" spellcheck=\"true\">// ensures that the referenced allocated</span>\n        <span class=\"token comment\" spellcheck=\"true\">// object, if any, is retained and not moved</span>\n        <span class=\"token comment\" spellcheck=\"true\">// until the call completes, even though from</span>\n        <span class=\"token comment\" spellcheck=\"true\">// the types alone it would appear that the</span>\n        <span class=\"token comment\" spellcheck=\"true\">// object is no longer needed during the</span>\n        <span class=\"token comment\" spellcheck=\"true\">// call. The conversion to uintptr must appear</span>\n        <span class=\"token comment\" spellcheck=\"true\">// in the argument list.</span>\n        <span class=\"token comment\" spellcheck=\"true\">// Used in syscall/dll_windows.go.</span>\n        <span class=\"token keyword\">return</span> UintptrEscapes\n    <span class=\"token keyword\">case</span> <span class=\"token string\">\"go:notinheap\"</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> NotInHeap\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"通用标签\"><a href=\"#通用标签\" class=\"headerlink\" title=\"通用标签\"></a>通用标签</h1><h2 id=\"noescape\"><a href=\"#noescape\" class=\"headerlink\" title=\"noescape\"></a>noescape</h2><p><code>//go:noescape</code>表示当前函数的局部变量不能逃逸，它只能指示一个只有声明没有主体的函数。<br>例如：在原子操作，函数内创建的变量是不能向外传递指针，只能传递值</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token comment\" spellcheck=\"true\">//go:noescape</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">Xadd</span><span class=\"token punctuation\">(</span>ptr <span class=\"token operator\">*</span><span class=\"token builtin\">uint32</span><span class=\"token punctuation\">,</span> delta <span class=\"token builtin\">int32</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">uint32</span></code></pre>\n<h2 id=\"norace\"><a href=\"#norace\" class=\"headerlink\" title=\"norace\"></a>norace</h2><p><code>//go:norace</code>表示当前函数不需要竞态检测。<br>例如：处理错误信号时，在没有m或g的外部堆栈上运行，所以没有竞争</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token comment\" spellcheck=\"true\">//go:norace</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">badsignal</span><span class=\"token punctuation\">(</span>sig <span class=\"token builtin\">uintptr</span><span class=\"token punctuation\">,</span> c <span class=\"token operator\">*</span>sigctxt<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">...</span><span class=\"token operator\">...</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"nosplit\"><a href=\"#nosplit\" class=\"headerlink\" title=\"nosplit\"></a>nosplit</h2><p><code>//go:nosplit</code>表示当前函数不需要栈溢出检测。<br>例如：当创建新的协程的函数是在<code>g0</code>栈上执行的，<code>g0</code>栈是不需要栈溢出检测的，所以就使用<code>nosplit</code>进行标记。</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token comment\" spellcheck=\"true\">//go:nosplit</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">newproc</span><span class=\"token punctuation\">(</span>siz <span class=\"token builtin\">int32</span><span class=\"token punctuation\">,</span> fn <span class=\"token operator\">*</span>funcval<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">...</span><span class=\"token operator\">...</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"noinline\"><a href=\"#noinline\" class=\"headerlink\" title=\"noinline\"></a>noinline</h2><p><code>//go:noinline</code>表示当前函数不需要内联。<br>例如：原子获取<code>uint32</code>指针指向的值</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token comment\" spellcheck=\"true\">//go:noinline</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">Load</span><span class=\"token punctuation\">(</span>ptr <span class=\"token operator\">*</span><span class=\"token builtin\">uint32</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">uint32</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">*</span>ptr\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"linkname\"><a href=\"#linkname\" class=\"headerlink\" title=\"linkname\"></a>linkname</h2><p><code>//go:linkname</code>表示函数之间的链接，可以将不可导出函数通过链接方式指向另一个包外的函数。<br>例如：将<code>runtime/timestub.go</code>的<code>time_now()</code>链接到<code>time/time.go</code>的<code>time.now()</code></p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">import</span> <span class=\"token boolean\">_</span> <span class=\"token string\">\"unsafe\"</span> <span class=\"token comment\" spellcheck=\"true\">// for go:linkname</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//go:linkname time_now time.now</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">time_now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>sec <span class=\"token builtin\">int64</span><span class=\"token punctuation\">,</span> nsec <span class=\"token builtin\">int32</span><span class=\"token punctuation\">,</span> mono <span class=\"token builtin\">int64</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    sec<span class=\"token punctuation\">,</span> nsec <span class=\"token operator\">=</span> <span class=\"token function\">walltime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> sec<span class=\"token punctuation\">,</span> nsec<span class=\"token punctuation\">,</span> <span class=\"token function\">nanotime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"仅运行时可用标签\"><a href=\"#仅运行时可用标签\" class=\"headerlink\" title=\"仅运行时可用标签\"></a>仅运行时可用标签</h1><h2 id=\"systemstack\"><a href=\"#systemstack\" class=\"headerlink\" title=\"systemstack\"></a>systemstack</h2><p><code>//go:systemstack</code>表示当前函数只能在系统栈上运行，即<code>m-&gt;g0</code>的栈上运行。进入该标签函数必须要在<code>func systemstack(fn func())</code>作为参数fn的一部分。<br>例如：创建新协程时需要使用系统栈进行创建相关操作</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token function\">systemstack</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    newg <span class=\"token operator\">:=</span> <span class=\"token function\">newproc1</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">,</span> argp<span class=\"token punctuation\">,</span> siz<span class=\"token punctuation\">,</span> gp<span class=\"token punctuation\">,</span> pc<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 创建新g</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//go:systemstack</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">newproc1</span><span class=\"token punctuation\">(</span>fn <span class=\"token operator\">*</span>funcval<span class=\"token punctuation\">,</span> argp unsafe<span class=\"token punctuation\">.</span>Pointer<span class=\"token punctuation\">,</span> narg <span class=\"token builtin\">int32</span><span class=\"token punctuation\">,</span> callergp <span class=\"token operator\">*</span>g<span class=\"token punctuation\">,</span> callerpc <span class=\"token builtin\">uintptr</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span>g <span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">...</span><span class=\"token operator\">...</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"nowritebarrier\"><a href=\"#nowritebarrier\" class=\"headerlink\" title=\"nowritebarrier\"></a>nowritebarrier</h2><p><code>//go:nowritebarrier</code>表示允许编译器用错误替换写屏障</p>\n<h2 id=\"nowritebarrierrec\"><a href=\"#nowritebarrierrec\" class=\"headerlink\" title=\"nowritebarrierrec\"></a>nowritebarrierrec</h2><p><code>//go:nowritebarrierrec</code>表示允许编译器用错误替换写屏障，并允许递归</p>\n<h2 id=\"yeswritebarrierrec\"><a href=\"#yeswritebarrierrec\" class=\"headerlink\" title=\"yeswritebarrierrec\"></a>yeswritebarrierrec</h2><p><code>//go:yeswritebarrierrec</code>表示编译器遇到写屏障时停止</p>\n<h1 id=\"运行时或cgo标签\"><a href=\"#运行时或cgo标签\" class=\"headerlink\" title=\"运行时或cgo标签\"></a>运行时或cgo标签</h1><h2 id=\"notinheap\"><a href=\"#notinheap\" class=\"headerlink\" title=\"notinheap\"></a>notinheap</h2><p><code>//go:notinheap</code>表示当前对象不能使用堆内存进行分配<br>例如：<code>mcache</code>不是由GC内存分配的，所以需要标记</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token comment\" spellcheck=\"true\">//go:notinheap</span>\n<span class=\"token keyword\">type</span> mcache <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">...</span><span class=\"token operator\">...</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"命令标签\"><a href=\"#命令标签\" class=\"headerlink\" title=\"命令标签\"></a>命令标签</h1><h2 id=\"build\"><a href=\"#build\" class=\"headerlink\" title=\"build\"></a>build</h2><p><code>//go:build</code></p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"friends":[{"avatar":"https://img-1251474779.cos.ap-beijing.myqcloud.com/icon.png","name":"djaigo","introduction":"好好学习，天天向上","url":"/","title":"前去学习"},{"avatar":"https://awps-assets.meituan.net/mit/blog/v20190629/asset/icon/favicon.ico?v=Whistle&t=20181017-1r","name":"美团技术团队","introduction":"一行代码，亿万生活。","url":"https://tech.meituan.com/","title":"点个外卖-->"},{"avatar":"","name":"鸟窝","introduction":"rpcx作者","url":"https://colobu.com/","title":"进个鸟窝-->"},{"avatar":"https://d1j8pt39hxlh3d.cloudfront.net/emoji/emojione/5.0/png/unicode/32/1f92a.png","name":"labuladong的算法小抄","introduction":"算法大神","url":"https://labuladong.gitbook.io/algo/","title":"学个算法-->"}]}},"excerpt":"","more":"<h1 id=\"编译指示\"><a href=\"#编译指示\" class=\"headerlink\" title=\"编译指示\"></a>编译指示</h1><p>函数声明前一行写上<code>//go:</code>后面跟上编译指示，在编译的时候，go编译器会进行指定的操作</p>\n<pre><code class=\"go\">// cmd/compile/internal/gc/lex.go\n\nconst (\n    // Func pragmas.\n    Nointerface    PragmaFlag = 1 &lt;&lt; iota\n    Noescape                  // func parameters don&#39;t escape\n    Norace                    // func must not have race detector annotations\n    Nosplit                   // func should not execute on separate stack\n    Noinline                  // func should not be inlined\n    NoCheckPtr                // func should not be instrumented by checkptr\n    CgoUnsafeArgs             // treat a pointer to one arg as a pointer to them all\n    UintptrEscapes            // pointers converted to uintptr escape\n\n    // Runtime-only func pragmas.\n    // See ../../../../runtime/README.md for detailed descriptions.\n    Systemstack        // func must run on system stack\n    Nowritebarrier     // emit compiler error instead of write barrier\n    Nowritebarrierrec  // error on write barrier in this or recursive callees\n    Yeswritebarrierrec // cancels Nowritebarrierrec in this function and callees\n\n    // Runtime and cgo type pragmas\n    NotInHeap // values of this type must not be heap allocated\n\n    // Go command pragmas\n    GoBuildPragma\n)\n\nfunc pragmaFlag(verb string) PragmaFlag {\n    switch verb {\n    case &quot;go:build&quot;:\n        return GoBuildPragma\n    case &quot;go:nointerface&quot;:\n        if objabi.Fieldtrack_enabled != 0 {\n            return Nointerface\n        }\n    case &quot;go:noescape&quot;:\n        return Noescape\n    case &quot;go:norace&quot;:\n        return Norace\n    case &quot;go:nosplit&quot;:\n        return Nosplit | NoCheckPtr // implies NoCheckPtr (see #34972)\n    case &quot;go:noinline&quot;:\n        return Noinline\n    case &quot;go:nocheckptr&quot;:\n        return NoCheckPtr\n    case &quot;go:systemstack&quot;:\n        return Systemstack\n    case &quot;go:nowritebarrier&quot;:\n        return Nowritebarrier\n    case &quot;go:nowritebarrierrec&quot;:\n        return Nowritebarrierrec | Nowritebarrier // implies Nowritebarrier\n    case &quot;go:yeswritebarrierrec&quot;:\n        return Yeswritebarrierrec\n    case &quot;go:cgo_unsafe_args&quot;:\n        return CgoUnsafeArgs | NoCheckPtr // implies NoCheckPtr (see #34968)\n    case &quot;go:uintptrescapes&quot;:\n        // For the next function declared in the file\n        // any uintptr arguments may be pointer values\n        // converted to uintptr. This directive\n        // ensures that the referenced allocated\n        // object, if any, is retained and not moved\n        // until the call completes, even though from\n        // the types alone it would appear that the\n        // object is no longer needed during the\n        // call. The conversion to uintptr must appear\n        // in the argument list.\n        // Used in syscall/dll_windows.go.\n        return UintptrEscapes\n    case &quot;go:notinheap&quot;:\n        return NotInHeap\n    }\n    return 0\n}</code></pre>\n<h1 id=\"通用标签\"><a href=\"#通用标签\" class=\"headerlink\" title=\"通用标签\"></a>通用标签</h1><h2 id=\"noescape\"><a href=\"#noescape\" class=\"headerlink\" title=\"noescape\"></a>noescape</h2><p><code>//go:noescape</code>表示当前函数的局部变量不能逃逸，它只能指示一个只有声明没有主体的函数。<br>例如：在原子操作，函数内创建的变量是不能向外传递指针，只能传递值</p>\n<pre><code class=\"go\">//go:noescape\nfunc Xadd(ptr *uint32, delta int32) uint32</code></pre>\n<h2 id=\"norace\"><a href=\"#norace\" class=\"headerlink\" title=\"norace\"></a>norace</h2><p><code>//go:norace</code>表示当前函数不需要竞态检测。<br>例如：处理错误信号时，在没有m或g的外部堆栈上运行，所以没有竞争</p>\n<pre><code class=\"go\">//go:norace\nfunc badsignal(sig uintptr, c *sigctxt) {\n    ......\n}</code></pre>\n<h2 id=\"nosplit\"><a href=\"#nosplit\" class=\"headerlink\" title=\"nosplit\"></a>nosplit</h2><p><code>//go:nosplit</code>表示当前函数不需要栈溢出检测。<br>例如：当创建新的协程的函数是在<code>g0</code>栈上执行的，<code>g0</code>栈是不需要栈溢出检测的，所以就使用<code>nosplit</code>进行标记。</p>\n<pre><code class=\"go\">//go:nosplit\nfunc newproc(siz int32, fn *funcval) {\n    ......\n}</code></pre>\n<h2 id=\"noinline\"><a href=\"#noinline\" class=\"headerlink\" title=\"noinline\"></a>noinline</h2><p><code>//go:noinline</code>表示当前函数不需要内联。<br>例如：原子获取<code>uint32</code>指针指向的值</p>\n<pre><code class=\"go\">//go:noinline\nfunc Load(ptr *uint32) uint32 {\n    return *ptr\n}</code></pre>\n<h2 id=\"linkname\"><a href=\"#linkname\" class=\"headerlink\" title=\"linkname\"></a>linkname</h2><p><code>//go:linkname</code>表示函数之间的链接，可以将不可导出函数通过链接方式指向另一个包外的函数。<br>例如：将<code>runtime/timestub.go</code>的<code>time_now()</code>链接到<code>time/time.go</code>的<code>time.now()</code></p>\n<pre><code class=\"go\">import _ &quot;unsafe&quot; // for go:linkname\n\n//go:linkname time_now time.now\nfunc time_now() (sec int64, nsec int32, mono int64) {\n    sec, nsec = walltime()\n    return sec, nsec, nanotime()\n}</code></pre>\n<h1 id=\"仅运行时可用标签\"><a href=\"#仅运行时可用标签\" class=\"headerlink\" title=\"仅运行时可用标签\"></a>仅运行时可用标签</h1><h2 id=\"systemstack\"><a href=\"#systemstack\" class=\"headerlink\" title=\"systemstack\"></a>systemstack</h2><p><code>//go:systemstack</code>表示当前函数只能在系统栈上运行，即<code>m-&gt;g0</code>的栈上运行。进入该标签函数必须要在<code>func systemstack(fn func())</code>作为参数fn的一部分。<br>例如：创建新协程时需要使用系统栈进行创建相关操作</p>\n<pre><code class=\"go\">systemstack(func() {\n    newg := newproc1(fn, argp, siz, gp, pc) // 创建新g\n})\n\n//go:systemstack\nfunc newproc1(fn *funcval, argp unsafe.Pointer, narg int32, callergp *g, callerpc uintptr) *g {\n    ......\n}</code></pre>\n<h2 id=\"nowritebarrier\"><a href=\"#nowritebarrier\" class=\"headerlink\" title=\"nowritebarrier\"></a>nowritebarrier</h2><p><code>//go:nowritebarrier</code>表示允许编译器用错误替换写屏障</p>\n<h2 id=\"nowritebarrierrec\"><a href=\"#nowritebarrierrec\" class=\"headerlink\" title=\"nowritebarrierrec\"></a>nowritebarrierrec</h2><p><code>//go:nowritebarrierrec</code>表示允许编译器用错误替换写屏障，并允许递归</p>\n<h2 id=\"yeswritebarrierrec\"><a href=\"#yeswritebarrierrec\" class=\"headerlink\" title=\"yeswritebarrierrec\"></a>yeswritebarrierrec</h2><p><code>//go:yeswritebarrierrec</code>表示编译器遇到写屏障时停止</p>\n<h1 id=\"运行时或cgo标签\"><a href=\"#运行时或cgo标签\" class=\"headerlink\" title=\"运行时或cgo标签\"></a>运行时或cgo标签</h1><h2 id=\"notinheap\"><a href=\"#notinheap\" class=\"headerlink\" title=\"notinheap\"></a>notinheap</h2><p><code>//go:notinheap</code>表示当前对象不能使用堆内存进行分配<br>例如：<code>mcache</code>不是由GC内存分配的，所以需要标记</p>\n<pre><code class=\"go\">//go:notinheap\ntype mcache struct {\n    ......\n}</code></pre>\n<h1 id=\"命令标签\"><a href=\"#命令标签\" class=\"headerlink\" title=\"命令标签\"></a>命令标签</h1><h2 id=\"build\"><a href=\"#build\" class=\"headerlink\" title=\"build\"></a>build</h2><p><code>//go:build</code></p>\n"},{"author":"djaigo","title":"golang调用IPC","img":"https://img-1251474779.cos.ap-beijing.myqcloud.com/golang.png","date":"2020-04-15T01:26:21.000Z","updated":"2020-04-15T01:26:21.000Z","_content":"\n# 简介\n进程间通信（IPC，Inter-Process Communication）指至少两个进程或线程间传送数据或信号的一些技术或方法。最初Unix IPC包括：管道、FIFO、信号；System V IPC包括：System V消息队列、System V信号灯、System V共享内存区；Posix IPC包括： Posix消息队列、Posix信号灯、Posix共享内存区。\nIPC的生命周期都与内核相同\n# 管道\n管道（Pipe）及有名管道（named pipe）：管道可用于具有亲缘关系进程间的通信，有名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。\n# 信号\n# 消息队列\n消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。\n\n# 信号量\n信号量的本质是一种数据操作锁、用来负责数据操作过程中的互斥、同步等功能。\n信号量用来管理临界资源的。它本身只是一种外部资源的标识、不具有数据交换功能，而是通过控制其他的通信资源实现进程间通信。\n信号量通过PV操作（P减少信号，V增加信号）来控制信号量，其本质上信号量允许多个进程同时执行，当超过预定的数量后再次执行P操作或阻塞等待。P操作也叫做wait操作，sleep操作或者down操作，而V操作也被叫做signal操作，wake-up以及up操作。\n\n\n# 共享内存\n\n# 套接字\n\n# 参考文献\n[深刻理解Linux进程间通信（IPC）](https://www.ibm.com/developerworks/cn/linux/l-ipc/)\n[linux 信号量是什么怎么用？](https://www.zhihu.com/question/47411729)\n[Golang直接操作共享内存](https://studygolang.com/articles/10203)\n","source":"_posts/golang调用IPC.md","raw":"---\nauthor: djaigo\ntitle: golang调用IPC\nimg: 'https://img-1251474779.cos.ap-beijing.myqcloud.com/golang.png'\ncategories:\n  - golang\ntags:\n  - ipc\n  - shmems\n  - queues\n  - semaphores\ndate: 2020-04-15 09:26:21\nupdated: 2020-04-15 09:26:21\n---\n\n# 简介\n进程间通信（IPC，Inter-Process Communication）指至少两个进程或线程间传送数据或信号的一些技术或方法。最初Unix IPC包括：管道、FIFO、信号；System V IPC包括：System V消息队列、System V信号灯、System V共享内存区；Posix IPC包括： Posix消息队列、Posix信号灯、Posix共享内存区。\nIPC的生命周期都与内核相同\n# 管道\n管道（Pipe）及有名管道（named pipe）：管道可用于具有亲缘关系进程间的通信，有名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。\n# 信号\n# 消息队列\n消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。\n\n# 信号量\n信号量的本质是一种数据操作锁、用来负责数据操作过程中的互斥、同步等功能。\n信号量用来管理临界资源的。它本身只是一种外部资源的标识、不具有数据交换功能，而是通过控制其他的通信资源实现进程间通信。\n信号量通过PV操作（P减少信号，V增加信号）来控制信号量，其本质上信号量允许多个进程同时执行，当超过预定的数量后再次执行P操作或阻塞等待。P操作也叫做wait操作，sleep操作或者down操作，而V操作也被叫做signal操作，wake-up以及up操作。\n\n\n# 共享内存\n\n# 套接字\n\n# 参考文献\n[深刻理解Linux进程间通信（IPC）](https://www.ibm.com/developerworks/cn/linux/l-ipc/)\n[linux 信号量是什么怎么用？](https://www.zhihu.com/question/47411729)\n[Golang直接操作共享内存](https://studygolang.com/articles/10203)\n","slug":"golang调用IPC","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckh351dup001c19z4gwmp3xyw","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>进程间通信（IPC，Inter-Process Communication）指至少两个进程或线程间传送数据或信号的一些技术或方法。最初Unix IPC包括：管道、FIFO、信号；System V IPC包括：System V消息队列、System V信号灯、System V共享内存区；Posix IPC包括： Posix消息队列、Posix信号灯、Posix共享内存区。<br>IPC的生命周期都与内核相同</p>\n<h1 id=\"管道\"><a href=\"#管道\" class=\"headerlink\" title=\"管道\"></a>管道</h1><p>管道（Pipe）及有名管道（named pipe）：管道可用于具有亲缘关系进程间的通信，有名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。</p>\n<h1 id=\"信号\"><a href=\"#信号\" class=\"headerlink\" title=\"信号\"></a>信号</h1><h1 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h1><p>消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p>\n<h1 id=\"信号量\"><a href=\"#信号量\" class=\"headerlink\" title=\"信号量\"></a>信号量</h1><p>信号量的本质是一种数据操作锁、用来负责数据操作过程中的互斥、同步等功能。<br>信号量用来管理临界资源的。它本身只是一种外部资源的标识、不具有数据交换功能，而是通过控制其他的通信资源实现进程间通信。<br>信号量通过PV操作（P减少信号，V增加信号）来控制信号量，其本质上信号量允许多个进程同时执行，当超过预定的数量后再次执行P操作或阻塞等待。P操作也叫做wait操作，sleep操作或者down操作，而V操作也被叫做signal操作，wake-up以及up操作。</p>\n<h1 id=\"共享内存\"><a href=\"#共享内存\" class=\"headerlink\" title=\"共享内存\"></a>共享内存</h1><h1 id=\"套接字\"><a href=\"#套接字\" class=\"headerlink\" title=\"套接字\"></a>套接字</h1><h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p><a href=\"https://www.ibm.com/developerworks/cn/linux/l-ipc/\" target=\"_blank\" rel=\"noopener\">深刻理解Linux进程间通信（IPC）</a><br><a href=\"https://www.zhihu.com/question/47411729\" target=\"_blank\" rel=\"noopener\">linux 信号量是什么怎么用？</a><br><a href=\"https://studygolang.com/articles/10203\" target=\"_blank\" rel=\"noopener\">Golang直接操作共享内存</a></p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"friends":[{"avatar":"https://img-1251474779.cos.ap-beijing.myqcloud.com/icon.png","name":"djaigo","introduction":"好好学习，天天向上","url":"/","title":"前去学习"},{"avatar":"https://awps-assets.meituan.net/mit/blog/v20190629/asset/icon/favicon.ico?v=Whistle&t=20181017-1r","name":"美团技术团队","introduction":"一行代码，亿万生活。","url":"https://tech.meituan.com/","title":"点个外卖-->"},{"avatar":"","name":"鸟窝","introduction":"rpcx作者","url":"https://colobu.com/","title":"进个鸟窝-->"},{"avatar":"https://d1j8pt39hxlh3d.cloudfront.net/emoji/emojione/5.0/png/unicode/32/1f92a.png","name":"labuladong的算法小抄","introduction":"算法大神","url":"https://labuladong.gitbook.io/algo/","title":"学个算法-->"}]}},"excerpt":"","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>进程间通信（IPC，Inter-Process Communication）指至少两个进程或线程间传送数据或信号的一些技术或方法。最初Unix IPC包括：管道、FIFO、信号；System V IPC包括：System V消息队列、System V信号灯、System V共享内存区；Posix IPC包括： Posix消息队列、Posix信号灯、Posix共享内存区。<br>IPC的生命周期都与内核相同</p>\n<h1 id=\"管道\"><a href=\"#管道\" class=\"headerlink\" title=\"管道\"></a>管道</h1><p>管道（Pipe）及有名管道（named pipe）：管道可用于具有亲缘关系进程间的通信，有名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。</p>\n<h1 id=\"信号\"><a href=\"#信号\" class=\"headerlink\" title=\"信号\"></a>信号</h1><h1 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h1><p>消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p>\n<h1 id=\"信号量\"><a href=\"#信号量\" class=\"headerlink\" title=\"信号量\"></a>信号量</h1><p>信号量的本质是一种数据操作锁、用来负责数据操作过程中的互斥、同步等功能。<br>信号量用来管理临界资源的。它本身只是一种外部资源的标识、不具有数据交换功能，而是通过控制其他的通信资源实现进程间通信。<br>信号量通过PV操作（P减少信号，V增加信号）来控制信号量，其本质上信号量允许多个进程同时执行，当超过预定的数量后再次执行P操作或阻塞等待。P操作也叫做wait操作，sleep操作或者down操作，而V操作也被叫做signal操作，wake-up以及up操作。</p>\n<h1 id=\"共享内存\"><a href=\"#共享内存\" class=\"headerlink\" title=\"共享内存\"></a>共享内存</h1><h1 id=\"套接字\"><a href=\"#套接字\" class=\"headerlink\" title=\"套接字\"></a>套接字</h1><h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p><a href=\"https://www.ibm.com/developerworks/cn/linux/l-ipc/\" target=\"_blank\" rel=\"noopener\">深刻理解Linux进程间通信（IPC）</a><br><a href=\"https://www.zhihu.com/question/47411729\" target=\"_blank\" rel=\"noopener\">linux 信号量是什么怎么用？</a><br><a href=\"https://studygolang.com/articles/10203\" target=\"_blank\" rel=\"noopener\">Golang直接操作共享内存</a></p>\n"},{"author":"djaigo","title":"golang调用syscall","img":"https://img-1251474779.cos.ap-beijing.myqcloud.com/golang.png","date":"2020-04-17T02:04:41.000Z","updated":"2020-04-17T02:04:41.000Z","_content":"\n# 环境说明\nOS：linux\nARCH：amd64\nGOVERSION：1.14.1\n\n# syscall实现\n\n在linux下golang调用syscall的接口，文件路径`syscall/syscall_unix.go`\n```go\nfunc Syscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno)\nfunc Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno)\nfunc RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno)\nfunc RawSyscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno)\n```\n这些函数的实现都是汇编，按照 linux 的 syscall 调用规范，我们只要在汇编中把参数依次传入寄存器，并调用 SYSCALL 指令即可进入内核处理逻辑，系统调用执行完毕之后，返回值放在 RAX 中：\n\n| RDI   | RSI   | RDX   | R10   | R8    | R9    | RAX              |\n| ---   | ----- | ----  | ---   | ---   | ---   | ---              |\n| 参数一 | 参数二 | 参数三 | 参数四 | 参数五 | 参数六 | 系统调用编号/返回值 |\n\n这些函数的底层实现都是汇编代码，文件路径`syscall/asm_linux_amd64.s`\n```s\nTEXT ·Syscall(SB),NOSPLIT,$0-56\n\tCALL\truntime·entersyscall(SB)\n\tMOVQ\ta1+8(FP), DI\n\tMOVQ\ta2+16(FP), SI\n\tMOVQ\ta3+24(FP), DX\n\tMOVQ\ttrap+0(FP), AX\t// syscall entry\n\tSYSCALL\n\t// 0xfffffffffffff001 是 linux MAX_ERRNO 取反 转无符号，http://lxr.free-electrons.com/source/include/linux/err.h#L17\n\tCMPQ\tAX, $0xfffffffffffff001\n\tJLS\tok\n\tMOVQ\t$-1, r1+32(FP)\n\tMOVQ\t$0, r2+40(FP)\n\tNEGQ\tAX\n\tMOVQ\tAX, err+48(FP)\n\tCALL\truntime·exitsyscall(SB)\n\tRET\nok:\n\tMOVQ\tAX, r1+32(FP)\n\tMOVQ\tDX, r2+40(FP)\n\tMOVQ\t$0, err+48(FP)\n\tCALL\truntime·exitsyscall(SB)\n\tRET\n\n// func Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr)\nTEXT ·Syscall6(SB),NOSPLIT,$0-80\n\tCALL\truntime·entersyscall(SB)\n\tMOVQ\ta1+8(FP), DI\n\tMOVQ\ta2+16(FP), SI\n\tMOVQ\ta3+24(FP), DX\n\tMOVQ\ta4+32(FP), R10\n\tMOVQ\ta5+40(FP), R8\n\tMOVQ\ta6+48(FP), R9\n\tMOVQ\ttrap+0(FP), AX\t// syscall entry\n\tSYSCALL\n\tCMPQ\tAX, $0xfffffffffffff001\n\tJLS\tok6\n\tMOVQ\t$-1, r1+56(FP)\n\tMOVQ\t$0, r2+64(FP)\n\tNEGQ\tAX\n\tMOVQ\tAX, err+72(FP)\n\tCALL\truntime·exitsyscall(SB)\n\tRET\nok6:\n\tMOVQ\tAX, r1+56(FP)\n\tMOVQ\tDX, r2+64(FP)\n\tMOVQ\t$0, err+72(FP)\n\tCALL\truntime·exitsyscall(SB)\n\tRET\n```\n\n可以看到Syscall和Syscall6函数没有区别，只是在传参的个数上有区别，且在开始系统和结束系统调用时会调用`runtime·entersyscall(SB)`和`runtime·exitsyscall(SB)`，这样可以让系统调用和runtime进行沟通，让runtime进行调度当前正在调用syscall的g。\n\n```s\n// func RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2, err uintptr)\nTEXT ·RawSyscall(SB),NOSPLIT,$0-56\n\tMOVQ\ta1+8(FP), DI\n\tMOVQ\ta2+16(FP), SI\n\tMOVQ\ta3+24(FP), DX\n\tMOVQ\ttrap+0(FP), AX\t// syscall entry\n\tSYSCALL\n\tCMPQ\tAX, $0xfffffffffffff001\n\tJLS\tok1\n\tMOVQ\t$-1, r1+32(FP)\n\tMOVQ\t$0, r2+40(FP)\n\tNEGQ\tAX\n\tMOVQ\tAX, err+48(FP)\n\tRET\nok1:\n\tMOVQ\tAX, r1+32(FP)\n\tMOVQ\tDX, r2+40(FP)\n\tMOVQ\t$0, err+48(FP)\n\tRET\n\n// func RawSyscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr)\nTEXT ·RawSyscall6(SB),NOSPLIT,$0-80\n\tMOVQ\ta1+8(FP), DI\n\tMOVQ\ta2+16(FP), SI\n\tMOVQ\ta3+24(FP), DX\n\tMOVQ\ta4+32(FP), R10\n\tMOVQ\ta5+40(FP), R8\n\tMOVQ\ta6+48(FP), R9\n\tMOVQ\ttrap+0(FP), AX\t// syscall entry\n\tSYSCALL\n\tCMPQ\tAX, $0xfffffffffffff001\n\tJLS\tok2\n\tMOVQ\t$-1, r1+56(FP)\n\tMOVQ\t$0, r2+64(FP)\n\tNEGQ\tAX\n\tMOVQ\tAX, err+72(FP)\n\tRET\nok2:\n\tMOVQ\tAX, r1+56(FP)\n\tMOVQ\tDX, r2+64(FP)\n\tMOVQ\t$0, err+72(FP)\n\tRET\n```\n\nRawSyscall和RawSyscall6函数也只是只有传参数目的不同，但是Syscall和RawSyscall的区别在于没有调用`runtime·entersyscall(SB)`和`runtime·exitsyscall(SB)`，这样 runtime 理论上是没有办法通过调度把这个 g 的 m 的 p 调度走的，所以如果用户代码使用了 RawSyscall 来做一些阻塞的系统调用，是有可能阻塞其它的 g 的，下面是官方开发的原话:\n\n> Yes, if you call RawSyscall you may block other goroutines from running. The system monitor may start them up after a while, but I think there are cases where it won't. I would say that Go programs should always call Syscall. RawSyscall exists to make it slightly more efficient to call system calls that never block, such as getpid. But it's really an internal mechanism.\n\n# syscall管理\ngolang实现了部分系统调用，定义在`syscall/syscall_linux.go`中。\n可以把系统调用分为三类:\n*   阻塞系统调用\n*   非阻塞系统调用\n*   wrapped 系统调用\n\n这里截取部分代码注释\n```go\n//sys\tSetpriority(which int, who int, prio int) (err error)\n//sys\tSetxattr(path string, attr string, data []byte, flags int) (err error)\n//sys\tSync()\n//sysnb\tSysinfo(info *Sysinfo_t) (err error)\n//sys\tTee(rfd int, wfd int, len int, flags int) (n int64, err error)\n//sysnb\tTgkill(tgid int, tid int, sig Signal) (err error)\n//sysnb\tTimes(tms *Tms) (ticks uintptr, err error)\n//sysnb\tUmask(mask int) (oldmask int)\n//sysnb\tUname(buf *Utsname) (err error)\n//sys\tUnmount(target string, flags int) (err error) = SYS_UMOUNT2\n//sys\tUnshare(flags int) (err error)\n//sys\twrite(fd int, p []byte) (n int, err error)\n//sys\texitThread(code int) (err error) = SYS_EXIT\n//sys\treadlen(fd int, p *byte, np int) (n int, err error) = SYS_READ\n//sys\twritelen(fd int, p *byte, np int) (n int, err error) = SYS_WRITE\n```\n\n其中有`//sys`表示阻塞的系统调用，`//sysnb`表示非阻塞系统调用。然后，根据这些注释，mksyscall.pl 脚本会生成对应的平台的具体实现。mksyscall.pl 是一段 perl 脚本，感兴趣的同学可以自行查看，这里就不再赘述了。生成的代码前面会有一段`// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT`的注释。\n如果是标记为阻塞的系统调用生成的代码是调用`Syscall`和`Syscall6`，标记为非阻塞的系统调用会`RawSyscall`和`RawSyscall6`。\nwrapped系统调用是封装了一层系统调用，可能是觉得命名风格不是很golang。\n\n# runtime中的syscall\n除了上面提到的阻塞非阻塞和 wrapped syscall，runtime 中还定义了一些 low-level 的 syscall，这些是不暴露给用户的。\n提供给用户的 syscall 库，在使用时，会使 goroutine 和 p 分别进入 Gsyscall 和 Psyscall 状态。但 runtime 自己封装的这些 syscall 无论是否阻塞，都不会调用 entersyscall 和 exitsyscall。虽说是 “low-level” 的 syscall，不过和暴露给用户的 syscall 本质是一样的。\nruntime定义的系统调用列表，定义在`runtime/sys_linux_arm64.s`中。\n\n```golang\n#define SYS_exit\t\t93\n#define SYS_read\t\t63\n#define SYS_write\t\t64\n#define SYS_openat\t\t56\n#define SYS_close\t\t57\n#define SYS_pipe2\t\t59\n#define SYS_fcntl\t\t25\n#define SYS_nanosleep\t\t101\n#define SYS_mmap\t\t222\n#define SYS_munmap\t\t215\n#define SYS_setitimer\t\t103\n#define SYS_clone\t\t220\n#define SYS_sched_yield\t\t124\n#define SYS_rt_sigreturn\t139\n#define SYS_rt_sigaction\t134\n#define SYS_rt_sigprocmask\t135\n#define SYS_sigaltstack\t\t132\n#define SYS_madvise\t\t233\n#define SYS_mincore\t\t232\n#define SYS_getpid\t\t172\n#define SYS_gettid\t\t178\n#define SYS_kill\t\t129\n#define SYS_tgkill\t\t131\n#define SYS_futex\t\t98\n#define SYS_sched_getaffinity\t123\n#define SYS_exit_group\t\t94\n#define SYS_epoll_create1\t20\n#define SYS_epoll_ctl\t\t21\n#define SYS_epoll_pwait\t\t22\n#define SYS_clock_gettime\t113\n#define SYS_faccessat\t\t48\n#define SYS_socket\t\t198\n#define SYS_connect\t\t203\n#define SYS_brk\t\t\t214\n```\n\n这些 syscall 理论上都是不会在执行期间被调度器剥离掉 p 的，所以执行成功之后 goroutine 会继续执行，而不像用户的 goroutine 一样，若被剥离 p 会进入等待队列。\n\n# 调度交互\n既然要和调度交互，那友好地通知我要 syscall 了: entersyscall，我完事了: exitsyscall。\n所以这里的交互指的是用户代码使用 syscall 库时和调度器的交互。**runtime 里的 syscall 不走这套流程。**\n\n文件路径`runtime/proc.go:2974`\n```golang\n// Standard syscall entry used by the go syscall library and normal cgo calls.\n//\n// This is exported via linkname to assembly in the syscall package.\n//\n//go:nosplit\n//go:linkname entersyscall\nfunc entersyscall() {\n\treentersyscall(getcallerpc(), getcallersp())\n}\n```\n\n```golang\n//go:nosplit\nfunc reentersyscall(pc, sp uintptr) {\n\t_g_ := getg()\n\n\t// Disable preemption because during this function g is in Gsyscall status,\n\t// but can have inconsistent g->sched, do not let GC observe it.\n\t_g_.m.locks++\n\n\t// Entersyscall must not call any function that might split/grow the stack.\n\t// (See details in comment above.)\n\t// Catch calls that might, by replacing the stack guard with something that\n\t// will trip any stack check and leaving a flag to tell newstack to die.\n\t_g_.stackguard0 = stackPreempt\n\t_g_.throwsplit = true\n\n\t// Leave SP around for GC and traceback.\n\tsave(pc, sp)\n\t_g_.syscallsp = sp\n\t_g_.syscallpc = pc\n\tcasgstatus(_g_, _Grunning, _Gsyscall)\n\tif _g_.syscallsp < _g_.stack.lo || _g_.stack.hi < _g_.syscallsp {\n\t\tsystemstack(func() {\n\t\t\tprint(\"entersyscall inconsistent \", hex(_g_.syscallsp), \" [\", hex(_g_.stack.lo), \",\", hex(_g_.stack.hi), \"]\\n\")\n\t\t\tthrow(\"entersyscall\")\n\t\t})\n\t}\n\n\tif trace.enabled {\n\t\tsystemstack(traceGoSysCall)\n\t\t// systemstack itself clobbers g.sched.{pc,sp} and we might\n\t\t// need them later when the G is genuinely blocked in a\n\t\t// syscall\n\t\tsave(pc, sp)\n\t}\n\n\tif atomic.Load(&sched.sysmonwait) != 0 {\n\t\tsystemstack(entersyscall_sysmon)\n\t\tsave(pc, sp)\n\t}\n\n\tif _g_.m.p.ptr().runSafePointFn != 0 {\n\t\t// runSafePointFn may stack split if run on this stack\n\t\tsystemstack(runSafePointFn)\n\t\tsave(pc, sp)\n\t}\n\n\t_g_.m.syscalltick = _g_.m.p.ptr().syscalltick\n\t_g_.sysblocktraced = true\n\t_g_.m.mcache = nil\n\tpp := _g_.m.p.ptr()\n\tpp.m = 0\n\t_g_.m.oldp.set(pp)\n\t_g_.m.p = 0\n\tatomic.Store(&pp.status, _Psyscall)\n\tif sched.gcwaiting != 0 {\n\t\tsystemstack(entersyscall_gcwait)\n\t\tsave(pc, sp)\n\t}\n\n\t_g_.m.locks--\n}\n```\n\n# 参考文献\n[曹春晖：谈一谈 Go 和 Syscall]([https://juejin.im/post/5cdd56f6e51d456e8b07de5e](https://juejin.im/post/5cdd56f6e51d456e8b07de5e))\n","source":"_posts/golang调用syscall.md","raw":"---\nauthor: djaigo\ntitle: golang调用syscall\nimg: 'https://img-1251474779.cos.ap-beijing.myqcloud.com/golang.png'\ncategories:\n  - golang\ntags:\n  - syscall\n  - linux\n  - syscall6\n  - rawsyscall\n  - rawsyscall6\ndate: 2020-04-17 10:04:41\nupdated: 2020-04-17 10:04:41\n---\n\n# 环境说明\nOS：linux\nARCH：amd64\nGOVERSION：1.14.1\n\n# syscall实现\n\n在linux下golang调用syscall的接口，文件路径`syscall/syscall_unix.go`\n```go\nfunc Syscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno)\nfunc Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno)\nfunc RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno)\nfunc RawSyscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno)\n```\n这些函数的实现都是汇编，按照 linux 的 syscall 调用规范，我们只要在汇编中把参数依次传入寄存器，并调用 SYSCALL 指令即可进入内核处理逻辑，系统调用执行完毕之后，返回值放在 RAX 中：\n\n| RDI   | RSI   | RDX   | R10   | R8    | R9    | RAX              |\n| ---   | ----- | ----  | ---   | ---   | ---   | ---              |\n| 参数一 | 参数二 | 参数三 | 参数四 | 参数五 | 参数六 | 系统调用编号/返回值 |\n\n这些函数的底层实现都是汇编代码，文件路径`syscall/asm_linux_amd64.s`\n```s\nTEXT ·Syscall(SB),NOSPLIT,$0-56\n\tCALL\truntime·entersyscall(SB)\n\tMOVQ\ta1+8(FP), DI\n\tMOVQ\ta2+16(FP), SI\n\tMOVQ\ta3+24(FP), DX\n\tMOVQ\ttrap+0(FP), AX\t// syscall entry\n\tSYSCALL\n\t// 0xfffffffffffff001 是 linux MAX_ERRNO 取反 转无符号，http://lxr.free-electrons.com/source/include/linux/err.h#L17\n\tCMPQ\tAX, $0xfffffffffffff001\n\tJLS\tok\n\tMOVQ\t$-1, r1+32(FP)\n\tMOVQ\t$0, r2+40(FP)\n\tNEGQ\tAX\n\tMOVQ\tAX, err+48(FP)\n\tCALL\truntime·exitsyscall(SB)\n\tRET\nok:\n\tMOVQ\tAX, r1+32(FP)\n\tMOVQ\tDX, r2+40(FP)\n\tMOVQ\t$0, err+48(FP)\n\tCALL\truntime·exitsyscall(SB)\n\tRET\n\n// func Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr)\nTEXT ·Syscall6(SB),NOSPLIT,$0-80\n\tCALL\truntime·entersyscall(SB)\n\tMOVQ\ta1+8(FP), DI\n\tMOVQ\ta2+16(FP), SI\n\tMOVQ\ta3+24(FP), DX\n\tMOVQ\ta4+32(FP), R10\n\tMOVQ\ta5+40(FP), R8\n\tMOVQ\ta6+48(FP), R9\n\tMOVQ\ttrap+0(FP), AX\t// syscall entry\n\tSYSCALL\n\tCMPQ\tAX, $0xfffffffffffff001\n\tJLS\tok6\n\tMOVQ\t$-1, r1+56(FP)\n\tMOVQ\t$0, r2+64(FP)\n\tNEGQ\tAX\n\tMOVQ\tAX, err+72(FP)\n\tCALL\truntime·exitsyscall(SB)\n\tRET\nok6:\n\tMOVQ\tAX, r1+56(FP)\n\tMOVQ\tDX, r2+64(FP)\n\tMOVQ\t$0, err+72(FP)\n\tCALL\truntime·exitsyscall(SB)\n\tRET\n```\n\n可以看到Syscall和Syscall6函数没有区别，只是在传参的个数上有区别，且在开始系统和结束系统调用时会调用`runtime·entersyscall(SB)`和`runtime·exitsyscall(SB)`，这样可以让系统调用和runtime进行沟通，让runtime进行调度当前正在调用syscall的g。\n\n```s\n// func RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2, err uintptr)\nTEXT ·RawSyscall(SB),NOSPLIT,$0-56\n\tMOVQ\ta1+8(FP), DI\n\tMOVQ\ta2+16(FP), SI\n\tMOVQ\ta3+24(FP), DX\n\tMOVQ\ttrap+0(FP), AX\t// syscall entry\n\tSYSCALL\n\tCMPQ\tAX, $0xfffffffffffff001\n\tJLS\tok1\n\tMOVQ\t$-1, r1+32(FP)\n\tMOVQ\t$0, r2+40(FP)\n\tNEGQ\tAX\n\tMOVQ\tAX, err+48(FP)\n\tRET\nok1:\n\tMOVQ\tAX, r1+32(FP)\n\tMOVQ\tDX, r2+40(FP)\n\tMOVQ\t$0, err+48(FP)\n\tRET\n\n// func RawSyscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr)\nTEXT ·RawSyscall6(SB),NOSPLIT,$0-80\n\tMOVQ\ta1+8(FP), DI\n\tMOVQ\ta2+16(FP), SI\n\tMOVQ\ta3+24(FP), DX\n\tMOVQ\ta4+32(FP), R10\n\tMOVQ\ta5+40(FP), R8\n\tMOVQ\ta6+48(FP), R9\n\tMOVQ\ttrap+0(FP), AX\t// syscall entry\n\tSYSCALL\n\tCMPQ\tAX, $0xfffffffffffff001\n\tJLS\tok2\n\tMOVQ\t$-1, r1+56(FP)\n\tMOVQ\t$0, r2+64(FP)\n\tNEGQ\tAX\n\tMOVQ\tAX, err+72(FP)\n\tRET\nok2:\n\tMOVQ\tAX, r1+56(FP)\n\tMOVQ\tDX, r2+64(FP)\n\tMOVQ\t$0, err+72(FP)\n\tRET\n```\n\nRawSyscall和RawSyscall6函数也只是只有传参数目的不同，但是Syscall和RawSyscall的区别在于没有调用`runtime·entersyscall(SB)`和`runtime·exitsyscall(SB)`，这样 runtime 理论上是没有办法通过调度把这个 g 的 m 的 p 调度走的，所以如果用户代码使用了 RawSyscall 来做一些阻塞的系统调用，是有可能阻塞其它的 g 的，下面是官方开发的原话:\n\n> Yes, if you call RawSyscall you may block other goroutines from running. The system monitor may start them up after a while, but I think there are cases where it won't. I would say that Go programs should always call Syscall. RawSyscall exists to make it slightly more efficient to call system calls that never block, such as getpid. But it's really an internal mechanism.\n\n# syscall管理\ngolang实现了部分系统调用，定义在`syscall/syscall_linux.go`中。\n可以把系统调用分为三类:\n*   阻塞系统调用\n*   非阻塞系统调用\n*   wrapped 系统调用\n\n这里截取部分代码注释\n```go\n//sys\tSetpriority(which int, who int, prio int) (err error)\n//sys\tSetxattr(path string, attr string, data []byte, flags int) (err error)\n//sys\tSync()\n//sysnb\tSysinfo(info *Sysinfo_t) (err error)\n//sys\tTee(rfd int, wfd int, len int, flags int) (n int64, err error)\n//sysnb\tTgkill(tgid int, tid int, sig Signal) (err error)\n//sysnb\tTimes(tms *Tms) (ticks uintptr, err error)\n//sysnb\tUmask(mask int) (oldmask int)\n//sysnb\tUname(buf *Utsname) (err error)\n//sys\tUnmount(target string, flags int) (err error) = SYS_UMOUNT2\n//sys\tUnshare(flags int) (err error)\n//sys\twrite(fd int, p []byte) (n int, err error)\n//sys\texitThread(code int) (err error) = SYS_EXIT\n//sys\treadlen(fd int, p *byte, np int) (n int, err error) = SYS_READ\n//sys\twritelen(fd int, p *byte, np int) (n int, err error) = SYS_WRITE\n```\n\n其中有`//sys`表示阻塞的系统调用，`//sysnb`表示非阻塞系统调用。然后，根据这些注释，mksyscall.pl 脚本会生成对应的平台的具体实现。mksyscall.pl 是一段 perl 脚本，感兴趣的同学可以自行查看，这里就不再赘述了。生成的代码前面会有一段`// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT`的注释。\n如果是标记为阻塞的系统调用生成的代码是调用`Syscall`和`Syscall6`，标记为非阻塞的系统调用会`RawSyscall`和`RawSyscall6`。\nwrapped系统调用是封装了一层系统调用，可能是觉得命名风格不是很golang。\n\n# runtime中的syscall\n除了上面提到的阻塞非阻塞和 wrapped syscall，runtime 中还定义了一些 low-level 的 syscall，这些是不暴露给用户的。\n提供给用户的 syscall 库，在使用时，会使 goroutine 和 p 分别进入 Gsyscall 和 Psyscall 状态。但 runtime 自己封装的这些 syscall 无论是否阻塞，都不会调用 entersyscall 和 exitsyscall。虽说是 “low-level” 的 syscall，不过和暴露给用户的 syscall 本质是一样的。\nruntime定义的系统调用列表，定义在`runtime/sys_linux_arm64.s`中。\n\n```golang\n#define SYS_exit\t\t93\n#define SYS_read\t\t63\n#define SYS_write\t\t64\n#define SYS_openat\t\t56\n#define SYS_close\t\t57\n#define SYS_pipe2\t\t59\n#define SYS_fcntl\t\t25\n#define SYS_nanosleep\t\t101\n#define SYS_mmap\t\t222\n#define SYS_munmap\t\t215\n#define SYS_setitimer\t\t103\n#define SYS_clone\t\t220\n#define SYS_sched_yield\t\t124\n#define SYS_rt_sigreturn\t139\n#define SYS_rt_sigaction\t134\n#define SYS_rt_sigprocmask\t135\n#define SYS_sigaltstack\t\t132\n#define SYS_madvise\t\t233\n#define SYS_mincore\t\t232\n#define SYS_getpid\t\t172\n#define SYS_gettid\t\t178\n#define SYS_kill\t\t129\n#define SYS_tgkill\t\t131\n#define SYS_futex\t\t98\n#define SYS_sched_getaffinity\t123\n#define SYS_exit_group\t\t94\n#define SYS_epoll_create1\t20\n#define SYS_epoll_ctl\t\t21\n#define SYS_epoll_pwait\t\t22\n#define SYS_clock_gettime\t113\n#define SYS_faccessat\t\t48\n#define SYS_socket\t\t198\n#define SYS_connect\t\t203\n#define SYS_brk\t\t\t214\n```\n\n这些 syscall 理论上都是不会在执行期间被调度器剥离掉 p 的，所以执行成功之后 goroutine 会继续执行，而不像用户的 goroutine 一样，若被剥离 p 会进入等待队列。\n\n# 调度交互\n既然要和调度交互，那友好地通知我要 syscall 了: entersyscall，我完事了: exitsyscall。\n所以这里的交互指的是用户代码使用 syscall 库时和调度器的交互。**runtime 里的 syscall 不走这套流程。**\n\n文件路径`runtime/proc.go:2974`\n```golang\n// Standard syscall entry used by the go syscall library and normal cgo calls.\n//\n// This is exported via linkname to assembly in the syscall package.\n//\n//go:nosplit\n//go:linkname entersyscall\nfunc entersyscall() {\n\treentersyscall(getcallerpc(), getcallersp())\n}\n```\n\n```golang\n//go:nosplit\nfunc reentersyscall(pc, sp uintptr) {\n\t_g_ := getg()\n\n\t// Disable preemption because during this function g is in Gsyscall status,\n\t// but can have inconsistent g->sched, do not let GC observe it.\n\t_g_.m.locks++\n\n\t// Entersyscall must not call any function that might split/grow the stack.\n\t// (See details in comment above.)\n\t// Catch calls that might, by replacing the stack guard with something that\n\t// will trip any stack check and leaving a flag to tell newstack to die.\n\t_g_.stackguard0 = stackPreempt\n\t_g_.throwsplit = true\n\n\t// Leave SP around for GC and traceback.\n\tsave(pc, sp)\n\t_g_.syscallsp = sp\n\t_g_.syscallpc = pc\n\tcasgstatus(_g_, _Grunning, _Gsyscall)\n\tif _g_.syscallsp < _g_.stack.lo || _g_.stack.hi < _g_.syscallsp {\n\t\tsystemstack(func() {\n\t\t\tprint(\"entersyscall inconsistent \", hex(_g_.syscallsp), \" [\", hex(_g_.stack.lo), \",\", hex(_g_.stack.hi), \"]\\n\")\n\t\t\tthrow(\"entersyscall\")\n\t\t})\n\t}\n\n\tif trace.enabled {\n\t\tsystemstack(traceGoSysCall)\n\t\t// systemstack itself clobbers g.sched.{pc,sp} and we might\n\t\t// need them later when the G is genuinely blocked in a\n\t\t// syscall\n\t\tsave(pc, sp)\n\t}\n\n\tif atomic.Load(&sched.sysmonwait) != 0 {\n\t\tsystemstack(entersyscall_sysmon)\n\t\tsave(pc, sp)\n\t}\n\n\tif _g_.m.p.ptr().runSafePointFn != 0 {\n\t\t// runSafePointFn may stack split if run on this stack\n\t\tsystemstack(runSafePointFn)\n\t\tsave(pc, sp)\n\t}\n\n\t_g_.m.syscalltick = _g_.m.p.ptr().syscalltick\n\t_g_.sysblocktraced = true\n\t_g_.m.mcache = nil\n\tpp := _g_.m.p.ptr()\n\tpp.m = 0\n\t_g_.m.oldp.set(pp)\n\t_g_.m.p = 0\n\tatomic.Store(&pp.status, _Psyscall)\n\tif sched.gcwaiting != 0 {\n\t\tsystemstack(entersyscall_gcwait)\n\t\tsave(pc, sp)\n\t}\n\n\t_g_.m.locks--\n}\n```\n\n# 参考文献\n[曹春晖：谈一谈 Go 和 Syscall]([https://juejin.im/post/5cdd56f6e51d456e8b07de5e](https://juejin.im/post/5cdd56f6e51d456e8b07de5e))\n","slug":"golang调用syscall","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckh351duq001f19z4he7f7naa","content":"<h1 id=\"环境说明\"><a href=\"#环境说明\" class=\"headerlink\" title=\"环境说明\"></a>环境说明</h1><p>OS：linux<br>ARCH：amd64<br>GOVERSION：1.14.1</p>\n<h1 id=\"syscall实现\"><a href=\"#syscall实现\" class=\"headerlink\" title=\"syscall实现\"></a>syscall实现</h1><p>在linux下golang调用syscall的接口，文件路径<code>syscall/syscall_unix.go</code></p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">Syscall</span><span class=\"token punctuation\">(</span>trap<span class=\"token punctuation\">,</span> a1<span class=\"token punctuation\">,</span> a2<span class=\"token punctuation\">,</span> a3 <span class=\"token builtin\">uintptr</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>r1<span class=\"token punctuation\">,</span> r2 <span class=\"token builtin\">uintptr</span><span class=\"token punctuation\">,</span> err Errno<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">Syscall6</span><span class=\"token punctuation\">(</span>trap<span class=\"token punctuation\">,</span> a1<span class=\"token punctuation\">,</span> a2<span class=\"token punctuation\">,</span> a3<span class=\"token punctuation\">,</span> a4<span class=\"token punctuation\">,</span> a5<span class=\"token punctuation\">,</span> a6 <span class=\"token builtin\">uintptr</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>r1<span class=\"token punctuation\">,</span> r2 <span class=\"token builtin\">uintptr</span><span class=\"token punctuation\">,</span> err Errno<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">RawSyscall</span><span class=\"token punctuation\">(</span>trap<span class=\"token punctuation\">,</span> a1<span class=\"token punctuation\">,</span> a2<span class=\"token punctuation\">,</span> a3 <span class=\"token builtin\">uintptr</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>r1<span class=\"token punctuation\">,</span> r2 <span class=\"token builtin\">uintptr</span><span class=\"token punctuation\">,</span> err Errno<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">RawSyscall6</span><span class=\"token punctuation\">(</span>trap<span class=\"token punctuation\">,</span> a1<span class=\"token punctuation\">,</span> a2<span class=\"token punctuation\">,</span> a3<span class=\"token punctuation\">,</span> a4<span class=\"token punctuation\">,</span> a5<span class=\"token punctuation\">,</span> a6 <span class=\"token builtin\">uintptr</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>r1<span class=\"token punctuation\">,</span> r2 <span class=\"token builtin\">uintptr</span><span class=\"token punctuation\">,</span> err Errno<span class=\"token punctuation\">)</span></code></pre>\n<p>这些函数的实现都是汇编，按照 linux 的 syscall 调用规范，我们只要在汇编中把参数依次传入寄存器，并调用 SYSCALL 指令即可进入内核处理逻辑，系统调用执行完毕之后，返回值放在 RAX 中：</p>\n<table>\n<thead>\n<tr>\n<th>RDI</th>\n<th>RSI</th>\n<th>RDX</th>\n<th>R10</th>\n<th>R8</th>\n<th>R9</th>\n<th>RAX</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>参数一</td>\n<td>参数二</td>\n<td>参数三</td>\n<td>参数四</td>\n<td>参数五</td>\n<td>参数六</td>\n<td>系统调用编号/返回值</td>\n</tr>\n</tbody></table>\n<p>这些函数的底层实现都是汇编代码，文件路径<code>syscall/asm_linux_amd64.s</code></p>\n<pre class=\" language-s\"><code class=\"language-s\">TEXT ·Syscall(SB),NOSPLIT,$0-56\n    CALL    runtime·entersyscall(SB)\n    MOVQ    a1+8(FP), DI\n    MOVQ    a2+16(FP), SI\n    MOVQ    a3+24(FP), DX\n    MOVQ    trap+0(FP), AX    // syscall entry\n    SYSCALL\n    // 0xfffffffffffff001 是 linux MAX_ERRNO 取反 转无符号，http://lxr.free-electrons.com/source/include/linux/err.h#L17\n    CMPQ    AX, $0xfffffffffffff001\n    JLS    ok\n    MOVQ    $-1, r1+32(FP)\n    MOVQ    $0, r2+40(FP)\n    NEGQ    AX\n    MOVQ    AX, err+48(FP)\n    CALL    runtime·exitsyscall(SB)\n    RET\nok:\n    MOVQ    AX, r1+32(FP)\n    MOVQ    DX, r2+40(FP)\n    MOVQ    $0, err+48(FP)\n    CALL    runtime·exitsyscall(SB)\n    RET\n\n// func Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr)\nTEXT ·Syscall6(SB),NOSPLIT,$0-80\n    CALL    runtime·entersyscall(SB)\n    MOVQ    a1+8(FP), DI\n    MOVQ    a2+16(FP), SI\n    MOVQ    a3+24(FP), DX\n    MOVQ    a4+32(FP), R10\n    MOVQ    a5+40(FP), R8\n    MOVQ    a6+48(FP), R9\n    MOVQ    trap+0(FP), AX    // syscall entry\n    SYSCALL\n    CMPQ    AX, $0xfffffffffffff001\n    JLS    ok6\n    MOVQ    $-1, r1+56(FP)\n    MOVQ    $0, r2+64(FP)\n    NEGQ    AX\n    MOVQ    AX, err+72(FP)\n    CALL    runtime·exitsyscall(SB)\n    RET\nok6:\n    MOVQ    AX, r1+56(FP)\n    MOVQ    DX, r2+64(FP)\n    MOVQ    $0, err+72(FP)\n    CALL    runtime·exitsyscall(SB)\n    RET</code></pre>\n<p>可以看到Syscall和Syscall6函数没有区别，只是在传参的个数上有区别，且在开始系统和结束系统调用时会调用<code>runtime·entersyscall(SB)</code>和<code>runtime·exitsyscall(SB)</code>，这样可以让系统调用和runtime进行沟通，让runtime进行调度当前正在调用syscall的g。</p>\n<pre class=\" language-s\"><code class=\"language-s\">// func RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2, err uintptr)\nTEXT ·RawSyscall(SB),NOSPLIT,$0-56\n    MOVQ    a1+8(FP), DI\n    MOVQ    a2+16(FP), SI\n    MOVQ    a3+24(FP), DX\n    MOVQ    trap+0(FP), AX    // syscall entry\n    SYSCALL\n    CMPQ    AX, $0xfffffffffffff001\n    JLS    ok1\n    MOVQ    $-1, r1+32(FP)\n    MOVQ    $0, r2+40(FP)\n    NEGQ    AX\n    MOVQ    AX, err+48(FP)\n    RET\nok1:\n    MOVQ    AX, r1+32(FP)\n    MOVQ    DX, r2+40(FP)\n    MOVQ    $0, err+48(FP)\n    RET\n\n// func RawSyscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr)\nTEXT ·RawSyscall6(SB),NOSPLIT,$0-80\n    MOVQ    a1+8(FP), DI\n    MOVQ    a2+16(FP), SI\n    MOVQ    a3+24(FP), DX\n    MOVQ    a4+32(FP), R10\n    MOVQ    a5+40(FP), R8\n    MOVQ    a6+48(FP), R9\n    MOVQ    trap+0(FP), AX    // syscall entry\n    SYSCALL\n    CMPQ    AX, $0xfffffffffffff001\n    JLS    ok2\n    MOVQ    $-1, r1+56(FP)\n    MOVQ    $0, r2+64(FP)\n    NEGQ    AX\n    MOVQ    AX, err+72(FP)\n    RET\nok2:\n    MOVQ    AX, r1+56(FP)\n    MOVQ    DX, r2+64(FP)\n    MOVQ    $0, err+72(FP)\n    RET</code></pre>\n<p>RawSyscall和RawSyscall6函数也只是只有传参数目的不同，但是Syscall和RawSyscall的区别在于没有调用<code>runtime·entersyscall(SB)</code>和<code>runtime·exitsyscall(SB)</code>，这样 runtime 理论上是没有办法通过调度把这个 g 的 m 的 p 调度走的，所以如果用户代码使用了 RawSyscall 来做一些阻塞的系统调用，是有可能阻塞其它的 g 的，下面是官方开发的原话:</p>\n<blockquote>\n<p>Yes, if you call RawSyscall you may block other goroutines from running. The system monitor may start them up after a while, but I think there are cases where it won’t. I would say that Go programs should always call Syscall. RawSyscall exists to make it slightly more efficient to call system calls that never block, such as getpid. But it’s really an internal mechanism.</p>\n</blockquote>\n<h1 id=\"syscall管理\"><a href=\"#syscall管理\" class=\"headerlink\" title=\"syscall管理\"></a>syscall管理</h1><p>golang实现了部分系统调用，定义在<code>syscall/syscall_linux.go</code>中。<br>可以把系统调用分为三类:</p>\n<ul>\n<li>阻塞系统调用</li>\n<li>非阻塞系统调用</li>\n<li>wrapped 系统调用</li>\n</ul>\n<p>这里截取部分代码注释</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token comment\" spellcheck=\"true\">//sys    Setpriority(which int, who int, prio int) (err error)</span>\n<span class=\"token comment\" spellcheck=\"true\">//sys    Setxattr(path string, attr string, data []byte, flags int) (err error)</span>\n<span class=\"token comment\" spellcheck=\"true\">//sys    Sync()</span>\n<span class=\"token comment\" spellcheck=\"true\">//sysnb    Sysinfo(info *Sysinfo_t) (err error)</span>\n<span class=\"token comment\" spellcheck=\"true\">//sys    Tee(rfd int, wfd int, len int, flags int) (n int64, err error)</span>\n<span class=\"token comment\" spellcheck=\"true\">//sysnb    Tgkill(tgid int, tid int, sig Signal) (err error)</span>\n<span class=\"token comment\" spellcheck=\"true\">//sysnb    Times(tms *Tms) (ticks uintptr, err error)</span>\n<span class=\"token comment\" spellcheck=\"true\">//sysnb    Umask(mask int) (oldmask int)</span>\n<span class=\"token comment\" spellcheck=\"true\">//sysnb    Uname(buf *Utsname) (err error)</span>\n<span class=\"token comment\" spellcheck=\"true\">//sys    Unmount(target string, flags int) (err error) = SYS_UMOUNT2</span>\n<span class=\"token comment\" spellcheck=\"true\">//sys    Unshare(flags int) (err error)</span>\n<span class=\"token comment\" spellcheck=\"true\">//sys    write(fd int, p []byte) (n int, err error)</span>\n<span class=\"token comment\" spellcheck=\"true\">//sys    exitThread(code int) (err error) = SYS_EXIT</span>\n<span class=\"token comment\" spellcheck=\"true\">//sys    readlen(fd int, p *byte, np int) (n int, err error) = SYS_READ</span>\n<span class=\"token comment\" spellcheck=\"true\">//sys    writelen(fd int, p *byte, np int) (n int, err error) = SYS_WRITE</span></code></pre>\n<p>其中有<code>//sys</code>表示阻塞的系统调用，<code>//sysnb</code>表示非阻塞系统调用。然后，根据这些注释，mksyscall.pl 脚本会生成对应的平台的具体实现。mksyscall.pl 是一段 perl 脚本，感兴趣的同学可以自行查看，这里就不再赘述了。生成的代码前面会有一段<code>// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT</code>的注释。<br>如果是标记为阻塞的系统调用生成的代码是调用<code>Syscall</code>和<code>Syscall6</code>，标记为非阻塞的系统调用会<code>RawSyscall</code>和<code>RawSyscall6</code>。<br>wrapped系统调用是封装了一层系统调用，可能是觉得命名风格不是很golang。</p>\n<h1 id=\"runtime中的syscall\"><a href=\"#runtime中的syscall\" class=\"headerlink\" title=\"runtime中的syscall\"></a>runtime中的syscall</h1><p>除了上面提到的阻塞非阻塞和 wrapped syscall，runtime 中还定义了一些 low-level 的 syscall，这些是不暴露给用户的。<br>提供给用户的 syscall 库，在使用时，会使 goroutine 和 p 分别进入 Gsyscall 和 Psyscall 状态。但 runtime 自己封装的这些 syscall 无论是否阻塞，都不会调用 entersyscall 和 exitsyscall。虽说是 “low-level” 的 syscall，不过和暴露给用户的 syscall 本质是一样的。<br>runtime定义的系统调用列表，定义在<code>runtime/sys_linux_arm64.s</code>中。</p>\n<pre class=\" language-golang\"><code class=\"language-golang\">#define SYS_exit        93\n#define SYS_read        63\n#define SYS_write        64\n#define SYS_openat        56\n#define SYS_close        57\n#define SYS_pipe2        59\n#define SYS_fcntl        25\n#define SYS_nanosleep        101\n#define SYS_mmap        222\n#define SYS_munmap        215\n#define SYS_setitimer        103\n#define SYS_clone        220\n#define SYS_sched_yield        124\n#define SYS_rt_sigreturn    139\n#define SYS_rt_sigaction    134\n#define SYS_rt_sigprocmask    135\n#define SYS_sigaltstack        132\n#define SYS_madvise        233\n#define SYS_mincore        232\n#define SYS_getpid        172\n#define SYS_gettid        178\n#define SYS_kill        129\n#define SYS_tgkill        131\n#define SYS_futex        98\n#define SYS_sched_getaffinity    123\n#define SYS_exit_group        94\n#define SYS_epoll_create1    20\n#define SYS_epoll_ctl        21\n#define SYS_epoll_pwait        22\n#define SYS_clock_gettime    113\n#define SYS_faccessat        48\n#define SYS_socket        198\n#define SYS_connect        203\n#define SYS_brk            214</code></pre>\n<p>这些 syscall 理论上都是不会在执行期间被调度器剥离掉 p 的，所以执行成功之后 goroutine 会继续执行，而不像用户的 goroutine 一样，若被剥离 p 会进入等待队列。</p>\n<h1 id=\"调度交互\"><a href=\"#调度交互\" class=\"headerlink\" title=\"调度交互\"></a>调度交互</h1><p>既然要和调度交互，那友好地通知我要 syscall 了: entersyscall，我完事了: exitsyscall。<br>所以这里的交互指的是用户代码使用 syscall 库时和调度器的交互。<strong>runtime 里的 syscall 不走这套流程。</strong></p>\n<p>文件路径<code>runtime/proc.go:2974</code></p>\n<pre class=\" language-golang\"><code class=\"language-golang\">// Standard syscall entry used by the go syscall library and normal cgo calls.\n//\n// This is exported via linkname to assembly in the syscall package.\n//\n//go:nosplit\n//go:linkname entersyscall\nfunc entersyscall() {\n    reentersyscall(getcallerpc(), getcallersp())\n}</code></pre>\n<pre class=\" language-golang\"><code class=\"language-golang\">//go:nosplit\nfunc reentersyscall(pc, sp uintptr) {\n    _g_ := getg()\n\n    // Disable preemption because during this function g is in Gsyscall status,\n    // but can have inconsistent g->sched, do not let GC observe it.\n    _g_.m.locks++\n\n    // Entersyscall must not call any function that might split/grow the stack.\n    // (See details in comment above.)\n    // Catch calls that might, by replacing the stack guard with something that\n    // will trip any stack check and leaving a flag to tell newstack to die.\n    _g_.stackguard0 = stackPreempt\n    _g_.throwsplit = true\n\n    // Leave SP around for GC and traceback.\n    save(pc, sp)\n    _g_.syscallsp = sp\n    _g_.syscallpc = pc\n    casgstatus(_g_, _Grunning, _Gsyscall)\n    if _g_.syscallsp < _g_.stack.lo || _g_.stack.hi < _g_.syscallsp {\n        systemstack(func() {\n            print(\"entersyscall inconsistent \", hex(_g_.syscallsp), \" [\", hex(_g_.stack.lo), \",\", hex(_g_.stack.hi), \"]\\n\")\n            throw(\"entersyscall\")\n        })\n    }\n\n    if trace.enabled {\n        systemstack(traceGoSysCall)\n        // systemstack itself clobbers g.sched.{pc,sp} and we might\n        // need them later when the G is genuinely blocked in a\n        // syscall\n        save(pc, sp)\n    }\n\n    if atomic.Load(&sched.sysmonwait) != 0 {\n        systemstack(entersyscall_sysmon)\n        save(pc, sp)\n    }\n\n    if _g_.m.p.ptr().runSafePointFn != 0 {\n        // runSafePointFn may stack split if run on this stack\n        systemstack(runSafePointFn)\n        save(pc, sp)\n    }\n\n    _g_.m.syscalltick = _g_.m.p.ptr().syscalltick\n    _g_.sysblocktraced = true\n    _g_.m.mcache = nil\n    pp := _g_.m.p.ptr()\n    pp.m = 0\n    _g_.m.oldp.set(pp)\n    _g_.m.p = 0\n    atomic.Store(&pp.status, _Psyscall)\n    if sched.gcwaiting != 0 {\n        systemstack(entersyscall_gcwait)\n        save(pc, sp)\n    }\n\n    _g_.m.locks--\n}</code></pre>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p><a href=\"[https://juejin.im/post/5cdd56f6e51d456e8b07de5e](https://juejin.im/post/5cdd56f6e51d456e8b07de5e)\">曹春晖：谈一谈 Go 和 Syscall</a></p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"friends":[{"avatar":"https://img-1251474779.cos.ap-beijing.myqcloud.com/icon.png","name":"djaigo","introduction":"好好学习，天天向上","url":"/","title":"前去学习"},{"avatar":"https://awps-assets.meituan.net/mit/blog/v20190629/asset/icon/favicon.ico?v=Whistle&t=20181017-1r","name":"美团技术团队","introduction":"一行代码，亿万生活。","url":"https://tech.meituan.com/","title":"点个外卖-->"},{"avatar":"","name":"鸟窝","introduction":"rpcx作者","url":"https://colobu.com/","title":"进个鸟窝-->"},{"avatar":"https://d1j8pt39hxlh3d.cloudfront.net/emoji/emojione/5.0/png/unicode/32/1f92a.png","name":"labuladong的算法小抄","introduction":"算法大神","url":"https://labuladong.gitbook.io/algo/","title":"学个算法-->"}]}},"excerpt":"","more":"<h1 id=\"环境说明\"><a href=\"#环境说明\" class=\"headerlink\" title=\"环境说明\"></a>环境说明</h1><p>OS：linux<br>ARCH：amd64<br>GOVERSION：1.14.1</p>\n<h1 id=\"syscall实现\"><a href=\"#syscall实现\" class=\"headerlink\" title=\"syscall实现\"></a>syscall实现</h1><p>在linux下golang调用syscall的接口，文件路径<code>syscall/syscall_unix.go</code></p>\n<pre><code class=\"go\">func Syscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno)\nfunc Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno)\nfunc RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno)\nfunc RawSyscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno)</code></pre>\n<p>这些函数的实现都是汇编，按照 linux 的 syscall 调用规范，我们只要在汇编中把参数依次传入寄存器，并调用 SYSCALL 指令即可进入内核处理逻辑，系统调用执行完毕之后，返回值放在 RAX 中：</p>\n<table>\n<thead>\n<tr>\n<th>RDI</th>\n<th>RSI</th>\n<th>RDX</th>\n<th>R10</th>\n<th>R8</th>\n<th>R9</th>\n<th>RAX</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>参数一</td>\n<td>参数二</td>\n<td>参数三</td>\n<td>参数四</td>\n<td>参数五</td>\n<td>参数六</td>\n<td>系统调用编号/返回值</td>\n</tr>\n</tbody></table>\n<p>这些函数的底层实现都是汇编代码，文件路径<code>syscall/asm_linux_amd64.s</code></p>\n<pre><code class=\"s\">TEXT ·Syscall(SB),NOSPLIT,$0-56\n    CALL    runtime·entersyscall(SB)\n    MOVQ    a1+8(FP), DI\n    MOVQ    a2+16(FP), SI\n    MOVQ    a3+24(FP), DX\n    MOVQ    trap+0(FP), AX    // syscall entry\n    SYSCALL\n    // 0xfffffffffffff001 是 linux MAX_ERRNO 取反 转无符号，http://lxr.free-electrons.com/source/include/linux/err.h#L17\n    CMPQ    AX, $0xfffffffffffff001\n    JLS    ok\n    MOVQ    $-1, r1+32(FP)\n    MOVQ    $0, r2+40(FP)\n    NEGQ    AX\n    MOVQ    AX, err+48(FP)\n    CALL    runtime·exitsyscall(SB)\n    RET\nok:\n    MOVQ    AX, r1+32(FP)\n    MOVQ    DX, r2+40(FP)\n    MOVQ    $0, err+48(FP)\n    CALL    runtime·exitsyscall(SB)\n    RET\n\n// func Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr)\nTEXT ·Syscall6(SB),NOSPLIT,$0-80\n    CALL    runtime·entersyscall(SB)\n    MOVQ    a1+8(FP), DI\n    MOVQ    a2+16(FP), SI\n    MOVQ    a3+24(FP), DX\n    MOVQ    a4+32(FP), R10\n    MOVQ    a5+40(FP), R8\n    MOVQ    a6+48(FP), R9\n    MOVQ    trap+0(FP), AX    // syscall entry\n    SYSCALL\n    CMPQ    AX, $0xfffffffffffff001\n    JLS    ok6\n    MOVQ    $-1, r1+56(FP)\n    MOVQ    $0, r2+64(FP)\n    NEGQ    AX\n    MOVQ    AX, err+72(FP)\n    CALL    runtime·exitsyscall(SB)\n    RET\nok6:\n    MOVQ    AX, r1+56(FP)\n    MOVQ    DX, r2+64(FP)\n    MOVQ    $0, err+72(FP)\n    CALL    runtime·exitsyscall(SB)\n    RET</code></pre>\n<p>可以看到Syscall和Syscall6函数没有区别，只是在传参的个数上有区别，且在开始系统和结束系统调用时会调用<code>runtime·entersyscall(SB)</code>和<code>runtime·exitsyscall(SB)</code>，这样可以让系统调用和runtime进行沟通，让runtime进行调度当前正在调用syscall的g。</p>\n<pre><code class=\"s\">// func RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2, err uintptr)\nTEXT ·RawSyscall(SB),NOSPLIT,$0-56\n    MOVQ    a1+8(FP), DI\n    MOVQ    a2+16(FP), SI\n    MOVQ    a3+24(FP), DX\n    MOVQ    trap+0(FP), AX    // syscall entry\n    SYSCALL\n    CMPQ    AX, $0xfffffffffffff001\n    JLS    ok1\n    MOVQ    $-1, r1+32(FP)\n    MOVQ    $0, r2+40(FP)\n    NEGQ    AX\n    MOVQ    AX, err+48(FP)\n    RET\nok1:\n    MOVQ    AX, r1+32(FP)\n    MOVQ    DX, r2+40(FP)\n    MOVQ    $0, err+48(FP)\n    RET\n\n// func RawSyscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr)\nTEXT ·RawSyscall6(SB),NOSPLIT,$0-80\n    MOVQ    a1+8(FP), DI\n    MOVQ    a2+16(FP), SI\n    MOVQ    a3+24(FP), DX\n    MOVQ    a4+32(FP), R10\n    MOVQ    a5+40(FP), R8\n    MOVQ    a6+48(FP), R9\n    MOVQ    trap+0(FP), AX    // syscall entry\n    SYSCALL\n    CMPQ    AX, $0xfffffffffffff001\n    JLS    ok2\n    MOVQ    $-1, r1+56(FP)\n    MOVQ    $0, r2+64(FP)\n    NEGQ    AX\n    MOVQ    AX, err+72(FP)\n    RET\nok2:\n    MOVQ    AX, r1+56(FP)\n    MOVQ    DX, r2+64(FP)\n    MOVQ    $0, err+72(FP)\n    RET</code></pre>\n<p>RawSyscall和RawSyscall6函数也只是只有传参数目的不同，但是Syscall和RawSyscall的区别在于没有调用<code>runtime·entersyscall(SB)</code>和<code>runtime·exitsyscall(SB)</code>，这样 runtime 理论上是没有办法通过调度把这个 g 的 m 的 p 调度走的，所以如果用户代码使用了 RawSyscall 来做一些阻塞的系统调用，是有可能阻塞其它的 g 的，下面是官方开发的原话:</p>\n<blockquote>\n<p>Yes, if you call RawSyscall you may block other goroutines from running. The system monitor may start them up after a while, but I think there are cases where it won’t. I would say that Go programs should always call Syscall. RawSyscall exists to make it slightly more efficient to call system calls that never block, such as getpid. But it’s really an internal mechanism.</p>\n</blockquote>\n<h1 id=\"syscall管理\"><a href=\"#syscall管理\" class=\"headerlink\" title=\"syscall管理\"></a>syscall管理</h1><p>golang实现了部分系统调用，定义在<code>syscall/syscall_linux.go</code>中。<br>可以把系统调用分为三类:</p>\n<ul>\n<li>阻塞系统调用</li>\n<li>非阻塞系统调用</li>\n<li>wrapped 系统调用</li>\n</ul>\n<p>这里截取部分代码注释</p>\n<pre><code class=\"go\">//sys    Setpriority(which int, who int, prio int) (err error)\n//sys    Setxattr(path string, attr string, data []byte, flags int) (err error)\n//sys    Sync()\n//sysnb    Sysinfo(info *Sysinfo_t) (err error)\n//sys    Tee(rfd int, wfd int, len int, flags int) (n int64, err error)\n//sysnb    Tgkill(tgid int, tid int, sig Signal) (err error)\n//sysnb    Times(tms *Tms) (ticks uintptr, err error)\n//sysnb    Umask(mask int) (oldmask int)\n//sysnb    Uname(buf *Utsname) (err error)\n//sys    Unmount(target string, flags int) (err error) = SYS_UMOUNT2\n//sys    Unshare(flags int) (err error)\n//sys    write(fd int, p []byte) (n int, err error)\n//sys    exitThread(code int) (err error) = SYS_EXIT\n//sys    readlen(fd int, p *byte, np int) (n int, err error) = SYS_READ\n//sys    writelen(fd int, p *byte, np int) (n int, err error) = SYS_WRITE</code></pre>\n<p>其中有<code>//sys</code>表示阻塞的系统调用，<code>//sysnb</code>表示非阻塞系统调用。然后，根据这些注释，mksyscall.pl 脚本会生成对应的平台的具体实现。mksyscall.pl 是一段 perl 脚本，感兴趣的同学可以自行查看，这里就不再赘述了。生成的代码前面会有一段<code>// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT</code>的注释。<br>如果是标记为阻塞的系统调用生成的代码是调用<code>Syscall</code>和<code>Syscall6</code>，标记为非阻塞的系统调用会<code>RawSyscall</code>和<code>RawSyscall6</code>。<br>wrapped系统调用是封装了一层系统调用，可能是觉得命名风格不是很golang。</p>\n<h1 id=\"runtime中的syscall\"><a href=\"#runtime中的syscall\" class=\"headerlink\" title=\"runtime中的syscall\"></a>runtime中的syscall</h1><p>除了上面提到的阻塞非阻塞和 wrapped syscall，runtime 中还定义了一些 low-level 的 syscall，这些是不暴露给用户的。<br>提供给用户的 syscall 库，在使用时，会使 goroutine 和 p 分别进入 Gsyscall 和 Psyscall 状态。但 runtime 自己封装的这些 syscall 无论是否阻塞，都不会调用 entersyscall 和 exitsyscall。虽说是 “low-level” 的 syscall，不过和暴露给用户的 syscall 本质是一样的。<br>runtime定义的系统调用列表，定义在<code>runtime/sys_linux_arm64.s</code>中。</p>\n<pre><code class=\"golang\">#define SYS_exit        93\n#define SYS_read        63\n#define SYS_write        64\n#define SYS_openat        56\n#define SYS_close        57\n#define SYS_pipe2        59\n#define SYS_fcntl        25\n#define SYS_nanosleep        101\n#define SYS_mmap        222\n#define SYS_munmap        215\n#define SYS_setitimer        103\n#define SYS_clone        220\n#define SYS_sched_yield        124\n#define SYS_rt_sigreturn    139\n#define SYS_rt_sigaction    134\n#define SYS_rt_sigprocmask    135\n#define SYS_sigaltstack        132\n#define SYS_madvise        233\n#define SYS_mincore        232\n#define SYS_getpid        172\n#define SYS_gettid        178\n#define SYS_kill        129\n#define SYS_tgkill        131\n#define SYS_futex        98\n#define SYS_sched_getaffinity    123\n#define SYS_exit_group        94\n#define SYS_epoll_create1    20\n#define SYS_epoll_ctl        21\n#define SYS_epoll_pwait        22\n#define SYS_clock_gettime    113\n#define SYS_faccessat        48\n#define SYS_socket        198\n#define SYS_connect        203\n#define SYS_brk            214</code></pre>\n<p>这些 syscall 理论上都是不会在执行期间被调度器剥离掉 p 的，所以执行成功之后 goroutine 会继续执行，而不像用户的 goroutine 一样，若被剥离 p 会进入等待队列。</p>\n<h1 id=\"调度交互\"><a href=\"#调度交互\" class=\"headerlink\" title=\"调度交互\"></a>调度交互</h1><p>既然要和调度交互，那友好地通知我要 syscall 了: entersyscall，我完事了: exitsyscall。<br>所以这里的交互指的是用户代码使用 syscall 库时和调度器的交互。<strong>runtime 里的 syscall 不走这套流程。</strong></p>\n<p>文件路径<code>runtime/proc.go:2974</code></p>\n<pre><code class=\"golang\">// Standard syscall entry used by the go syscall library and normal cgo calls.\n//\n// This is exported via linkname to assembly in the syscall package.\n//\n//go:nosplit\n//go:linkname entersyscall\nfunc entersyscall() {\n    reentersyscall(getcallerpc(), getcallersp())\n}</code></pre>\n<pre><code class=\"golang\">//go:nosplit\nfunc reentersyscall(pc, sp uintptr) {\n    _g_ := getg()\n\n    // Disable preemption because during this function g is in Gsyscall status,\n    // but can have inconsistent g-&gt;sched, do not let GC observe it.\n    _g_.m.locks++\n\n    // Entersyscall must not call any function that might split/grow the stack.\n    // (See details in comment above.)\n    // Catch calls that might, by replacing the stack guard with something that\n    // will trip any stack check and leaving a flag to tell newstack to die.\n    _g_.stackguard0 = stackPreempt\n    _g_.throwsplit = true\n\n    // Leave SP around for GC and traceback.\n    save(pc, sp)\n    _g_.syscallsp = sp\n    _g_.syscallpc = pc\n    casgstatus(_g_, _Grunning, _Gsyscall)\n    if _g_.syscallsp &lt; _g_.stack.lo || _g_.stack.hi &lt; _g_.syscallsp {\n        systemstack(func() {\n            print(&quot;entersyscall inconsistent &quot;, hex(_g_.syscallsp), &quot; [&quot;, hex(_g_.stack.lo), &quot;,&quot;, hex(_g_.stack.hi), &quot;]\\n&quot;)\n            throw(&quot;entersyscall&quot;)\n        })\n    }\n\n    if trace.enabled {\n        systemstack(traceGoSysCall)\n        // systemstack itself clobbers g.sched.{pc,sp} and we might\n        // need them later when the G is genuinely blocked in a\n        // syscall\n        save(pc, sp)\n    }\n\n    if atomic.Load(&amp;sched.sysmonwait) != 0 {\n        systemstack(entersyscall_sysmon)\n        save(pc, sp)\n    }\n\n    if _g_.m.p.ptr().runSafePointFn != 0 {\n        // runSafePointFn may stack split if run on this stack\n        systemstack(runSafePointFn)\n        save(pc, sp)\n    }\n\n    _g_.m.syscalltick = _g_.m.p.ptr().syscalltick\n    _g_.sysblocktraced = true\n    _g_.m.mcache = nil\n    pp := _g_.m.p.ptr()\n    pp.m = 0\n    _g_.m.oldp.set(pp)\n    _g_.m.p = 0\n    atomic.Store(&amp;pp.status, _Psyscall)\n    if sched.gcwaiting != 0 {\n        systemstack(entersyscall_gcwait)\n        save(pc, sp)\n    }\n\n    _g_.m.locks--\n}</code></pre>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p><a href=\"[https://juejin.im/post/5cdd56f6e51d456e8b07de5e](https://juejin.im/post/5cdd56f6e51d456e8b07de5e)\">曹春晖：谈一谈 Go 和 Syscall</a></p>\n"},{"author":"djaigo","title":"Linux awk命令","date":"2019-12-18T16:00:00.000Z","updated":"2020-01-13T16:00:00.000Z","img":"https://img-1251474779.cos.ap-beijing.myqcloud.com/linux.png","mathjax":true,"_content":"\n# 简介\nawk是一个强大的文本处理和文本分析工具，不仅可以通过行为单位处理文本，还可以通过列为单位处理文本，默认行分隔符是换行符，默认列分隔符是连续空格和Tab，可以定义分隔符。awk提供了极其强大的功能：可以进行正则表达式的匹配，样式装入、流控制、数学运算符、进程控制语句甚至于内置的变量和函数。\n获取帮助信息，gawk是awk的GNU版本\n```sh\n➜ awk --help\nUsage: awk [POSIX or GNU style options] -f progfile [--] file ...\nUsage: awk [POSIX or GNU style options] [--] 'program' file ...\nPOSIX options:\t\tGNU long options: (standard)\n\t-f progfile\t\t--file=progfile\n\t-F fs\t\t\t--field-separator=fs\n\t-v var=val\t\t--assign=var=val\nShort options:\t\tGNU long options: (extensions)\n\t-b\t\t\t--characters-as-bytes\n\t-c\t\t\t--traditional\n\t-C\t\t\t--copyright\n\t-d[file]\t\t--dump-variables[=file]\n\t-e 'program-text'\t--source='program-text'\n\t-E file\t\t\t--exec=file\n\t-g\t\t\t--gen-pot\n\t-h\t\t\t--help\n\t-L [fatal]\t\t--lint[=fatal]\n\t-n\t\t\t--non-decimal-data\n\t-N\t\t\t--use-lc-numeric\n\t-O\t\t\t--optimize\n\t-p[file]\t\t--profile[=file]\n\t-P\t\t\t--posix\n\t-r\t\t\t--re-interval\n\t-S\t\t\t--sandbox\n\t-t\t\t\t--lint-old\n\t-V\t\t\t--version\n\nTo report bugs, see node `Bugs' in `gawk.info', which is\nsection `Reporting Problems and Bugs' in the printed version.\n\ngawk is a pattern scanning and processing language.\nBy default it reads standard input and writes standard output.\n\nExamples:\n\tgawk '{ sum += $1 }; END { print sum }' file\n\tgawk -F: '{ print $1 }' /etc/passwd\n```\n\n# 执行方式\nawk命令行的基本执行形式为：\n```sh\nawk option 'script' file1 file2 ...\nawk option -f scriptfile file1 file2 ...\n```\n\nawk的操作对象既可以是文本文件，也可以是标准输入重定向得到，亦或是命令行参数传入。\n\n## 命令行参数\n常用命令行参数说明：\n\n| 参数 | 说明 |\n|---|---|\n|-f|  执行awk脚本文件路径  |\n|-F|输入域分隔符   |\n|-v|传入shell变量   |\n|-b|字符按照字节区分   |\n|-h|帮助文档   |\n|-V|显示版本   |\n\n## 正则表达式\nscript一般格式为`/pattern/{actions}`，pattern表示正则表达式，actions表示一系列操作。awk利用正则表达式pattern匹配出需要执行actions的行，如果没有pattern表示每一行都执行actions。\n\n示例：打印所有行\n```sh\n➜ seq 20 | awk '{print $1}'\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n```\n\n示例：打印包含1的行\n```\n➜ seq 20 | awk '/1/{print $1}'\n1\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n```\n\nprint表示打印；`$1`表示第一列，`$2`表示第二列，以此类推，`$0`表示当前行。\n\nawk利用运算符`~`表示符合正则运算，`!~`表示不符合正则运算。\n示例：\n```sh\n➜ seq 20 | awk '$1 !~ /1/{print $1}'            \n2\n3\n4\n5\n6\n7\n8\n9\n20\n```\n\n## 数学运算\nawk支持使用数学条件筛选，支持运算符表格：\n\n| 运算符 | 描述 |\n| --- | --- |\n| `= += -= *= /= %= ^= **=` | 赋值 |\n| `?:` | C条件表达式 |\n| `\\|\\|` | 逻辑或 |\n| `&&` | 逻辑与 |\n| `~` 和 `!~` | 匹配正则表达式和不匹配正则表达式 |\n| `< <= > >= != ==` | 关系运算符 |\n| 空格 | 连接 |\n| `+ -`| 加，减 |\n| `* / %` | 乘，除与求余 |\n| `+ - !` | 一元加，减和逻辑非 |\n| `^ ***` | 求幂 |\n| `++ --` | 增加或减少，作为前缀或后缀 |\n| `$` | 字段引用 |\n| `in` | 数组成员 |\n\n示例：1-20中筛选大于10的偶数\n```sh\n➜ seq 20 | awk '$1%2==0&&$1>=10{print $1,\"Y\"}'\n10 Y\n12 Y\n14 Y\n16 Y\n18 Y\n20 Y\n```\n\n\nawk还支持算术函数\n\n| 函数名 | 说明 |\n| :-----: | --- |\n| `atan2( y, x )` | 返回 y/x 的反正切。 |\n| `cos( x )` | 返回 x 的余弦；x 是弧度。 |\n| `sin( x )` | 返回 x 的正弦；x 是弧度。 |\n| `exp( x )` | 返回 x 幂函数。 |\n| `log( x )` | 返回 x 的自然对数。 |\n| `sqrt( x )` | 返回 x 平方根。 |\n| `int( x )` | 返回 x 的截断至整数的值。 |\n| `rand()` | 返回任意数字 n，其中 0 <= n < 1。 |\n| `srand([Expr])` | 将rand函数的种子值设置为Expr参数的值，或如果省略Expr参数则使用某天的时间。返回先前的种子值。|\n\n示例：打印$e^{$1}$，上次随机数种子，随机数\n```\n➜ seq 20 | awk '{print exp($1), srand($1), rand()}'\n2.71828 0 0.840188\n7.38906 1 0.700976\n20.0855 2 0.56138\n54.5982 3 0.916458\n148.413 4 0.274746\n403.429 5 0.135439\n1096.63 6 0.486904\n2980.96 7 0.352761\n8103.08 8 0.206965\n22026.5 9 0.565811\n59874.1 10 0.926345\n162755 11 0.7856\n442413 12 0.632643\n1.2026e+06 13 0.999498\n3.26902e+06 14 0.354973\n8.88611e+06 15 0.215437\n2.4155e+07 16 0.571794\n6.566e+07 17 0.929073\n1.78482e+08 18 0.290233\n4.85165e+08 19 0.148812\n```\n\n## BEGIN-END\nawk有两个特殊的条件，对待每个处理的文件，BEGIN后面的actions在执行整个文件**之前**执行一次，END后面的actions在执行整个文件**之后**执行一次。awk可以像c一样使用使用变量，但是不需要定义变量。\n示例：\n```sh\n➜ seq 20 | awk  '/1/{x=x+1;}END{print x}'   \n11\n\n➜ seq 20 | awk 'BEGIN{x=100}/1/{x=x+1;}END{print x}' \n111\n```\n\n## 内建变量\n\n| 变量 | 描述 |\n| --- | --- |\n| `$n` | 当前记录的第n个字段，字段间由FS分隔 |\n| `$0` | 完整的输入记录 |\n| `ARGC` | 命令行参数的数目 |\n| `ARGIND` | 命令行中当前文件的位置(从0开始算) |\n| `ARGV` | 包含命令行参数的数组 |\n| `CONVFMT` | 数字转换格式(默认值为%.6g)ENVIRON环境变量关联数组 |\n| `ERRNO` | 最后一个系统错误的描述 |\n| `FIELDWIDTHS` | 字段宽度列表(用空格键分隔) |\n| `FILENAME` | 当前文件名 |\n| `FNR` | 各文件分别计数的行号 |\n| `FS` | 字段分隔符(默认是任何空格) |\n| `IGNORECASE` | 如果为真，则进行忽略大小写的匹配 |\n| `NF` | 一条记录的字段的数目 |\n| `NR` | 已经读出的记录数，就是行号，从1开始 |\n| `OFMT` | 数字的输出格式(默认值是%.6g) |\n| `OFS` | print函数输出字段分隔符（输出空格），输出时用指定的符号代替分隔符 |\n| `ORS` | 输出记录分隔符(默认值是一个换行符) |\n| `RLENGTH` | 由match函数所匹配的字符串的长度 |\n| `RS` | 记录分隔符(默认是一个换行符) |\n| `RSTART` | 由match函数所匹配的字符串的第一个位置 |\n| `SUBSEP` | 数组下标分隔符(默认值是/034) |\n\n示例：打印最后一列，并打印当前行数\n```sh\n➜ seq 20 | sort | awk '{print $NF \"\\t\" NR}'\n1\t1\n10\t2\n11\t3\n12\t4\n13\t5\n14\t6\n15\t7\n16\t8\n17\t9\n18\t10\n19\t11\n2\t12\n20\t13\n3\t14\n4\t15\n5\t16\n6\t17\n7\t18\n8\t19\n9\t20\n```\n\n示例：替换输出分隔符和换行符\n```sh\n➜ echo \"this is a test\\nthis is a test\" | awk 'BEGIN{OFS=\"_\";ORS=\"--\"}{print $1,$2,$3,$4}'\nthis_is_a_test--this_is_a_test--\n```\n\n## 一般函数\n\n| **函数** | **说明** |\n| --- | --- |\n| `close( Expression )` | 用同一个带字符串值的 Expression 参数来关闭由 print 或 printf 语句打开的或调用 getline 函数打开的文件或管道。如果文件或管道成功关闭，则返回 0；其它情况下返回非零值。如果打算写一个文件，并稍后在同一个程序中读取文件，则 close 语句是必需的。 |\n| `system(Command )` | 执行 Command 参数指定的命令，并返回退出状态。 |\n| `Expression \\| getline [ Variable ]` | 从来自 Expression 参数指定的命令的输出中通过管道传送的流中读取一个输入记录，并将该记录的值指定给 Variable 参数指定的变量。如果当前未打开将 Expression 参数的值作为其命令名称的流，则创建流。此时 Command 参数取 Expression 参数的值且 Mode 参数设置为一个是 r 的值。只要流保留打开且 Expression 参数求得同一个字符串，则对 getline 函数的每次后续调用读取另一个记录。如果未指定 Variable 参数，则 $0 记录变量和 NF 特殊变量设置为从流读取的记录。 |\n| `getline [ Variable ] < Expression` | 从 Expression 参数指定的文件读取输入的下一个记录，并将 Variable 参数指定的变量设置为该记录的值。只要流保留打开且 Expression 参数对同一个字符串求值，则对 getline 函数的每次后续调用读取另一个记录。如果未指定 Variable 参数，则 $0 记录变量和 NF 特殊变量设置为从流读取的记录。 |\n| `getline [ Variable ]` | 将 Variable 参数指定的变量设置为从当前输入文件读取的下一个输入记录。如果未指定 Variable 参数，则 $0 记录变量设置为该记录的值，还将设置 NF、NR 和 FNR 特殊变量。 |\n\n示例：通过system函数执行shell语句，最后0表示Errno\n```sh\n➜ awk 'BEGIN{print system(\"ps -ef | grep awk\")}'\nroot      6490 10366  0 17:16 pts/0    00:00:00 awk BEGIN{print system(\"ps -ef | grep awk\")}\nroot      6491  6490  0 17:16 pts/0    00:00:00 sh -c ps -ef | grep awk\nroot      6493  6491  0 17:16 pts/0    00:00:00 grep awk\n0\n```\n\n## 字符串函数\nawk还有内置字符串函数\n\n| **函数** | **说明** |\n| --- | --- |\n| `gsub( Ere, Repl, [ In ] )` | 除了正则表达式所有具体值被替代这点，它和 sub 函数完全一样地执行。 |\n| `sub( Ere, Repl, [ In ] )`| 用 Repl 参数指定的字符串替换 In 参数指定的字符串中的由 Ere 参数指定的扩展正则表达式的第一个具体值。sub 函数返回替换的数量。出现在 Repl 参数指定的字符串中的 &（和符号）由 In 参数指定的与 Ere 参数的指定的扩展正则表达式匹配的字符串替换。如果未指定 In 参数，缺省值是整个记录（$0 记录变量）。 |\n| `index( String1, String2 )` | 在由 String1 参数指定的字符串（其中有出现 String2 指定的参数）中，返回位置，从 1 开始编号。如果 String2 参数不在 String1 参数中出现，则返回 0（零）。 |\n| `length [(String)]` | 返回 String 参数指定的字符串的长度（字符形式）。如果未给出 String 参数，则返回整个记录的长度（$0 记录变量）。 |\n| `substr( String, M, [ N ] )` | 返回具有 N 参数指定的字符数量子串。子串从 String 参数指定的字符串取得，其字符以 M 参数指定的位置开始。M 参数指定为将 String 参数中的第一个字符作为编号 1。如果未指定 N 参数，则子串的长度将是 M 参数指定的位置到 String 参数的末尾 的长度。 |\n| `match( String, Ere )` | 在 String 参数指定的字符串（Ere 参数指定的扩展正则表达式出现在其中）中返回位置（字符形式），从 1 开始编号，或如果 Ere 参数不出现，则返回 0（零）。RSTART 特殊变量设置为返回值。RLENGTH 特殊变量设置为匹配的字符串的长度，或如果未找到任何匹配，则设置为 -1（负一）。 |\n| `split( String, A, [Ere] )` | 将 String 参数指定的参数分割为数组元素 `A[1], A[2], . . ., A[n]`，并返回 n 变量的值。此分隔可以通过 Ere 参数指定的扩展正则表达式进行，或用当前字段分隔符（FS 特殊变量）来进行（如果没有给出 Ere 参数）。除非上下文指明特定的元素还应具有一个数字值，否则 A 数组中的元素用字符串值来创建。 |\n| `tolower( String )` | 返回 String 参数指定的字符串，字符串中每个大写字符将更改为小写。大写和小写的映射由当前语言环境的 LC_CTYPE 范畴定义。 |\n| `toupper( String )` | 返回 String 参数指定的字符串，字符串中每个小写字符将更改为大写。大写和小写的映射由当前语言环境的 LC_CTYPE 范畴定义。 |\n| `printf(Format, Expr, Expr, . . . )` | 根据 Format 参数指定的格式字符串来格式化 Expr 参数指定的表达式并返回最后生成的字符串。 |\n\nsprintf函数format格式化参数转换表\n\n| **格式符** | **说明** |\n| --- | --- |\n| `%d` | 十进制有符号整数 |\n| `%u` | 十进制无符号整数 |\n| `%f` | 浮点数 |\n| `%s` | 字符串 |\n| `%c` | 单个字符 |\n| `%p` | 指针的值 |\n| `%e` | 指数形式的浮点数 |\n| `%x` | %X 无符号以十六进制表示的整数 |\n| `%o` | 无符号以八进制表示的整数 |\n| `%g`| 自动选择合适的表示法 |\n\n\n示例：打印字符串，转换大小写\n```sh\n➜ awk 'BEGIN{str=\"Hello World\";print str \"\\n\" tolower(str) \"\\n\" toupper(str)}'\nHello World\nhello world\nHELLO WORLD\n```\n\n示例：打印字符串长度，查找指定字串并返回子串索引，匹配正则字串并返回子串索引\n```sh\n➜ awk 'BEGIN{str=\"Hello World\";printf(\"len:%d, index:%d, match:%d\\n\",length(str),index(str,\"world\"),match(str,/[wW]orld/))}'\nlen:11, index:0, match:7\n```\n\n示例：利用split函数，打印字串数组\n```sh\n➜ awk 'BEGIN{str=\"this is a test\";split(str,t,\" \");print length(t);for(k in t){print k,t[k];}}'\n4\n4 test\n1 this\n2 is\n3 a\n```\n\n## 时间函数\n\n| **函数名** | **说明** |\n| --- | --- |\n| `mktime( YYYY MM DD HH MM SS[ DST])` | 生成时间格式 |\n| `strftime([format [, timestamp]])` | 格式化时间输出，将时间戳转为时间字符串具体格式，见下表. |\n| `systime()` | 得到时间戳,返回从1970年1月1日开始到当前时间（不计闰年）的整秒数 |\n\nstrftime函数format格式化参数转换表\n\n| 格式 | 描述 |\n| --- | --- |\n| `%a` | 星期几的缩写（Sun） |\n| `%A` | 星期几的完整写法（Sunday） |\n| `%b` | 月名的缩写（Oct） |\n| `%B` | 月名的完整写法（October） |\n| `%c` | 本地日期和时间 |\n| `%d` | 十进制日期 |\n| `%D` | 日期 08/20/99 |\n| `%e` | 日期，如果只有一位会补上一个空格 |\n| `%H` | 用十进制表示24小时格式的小时 |\n| `%I` | 用十进制表示12小时格式的小时 |\n| `%j` | 从1月1日起一年中的第几天 |\n| `%m` | 十进制表示的月份 |\n| `%M` | 十进制表示的分钟 |\n| `%p` | 12小时表示法（AM/PM） |\n| `%S` | 十进制表示的秒 |\n| `%U` | 十进制表示的一年中的第几个星期（星期天作为一个星期的开始） |\n| `%w` | 十进制表示的星期几（星期天是0） |\n| `%W` | 十进制表示的一年中的第几个星期（星期一作为一个星期的开始） |\n| `%x` | 重新设置本地日期（08/20/99） |\n| `%X` | 重新设置本地时间（12:00:00） |\n| `%y` | 两位数字表示的年（99） |\n| `%Y` | 当前月份 |\n| `%Z` | 时区（PDT） |\n| `%%` | 百分号（%） |\n\n示例：获取当前时间，并格式化输出\n```sh\n➜ awk 'BEGIN{st=systime();print st, strftime(\"%c %Z\", st)}'\n1576744487 2019年12月19日 星期四 16时34分47秒 CST\n```\n\n# 进阶\nawk可以利用类c风格的代码进行简单的程序编写，使之能完成更多的事情。\n## 编程语法\n### 条件判断\nawk的条件判断格式是类c风格的\n```c\nif (expression) \n{\n    statement;\n    ...\n}\n\nif (expression) \n{\n    statement1;\n} \nelse \n{\n    statement2;\n}\n\nif (expression1) \n{\n    statement1;\n}\nelse if (expression2) \n{\n    statement2;\n}\nelse \n{\n    statement3;\n}\n```\n\n### 循环\nawk支持while、for和do-while循环，格式也是类c风格的\n```sh\nwhile (expression) \n{\n    statement;\n}\n\n// for-in 输出的var顺序可能不一致\nfor (var in array) \n{\n    statement;\n}\nfor (var; condtion; expression) \n{\n    statement;\n}\n\ndo \n{\n    statement;\n} while (expression);\n```\n\n同时awk也支持退出循环\n\n| 字段 | 说明 |\n| --- | --- |\n| break | 当 break 语句用于 while 或 for 语句时，导致退出程序循环。 |\n| continue | 当 continue 语句用于 while 或 for 语句时，使程序循环移动到下一个迭代。 |\n| next | 能能够导致读入下一个输入行，并返回到脚本的顶部。这可以避免对当前输入行执行其他的操作过程。|\n| exit |语句使主输入循环退出并将控制转移到END,如果END存在的话。如果没有定义END规则，或在END中应用exit语句，则终止脚本的执行。|\n\n\n\n\n## 数组\nawk数组支持数字下标和字符串下标，底层是哈希表，所以每次遍历不能保证都是相同顺序。\n示例：\n```sh\narray_name[key]=value\n```\n\n* array_name：数组的名称\n* key：数组索引\n* value：数组中元素所赋予的值\n\n### 添加元素\nawk可以直接声明元素key-value对\n示例：\n```sh\n➜ awk 'BEGIN{keys[1]=2;keys[\"start\"]=\"start\";print keys[1], keys[\"start\"]}'\n2 start\n```\n\n### 删除元素\n使用delete可以删除数组的元素\n示例：删除key为1的值，最后打印keys[1]的值为空字符串\n```sh\n➜ awk 'BEGIN{keys[1]=2;keys[\"start\"]=\"start\";delete keys[1];print keys[1], keys[\"start\"]}'\n start\n```\n\n### 二维数组\nawk 多维数组在本质上是一维数组，因awk在存储上并不支持多维数组，awk提供了逻辑上模拟二维数组的访问方式。例如，array[2,3] = 1这样的访问是允许的。\nawk使用一个特殊的字符串SUBSEP （`\\034`）作为分割字段，在上面的例子 array[2,3] = 1 中，关联数组array存储的键值实际上是2`\\034`3，2和3分别为下标（2，3），`\\034`为SUBSEP分隔符。\n示例：\n```sh\n➜ awk 'BEGIN{a[1,1]=1;a[\"1,1\"]=2;a[11]=3;for(i in a){print i,a[i]}}'\n1,1 2\n11 3\n11 1\n```\n\n### 数组排序\nasort对数组array按照首字母进行排序，返回数组长度。如果要得到数组原本顺序，需要使用数组下标依次访问。\nfor-in 输出关联数组的顺序是无序的，所以通过for-in 得到是无序的数组。如果需要得到有序数组，需要通过下标获得。\n示例：\n```sh\n➜ awk 'BEGIN{str=\"it is a test\";l=split(str,array,\" \");for(i in array){print i,array[i];};asort(array);for(i in array){print i,array[i;}}'\n4 test\n1 it\n2 is\n3 a\n4 test\n1 a\n2 is\n3 it\n```\n\n## 函数\n一个程序包含有多个功能，每个功能我们可以独立一个函数，函数可以提高代码的复用性。用户自定义函数的语法格式为：\n```sh\nfunction function_name(argument1, argument2,  ...)\n{\n  function body \n}\n```\n\n**解析：**\n*   **function_name** 是用户自定义函数的名称。函数名称应该以字母开头，其后可以是数字、字母或下划线的自由组合。AWK 保留的关键字不能作为用户自定义函数的名称。\n*   自定义函数可以接受多个输入参数，这些参数之间通过逗号分隔。参数并不是必须的。我们也可以定义没有任何输入参数的函数。\n*   **function body** 是函数体部分，它包含 AWK 程序代码。\n\n示例：写一个求和函数\n```sh\n➜ awk 'function sum(n1,n2){return n1+n2}BEGIN{print sum(1,2)}'\n3\n```\n\n如果函数比较复杂，我们可以写成一个文件的形式来执行awk。\n\n```sh\n# 返回最小值\nfunction find_min(num1, num2)\n{\n  if (num1 < num2)\n    return num1\n  return num2\n}\n\n# 返回最大值\nfunction find_max(num1, num2)\n{\n  if (num1 > num2)\n    return num1\n  return num2\n}\n\n# 主函数\nfunction main(num1, num2)\n{\n  # 查找最小值\n  result = find_min(10, 20)\n  print \"Minimum =\", result\n\n  # 查找最大值\n  result = find_max(10, 20)\n  print \"Maximum =\", result\n}\n\n# 脚本从这里开始执行\nBEGIN {\n  main(10, 20)\n}\n```\n\n执行可以得到\n```sh\nMinimum = 10\nMaximum = 20\n```\n\n# 参考文献\n* [维基百科](https://zh.wikipedia.org/wiki/AWK)\n* [菜鸟教程](https://www.runoob.com/linux/linux-comm-awk.html)\n","source":"_posts/linux-awk命令.md","raw":"---\nauthor: djaigo\ntitle: Linux awk命令\ndate: 2019-12-19\nupdated: 2020-01-14\nimg: https://img-1251474779.cos.ap-beijing.myqcloud.com/linux.png\ncategories: \n  - linux\ntags: \n  - cmd\n  - command\nmathjax: true\n---\n\n# 简介\nawk是一个强大的文本处理和文本分析工具，不仅可以通过行为单位处理文本，还可以通过列为单位处理文本，默认行分隔符是换行符，默认列分隔符是连续空格和Tab，可以定义分隔符。awk提供了极其强大的功能：可以进行正则表达式的匹配，样式装入、流控制、数学运算符、进程控制语句甚至于内置的变量和函数。\n获取帮助信息，gawk是awk的GNU版本\n```sh\n➜ awk --help\nUsage: awk [POSIX or GNU style options] -f progfile [--] file ...\nUsage: awk [POSIX or GNU style options] [--] 'program' file ...\nPOSIX options:\t\tGNU long options: (standard)\n\t-f progfile\t\t--file=progfile\n\t-F fs\t\t\t--field-separator=fs\n\t-v var=val\t\t--assign=var=val\nShort options:\t\tGNU long options: (extensions)\n\t-b\t\t\t--characters-as-bytes\n\t-c\t\t\t--traditional\n\t-C\t\t\t--copyright\n\t-d[file]\t\t--dump-variables[=file]\n\t-e 'program-text'\t--source='program-text'\n\t-E file\t\t\t--exec=file\n\t-g\t\t\t--gen-pot\n\t-h\t\t\t--help\n\t-L [fatal]\t\t--lint[=fatal]\n\t-n\t\t\t--non-decimal-data\n\t-N\t\t\t--use-lc-numeric\n\t-O\t\t\t--optimize\n\t-p[file]\t\t--profile[=file]\n\t-P\t\t\t--posix\n\t-r\t\t\t--re-interval\n\t-S\t\t\t--sandbox\n\t-t\t\t\t--lint-old\n\t-V\t\t\t--version\n\nTo report bugs, see node `Bugs' in `gawk.info', which is\nsection `Reporting Problems and Bugs' in the printed version.\n\ngawk is a pattern scanning and processing language.\nBy default it reads standard input and writes standard output.\n\nExamples:\n\tgawk '{ sum += $1 }; END { print sum }' file\n\tgawk -F: '{ print $1 }' /etc/passwd\n```\n\n# 执行方式\nawk命令行的基本执行形式为：\n```sh\nawk option 'script' file1 file2 ...\nawk option -f scriptfile file1 file2 ...\n```\n\nawk的操作对象既可以是文本文件，也可以是标准输入重定向得到，亦或是命令行参数传入。\n\n## 命令行参数\n常用命令行参数说明：\n\n| 参数 | 说明 |\n|---|---|\n|-f|  执行awk脚本文件路径  |\n|-F|输入域分隔符   |\n|-v|传入shell变量   |\n|-b|字符按照字节区分   |\n|-h|帮助文档   |\n|-V|显示版本   |\n\n## 正则表达式\nscript一般格式为`/pattern/{actions}`，pattern表示正则表达式，actions表示一系列操作。awk利用正则表达式pattern匹配出需要执行actions的行，如果没有pattern表示每一行都执行actions。\n\n示例：打印所有行\n```sh\n➜ seq 20 | awk '{print $1}'\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n```\n\n示例：打印包含1的行\n```\n➜ seq 20 | awk '/1/{print $1}'\n1\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n```\n\nprint表示打印；`$1`表示第一列，`$2`表示第二列，以此类推，`$0`表示当前行。\n\nawk利用运算符`~`表示符合正则运算，`!~`表示不符合正则运算。\n示例：\n```sh\n➜ seq 20 | awk '$1 !~ /1/{print $1}'            \n2\n3\n4\n5\n6\n7\n8\n9\n20\n```\n\n## 数学运算\nawk支持使用数学条件筛选，支持运算符表格：\n\n| 运算符 | 描述 |\n| --- | --- |\n| `= += -= *= /= %= ^= **=` | 赋值 |\n| `?:` | C条件表达式 |\n| `\\|\\|` | 逻辑或 |\n| `&&` | 逻辑与 |\n| `~` 和 `!~` | 匹配正则表达式和不匹配正则表达式 |\n| `< <= > >= != ==` | 关系运算符 |\n| 空格 | 连接 |\n| `+ -`| 加，减 |\n| `* / %` | 乘，除与求余 |\n| `+ - !` | 一元加，减和逻辑非 |\n| `^ ***` | 求幂 |\n| `++ --` | 增加或减少，作为前缀或后缀 |\n| `$` | 字段引用 |\n| `in` | 数组成员 |\n\n示例：1-20中筛选大于10的偶数\n```sh\n➜ seq 20 | awk '$1%2==0&&$1>=10{print $1,\"Y\"}'\n10 Y\n12 Y\n14 Y\n16 Y\n18 Y\n20 Y\n```\n\n\nawk还支持算术函数\n\n| 函数名 | 说明 |\n| :-----: | --- |\n| `atan2( y, x )` | 返回 y/x 的反正切。 |\n| `cos( x )` | 返回 x 的余弦；x 是弧度。 |\n| `sin( x )` | 返回 x 的正弦；x 是弧度。 |\n| `exp( x )` | 返回 x 幂函数。 |\n| `log( x )` | 返回 x 的自然对数。 |\n| `sqrt( x )` | 返回 x 平方根。 |\n| `int( x )` | 返回 x 的截断至整数的值。 |\n| `rand()` | 返回任意数字 n，其中 0 <= n < 1。 |\n| `srand([Expr])` | 将rand函数的种子值设置为Expr参数的值，或如果省略Expr参数则使用某天的时间。返回先前的种子值。|\n\n示例：打印$e^{$1}$，上次随机数种子，随机数\n```\n➜ seq 20 | awk '{print exp($1), srand($1), rand()}'\n2.71828 0 0.840188\n7.38906 1 0.700976\n20.0855 2 0.56138\n54.5982 3 0.916458\n148.413 4 0.274746\n403.429 5 0.135439\n1096.63 6 0.486904\n2980.96 7 0.352761\n8103.08 8 0.206965\n22026.5 9 0.565811\n59874.1 10 0.926345\n162755 11 0.7856\n442413 12 0.632643\n1.2026e+06 13 0.999498\n3.26902e+06 14 0.354973\n8.88611e+06 15 0.215437\n2.4155e+07 16 0.571794\n6.566e+07 17 0.929073\n1.78482e+08 18 0.290233\n4.85165e+08 19 0.148812\n```\n\n## BEGIN-END\nawk有两个特殊的条件，对待每个处理的文件，BEGIN后面的actions在执行整个文件**之前**执行一次，END后面的actions在执行整个文件**之后**执行一次。awk可以像c一样使用使用变量，但是不需要定义变量。\n示例：\n```sh\n➜ seq 20 | awk  '/1/{x=x+1;}END{print x}'   \n11\n\n➜ seq 20 | awk 'BEGIN{x=100}/1/{x=x+1;}END{print x}' \n111\n```\n\n## 内建变量\n\n| 变量 | 描述 |\n| --- | --- |\n| `$n` | 当前记录的第n个字段，字段间由FS分隔 |\n| `$0` | 完整的输入记录 |\n| `ARGC` | 命令行参数的数目 |\n| `ARGIND` | 命令行中当前文件的位置(从0开始算) |\n| `ARGV` | 包含命令行参数的数组 |\n| `CONVFMT` | 数字转换格式(默认值为%.6g)ENVIRON环境变量关联数组 |\n| `ERRNO` | 最后一个系统错误的描述 |\n| `FIELDWIDTHS` | 字段宽度列表(用空格键分隔) |\n| `FILENAME` | 当前文件名 |\n| `FNR` | 各文件分别计数的行号 |\n| `FS` | 字段分隔符(默认是任何空格) |\n| `IGNORECASE` | 如果为真，则进行忽略大小写的匹配 |\n| `NF` | 一条记录的字段的数目 |\n| `NR` | 已经读出的记录数，就是行号，从1开始 |\n| `OFMT` | 数字的输出格式(默认值是%.6g) |\n| `OFS` | print函数输出字段分隔符（输出空格），输出时用指定的符号代替分隔符 |\n| `ORS` | 输出记录分隔符(默认值是一个换行符) |\n| `RLENGTH` | 由match函数所匹配的字符串的长度 |\n| `RS` | 记录分隔符(默认是一个换行符) |\n| `RSTART` | 由match函数所匹配的字符串的第一个位置 |\n| `SUBSEP` | 数组下标分隔符(默认值是/034) |\n\n示例：打印最后一列，并打印当前行数\n```sh\n➜ seq 20 | sort | awk '{print $NF \"\\t\" NR}'\n1\t1\n10\t2\n11\t3\n12\t4\n13\t5\n14\t6\n15\t7\n16\t8\n17\t9\n18\t10\n19\t11\n2\t12\n20\t13\n3\t14\n4\t15\n5\t16\n6\t17\n7\t18\n8\t19\n9\t20\n```\n\n示例：替换输出分隔符和换行符\n```sh\n➜ echo \"this is a test\\nthis is a test\" | awk 'BEGIN{OFS=\"_\";ORS=\"--\"}{print $1,$2,$3,$4}'\nthis_is_a_test--this_is_a_test--\n```\n\n## 一般函数\n\n| **函数** | **说明** |\n| --- | --- |\n| `close( Expression )` | 用同一个带字符串值的 Expression 参数来关闭由 print 或 printf 语句打开的或调用 getline 函数打开的文件或管道。如果文件或管道成功关闭，则返回 0；其它情况下返回非零值。如果打算写一个文件，并稍后在同一个程序中读取文件，则 close 语句是必需的。 |\n| `system(Command )` | 执行 Command 参数指定的命令，并返回退出状态。 |\n| `Expression \\| getline [ Variable ]` | 从来自 Expression 参数指定的命令的输出中通过管道传送的流中读取一个输入记录，并将该记录的值指定给 Variable 参数指定的变量。如果当前未打开将 Expression 参数的值作为其命令名称的流，则创建流。此时 Command 参数取 Expression 参数的值且 Mode 参数设置为一个是 r 的值。只要流保留打开且 Expression 参数求得同一个字符串，则对 getline 函数的每次后续调用读取另一个记录。如果未指定 Variable 参数，则 $0 记录变量和 NF 特殊变量设置为从流读取的记录。 |\n| `getline [ Variable ] < Expression` | 从 Expression 参数指定的文件读取输入的下一个记录，并将 Variable 参数指定的变量设置为该记录的值。只要流保留打开且 Expression 参数对同一个字符串求值，则对 getline 函数的每次后续调用读取另一个记录。如果未指定 Variable 参数，则 $0 记录变量和 NF 特殊变量设置为从流读取的记录。 |\n| `getline [ Variable ]` | 将 Variable 参数指定的变量设置为从当前输入文件读取的下一个输入记录。如果未指定 Variable 参数，则 $0 记录变量设置为该记录的值，还将设置 NF、NR 和 FNR 特殊变量。 |\n\n示例：通过system函数执行shell语句，最后0表示Errno\n```sh\n➜ awk 'BEGIN{print system(\"ps -ef | grep awk\")}'\nroot      6490 10366  0 17:16 pts/0    00:00:00 awk BEGIN{print system(\"ps -ef | grep awk\")}\nroot      6491  6490  0 17:16 pts/0    00:00:00 sh -c ps -ef | grep awk\nroot      6493  6491  0 17:16 pts/0    00:00:00 grep awk\n0\n```\n\n## 字符串函数\nawk还有内置字符串函数\n\n| **函数** | **说明** |\n| --- | --- |\n| `gsub( Ere, Repl, [ In ] )` | 除了正则表达式所有具体值被替代这点，它和 sub 函数完全一样地执行。 |\n| `sub( Ere, Repl, [ In ] )`| 用 Repl 参数指定的字符串替换 In 参数指定的字符串中的由 Ere 参数指定的扩展正则表达式的第一个具体值。sub 函数返回替换的数量。出现在 Repl 参数指定的字符串中的 &（和符号）由 In 参数指定的与 Ere 参数的指定的扩展正则表达式匹配的字符串替换。如果未指定 In 参数，缺省值是整个记录（$0 记录变量）。 |\n| `index( String1, String2 )` | 在由 String1 参数指定的字符串（其中有出现 String2 指定的参数）中，返回位置，从 1 开始编号。如果 String2 参数不在 String1 参数中出现，则返回 0（零）。 |\n| `length [(String)]` | 返回 String 参数指定的字符串的长度（字符形式）。如果未给出 String 参数，则返回整个记录的长度（$0 记录变量）。 |\n| `substr( String, M, [ N ] )` | 返回具有 N 参数指定的字符数量子串。子串从 String 参数指定的字符串取得，其字符以 M 参数指定的位置开始。M 参数指定为将 String 参数中的第一个字符作为编号 1。如果未指定 N 参数，则子串的长度将是 M 参数指定的位置到 String 参数的末尾 的长度。 |\n| `match( String, Ere )` | 在 String 参数指定的字符串（Ere 参数指定的扩展正则表达式出现在其中）中返回位置（字符形式），从 1 开始编号，或如果 Ere 参数不出现，则返回 0（零）。RSTART 特殊变量设置为返回值。RLENGTH 特殊变量设置为匹配的字符串的长度，或如果未找到任何匹配，则设置为 -1（负一）。 |\n| `split( String, A, [Ere] )` | 将 String 参数指定的参数分割为数组元素 `A[1], A[2], . . ., A[n]`，并返回 n 变量的值。此分隔可以通过 Ere 参数指定的扩展正则表达式进行，或用当前字段分隔符（FS 特殊变量）来进行（如果没有给出 Ere 参数）。除非上下文指明特定的元素还应具有一个数字值，否则 A 数组中的元素用字符串值来创建。 |\n| `tolower( String )` | 返回 String 参数指定的字符串，字符串中每个大写字符将更改为小写。大写和小写的映射由当前语言环境的 LC_CTYPE 范畴定义。 |\n| `toupper( String )` | 返回 String 参数指定的字符串，字符串中每个小写字符将更改为大写。大写和小写的映射由当前语言环境的 LC_CTYPE 范畴定义。 |\n| `printf(Format, Expr, Expr, . . . )` | 根据 Format 参数指定的格式字符串来格式化 Expr 参数指定的表达式并返回最后生成的字符串。 |\n\nsprintf函数format格式化参数转换表\n\n| **格式符** | **说明** |\n| --- | --- |\n| `%d` | 十进制有符号整数 |\n| `%u` | 十进制无符号整数 |\n| `%f` | 浮点数 |\n| `%s` | 字符串 |\n| `%c` | 单个字符 |\n| `%p` | 指针的值 |\n| `%e` | 指数形式的浮点数 |\n| `%x` | %X 无符号以十六进制表示的整数 |\n| `%o` | 无符号以八进制表示的整数 |\n| `%g`| 自动选择合适的表示法 |\n\n\n示例：打印字符串，转换大小写\n```sh\n➜ awk 'BEGIN{str=\"Hello World\";print str \"\\n\" tolower(str) \"\\n\" toupper(str)}'\nHello World\nhello world\nHELLO WORLD\n```\n\n示例：打印字符串长度，查找指定字串并返回子串索引，匹配正则字串并返回子串索引\n```sh\n➜ awk 'BEGIN{str=\"Hello World\";printf(\"len:%d, index:%d, match:%d\\n\",length(str),index(str,\"world\"),match(str,/[wW]orld/))}'\nlen:11, index:0, match:7\n```\n\n示例：利用split函数，打印字串数组\n```sh\n➜ awk 'BEGIN{str=\"this is a test\";split(str,t,\" \");print length(t);for(k in t){print k,t[k];}}'\n4\n4 test\n1 this\n2 is\n3 a\n```\n\n## 时间函数\n\n| **函数名** | **说明** |\n| --- | --- |\n| `mktime( YYYY MM DD HH MM SS[ DST])` | 生成时间格式 |\n| `strftime([format [, timestamp]])` | 格式化时间输出，将时间戳转为时间字符串具体格式，见下表. |\n| `systime()` | 得到时间戳,返回从1970年1月1日开始到当前时间（不计闰年）的整秒数 |\n\nstrftime函数format格式化参数转换表\n\n| 格式 | 描述 |\n| --- | --- |\n| `%a` | 星期几的缩写（Sun） |\n| `%A` | 星期几的完整写法（Sunday） |\n| `%b` | 月名的缩写（Oct） |\n| `%B` | 月名的完整写法（October） |\n| `%c` | 本地日期和时间 |\n| `%d` | 十进制日期 |\n| `%D` | 日期 08/20/99 |\n| `%e` | 日期，如果只有一位会补上一个空格 |\n| `%H` | 用十进制表示24小时格式的小时 |\n| `%I` | 用十进制表示12小时格式的小时 |\n| `%j` | 从1月1日起一年中的第几天 |\n| `%m` | 十进制表示的月份 |\n| `%M` | 十进制表示的分钟 |\n| `%p` | 12小时表示法（AM/PM） |\n| `%S` | 十进制表示的秒 |\n| `%U` | 十进制表示的一年中的第几个星期（星期天作为一个星期的开始） |\n| `%w` | 十进制表示的星期几（星期天是0） |\n| `%W` | 十进制表示的一年中的第几个星期（星期一作为一个星期的开始） |\n| `%x` | 重新设置本地日期（08/20/99） |\n| `%X` | 重新设置本地时间（12:00:00） |\n| `%y` | 两位数字表示的年（99） |\n| `%Y` | 当前月份 |\n| `%Z` | 时区（PDT） |\n| `%%` | 百分号（%） |\n\n示例：获取当前时间，并格式化输出\n```sh\n➜ awk 'BEGIN{st=systime();print st, strftime(\"%c %Z\", st)}'\n1576744487 2019年12月19日 星期四 16时34分47秒 CST\n```\n\n# 进阶\nawk可以利用类c风格的代码进行简单的程序编写，使之能完成更多的事情。\n## 编程语法\n### 条件判断\nawk的条件判断格式是类c风格的\n```c\nif (expression) \n{\n    statement;\n    ...\n}\n\nif (expression) \n{\n    statement1;\n} \nelse \n{\n    statement2;\n}\n\nif (expression1) \n{\n    statement1;\n}\nelse if (expression2) \n{\n    statement2;\n}\nelse \n{\n    statement3;\n}\n```\n\n### 循环\nawk支持while、for和do-while循环，格式也是类c风格的\n```sh\nwhile (expression) \n{\n    statement;\n}\n\n// for-in 输出的var顺序可能不一致\nfor (var in array) \n{\n    statement;\n}\nfor (var; condtion; expression) \n{\n    statement;\n}\n\ndo \n{\n    statement;\n} while (expression);\n```\n\n同时awk也支持退出循环\n\n| 字段 | 说明 |\n| --- | --- |\n| break | 当 break 语句用于 while 或 for 语句时，导致退出程序循环。 |\n| continue | 当 continue 语句用于 while 或 for 语句时，使程序循环移动到下一个迭代。 |\n| next | 能能够导致读入下一个输入行，并返回到脚本的顶部。这可以避免对当前输入行执行其他的操作过程。|\n| exit |语句使主输入循环退出并将控制转移到END,如果END存在的话。如果没有定义END规则，或在END中应用exit语句，则终止脚本的执行。|\n\n\n\n\n## 数组\nawk数组支持数字下标和字符串下标，底层是哈希表，所以每次遍历不能保证都是相同顺序。\n示例：\n```sh\narray_name[key]=value\n```\n\n* array_name：数组的名称\n* key：数组索引\n* value：数组中元素所赋予的值\n\n### 添加元素\nawk可以直接声明元素key-value对\n示例：\n```sh\n➜ awk 'BEGIN{keys[1]=2;keys[\"start\"]=\"start\";print keys[1], keys[\"start\"]}'\n2 start\n```\n\n### 删除元素\n使用delete可以删除数组的元素\n示例：删除key为1的值，最后打印keys[1]的值为空字符串\n```sh\n➜ awk 'BEGIN{keys[1]=2;keys[\"start\"]=\"start\";delete keys[1];print keys[1], keys[\"start\"]}'\n start\n```\n\n### 二维数组\nawk 多维数组在本质上是一维数组，因awk在存储上并不支持多维数组，awk提供了逻辑上模拟二维数组的访问方式。例如，array[2,3] = 1这样的访问是允许的。\nawk使用一个特殊的字符串SUBSEP （`\\034`）作为分割字段，在上面的例子 array[2,3] = 1 中，关联数组array存储的键值实际上是2`\\034`3，2和3分别为下标（2，3），`\\034`为SUBSEP分隔符。\n示例：\n```sh\n➜ awk 'BEGIN{a[1,1]=1;a[\"1,1\"]=2;a[11]=3;for(i in a){print i,a[i]}}'\n1,1 2\n11 3\n11 1\n```\n\n### 数组排序\nasort对数组array按照首字母进行排序，返回数组长度。如果要得到数组原本顺序，需要使用数组下标依次访问。\nfor-in 输出关联数组的顺序是无序的，所以通过for-in 得到是无序的数组。如果需要得到有序数组，需要通过下标获得。\n示例：\n```sh\n➜ awk 'BEGIN{str=\"it is a test\";l=split(str,array,\" \");for(i in array){print i,array[i];};asort(array);for(i in array){print i,array[i;}}'\n4 test\n1 it\n2 is\n3 a\n4 test\n1 a\n2 is\n3 it\n```\n\n## 函数\n一个程序包含有多个功能，每个功能我们可以独立一个函数，函数可以提高代码的复用性。用户自定义函数的语法格式为：\n```sh\nfunction function_name(argument1, argument2,  ...)\n{\n  function body \n}\n```\n\n**解析：**\n*   **function_name** 是用户自定义函数的名称。函数名称应该以字母开头，其后可以是数字、字母或下划线的自由组合。AWK 保留的关键字不能作为用户自定义函数的名称。\n*   自定义函数可以接受多个输入参数，这些参数之间通过逗号分隔。参数并不是必须的。我们也可以定义没有任何输入参数的函数。\n*   **function body** 是函数体部分，它包含 AWK 程序代码。\n\n示例：写一个求和函数\n```sh\n➜ awk 'function sum(n1,n2){return n1+n2}BEGIN{print sum(1,2)}'\n3\n```\n\n如果函数比较复杂，我们可以写成一个文件的形式来执行awk。\n\n```sh\n# 返回最小值\nfunction find_min(num1, num2)\n{\n  if (num1 < num2)\n    return num1\n  return num2\n}\n\n# 返回最大值\nfunction find_max(num1, num2)\n{\n  if (num1 > num2)\n    return num1\n  return num2\n}\n\n# 主函数\nfunction main(num1, num2)\n{\n  # 查找最小值\n  result = find_min(10, 20)\n  print \"Minimum =\", result\n\n  # 查找最大值\n  result = find_max(10, 20)\n  print \"Maximum =\", result\n}\n\n# 脚本从这里开始执行\nBEGIN {\n  main(10, 20)\n}\n```\n\n执行可以得到\n```sh\nMinimum = 10\nMaximum = 20\n```\n\n# 参考文献\n* [维基百科](https://zh.wikipedia.org/wiki/AWK)\n* [菜鸟教程](https://www.runoob.com/linux/linux-comm-awk.html)\n","slug":"linux-awk命令","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckh351dus001j19z4ajma45u8","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>awk是一个强大的文本处理和文本分析工具，不仅可以通过行为单位处理文本，还可以通过列为单位处理文本，默认行分隔符是换行符，默认列分隔符是连续空格和Tab，可以定义分隔符。awk提供了极其强大的功能：可以进行正则表达式的匹配，样式装入、流控制、数学运算符、进程控制语句甚至于内置的变量和函数。<br>获取帮助信息，gawk是awk的GNU版本</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">➜ awk --help\nUsage: awk [POSIX or GNU style options] -f progfile [--] file ...\nUsage: awk [POSIX or GNU style options] [--] 'program' file ...\nPOSIX options:        GNU long options: (standard)\n    -f progfile        --file=progfile\n    -F fs            --field-separator=fs\n    -v var=val        --assign=var=val\nShort options:        GNU long options: (extensions)\n    -b            --characters-as-bytes\n    -c            --traditional\n    -C            --copyright\n    -d[file]        --dump-variables[=file]\n    -e 'program-text'    --source='program-text'\n    -E file            --exec=file\n    -g            --gen-pot\n    -h            --help\n    -L [fatal]        --lint[=fatal]\n    -n            --non-decimal-data\n    -N            --use-lc-numeric\n    -O            --optimize\n    -p[file]        --profile[=file]\n    -P            --posix\n    -r            --re-interval\n    -S            --sandbox\n    -t            --lint-old\n    -V            --version\n\nTo report bugs, see node `Bugs' in `gawk.info', which is\nsection `Reporting Problems and Bugs' in the printed version.\n\ngawk is a pattern scanning and processing language.\nBy default it reads standard input and writes standard output.\n\nExamples:\n    gawk '{ sum += $1 }; END { print sum }' file\n    gawk -F: '{ print $1 }' /etc/passwd</code></pre>\n<h1 id=\"执行方式\"><a href=\"#执行方式\" class=\"headerlink\" title=\"执行方式\"></a>执行方式</h1><p>awk命令行的基本执行形式为：</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">awk option 'script' file1 file2 ...\nawk option -f scriptfile file1 file2 ...</code></pre>\n<p>awk的操作对象既可以是文本文件，也可以是标准输入重定向得到，亦或是命令行参数传入。</p>\n<h2 id=\"命令行参数\"><a href=\"#命令行参数\" class=\"headerlink\" title=\"命令行参数\"></a>命令行参数</h2><p>常用命令行参数说明：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-f</td>\n<td>执行awk脚本文件路径</td>\n</tr>\n<tr>\n<td>-F</td>\n<td>输入域分隔符</td>\n</tr>\n<tr>\n<td>-v</td>\n<td>传入shell变量</td>\n</tr>\n<tr>\n<td>-b</td>\n<td>字符按照字节区分</td>\n</tr>\n<tr>\n<td>-h</td>\n<td>帮助文档</td>\n</tr>\n<tr>\n<td>-V</td>\n<td>显示版本</td>\n</tr>\n</tbody></table>\n<h2 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h2><p>script一般格式为<code>/pattern/{actions}</code>，pattern表示正则表达式，actions表示一系列操作。awk利用正则表达式pattern匹配出需要执行actions的行，如果没有pattern表示每一行都执行actions。</p>\n<p>示例：打印所有行</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">➜ seq 20 | awk '{print $1}'\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20</code></pre>\n<p>示例：打印包含1的行</p>\n<pre><code>➜ seq 20 | awk '/1/{print $1}'\n1\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19</code></pre><p>print表示打印；<code>$1</code>表示第一列，<code>$2</code>表示第二列，以此类推，<code>$0</code>表示当前行。</p>\n<p>awk利用运算符<code>~</code>表示符合正则运算，<code>!~</code>表示不符合正则运算。<br>示例：</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">➜ seq 20 | awk '$1 !~ /1/{print $1}'            \n2\n3\n4\n5\n6\n7\n8\n9\n20</code></pre>\n<h2 id=\"数学运算\"><a href=\"#数学运算\" class=\"headerlink\" title=\"数学运算\"></a>数学运算</h2><p>awk支持使用数学条件筛选，支持运算符表格：</p>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>= += -= *= /= %= ^= **=</code></td>\n<td>赋值</td>\n</tr>\n<tr>\n<td><code>?:</code></td>\n<td>C条件表达式</td>\n</tr>\n<tr>\n<td><code>||</code></td>\n<td>逻辑或</td>\n</tr>\n<tr>\n<td><code>&amp;&amp;</code></td>\n<td>逻辑与</td>\n</tr>\n<tr>\n<td><code>~</code> 和 <code>!~</code></td>\n<td>匹配正则表达式和不匹配正则表达式</td>\n</tr>\n<tr>\n<td><code>&lt; &lt;= &gt; &gt;= != ==</code></td>\n<td>关系运算符</td>\n</tr>\n<tr>\n<td>空格</td>\n<td>连接</td>\n</tr>\n<tr>\n<td><code>+ -</code></td>\n<td>加，减</td>\n</tr>\n<tr>\n<td><code>* / %</code></td>\n<td>乘，除与求余</td>\n</tr>\n<tr>\n<td><code>+ - !</code></td>\n<td>一元加，减和逻辑非</td>\n</tr>\n<tr>\n<td><code>^ ***</code></td>\n<td>求幂</td>\n</tr>\n<tr>\n<td><code>++ --</code></td>\n<td>增加或减少，作为前缀或后缀</td>\n</tr>\n<tr>\n<td><code>$</code></td>\n<td>字段引用</td>\n</tr>\n<tr>\n<td><code>in</code></td>\n<td>数组成员</td>\n</tr>\n</tbody></table>\n<p>示例：1-20中筛选大于10的偶数</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">➜ seq 20 | awk '$1%2==0&&$1>=10{print $1,\"Y\"}'\n10 Y\n12 Y\n14 Y\n16 Y\n18 Y\n20 Y</code></pre>\n<p>awk还支持算术函数</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">函数名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>atan2( y, x )</code></td>\n<td>返回 y/x 的反正切。</td>\n</tr>\n<tr>\n<td align=\"center\"><code>cos( x )</code></td>\n<td>返回 x 的余弦；x 是弧度。</td>\n</tr>\n<tr>\n<td align=\"center\"><code>sin( x )</code></td>\n<td>返回 x 的正弦；x 是弧度。</td>\n</tr>\n<tr>\n<td align=\"center\"><code>exp( x )</code></td>\n<td>返回 x 幂函数。</td>\n</tr>\n<tr>\n<td align=\"center\"><code>log( x )</code></td>\n<td>返回 x 的自然对数。</td>\n</tr>\n<tr>\n<td align=\"center\"><code>sqrt( x )</code></td>\n<td>返回 x 平方根。</td>\n</tr>\n<tr>\n<td align=\"center\"><code>int( x )</code></td>\n<td>返回 x 的截断至整数的值。</td>\n</tr>\n<tr>\n<td align=\"center\"><code>rand()</code></td>\n<td>返回任意数字 n，其中 0 &lt;= n &lt; 1。</td>\n</tr>\n<tr>\n<td align=\"center\"><code>srand([Expr])</code></td>\n<td>将rand函数的种子值设置为Expr参数的值，或如果省略Expr参数则使用某天的时间。返回先前的种子值。</td>\n</tr>\n</tbody></table>\n<p>示例：打印$e^{$1}$，上次随机数种子，随机数</p>\n<pre><code>➜ seq 20 | awk '{print exp($1), srand($1), rand()}'\n2.71828 0 0.840188\n7.38906 1 0.700976\n20.0855 2 0.56138\n54.5982 3 0.916458\n148.413 4 0.274746\n403.429 5 0.135439\n1096.63 6 0.486904\n2980.96 7 0.352761\n8103.08 8 0.206965\n22026.5 9 0.565811\n59874.1 10 0.926345\n162755 11 0.7856\n442413 12 0.632643\n1.2026e+06 13 0.999498\n3.26902e+06 14 0.354973\n8.88611e+06 15 0.215437\n2.4155e+07 16 0.571794\n6.566e+07 17 0.929073\n1.78482e+08 18 0.290233\n4.85165e+08 19 0.148812</code></pre><h2 id=\"BEGIN-END\"><a href=\"#BEGIN-END\" class=\"headerlink\" title=\"BEGIN-END\"></a>BEGIN-END</h2><p>awk有两个特殊的条件，对待每个处理的文件，BEGIN后面的actions在执行整个文件<strong>之前</strong>执行一次，END后面的actions在执行整个文件<strong>之后</strong>执行一次。awk可以像c一样使用使用变量，但是不需要定义变量。<br>示例：</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">➜ seq 20 | awk  '/1/{x=x+1;}END{print x}'   \n11\n\n➜ seq 20 | awk 'BEGIN{x=100}/1/{x=x+1;}END{print x}' \n111</code></pre>\n<h2 id=\"内建变量\"><a href=\"#内建变量\" class=\"headerlink\" title=\"内建变量\"></a>内建变量</h2><table>\n<thead>\n<tr>\n<th>变量</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>$n</code></td>\n<td>当前记录的第n个字段，字段间由FS分隔</td>\n</tr>\n<tr>\n<td><code>$0</code></td>\n<td>完整的输入记录</td>\n</tr>\n<tr>\n<td><code>ARGC</code></td>\n<td>命令行参数的数目</td>\n</tr>\n<tr>\n<td><code>ARGIND</code></td>\n<td>命令行中当前文件的位置(从0开始算)</td>\n</tr>\n<tr>\n<td><code>ARGV</code></td>\n<td>包含命令行参数的数组</td>\n</tr>\n<tr>\n<td><code>CONVFMT</code></td>\n<td>数字转换格式(默认值为%.6g)ENVIRON环境变量关联数组</td>\n</tr>\n<tr>\n<td><code>ERRNO</code></td>\n<td>最后一个系统错误的描述</td>\n</tr>\n<tr>\n<td><code>FIELDWIDTHS</code></td>\n<td>字段宽度列表(用空格键分隔)</td>\n</tr>\n<tr>\n<td><code>FILENAME</code></td>\n<td>当前文件名</td>\n</tr>\n<tr>\n<td><code>FNR</code></td>\n<td>各文件分别计数的行号</td>\n</tr>\n<tr>\n<td><code>FS</code></td>\n<td>字段分隔符(默认是任何空格)</td>\n</tr>\n<tr>\n<td><code>IGNORECASE</code></td>\n<td>如果为真，则进行忽略大小写的匹配</td>\n</tr>\n<tr>\n<td><code>NF</code></td>\n<td>一条记录的字段的数目</td>\n</tr>\n<tr>\n<td><code>NR</code></td>\n<td>已经读出的记录数，就是行号，从1开始</td>\n</tr>\n<tr>\n<td><code>OFMT</code></td>\n<td>数字的输出格式(默认值是%.6g)</td>\n</tr>\n<tr>\n<td><code>OFS</code></td>\n<td>print函数输出字段分隔符（输出空格），输出时用指定的符号代替分隔符</td>\n</tr>\n<tr>\n<td><code>ORS</code></td>\n<td>输出记录分隔符(默认值是一个换行符)</td>\n</tr>\n<tr>\n<td><code>RLENGTH</code></td>\n<td>由match函数所匹配的字符串的长度</td>\n</tr>\n<tr>\n<td><code>RS</code></td>\n<td>记录分隔符(默认是一个换行符)</td>\n</tr>\n<tr>\n<td><code>RSTART</code></td>\n<td>由match函数所匹配的字符串的第一个位置</td>\n</tr>\n<tr>\n<td><code>SUBSEP</code></td>\n<td>数组下标分隔符(默认值是/034)</td>\n</tr>\n</tbody></table>\n<p>示例：打印最后一列，并打印当前行数</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">➜ seq 20 | sort | awk '{print $NF \"\\t\" NR}'\n1    1\n10    2\n11    3\n12    4\n13    5\n14    6\n15    7\n16    8\n17    9\n18    10\n19    11\n2    12\n20    13\n3    14\n4    15\n5    16\n6    17\n7    18\n8    19\n9    20</code></pre>\n<p>示例：替换输出分隔符和换行符</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">➜ echo \"this is a test\\nthis is a test\" | awk 'BEGIN{OFS=\"_\";ORS=\"--\"}{print $1,$2,$3,$4}'\nthis_is_a_test--this_is_a_test--</code></pre>\n<h2 id=\"一般函数\"><a href=\"#一般函数\" class=\"headerlink\" title=\"一般函数\"></a>一般函数</h2><table>\n<thead>\n<tr>\n<th><strong>函数</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>close( Expression )</code></td>\n<td>用同一个带字符串值的 Expression 参数来关闭由 print 或 printf 语句打开的或调用 getline 函数打开的文件或管道。如果文件或管道成功关闭，则返回 0；其它情况下返回非零值。如果打算写一个文件，并稍后在同一个程序中读取文件，则 close 语句是必需的。</td>\n</tr>\n<tr>\n<td><code>system(Command )</code></td>\n<td>执行 Command 参数指定的命令，并返回退出状态。</td>\n</tr>\n<tr>\n<td><code>Expression | getline [ Variable ]</code></td>\n<td>从来自 Expression 参数指定的命令的输出中通过管道传送的流中读取一个输入记录，并将该记录的值指定给 Variable 参数指定的变量。如果当前未打开将 Expression 参数的值作为其命令名称的流，则创建流。此时 Command 参数取 Expression 参数的值且 Mode 参数设置为一个是 r 的值。只要流保留打开且 Expression 参数求得同一个字符串，则对 getline 函数的每次后续调用读取另一个记录。如果未指定 Variable 参数，则 $0 记录变量和 NF 特殊变量设置为从流读取的记录。</td>\n</tr>\n<tr>\n<td><code>getline [ Variable ] &lt; Expression</code></td>\n<td>从 Expression 参数指定的文件读取输入的下一个记录，并将 Variable 参数指定的变量设置为该记录的值。只要流保留打开且 Expression 参数对同一个字符串求值，则对 getline 函数的每次后续调用读取另一个记录。如果未指定 Variable 参数，则 $0 记录变量和 NF 特殊变量设置为从流读取的记录。</td>\n</tr>\n<tr>\n<td><code>getline [ Variable ]</code></td>\n<td>将 Variable 参数指定的变量设置为从当前输入文件读取的下一个输入记录。如果未指定 Variable 参数，则 $0 记录变量设置为该记录的值，还将设置 NF、NR 和 FNR 特殊变量。</td>\n</tr>\n</tbody></table>\n<p>示例：通过system函数执行shell语句，最后0表示Errno</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">➜ awk 'BEGIN{print system(\"ps -ef | grep awk\")}'\nroot      6490 10366  0 17:16 pts/0    00:00:00 awk BEGIN{print system(\"ps -ef | grep awk\")}\nroot      6491  6490  0 17:16 pts/0    00:00:00 sh -c ps -ef | grep awk\nroot      6493  6491  0 17:16 pts/0    00:00:00 grep awk\n0</code></pre>\n<h2 id=\"字符串函数\"><a href=\"#字符串函数\" class=\"headerlink\" title=\"字符串函数\"></a>字符串函数</h2><p>awk还有内置字符串函数</p>\n<table>\n<thead>\n<tr>\n<th><strong>函数</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>gsub( Ere, Repl, [ In ] )</code></td>\n<td>除了正则表达式所有具体值被替代这点，它和 sub 函数完全一样地执行。</td>\n</tr>\n<tr>\n<td><code>sub( Ere, Repl, [ In ] )</code></td>\n<td>用 Repl 参数指定的字符串替换 In 参数指定的字符串中的由 Ere 参数指定的扩展正则表达式的第一个具体值。sub 函数返回替换的数量。出现在 Repl 参数指定的字符串中的 &amp;（和符号）由 In 参数指定的与 Ere 参数的指定的扩展正则表达式匹配的字符串替换。如果未指定 In 参数，缺省值是整个记录（$0 记录变量）。</td>\n</tr>\n<tr>\n<td><code>index( String1, String2 )</code></td>\n<td>在由 String1 参数指定的字符串（其中有出现 String2 指定的参数）中，返回位置，从 1 开始编号。如果 String2 参数不在 String1 参数中出现，则返回 0（零）。</td>\n</tr>\n<tr>\n<td><code>length [(String)]</code></td>\n<td>返回 String 参数指定的字符串的长度（字符形式）。如果未给出 String 参数，则返回整个记录的长度（$0 记录变量）。</td>\n</tr>\n<tr>\n<td><code>substr( String, M, [ N ] )</code></td>\n<td>返回具有 N 参数指定的字符数量子串。子串从 String 参数指定的字符串取得，其字符以 M 参数指定的位置开始。M 参数指定为将 String 参数中的第一个字符作为编号 1。如果未指定 N 参数，则子串的长度将是 M 参数指定的位置到 String 参数的末尾 的长度。</td>\n</tr>\n<tr>\n<td><code>match( String, Ere )</code></td>\n<td>在 String 参数指定的字符串（Ere 参数指定的扩展正则表达式出现在其中）中返回位置（字符形式），从 1 开始编号，或如果 Ere 参数不出现，则返回 0（零）。RSTART 特殊变量设置为返回值。RLENGTH 特殊变量设置为匹配的字符串的长度，或如果未找到任何匹配，则设置为 -1（负一）。</td>\n</tr>\n<tr>\n<td><code>split( String, A, [Ere] )</code></td>\n<td>将 String 参数指定的参数分割为数组元素 <code>A[1], A[2], . . ., A[n]</code>，并返回 n 变量的值。此分隔可以通过 Ere 参数指定的扩展正则表达式进行，或用当前字段分隔符（FS 特殊变量）来进行（如果没有给出 Ere 参数）。除非上下文指明特定的元素还应具有一个数字值，否则 A 数组中的元素用字符串值来创建。</td>\n</tr>\n<tr>\n<td><code>tolower( String )</code></td>\n<td>返回 String 参数指定的字符串，字符串中每个大写字符将更改为小写。大写和小写的映射由当前语言环境的 LC_CTYPE 范畴定义。</td>\n</tr>\n<tr>\n<td><code>toupper( String )</code></td>\n<td>返回 String 参数指定的字符串，字符串中每个小写字符将更改为大写。大写和小写的映射由当前语言环境的 LC_CTYPE 范畴定义。</td>\n</tr>\n<tr>\n<td><code>printf(Format, Expr, Expr, . . . )</code></td>\n<td>根据 Format 参数指定的格式字符串来格式化 Expr 参数指定的表达式并返回最后生成的字符串。</td>\n</tr>\n</tbody></table>\n<p>sprintf函数format格式化参数转换表</p>\n<table>\n<thead>\n<tr>\n<th><strong>格式符</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>%d</code></td>\n<td>十进制有符号整数</td>\n</tr>\n<tr>\n<td><code>%u</code></td>\n<td>十进制无符号整数</td>\n</tr>\n<tr>\n<td><code>%f</code></td>\n<td>浮点数</td>\n</tr>\n<tr>\n<td><code>%s</code></td>\n<td>字符串</td>\n</tr>\n<tr>\n<td><code>%c</code></td>\n<td>单个字符</td>\n</tr>\n<tr>\n<td><code>%p</code></td>\n<td>指针的值</td>\n</tr>\n<tr>\n<td><code>%e</code></td>\n<td>指数形式的浮点数</td>\n</tr>\n<tr>\n<td><code>%x</code></td>\n<td>%X 无符号以十六进制表示的整数</td>\n</tr>\n<tr>\n<td><code>%o</code></td>\n<td>无符号以八进制表示的整数</td>\n</tr>\n<tr>\n<td><code>%g</code></td>\n<td>自动选择合适的表示法</td>\n</tr>\n</tbody></table>\n<p>示例：打印字符串，转换大小写</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">➜ awk 'BEGIN{str=\"Hello World\";print str \"\\n\" tolower(str) \"\\n\" toupper(str)}'\nHello World\nhello world\nHELLO WORLD</code></pre>\n<p>示例：打印字符串长度，查找指定字串并返回子串索引，匹配正则字串并返回子串索引</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">➜ awk 'BEGIN{str=\"Hello World\";printf(\"len:%d, index:%d, match:%d\\n\",length(str),index(str,\"world\"),match(str,/[wW]orld/))}'\nlen:11, index:0, match:7</code></pre>\n<p>示例：利用split函数，打印字串数组</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">➜ awk 'BEGIN{str=\"this is a test\";split(str,t,\" \");print length(t);for(k in t){print k,t[k];}}'\n4\n4 test\n1 this\n2 is\n3 a</code></pre>\n<h2 id=\"时间函数\"><a href=\"#时间函数\" class=\"headerlink\" title=\"时间函数\"></a>时间函数</h2><table>\n<thead>\n<tr>\n<th><strong>函数名</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>mktime( YYYY MM DD HH MM SS[ DST])</code></td>\n<td>生成时间格式</td>\n</tr>\n<tr>\n<td><code>strftime([format [, timestamp]])</code></td>\n<td>格式化时间输出，将时间戳转为时间字符串具体格式，见下表.</td>\n</tr>\n<tr>\n<td><code>systime()</code></td>\n<td>得到时间戳,返回从1970年1月1日开始到当前时间（不计闰年）的整秒数</td>\n</tr>\n</tbody></table>\n<p>strftime函数format格式化参数转换表</p>\n<table>\n<thead>\n<tr>\n<th>格式</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>%a</code></td>\n<td>星期几的缩写（Sun）</td>\n</tr>\n<tr>\n<td><code>%A</code></td>\n<td>星期几的完整写法（Sunday）</td>\n</tr>\n<tr>\n<td><code>%b</code></td>\n<td>月名的缩写（Oct）</td>\n</tr>\n<tr>\n<td><code>%B</code></td>\n<td>月名的完整写法（October）</td>\n</tr>\n<tr>\n<td><code>%c</code></td>\n<td>本地日期和时间</td>\n</tr>\n<tr>\n<td><code>%d</code></td>\n<td>十进制日期</td>\n</tr>\n<tr>\n<td><code>%D</code></td>\n<td>日期 08/20/99</td>\n</tr>\n<tr>\n<td><code>%e</code></td>\n<td>日期，如果只有一位会补上一个空格</td>\n</tr>\n<tr>\n<td><code>%H</code></td>\n<td>用十进制表示24小时格式的小时</td>\n</tr>\n<tr>\n<td><code>%I</code></td>\n<td>用十进制表示12小时格式的小时</td>\n</tr>\n<tr>\n<td><code>%j</code></td>\n<td>从1月1日起一年中的第几天</td>\n</tr>\n<tr>\n<td><code>%m</code></td>\n<td>十进制表示的月份</td>\n</tr>\n<tr>\n<td><code>%M</code></td>\n<td>十进制表示的分钟</td>\n</tr>\n<tr>\n<td><code>%p</code></td>\n<td>12小时表示法（AM/PM）</td>\n</tr>\n<tr>\n<td><code>%S</code></td>\n<td>十进制表示的秒</td>\n</tr>\n<tr>\n<td><code>%U</code></td>\n<td>十进制表示的一年中的第几个星期（星期天作为一个星期的开始）</td>\n</tr>\n<tr>\n<td><code>%w</code></td>\n<td>十进制表示的星期几（星期天是0）</td>\n</tr>\n<tr>\n<td><code>%W</code></td>\n<td>十进制表示的一年中的第几个星期（星期一作为一个星期的开始）</td>\n</tr>\n<tr>\n<td><code>%x</code></td>\n<td>重新设置本地日期（08/20/99）</td>\n</tr>\n<tr>\n<td><code>%X</code></td>\n<td>重新设置本地时间（12:00:00）</td>\n</tr>\n<tr>\n<td><code>%y</code></td>\n<td>两位数字表示的年（99）</td>\n</tr>\n<tr>\n<td><code>%Y</code></td>\n<td>当前月份</td>\n</tr>\n<tr>\n<td><code>%Z</code></td>\n<td>时区（PDT）</td>\n</tr>\n<tr>\n<td><code>%%</code></td>\n<td>百分号（%）</td>\n</tr>\n</tbody></table>\n<p>示例：获取当前时间，并格式化输出</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">➜ awk 'BEGIN{st=systime();print st, strftime(\"%c %Z\", st)}'\n1576744487 2019年12月19日 星期四 16时34分47秒 CST</code></pre>\n<h1 id=\"进阶\"><a href=\"#进阶\" class=\"headerlink\" title=\"进阶\"></a>进阶</h1><p>awk可以利用类c风格的代码进行简单的程序编写，使之能完成更多的事情。</p>\n<h2 id=\"编程语法\"><a href=\"#编程语法\" class=\"headerlink\" title=\"编程语法\"></a>编程语法</h2><h3 id=\"条件判断\"><a href=\"#条件判断\" class=\"headerlink\" title=\"条件判断\"></a>条件判断</h3><p>awk的条件判断格式是类c风格的</p>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>expression<span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">{</span>\n    statement<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>expression<span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">{</span>\n    statement1<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> \n<span class=\"token keyword\">else</span> \n<span class=\"token punctuation\">{</span>\n    statement2<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>expression1<span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">{</span>\n    statement1<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>expression2<span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">{</span>\n    statement2<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">else</span> \n<span class=\"token punctuation\">{</span>\n    statement3<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h3><p>awk支持while、for和do-while循环，格式也是类c风格的</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">while (expression) \n{\n    statement;\n}\n\n// for-in 输出的var顺序可能不一致\nfor (var in array) \n{\n    statement;\n}\nfor (var; condtion; expression) \n{\n    statement;\n}\n\ndo \n{\n    statement;\n} while (expression);</code></pre>\n<p>同时awk也支持退出循环</p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>break</td>\n<td>当 break 语句用于 while 或 for 语句时，导致退出程序循环。</td>\n</tr>\n<tr>\n<td>continue</td>\n<td>当 continue 语句用于 while 或 for 语句时，使程序循环移动到下一个迭代。</td>\n</tr>\n<tr>\n<td>next</td>\n<td>能能够导致读入下一个输入行，并返回到脚本的顶部。这可以避免对当前输入行执行其他的操作过程。</td>\n</tr>\n<tr>\n<td>exit</td>\n<td>语句使主输入循环退出并将控制转移到END,如果END存在的话。如果没有定义END规则，或在END中应用exit语句，则终止脚本的执行。</td>\n</tr>\n</tbody></table>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><p>awk数组支持数字下标和字符串下标，底层是哈希表，所以每次遍历不能保证都是相同顺序。<br>示例：</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">array_name[key]=value</code></pre>\n<ul>\n<li>array_name：数组的名称</li>\n<li>key：数组索引</li>\n<li>value：数组中元素所赋予的值</li>\n</ul>\n<h3 id=\"添加元素\"><a href=\"#添加元素\" class=\"headerlink\" title=\"添加元素\"></a>添加元素</h3><p>awk可以直接声明元素key-value对<br>示例：</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">➜ awk 'BEGIN{keys[1]=2;keys[\"start\"]=\"start\";print keys[1], keys[\"start\"]}'\n2 start</code></pre>\n<h3 id=\"删除元素\"><a href=\"#删除元素\" class=\"headerlink\" title=\"删除元素\"></a>删除元素</h3><p>使用delete可以删除数组的元素<br>示例：删除key为1的值，最后打印keys[1]的值为空字符串</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">➜ awk 'BEGIN{keys[1]=2;keys[\"start\"]=\"start\";delete keys[1];print keys[1], keys[\"start\"]}'\n start</code></pre>\n<h3 id=\"二维数组\"><a href=\"#二维数组\" class=\"headerlink\" title=\"二维数组\"></a>二维数组</h3><p>awk 多维数组在本质上是一维数组，因awk在存储上并不支持多维数组，awk提供了逻辑上模拟二维数组的访问方式。例如，array[2,3] = 1这样的访问是允许的。<br>awk使用一个特殊的字符串SUBSEP （<code>\\034</code>）作为分割字段，在上面的例子 array[2,3] = 1 中，关联数组array存储的键值实际上是2<code>\\034</code>3，2和3分别为下标（2，3），<code>\\034</code>为SUBSEP分隔符。<br>示例：</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">➜ awk 'BEGIN{a[1,1]=1;a[\"1,1\"]=2;a[11]=3;for(i in a){print i,a[i]}}'\n1,1 2\n11 3\n11 1</code></pre>\n<h3 id=\"数组排序\"><a href=\"#数组排序\" class=\"headerlink\" title=\"数组排序\"></a>数组排序</h3><p>asort对数组array按照首字母进行排序，返回数组长度。如果要得到数组原本顺序，需要使用数组下标依次访问。<br>for-in 输出关联数组的顺序是无序的，所以通过for-in 得到是无序的数组。如果需要得到有序数组，需要通过下标获得。<br>示例：</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">➜ awk 'BEGIN{str=\"it is a test\";l=split(str,array,\" \");for(i in array){print i,array[i];};asort(array);for(i in array){print i,array[i;}}'\n4 test\n1 it\n2 is\n3 a\n4 test\n1 a\n2 is\n3 it</code></pre>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><p>一个程序包含有多个功能，每个功能我们可以独立一个函数，函数可以提高代码的复用性。用户自定义函数的语法格式为：</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">function function_name(argument1, argument2,  ...)\n{\n  function body \n}</code></pre>\n<p><strong>解析：</strong></p>\n<ul>\n<li><strong>function_name</strong> 是用户自定义函数的名称。函数名称应该以字母开头，其后可以是数字、字母或下划线的自由组合。AWK 保留的关键字不能作为用户自定义函数的名称。</li>\n<li>自定义函数可以接受多个输入参数，这些参数之间通过逗号分隔。参数并不是必须的。我们也可以定义没有任何输入参数的函数。</li>\n<li><strong>function body</strong> 是函数体部分，它包含 AWK 程序代码。</li>\n</ul>\n<p>示例：写一个求和函数</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">➜ awk 'function sum(n1,n2){return n1+n2}BEGIN{print sum(1,2)}'\n3</code></pre>\n<p>如果函数比较复杂，我们可以写成一个文件的形式来执行awk。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\"># 返回最小值\nfunction find_min(num1, num2)\n{\n  if (num1 < num2)\n    return num1\n  return num2\n}\n\n# 返回最大值\nfunction find_max(num1, num2)\n{\n  if (num1 > num2)\n    return num1\n  return num2\n}\n\n# 主函数\nfunction main(num1, num2)\n{\n  # 查找最小值\n  result = find_min(10, 20)\n  print \"Minimum =\", result\n\n  # 查找最大值\n  result = find_max(10, 20)\n  print \"Maximum =\", result\n}\n\n# 脚本从这里开始执行\nBEGIN {\n  main(10, 20)\n}</code></pre>\n<p>执行可以得到</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">Minimum = 10\nMaximum = 20</code></pre>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/AWK\" target=\"_blank\" rel=\"noopener\">维基百科</a></li>\n<li><a href=\"https://www.runoob.com/linux/linux-comm-awk.html\" target=\"_blank\" rel=\"noopener\">菜鸟教程</a></li>\n</ul>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"friends":[{"avatar":"https://img-1251474779.cos.ap-beijing.myqcloud.com/icon.png","name":"djaigo","introduction":"好好学习，天天向上","url":"/","title":"前去学习"},{"avatar":"https://awps-assets.meituan.net/mit/blog/v20190629/asset/icon/favicon.ico?v=Whistle&t=20181017-1r","name":"美团技术团队","introduction":"一行代码，亿万生活。","url":"https://tech.meituan.com/","title":"点个外卖-->"},{"avatar":"","name":"鸟窝","introduction":"rpcx作者","url":"https://colobu.com/","title":"进个鸟窝-->"},{"avatar":"https://d1j8pt39hxlh3d.cloudfront.net/emoji/emojione/5.0/png/unicode/32/1f92a.png","name":"labuladong的算法小抄","introduction":"算法大神","url":"https://labuladong.gitbook.io/algo/","title":"学个算法-->"}]}},"excerpt":"","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>awk是一个强大的文本处理和文本分析工具，不仅可以通过行为单位处理文本，还可以通过列为单位处理文本，默认行分隔符是换行符，默认列分隔符是连续空格和Tab，可以定义分隔符。awk提供了极其强大的功能：可以进行正则表达式的匹配，样式装入、流控制、数学运算符、进程控制语句甚至于内置的变量和函数。<br>获取帮助信息，gawk是awk的GNU版本</p>\n<pre><code class=\"sh\">➜ awk --help\nUsage: awk [POSIX or GNU style options] -f progfile [--] file ...\nUsage: awk [POSIX or GNU style options] [--] &#39;program&#39; file ...\nPOSIX options:        GNU long options: (standard)\n    -f progfile        --file=progfile\n    -F fs            --field-separator=fs\n    -v var=val        --assign=var=val\nShort options:        GNU long options: (extensions)\n    -b            --characters-as-bytes\n    -c            --traditional\n    -C            --copyright\n    -d[file]        --dump-variables[=file]\n    -e &#39;program-text&#39;    --source=&#39;program-text&#39;\n    -E file            --exec=file\n    -g            --gen-pot\n    -h            --help\n    -L [fatal]        --lint[=fatal]\n    -n            --non-decimal-data\n    -N            --use-lc-numeric\n    -O            --optimize\n    -p[file]        --profile[=file]\n    -P            --posix\n    -r            --re-interval\n    -S            --sandbox\n    -t            --lint-old\n    -V            --version\n\nTo report bugs, see node `Bugs&#39; in `gawk.info&#39;, which is\nsection `Reporting Problems and Bugs&#39; in the printed version.\n\ngawk is a pattern scanning and processing language.\nBy default it reads standard input and writes standard output.\n\nExamples:\n    gawk &#39;{ sum += $1 }; END { print sum }&#39; file\n    gawk -F: &#39;{ print $1 }&#39; /etc/passwd</code></pre>\n<h1 id=\"执行方式\"><a href=\"#执行方式\" class=\"headerlink\" title=\"执行方式\"></a>执行方式</h1><p>awk命令行的基本执行形式为：</p>\n<pre><code class=\"sh\">awk option &#39;script&#39; file1 file2 ...\nawk option -f scriptfile file1 file2 ...</code></pre>\n<p>awk的操作对象既可以是文本文件，也可以是标准输入重定向得到，亦或是命令行参数传入。</p>\n<h2 id=\"命令行参数\"><a href=\"#命令行参数\" class=\"headerlink\" title=\"命令行参数\"></a>命令行参数</h2><p>常用命令行参数说明：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-f</td>\n<td>执行awk脚本文件路径</td>\n</tr>\n<tr>\n<td>-F</td>\n<td>输入域分隔符</td>\n</tr>\n<tr>\n<td>-v</td>\n<td>传入shell变量</td>\n</tr>\n<tr>\n<td>-b</td>\n<td>字符按照字节区分</td>\n</tr>\n<tr>\n<td>-h</td>\n<td>帮助文档</td>\n</tr>\n<tr>\n<td>-V</td>\n<td>显示版本</td>\n</tr>\n</tbody></table>\n<h2 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h2><p>script一般格式为<code>/pattern/{actions}</code>，pattern表示正则表达式，actions表示一系列操作。awk利用正则表达式pattern匹配出需要执行actions的行，如果没有pattern表示每一行都执行actions。</p>\n<p>示例：打印所有行</p>\n<pre><code class=\"sh\">➜ seq 20 | awk &#39;{print $1}&#39;\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20</code></pre>\n<p>示例：打印包含1的行</p>\n<pre><code>➜ seq 20 | awk &#39;/1/{print $1}&#39;\n1\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19</code></pre><p>print表示打印；<code>$1</code>表示第一列，<code>$2</code>表示第二列，以此类推，<code>$0</code>表示当前行。</p>\n<p>awk利用运算符<code>~</code>表示符合正则运算，<code>!~</code>表示不符合正则运算。<br>示例：</p>\n<pre><code class=\"sh\">➜ seq 20 | awk &#39;$1 !~ /1/{print $1}&#39;            \n2\n3\n4\n5\n6\n7\n8\n9\n20</code></pre>\n<h2 id=\"数学运算\"><a href=\"#数学运算\" class=\"headerlink\" title=\"数学运算\"></a>数学运算</h2><p>awk支持使用数学条件筛选，支持运算符表格：</p>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>= += -= *= /= %= ^= **=</code></td>\n<td>赋值</td>\n</tr>\n<tr>\n<td><code>?:</code></td>\n<td>C条件表达式</td>\n</tr>\n<tr>\n<td><code>||</code></td>\n<td>逻辑或</td>\n</tr>\n<tr>\n<td><code>&amp;&amp;</code></td>\n<td>逻辑与</td>\n</tr>\n<tr>\n<td><code>~</code> 和 <code>!~</code></td>\n<td>匹配正则表达式和不匹配正则表达式</td>\n</tr>\n<tr>\n<td><code>&lt; &lt;= &gt; &gt;= != ==</code></td>\n<td>关系运算符</td>\n</tr>\n<tr>\n<td>空格</td>\n<td>连接</td>\n</tr>\n<tr>\n<td><code>+ -</code></td>\n<td>加，减</td>\n</tr>\n<tr>\n<td><code>* / %</code></td>\n<td>乘，除与求余</td>\n</tr>\n<tr>\n<td><code>+ - !</code></td>\n<td>一元加，减和逻辑非</td>\n</tr>\n<tr>\n<td><code>^ ***</code></td>\n<td>求幂</td>\n</tr>\n<tr>\n<td><code>++ --</code></td>\n<td>增加或减少，作为前缀或后缀</td>\n</tr>\n<tr>\n<td><code>$</code></td>\n<td>字段引用</td>\n</tr>\n<tr>\n<td><code>in</code></td>\n<td>数组成员</td>\n</tr>\n</tbody></table>\n<p>示例：1-20中筛选大于10的偶数</p>\n<pre><code class=\"sh\">➜ seq 20 | awk &#39;$1%2==0&amp;&amp;$1&gt;=10{print $1,&quot;Y&quot;}&#39;\n10 Y\n12 Y\n14 Y\n16 Y\n18 Y\n20 Y</code></pre>\n<p>awk还支持算术函数</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">函数名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>atan2( y, x )</code></td>\n<td>返回 y/x 的反正切。</td>\n</tr>\n<tr>\n<td align=\"center\"><code>cos( x )</code></td>\n<td>返回 x 的余弦；x 是弧度。</td>\n</tr>\n<tr>\n<td align=\"center\"><code>sin( x )</code></td>\n<td>返回 x 的正弦；x 是弧度。</td>\n</tr>\n<tr>\n<td align=\"center\"><code>exp( x )</code></td>\n<td>返回 x 幂函数。</td>\n</tr>\n<tr>\n<td align=\"center\"><code>log( x )</code></td>\n<td>返回 x 的自然对数。</td>\n</tr>\n<tr>\n<td align=\"center\"><code>sqrt( x )</code></td>\n<td>返回 x 平方根。</td>\n</tr>\n<tr>\n<td align=\"center\"><code>int( x )</code></td>\n<td>返回 x 的截断至整数的值。</td>\n</tr>\n<tr>\n<td align=\"center\"><code>rand()</code></td>\n<td>返回任意数字 n，其中 0 &lt;= n &lt; 1。</td>\n</tr>\n<tr>\n<td align=\"center\"><code>srand([Expr])</code></td>\n<td>将rand函数的种子值设置为Expr参数的值，或如果省略Expr参数则使用某天的时间。返回先前的种子值。</td>\n</tr>\n</tbody></table>\n<p>示例：打印$e^{$1}$，上次随机数种子，随机数</p>\n<pre><code>➜ seq 20 | awk &#39;{print exp($1), srand($1), rand()}&#39;\n2.71828 0 0.840188\n7.38906 1 0.700976\n20.0855 2 0.56138\n54.5982 3 0.916458\n148.413 4 0.274746\n403.429 5 0.135439\n1096.63 6 0.486904\n2980.96 7 0.352761\n8103.08 8 0.206965\n22026.5 9 0.565811\n59874.1 10 0.926345\n162755 11 0.7856\n442413 12 0.632643\n1.2026e+06 13 0.999498\n3.26902e+06 14 0.354973\n8.88611e+06 15 0.215437\n2.4155e+07 16 0.571794\n6.566e+07 17 0.929073\n1.78482e+08 18 0.290233\n4.85165e+08 19 0.148812</code></pre><h2 id=\"BEGIN-END\"><a href=\"#BEGIN-END\" class=\"headerlink\" title=\"BEGIN-END\"></a>BEGIN-END</h2><p>awk有两个特殊的条件，对待每个处理的文件，BEGIN后面的actions在执行整个文件<strong>之前</strong>执行一次，END后面的actions在执行整个文件<strong>之后</strong>执行一次。awk可以像c一样使用使用变量，但是不需要定义变量。<br>示例：</p>\n<pre><code class=\"sh\">➜ seq 20 | awk  &#39;/1/{x=x+1;}END{print x}&#39;   \n11\n\n➜ seq 20 | awk &#39;BEGIN{x=100}/1/{x=x+1;}END{print x}&#39; \n111</code></pre>\n<h2 id=\"内建变量\"><a href=\"#内建变量\" class=\"headerlink\" title=\"内建变量\"></a>内建变量</h2><table>\n<thead>\n<tr>\n<th>变量</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>$n</code></td>\n<td>当前记录的第n个字段，字段间由FS分隔</td>\n</tr>\n<tr>\n<td><code>$0</code></td>\n<td>完整的输入记录</td>\n</tr>\n<tr>\n<td><code>ARGC</code></td>\n<td>命令行参数的数目</td>\n</tr>\n<tr>\n<td><code>ARGIND</code></td>\n<td>命令行中当前文件的位置(从0开始算)</td>\n</tr>\n<tr>\n<td><code>ARGV</code></td>\n<td>包含命令行参数的数组</td>\n</tr>\n<tr>\n<td><code>CONVFMT</code></td>\n<td>数字转换格式(默认值为%.6g)ENVIRON环境变量关联数组</td>\n</tr>\n<tr>\n<td><code>ERRNO</code></td>\n<td>最后一个系统错误的描述</td>\n</tr>\n<tr>\n<td><code>FIELDWIDTHS</code></td>\n<td>字段宽度列表(用空格键分隔)</td>\n</tr>\n<tr>\n<td><code>FILENAME</code></td>\n<td>当前文件名</td>\n</tr>\n<tr>\n<td><code>FNR</code></td>\n<td>各文件分别计数的行号</td>\n</tr>\n<tr>\n<td><code>FS</code></td>\n<td>字段分隔符(默认是任何空格)</td>\n</tr>\n<tr>\n<td><code>IGNORECASE</code></td>\n<td>如果为真，则进行忽略大小写的匹配</td>\n</tr>\n<tr>\n<td><code>NF</code></td>\n<td>一条记录的字段的数目</td>\n</tr>\n<tr>\n<td><code>NR</code></td>\n<td>已经读出的记录数，就是行号，从1开始</td>\n</tr>\n<tr>\n<td><code>OFMT</code></td>\n<td>数字的输出格式(默认值是%.6g)</td>\n</tr>\n<tr>\n<td><code>OFS</code></td>\n<td>print函数输出字段分隔符（输出空格），输出时用指定的符号代替分隔符</td>\n</tr>\n<tr>\n<td><code>ORS</code></td>\n<td>输出记录分隔符(默认值是一个换行符)</td>\n</tr>\n<tr>\n<td><code>RLENGTH</code></td>\n<td>由match函数所匹配的字符串的长度</td>\n</tr>\n<tr>\n<td><code>RS</code></td>\n<td>记录分隔符(默认是一个换行符)</td>\n</tr>\n<tr>\n<td><code>RSTART</code></td>\n<td>由match函数所匹配的字符串的第一个位置</td>\n</tr>\n<tr>\n<td><code>SUBSEP</code></td>\n<td>数组下标分隔符(默认值是/034)</td>\n</tr>\n</tbody></table>\n<p>示例：打印最后一列，并打印当前行数</p>\n<pre><code class=\"sh\">➜ seq 20 | sort | awk &#39;{print $NF &quot;\\t&quot; NR}&#39;\n1    1\n10    2\n11    3\n12    4\n13    5\n14    6\n15    7\n16    8\n17    9\n18    10\n19    11\n2    12\n20    13\n3    14\n4    15\n5    16\n6    17\n7    18\n8    19\n9    20</code></pre>\n<p>示例：替换输出分隔符和换行符</p>\n<pre><code class=\"sh\">➜ echo &quot;this is a test\\nthis is a test&quot; | awk &#39;BEGIN{OFS=&quot;_&quot;;ORS=&quot;--&quot;}{print $1,$2,$3,$4}&#39;\nthis_is_a_test--this_is_a_test--</code></pre>\n<h2 id=\"一般函数\"><a href=\"#一般函数\" class=\"headerlink\" title=\"一般函数\"></a>一般函数</h2><table>\n<thead>\n<tr>\n<th><strong>函数</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>close( Expression )</code></td>\n<td>用同一个带字符串值的 Expression 参数来关闭由 print 或 printf 语句打开的或调用 getline 函数打开的文件或管道。如果文件或管道成功关闭，则返回 0；其它情况下返回非零值。如果打算写一个文件，并稍后在同一个程序中读取文件，则 close 语句是必需的。</td>\n</tr>\n<tr>\n<td><code>system(Command )</code></td>\n<td>执行 Command 参数指定的命令，并返回退出状态。</td>\n</tr>\n<tr>\n<td><code>Expression | getline [ Variable ]</code></td>\n<td>从来自 Expression 参数指定的命令的输出中通过管道传送的流中读取一个输入记录，并将该记录的值指定给 Variable 参数指定的变量。如果当前未打开将 Expression 参数的值作为其命令名称的流，则创建流。此时 Command 参数取 Expression 参数的值且 Mode 参数设置为一个是 r 的值。只要流保留打开且 Expression 参数求得同一个字符串，则对 getline 函数的每次后续调用读取另一个记录。如果未指定 Variable 参数，则 $0 记录变量和 NF 特殊变量设置为从流读取的记录。</td>\n</tr>\n<tr>\n<td><code>getline [ Variable ] &lt; Expression</code></td>\n<td>从 Expression 参数指定的文件读取输入的下一个记录，并将 Variable 参数指定的变量设置为该记录的值。只要流保留打开且 Expression 参数对同一个字符串求值，则对 getline 函数的每次后续调用读取另一个记录。如果未指定 Variable 参数，则 $0 记录变量和 NF 特殊变量设置为从流读取的记录。</td>\n</tr>\n<tr>\n<td><code>getline [ Variable ]</code></td>\n<td>将 Variable 参数指定的变量设置为从当前输入文件读取的下一个输入记录。如果未指定 Variable 参数，则 $0 记录变量设置为该记录的值，还将设置 NF、NR 和 FNR 特殊变量。</td>\n</tr>\n</tbody></table>\n<p>示例：通过system函数执行shell语句，最后0表示Errno</p>\n<pre><code class=\"sh\">➜ awk &#39;BEGIN{print system(&quot;ps -ef | grep awk&quot;)}&#39;\nroot      6490 10366  0 17:16 pts/0    00:00:00 awk BEGIN{print system(&quot;ps -ef | grep awk&quot;)}\nroot      6491  6490  0 17:16 pts/0    00:00:00 sh -c ps -ef | grep awk\nroot      6493  6491  0 17:16 pts/0    00:00:00 grep awk\n0</code></pre>\n<h2 id=\"字符串函数\"><a href=\"#字符串函数\" class=\"headerlink\" title=\"字符串函数\"></a>字符串函数</h2><p>awk还有内置字符串函数</p>\n<table>\n<thead>\n<tr>\n<th><strong>函数</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>gsub( Ere, Repl, [ In ] )</code></td>\n<td>除了正则表达式所有具体值被替代这点，它和 sub 函数完全一样地执行。</td>\n</tr>\n<tr>\n<td><code>sub( Ere, Repl, [ In ] )</code></td>\n<td>用 Repl 参数指定的字符串替换 In 参数指定的字符串中的由 Ere 参数指定的扩展正则表达式的第一个具体值。sub 函数返回替换的数量。出现在 Repl 参数指定的字符串中的 &amp;（和符号）由 In 参数指定的与 Ere 参数的指定的扩展正则表达式匹配的字符串替换。如果未指定 In 参数，缺省值是整个记录（$0 记录变量）。</td>\n</tr>\n<tr>\n<td><code>index( String1, String2 )</code></td>\n<td>在由 String1 参数指定的字符串（其中有出现 String2 指定的参数）中，返回位置，从 1 开始编号。如果 String2 参数不在 String1 参数中出现，则返回 0（零）。</td>\n</tr>\n<tr>\n<td><code>length [(String)]</code></td>\n<td>返回 String 参数指定的字符串的长度（字符形式）。如果未给出 String 参数，则返回整个记录的长度（$0 记录变量）。</td>\n</tr>\n<tr>\n<td><code>substr( String, M, [ N ] )</code></td>\n<td>返回具有 N 参数指定的字符数量子串。子串从 String 参数指定的字符串取得，其字符以 M 参数指定的位置开始。M 参数指定为将 String 参数中的第一个字符作为编号 1。如果未指定 N 参数，则子串的长度将是 M 参数指定的位置到 String 参数的末尾 的长度。</td>\n</tr>\n<tr>\n<td><code>match( String, Ere )</code></td>\n<td>在 String 参数指定的字符串（Ere 参数指定的扩展正则表达式出现在其中）中返回位置（字符形式），从 1 开始编号，或如果 Ere 参数不出现，则返回 0（零）。RSTART 特殊变量设置为返回值。RLENGTH 特殊变量设置为匹配的字符串的长度，或如果未找到任何匹配，则设置为 -1（负一）。</td>\n</tr>\n<tr>\n<td><code>split( String, A, [Ere] )</code></td>\n<td>将 String 参数指定的参数分割为数组元素 <code>A[1], A[2], . . ., A[n]</code>，并返回 n 变量的值。此分隔可以通过 Ere 参数指定的扩展正则表达式进行，或用当前字段分隔符（FS 特殊变量）来进行（如果没有给出 Ere 参数）。除非上下文指明特定的元素还应具有一个数字值，否则 A 数组中的元素用字符串值来创建。</td>\n</tr>\n<tr>\n<td><code>tolower( String )</code></td>\n<td>返回 String 参数指定的字符串，字符串中每个大写字符将更改为小写。大写和小写的映射由当前语言环境的 LC_CTYPE 范畴定义。</td>\n</tr>\n<tr>\n<td><code>toupper( String )</code></td>\n<td>返回 String 参数指定的字符串，字符串中每个小写字符将更改为大写。大写和小写的映射由当前语言环境的 LC_CTYPE 范畴定义。</td>\n</tr>\n<tr>\n<td><code>printf(Format, Expr, Expr, . . . )</code></td>\n<td>根据 Format 参数指定的格式字符串来格式化 Expr 参数指定的表达式并返回最后生成的字符串。</td>\n</tr>\n</tbody></table>\n<p>sprintf函数format格式化参数转换表</p>\n<table>\n<thead>\n<tr>\n<th><strong>格式符</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>%d</code></td>\n<td>十进制有符号整数</td>\n</tr>\n<tr>\n<td><code>%u</code></td>\n<td>十进制无符号整数</td>\n</tr>\n<tr>\n<td><code>%f</code></td>\n<td>浮点数</td>\n</tr>\n<tr>\n<td><code>%s</code></td>\n<td>字符串</td>\n</tr>\n<tr>\n<td><code>%c</code></td>\n<td>单个字符</td>\n</tr>\n<tr>\n<td><code>%p</code></td>\n<td>指针的值</td>\n</tr>\n<tr>\n<td><code>%e</code></td>\n<td>指数形式的浮点数</td>\n</tr>\n<tr>\n<td><code>%x</code></td>\n<td>%X 无符号以十六进制表示的整数</td>\n</tr>\n<tr>\n<td><code>%o</code></td>\n<td>无符号以八进制表示的整数</td>\n</tr>\n<tr>\n<td><code>%g</code></td>\n<td>自动选择合适的表示法</td>\n</tr>\n</tbody></table>\n<p>示例：打印字符串，转换大小写</p>\n<pre><code class=\"sh\">➜ awk &#39;BEGIN{str=&quot;Hello World&quot;;print str &quot;\\n&quot; tolower(str) &quot;\\n&quot; toupper(str)}&#39;\nHello World\nhello world\nHELLO WORLD</code></pre>\n<p>示例：打印字符串长度，查找指定字串并返回子串索引，匹配正则字串并返回子串索引</p>\n<pre><code class=\"sh\">➜ awk &#39;BEGIN{str=&quot;Hello World&quot;;printf(&quot;len:%d, index:%d, match:%d\\n&quot;,length(str),index(str,&quot;world&quot;),match(str,/[wW]orld/))}&#39;\nlen:11, index:0, match:7</code></pre>\n<p>示例：利用split函数，打印字串数组</p>\n<pre><code class=\"sh\">➜ awk &#39;BEGIN{str=&quot;this is a test&quot;;split(str,t,&quot; &quot;);print length(t);for(k in t){print k,t[k];}}&#39;\n4\n4 test\n1 this\n2 is\n3 a</code></pre>\n<h2 id=\"时间函数\"><a href=\"#时间函数\" class=\"headerlink\" title=\"时间函数\"></a>时间函数</h2><table>\n<thead>\n<tr>\n<th><strong>函数名</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>mktime( YYYY MM DD HH MM SS[ DST])</code></td>\n<td>生成时间格式</td>\n</tr>\n<tr>\n<td><code>strftime([format [, timestamp]])</code></td>\n<td>格式化时间输出，将时间戳转为时间字符串具体格式，见下表.</td>\n</tr>\n<tr>\n<td><code>systime()</code></td>\n<td>得到时间戳,返回从1970年1月1日开始到当前时间（不计闰年）的整秒数</td>\n</tr>\n</tbody></table>\n<p>strftime函数format格式化参数转换表</p>\n<table>\n<thead>\n<tr>\n<th>格式</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>%a</code></td>\n<td>星期几的缩写（Sun）</td>\n</tr>\n<tr>\n<td><code>%A</code></td>\n<td>星期几的完整写法（Sunday）</td>\n</tr>\n<tr>\n<td><code>%b</code></td>\n<td>月名的缩写（Oct）</td>\n</tr>\n<tr>\n<td><code>%B</code></td>\n<td>月名的完整写法（October）</td>\n</tr>\n<tr>\n<td><code>%c</code></td>\n<td>本地日期和时间</td>\n</tr>\n<tr>\n<td><code>%d</code></td>\n<td>十进制日期</td>\n</tr>\n<tr>\n<td><code>%D</code></td>\n<td>日期 08/20/99</td>\n</tr>\n<tr>\n<td><code>%e</code></td>\n<td>日期，如果只有一位会补上一个空格</td>\n</tr>\n<tr>\n<td><code>%H</code></td>\n<td>用十进制表示24小时格式的小时</td>\n</tr>\n<tr>\n<td><code>%I</code></td>\n<td>用十进制表示12小时格式的小时</td>\n</tr>\n<tr>\n<td><code>%j</code></td>\n<td>从1月1日起一年中的第几天</td>\n</tr>\n<tr>\n<td><code>%m</code></td>\n<td>十进制表示的月份</td>\n</tr>\n<tr>\n<td><code>%M</code></td>\n<td>十进制表示的分钟</td>\n</tr>\n<tr>\n<td><code>%p</code></td>\n<td>12小时表示法（AM/PM）</td>\n</tr>\n<tr>\n<td><code>%S</code></td>\n<td>十进制表示的秒</td>\n</tr>\n<tr>\n<td><code>%U</code></td>\n<td>十进制表示的一年中的第几个星期（星期天作为一个星期的开始）</td>\n</tr>\n<tr>\n<td><code>%w</code></td>\n<td>十进制表示的星期几（星期天是0）</td>\n</tr>\n<tr>\n<td><code>%W</code></td>\n<td>十进制表示的一年中的第几个星期（星期一作为一个星期的开始）</td>\n</tr>\n<tr>\n<td><code>%x</code></td>\n<td>重新设置本地日期（08/20/99）</td>\n</tr>\n<tr>\n<td><code>%X</code></td>\n<td>重新设置本地时间（12:00:00）</td>\n</tr>\n<tr>\n<td><code>%y</code></td>\n<td>两位数字表示的年（99）</td>\n</tr>\n<tr>\n<td><code>%Y</code></td>\n<td>当前月份</td>\n</tr>\n<tr>\n<td><code>%Z</code></td>\n<td>时区（PDT）</td>\n</tr>\n<tr>\n<td><code>%%</code></td>\n<td>百分号（%）</td>\n</tr>\n</tbody></table>\n<p>示例：获取当前时间，并格式化输出</p>\n<pre><code class=\"sh\">➜ awk &#39;BEGIN{st=systime();print st, strftime(&quot;%c %Z&quot;, st)}&#39;\n1576744487 2019年12月19日 星期四 16时34分47秒 CST</code></pre>\n<h1 id=\"进阶\"><a href=\"#进阶\" class=\"headerlink\" title=\"进阶\"></a>进阶</h1><p>awk可以利用类c风格的代码进行简单的程序编写，使之能完成更多的事情。</p>\n<h2 id=\"编程语法\"><a href=\"#编程语法\" class=\"headerlink\" title=\"编程语法\"></a>编程语法</h2><h3 id=\"条件判断\"><a href=\"#条件判断\" class=\"headerlink\" title=\"条件判断\"></a>条件判断</h3><p>awk的条件判断格式是类c风格的</p>\n<pre><code class=\"c\">if (expression) \n{\n    statement;\n    ...\n}\n\nif (expression) \n{\n    statement1;\n} \nelse \n{\n    statement2;\n}\n\nif (expression1) \n{\n    statement1;\n}\nelse if (expression2) \n{\n    statement2;\n}\nelse \n{\n    statement3;\n}</code></pre>\n<h3 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h3><p>awk支持while、for和do-while循环，格式也是类c风格的</p>\n<pre><code class=\"sh\">while (expression) \n{\n    statement;\n}\n\n// for-in 输出的var顺序可能不一致\nfor (var in array) \n{\n    statement;\n}\nfor (var; condtion; expression) \n{\n    statement;\n}\n\ndo \n{\n    statement;\n} while (expression);</code></pre>\n<p>同时awk也支持退出循环</p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>break</td>\n<td>当 break 语句用于 while 或 for 语句时，导致退出程序循环。</td>\n</tr>\n<tr>\n<td>continue</td>\n<td>当 continue 语句用于 while 或 for 语句时，使程序循环移动到下一个迭代。</td>\n</tr>\n<tr>\n<td>next</td>\n<td>能能够导致读入下一个输入行，并返回到脚本的顶部。这可以避免对当前输入行执行其他的操作过程。</td>\n</tr>\n<tr>\n<td>exit</td>\n<td>语句使主输入循环退出并将控制转移到END,如果END存在的话。如果没有定义END规则，或在END中应用exit语句，则终止脚本的执行。</td>\n</tr>\n</tbody></table>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><p>awk数组支持数字下标和字符串下标，底层是哈希表，所以每次遍历不能保证都是相同顺序。<br>示例：</p>\n<pre><code class=\"sh\">array_name[key]=value</code></pre>\n<ul>\n<li>array_name：数组的名称</li>\n<li>key：数组索引</li>\n<li>value：数组中元素所赋予的值</li>\n</ul>\n<h3 id=\"添加元素\"><a href=\"#添加元素\" class=\"headerlink\" title=\"添加元素\"></a>添加元素</h3><p>awk可以直接声明元素key-value对<br>示例：</p>\n<pre><code class=\"sh\">➜ awk &#39;BEGIN{keys[1]=2;keys[&quot;start&quot;]=&quot;start&quot;;print keys[1], keys[&quot;start&quot;]}&#39;\n2 start</code></pre>\n<h3 id=\"删除元素\"><a href=\"#删除元素\" class=\"headerlink\" title=\"删除元素\"></a>删除元素</h3><p>使用delete可以删除数组的元素<br>示例：删除key为1的值，最后打印keys[1]的值为空字符串</p>\n<pre><code class=\"sh\">➜ awk &#39;BEGIN{keys[1]=2;keys[&quot;start&quot;]=&quot;start&quot;;delete keys[1];print keys[1], keys[&quot;start&quot;]}&#39;\n start</code></pre>\n<h3 id=\"二维数组\"><a href=\"#二维数组\" class=\"headerlink\" title=\"二维数组\"></a>二维数组</h3><p>awk 多维数组在本质上是一维数组，因awk在存储上并不支持多维数组，awk提供了逻辑上模拟二维数组的访问方式。例如，array[2,3] = 1这样的访问是允许的。<br>awk使用一个特殊的字符串SUBSEP （<code>\\034</code>）作为分割字段，在上面的例子 array[2,3] = 1 中，关联数组array存储的键值实际上是2<code>\\034</code>3，2和3分别为下标（2，3），<code>\\034</code>为SUBSEP分隔符。<br>示例：</p>\n<pre><code class=\"sh\">➜ awk &#39;BEGIN{a[1,1]=1;a[&quot;1,1&quot;]=2;a[11]=3;for(i in a){print i,a[i]}}&#39;\n1,1 2\n11 3\n11 1</code></pre>\n<h3 id=\"数组排序\"><a href=\"#数组排序\" class=\"headerlink\" title=\"数组排序\"></a>数组排序</h3><p>asort对数组array按照首字母进行排序，返回数组长度。如果要得到数组原本顺序，需要使用数组下标依次访问。<br>for-in 输出关联数组的顺序是无序的，所以通过for-in 得到是无序的数组。如果需要得到有序数组，需要通过下标获得。<br>示例：</p>\n<pre><code class=\"sh\">➜ awk &#39;BEGIN{str=&quot;it is a test&quot;;l=split(str,array,&quot; &quot;);for(i in array){print i,array[i];};asort(array);for(i in array){print i,array[i;}}&#39;\n4 test\n1 it\n2 is\n3 a\n4 test\n1 a\n2 is\n3 it</code></pre>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><p>一个程序包含有多个功能，每个功能我们可以独立一个函数，函数可以提高代码的复用性。用户自定义函数的语法格式为：</p>\n<pre><code class=\"sh\">function function_name(argument1, argument2,  ...)\n{\n  function body \n}</code></pre>\n<p><strong>解析：</strong></p>\n<ul>\n<li><strong>function_name</strong> 是用户自定义函数的名称。函数名称应该以字母开头，其后可以是数字、字母或下划线的自由组合。AWK 保留的关键字不能作为用户自定义函数的名称。</li>\n<li>自定义函数可以接受多个输入参数，这些参数之间通过逗号分隔。参数并不是必须的。我们也可以定义没有任何输入参数的函数。</li>\n<li><strong>function body</strong> 是函数体部分，它包含 AWK 程序代码。</li>\n</ul>\n<p>示例：写一个求和函数</p>\n<pre><code class=\"sh\">➜ awk &#39;function sum(n1,n2){return n1+n2}BEGIN{print sum(1,2)}&#39;\n3</code></pre>\n<p>如果函数比较复杂，我们可以写成一个文件的形式来执行awk。</p>\n<pre><code class=\"sh\"># 返回最小值\nfunction find_min(num1, num2)\n{\n  if (num1 &lt; num2)\n    return num1\n  return num2\n}\n\n# 返回最大值\nfunction find_max(num1, num2)\n{\n  if (num1 &gt; num2)\n    return num1\n  return num2\n}\n\n# 主函数\nfunction main(num1, num2)\n{\n  # 查找最小值\n  result = find_min(10, 20)\n  print &quot;Minimum =&quot;, result\n\n  # 查找最大值\n  result = find_max(10, 20)\n  print &quot;Maximum =&quot;, result\n}\n\n# 脚本从这里开始执行\nBEGIN {\n  main(10, 20)\n}</code></pre>\n<p>执行可以得到</p>\n<pre><code class=\"sh\">Minimum = 10\nMaximum = 20</code></pre>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/AWK\" target=\"_blank\" rel=\"noopener\">维基百科</a></li>\n<li><a href=\"https://www.runoob.com/linux/linux-comm-awk.html\" target=\"_blank\" rel=\"noopener\">菜鸟教程</a></li>\n</ul>\n"},{"author":"djaigo","title":"Linux cut命令","img":"https://img-1251474779.cos.ap-beijing.myqcloud.com/linux.png","date":"2019-12-20T08:22:37.000Z","_content":"\n在linux中，cut常用修剪出指定位置的数据，cut是按行为单位进行裁剪。\n它有三个裁剪模式：\n```text\n用法：cut [选项]... [文件]...\n  -b, --bytes=列表\t\t只选中指定的这些字节\n  -c, --characters=列表\t只选中指定的这些字符\n  -d, --delimiter=分界符\t使用指定分界符代替制表符作为区域分界\n  -f, --fields=LIST       select only these fields;  also print any line\n                            that contains no delimiter character, unless\n                            the -s option is specified\n  -n                      with -b: don't split multibyte characters\n      --complement\t\t补全选中的字节、字符或域\n  -s, --only-delimited\t\t不打印没有包含分界符的行\n      --output-delimiter=字符串\t使用指定的字符串作为输出分界符，默认采用输入\n\t\t\t\t的分界符\n      --help\t\t显示此帮助信息并退出\n      --version\t\t显示版本信息并退出\n\n仅使用 -b, -c 或-f 中的一个。每一个列表都是专门为一个类别作出的，或者您可以用逗号隔\n开要同时显示的不同类别。您的输入顺序将作为读取顺序，每个仅能输入一次。\n每种参数格式表示范围如下：\n    N\t第N 个字节、字符或域\n    N-\t从第N 个开始到所在行结束的所有字符、字节或域\n    N-M\t从第N 个开始到第M 个之间(包括第M 个)的所有字符、字节或域\n    -M\t从第1 个开始到第M 个之间(包括第M 个)的所有字符、字节或域\n\n当没有文件参数，或者文件不存在时，从标准输入读取      \n```\n\n常用选项：\n* b，按照字节长度裁剪，-n表示\n* c，按照字符长度来裁剪\n* d，表示自定义分隔符，默认为制表符\n* f，按照域长度来裁剪，-s表示\n\n示例：\n```sh\n➜ echo \"你好:哈哈\" | cut -b 1-3\n你\n\n➜ echo \"你好:哈哈\" | cut -c 1-2\n你好\n\n➜ echo \"你好:哈哈\" | cut -d: -f 1-1\n你好\n```\n\ncomplement表示反选。\n示例：\n```sh\n➜ echo \"12 34 56 67\" | cut -b 1,4\n13\n\n➜ echo \"12 34 56 67\" | cut -b 1,4 --complement\n2 4 56 67\n\n➜ echo \"12 34 56 67\" | cut -b 1-4 --complement\n4 56 67\n```\n\noutput-delimiter表示设置输出的分隔符。\n示例：\n```sh\n➜ echo \"你好:哈哈:hello\" | cut -d: -f 1-2 --output-delimiter=!\n你好!哈哈\n```\n","source":"_posts/linux-cut命令.md","raw":"---\nauthor: djaigo\ntitle: Linux cut命令\nimg: 'https://img-1251474779.cos.ap-beijing.myqcloud.com/linux.png'\ncategories:\n  - linux\ntags:\n  - cmd\n  - command\ndate: 2019-12-20 16:22:37\n---\n\n在linux中，cut常用修剪出指定位置的数据，cut是按行为单位进行裁剪。\n它有三个裁剪模式：\n```text\n用法：cut [选项]... [文件]...\n  -b, --bytes=列表\t\t只选中指定的这些字节\n  -c, --characters=列表\t只选中指定的这些字符\n  -d, --delimiter=分界符\t使用指定分界符代替制表符作为区域分界\n  -f, --fields=LIST       select only these fields;  also print any line\n                            that contains no delimiter character, unless\n                            the -s option is specified\n  -n                      with -b: don't split multibyte characters\n      --complement\t\t补全选中的字节、字符或域\n  -s, --only-delimited\t\t不打印没有包含分界符的行\n      --output-delimiter=字符串\t使用指定的字符串作为输出分界符，默认采用输入\n\t\t\t\t的分界符\n      --help\t\t显示此帮助信息并退出\n      --version\t\t显示版本信息并退出\n\n仅使用 -b, -c 或-f 中的一个。每一个列表都是专门为一个类别作出的，或者您可以用逗号隔\n开要同时显示的不同类别。您的输入顺序将作为读取顺序，每个仅能输入一次。\n每种参数格式表示范围如下：\n    N\t第N 个字节、字符或域\n    N-\t从第N 个开始到所在行结束的所有字符、字节或域\n    N-M\t从第N 个开始到第M 个之间(包括第M 个)的所有字符、字节或域\n    -M\t从第1 个开始到第M 个之间(包括第M 个)的所有字符、字节或域\n\n当没有文件参数，或者文件不存在时，从标准输入读取      \n```\n\n常用选项：\n* b，按照字节长度裁剪，-n表示\n* c，按照字符长度来裁剪\n* d，表示自定义分隔符，默认为制表符\n* f，按照域长度来裁剪，-s表示\n\n示例：\n```sh\n➜ echo \"你好:哈哈\" | cut -b 1-3\n你\n\n➜ echo \"你好:哈哈\" | cut -c 1-2\n你好\n\n➜ echo \"你好:哈哈\" | cut -d: -f 1-1\n你好\n```\n\ncomplement表示反选。\n示例：\n```sh\n➜ echo \"12 34 56 67\" | cut -b 1,4\n13\n\n➜ echo \"12 34 56 67\" | cut -b 1,4 --complement\n2 4 56 67\n\n➜ echo \"12 34 56 67\" | cut -b 1-4 --complement\n4 56 67\n```\n\noutput-delimiter表示设置输出的分隔符。\n示例：\n```sh\n➜ echo \"你好:哈哈:hello\" | cut -d: -f 1-2 --output-delimiter=!\n你好!哈哈\n```\n","slug":"linux-cut命令","published":1,"updated":"2019-12-20T08:22:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh351duu001m19z4205dd6kr","content":"<p>在linux中，cut常用修剪出指定位置的数据，cut是按行为单位进行裁剪。<br>它有三个裁剪模式：</p>\n<pre class=\" language-text\"><code class=\"language-text\">用法：cut [选项]... [文件]...\n  -b, --bytes=列表        只选中指定的这些字节\n  -c, --characters=列表    只选中指定的这些字符\n  -d, --delimiter=分界符    使用指定分界符代替制表符作为区域分界\n  -f, --fields=LIST       select only these fields;  also print any line\n                            that contains no delimiter character, unless\n                            the -s option is specified\n  -n                      with -b: don't split multibyte characters\n      --complement        补全选中的字节、字符或域\n  -s, --only-delimited        不打印没有包含分界符的行\n      --output-delimiter=字符串    使用指定的字符串作为输出分界符，默认采用输入\n                的分界符\n      --help        显示此帮助信息并退出\n      --version        显示版本信息并退出\n\n仅使用 -b, -c 或-f 中的一个。每一个列表都是专门为一个类别作出的，或者您可以用逗号隔\n开要同时显示的不同类别。您的输入顺序将作为读取顺序，每个仅能输入一次。\n每种参数格式表示范围如下：\n    N    第N 个字节、字符或域\n    N-    从第N 个开始到所在行结束的所有字符、字节或域\n    N-M    从第N 个开始到第M 个之间(包括第M 个)的所有字符、字节或域\n    -M    从第1 个开始到第M 个之间(包括第M 个)的所有字符、字节或域\n\n当没有文件参数，或者文件不存在时，从标准输入读取      </code></pre>\n<p>常用选项：</p>\n<ul>\n<li>b，按照字节长度裁剪，-n表示</li>\n<li>c，按照字符长度来裁剪</li>\n<li>d，表示自定义分隔符，默认为制表符</li>\n<li>f，按照域长度来裁剪，-s表示</li>\n</ul>\n<p>示例：</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">➜ echo \"你好:哈哈\" | cut -b 1-3\n你\n\n➜ echo \"你好:哈哈\" | cut -c 1-2\n你好\n\n➜ echo \"你好:哈哈\" | cut -d: -f 1-1\n你好</code></pre>\n<p>complement表示反选。<br>示例：</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">➜ echo \"12 34 56 67\" | cut -b 1,4\n13\n\n➜ echo \"12 34 56 67\" | cut -b 1,4 --complement\n2 4 56 67\n\n➜ echo \"12 34 56 67\" | cut -b 1-4 --complement\n4 56 67</code></pre>\n<p>output-delimiter表示设置输出的分隔符。<br>示例：</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">➜ echo \"你好:哈哈:hello\" | cut -d: -f 1-2 --output-delimiter=!\n你好!哈哈</code></pre>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"friends":[{"avatar":"https://img-1251474779.cos.ap-beijing.myqcloud.com/icon.png","name":"djaigo","introduction":"好好学习，天天向上","url":"/","title":"前去学习"},{"avatar":"https://awps-assets.meituan.net/mit/blog/v20190629/asset/icon/favicon.ico?v=Whistle&t=20181017-1r","name":"美团技术团队","introduction":"一行代码，亿万生活。","url":"https://tech.meituan.com/","title":"点个外卖-->"},{"avatar":"","name":"鸟窝","introduction":"rpcx作者","url":"https://colobu.com/","title":"进个鸟窝-->"},{"avatar":"https://d1j8pt39hxlh3d.cloudfront.net/emoji/emojione/5.0/png/unicode/32/1f92a.png","name":"labuladong的算法小抄","introduction":"算法大神","url":"https://labuladong.gitbook.io/algo/","title":"学个算法-->"}]}},"excerpt":"","more":"<p>在linux中，cut常用修剪出指定位置的数据，cut是按行为单位进行裁剪。<br>它有三个裁剪模式：</p>\n<pre><code class=\"text\">用法：cut [选项]... [文件]...\n  -b, --bytes=列表        只选中指定的这些字节\n  -c, --characters=列表    只选中指定的这些字符\n  -d, --delimiter=分界符    使用指定分界符代替制表符作为区域分界\n  -f, --fields=LIST       select only these fields;  also print any line\n                            that contains no delimiter character, unless\n                            the -s option is specified\n  -n                      with -b: don&#39;t split multibyte characters\n      --complement        补全选中的字节、字符或域\n  -s, --only-delimited        不打印没有包含分界符的行\n      --output-delimiter=字符串    使用指定的字符串作为输出分界符，默认采用输入\n                的分界符\n      --help        显示此帮助信息并退出\n      --version        显示版本信息并退出\n\n仅使用 -b, -c 或-f 中的一个。每一个列表都是专门为一个类别作出的，或者您可以用逗号隔\n开要同时显示的不同类别。您的输入顺序将作为读取顺序，每个仅能输入一次。\n每种参数格式表示范围如下：\n    N    第N 个字节、字符或域\n    N-    从第N 个开始到所在行结束的所有字符、字节或域\n    N-M    从第N 个开始到第M 个之间(包括第M 个)的所有字符、字节或域\n    -M    从第1 个开始到第M 个之间(包括第M 个)的所有字符、字节或域\n\n当没有文件参数，或者文件不存在时，从标准输入读取      </code></pre>\n<p>常用选项：</p>\n<ul>\n<li>b，按照字节长度裁剪，-n表示</li>\n<li>c，按照字符长度来裁剪</li>\n<li>d，表示自定义分隔符，默认为制表符</li>\n<li>f，按照域长度来裁剪，-s表示</li>\n</ul>\n<p>示例：</p>\n<pre><code class=\"sh\">➜ echo &quot;你好:哈哈&quot; | cut -b 1-3\n你\n\n➜ echo &quot;你好:哈哈&quot; | cut -c 1-2\n你好\n\n➜ echo &quot;你好:哈哈&quot; | cut -d: -f 1-1\n你好</code></pre>\n<p>complement表示反选。<br>示例：</p>\n<pre><code class=\"sh\">➜ echo &quot;12 34 56 67&quot; | cut -b 1,4\n13\n\n➜ echo &quot;12 34 56 67&quot; | cut -b 1,4 --complement\n2 4 56 67\n\n➜ echo &quot;12 34 56 67&quot; | cut -b 1-4 --complement\n4 56 67</code></pre>\n<p>output-delimiter表示设置输出的分隔符。<br>示例：</p>\n<pre><code class=\"sh\">➜ echo &quot;你好:哈哈:hello&quot; | cut -d: -f 1-2 --output-delimiter=!\n你好!哈哈</code></pre>\n"},{"author":"djaigo","title":"linux-find命令","img":"https://img-1251474779.cos.ap-beijing.myqcloud.com/golang.png","date":"2020-09-16T10:18:17.000Z","updated":"2020-09-16T10:18:17.000Z","_content":"\n在linux中find是一个非常有用的命令，它可以快速查找指定目录下符合条件的文件。\n\n```sh\n➜ find --help\nUsage: find [-H] [-L] [-P] [-Olevel] [-D help|tree|search|stat|rates|opt|exec] [path...] [expression]\n\ndefault path is the current directory; default expression is -print\nexpression may consist of: operators, options, tests, and actions:\n\noperators (decreasing precedence; -and is implicit where no others are given):\n      ( EXPR )   ! EXPR   -not EXPR   EXPR1 -a EXPR2   EXPR1 -and EXPR2\n      EXPR1 -o EXPR2   EXPR1 -or EXPR2   EXPR1 , EXPR2\n\npositional options (always true): -daystart -follow -regextype\n\nnormal options (always true, specified before other expressions):\n      -depth --help -maxdepth LEVELS -mindepth LEVELS -mount -noleaf\n      --version -xautofs -xdev -ignore_readdir_race -noignore_readdir_race\n\ntests (N can be +N or -N or N): -amin N -anewer FILE -atime N -cmin N\n      -cnewer FILE -ctime N -empty -false -fstype TYPE -gid N -group NAME\n      -ilname PATTERN -iname PATTERN -inum N -iwholename PATTERN -iregex PATTERN\n      -links N -lname PATTERN -mmin N -mtime N -name PATTERN -newer FILE\n      -nouser -nogroup -path PATTERN -perm [-/]MODE -regex PATTERN\n      -readable -writable -executable\n      -wholename PATTERN -size N[bcwkMG] -true -type [bcdpflsD] -uid N\n      -used N -user NAME -xtype [bcdpfls]\n      -context CONTEXT\n\n\nactions: -delete -print0 -printf FORMAT -fprintf FILE FORMAT -print\n      -fprint0 FILE -fprint FILE -ls -fls FILE -prune -quit\n      -exec COMMAND ; -exec COMMAND {} + -ok COMMAND ;\n      -execdir COMMAND ; -execdir COMMAND {} + -okdir COMMAND ;\n```\n\nfind的语法：`find [option] [path ... ] [expression]`\n默认`path`是当前路径，默认`expression`是`-print`。`expression`还可以是`operators`，`options`，`tests`，`actions`。\n\noperators：优先级递减，默认是`-and`\n* `()`，集合\n* `!`，`-not`，非\n* `-a`，`-and`，且\n* `-o`，`-or`，或\n* `,`，合并\n\npositional options：总是true\n* `-daystart`，从本日开始计算时间\n* `-follow`，排除符号连接\n* `-regextype`\n\nnormal options：总是true，在其他表达式之前指定\n* `-depth`，限制递归深度\n* `--help`，打印usage\n* `-maxdepth LEVELS`，\n* `-mindepth LEVELS`，\n* `-mount`，同`-xdev`\n* `-noleaf`，不去考虑目录至少需拥有两个硬连接存在\n* `--version`，打印版本\n* `-xautofs`，\n* `-xdev`，将范围局限在先行的文件系统中\n`-ignore_readdir_race`，`-noignore_readdir_race`\n\ntests：（N可以是+N -N N，+表示大于N，-表示小于N，不带符号表示等于N）\n* `-amin N`，查找在指定时间曾被存取过的文件或目录，单位以分钟计算\n* `-anewer FILE`，查找其存取时间较指定文件或目录的存取时间更接近现在的文件或目录\n* `-atime N`，查找在指定时间曾被存取过的文件或目录，单位以 24 小时计算\n* `-cmin N`，查找在指定时间之时被更改过的文件或目录\n* `-cnewer FILE`，查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录\n* `-ctime N`，查找在指定时间之时被更改的文件或目录，单位以 24 小时计算\n* `-empty`，寻找文件大小为 0 Byte 的文件，或目录下没有任何子目录或文件的空目录\n* `-false`，回传值都为false\n* `-fstype TYPE`，只寻找该文件系统类型下的文件或目录\n* `-gid N`，所属组id的文件\n* `-group NAME`，所属组名称的文件\n* `-ilname PATTERN`，类似`-lname`，忽略大小写\n* `-iname PATTERN`，类似`-name`，忽略大小写\n* `-inum N`，查找符合指定的`inode`编号的文件或目录\n* `-iwholename PATTERN` \n* `-iregex PATTERN`，类似`-regex`，忽略大小写\n* `-links N`，查找符合指定的硬连接数目的文件或目录\n* `-lname PATTERN`，类似`-name`，只获取连接文件\n* `-mmin N`，查找在指定时间曾被更改过的文件或目录，单位以分钟计算\n* `-mtime N`，查找在指定时间曾被更改过的文件或目录，单位以 24 小时计算\n* `-name PATTERN`，按照**文件名**查找，支持`*`通配符\n* `-newer FILE`，查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录\n* `-nouser`，找出不属于本地主机用户识别码的文件或目录\n* `-nogroup`，找出不属于本地主机群组识别码的文件或目录\n* `-path PATTERN`，类似`-name`，匹配的是整个相对路径\n* `-perm [-/]MODE`，按照文件权限查找\n* `-regex PATTERN`，正则\n* `-readable`，可读文件\n* `-writable`，可写文件\n* `-executable`，可执行文件\n* `-wholename PATTERN`，完全名字匹配\n* `-size N[bcwkMG]`，按照文件大小查找\n* `-true`，回传值都为true\n* `-type [bcdpflsD]`，按照文件类型查找\n* `-uid N`，按照文件拥有者ID查找\n* `-used N`，查找文件或目录被更改之后在指定时间曾被存取过的文件或目录，单位以日计算\n* `-user NAME`，按照文件拥有者查找\n* `-xtype [bcdpfls]`，类似`-type`，针对符号连接检查\n* `-context CONTEXT`\n\nactions：\n* `-delete`\n* `-print0`，假设`find`指令的回传值为`ture`，就将文件或目录名称列出到标准输出，格式为全部的名称皆在同一行\n* `-printf FORMAT`，假设`find`指令的回传值为`ture`，就将文件或目录名称列出到标准输出，格式由`FORMAT`指定\n* `-fprintf FILE FORMAT`，类似`-printf`，格式化输出到文件\n* `-print`，假设`find`指令的回传值为`ture`，就将文件或目录名称列出到标准输出，格式为每列一个名称\n* `-fprint0 FILE`，类似`-print0`，将输出写入文件\n* `-fprint FILE`，类似`-print`，将输出写入文件\n* `-ls`，打印查找结果详细信息\n* `-fls FILE`，类似`-ls`，将输出写入文件\n* `-prune`，不寻找字符串作为寻找文件或目录的范本样式\n* `-quit`，什么也不打印\n* `-exec COMMAND`、`-exec COMMAND {} + -ok COMMAND`、`-execdir COMMAND`、`-execdir COMMAND {} + -okdir COMMAND`，将`find`出的结果执行其他命令，`{}`表示find后的集合，在`COMMAND`后面需要加上`\\;`来标记`COMMAND`结束。`ok`类似`exec`，在执行`COMMAND`之前会询问是否执行。\n\n文件类型：\n* b，块设备\n* c，字符设备\n* d，目录\n* p，管道\n* f，普通文件\n* l，链接文件\n* s，套接字\n* D，未知\n\n大小单位：\n* b，块（512 字节）\n* c，字节\n* w，字（2 字节）\n* k，千字节\n* M，兆字节\n* G，吉字节\n\n# 参考文献\n* [Linux 命令之 find：查找文件](https://blog.csdn.net/qq_35246620/article/details/79104520)\n","source":"_posts/linux-find命令.md","raw":"---\nauthor: djaigo\ntitle: linux-find命令\nimg: 'https://img-1251474779.cos.ap-beijing.myqcloud.com/golang.png'\ncategories:\n  - linux\ntags:\n  - cmd\n  - command\ndate: 2020-09-16 18:18:17\nupdated: 2020-09-16 18:18:17\n---\n\n在linux中find是一个非常有用的命令，它可以快速查找指定目录下符合条件的文件。\n\n```sh\n➜ find --help\nUsage: find [-H] [-L] [-P] [-Olevel] [-D help|tree|search|stat|rates|opt|exec] [path...] [expression]\n\ndefault path is the current directory; default expression is -print\nexpression may consist of: operators, options, tests, and actions:\n\noperators (decreasing precedence; -and is implicit where no others are given):\n      ( EXPR )   ! EXPR   -not EXPR   EXPR1 -a EXPR2   EXPR1 -and EXPR2\n      EXPR1 -o EXPR2   EXPR1 -or EXPR2   EXPR1 , EXPR2\n\npositional options (always true): -daystart -follow -regextype\n\nnormal options (always true, specified before other expressions):\n      -depth --help -maxdepth LEVELS -mindepth LEVELS -mount -noleaf\n      --version -xautofs -xdev -ignore_readdir_race -noignore_readdir_race\n\ntests (N can be +N or -N or N): -amin N -anewer FILE -atime N -cmin N\n      -cnewer FILE -ctime N -empty -false -fstype TYPE -gid N -group NAME\n      -ilname PATTERN -iname PATTERN -inum N -iwholename PATTERN -iregex PATTERN\n      -links N -lname PATTERN -mmin N -mtime N -name PATTERN -newer FILE\n      -nouser -nogroup -path PATTERN -perm [-/]MODE -regex PATTERN\n      -readable -writable -executable\n      -wholename PATTERN -size N[bcwkMG] -true -type [bcdpflsD] -uid N\n      -used N -user NAME -xtype [bcdpfls]\n      -context CONTEXT\n\n\nactions: -delete -print0 -printf FORMAT -fprintf FILE FORMAT -print\n      -fprint0 FILE -fprint FILE -ls -fls FILE -prune -quit\n      -exec COMMAND ; -exec COMMAND {} + -ok COMMAND ;\n      -execdir COMMAND ; -execdir COMMAND {} + -okdir COMMAND ;\n```\n\nfind的语法：`find [option] [path ... ] [expression]`\n默认`path`是当前路径，默认`expression`是`-print`。`expression`还可以是`operators`，`options`，`tests`，`actions`。\n\noperators：优先级递减，默认是`-and`\n* `()`，集合\n* `!`，`-not`，非\n* `-a`，`-and`，且\n* `-o`，`-or`，或\n* `,`，合并\n\npositional options：总是true\n* `-daystart`，从本日开始计算时间\n* `-follow`，排除符号连接\n* `-regextype`\n\nnormal options：总是true，在其他表达式之前指定\n* `-depth`，限制递归深度\n* `--help`，打印usage\n* `-maxdepth LEVELS`，\n* `-mindepth LEVELS`，\n* `-mount`，同`-xdev`\n* `-noleaf`，不去考虑目录至少需拥有两个硬连接存在\n* `--version`，打印版本\n* `-xautofs`，\n* `-xdev`，将范围局限在先行的文件系统中\n`-ignore_readdir_race`，`-noignore_readdir_race`\n\ntests：（N可以是+N -N N，+表示大于N，-表示小于N，不带符号表示等于N）\n* `-amin N`，查找在指定时间曾被存取过的文件或目录，单位以分钟计算\n* `-anewer FILE`，查找其存取时间较指定文件或目录的存取时间更接近现在的文件或目录\n* `-atime N`，查找在指定时间曾被存取过的文件或目录，单位以 24 小时计算\n* `-cmin N`，查找在指定时间之时被更改过的文件或目录\n* `-cnewer FILE`，查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录\n* `-ctime N`，查找在指定时间之时被更改的文件或目录，单位以 24 小时计算\n* `-empty`，寻找文件大小为 0 Byte 的文件，或目录下没有任何子目录或文件的空目录\n* `-false`，回传值都为false\n* `-fstype TYPE`，只寻找该文件系统类型下的文件或目录\n* `-gid N`，所属组id的文件\n* `-group NAME`，所属组名称的文件\n* `-ilname PATTERN`，类似`-lname`，忽略大小写\n* `-iname PATTERN`，类似`-name`，忽略大小写\n* `-inum N`，查找符合指定的`inode`编号的文件或目录\n* `-iwholename PATTERN` \n* `-iregex PATTERN`，类似`-regex`，忽略大小写\n* `-links N`，查找符合指定的硬连接数目的文件或目录\n* `-lname PATTERN`，类似`-name`，只获取连接文件\n* `-mmin N`，查找在指定时间曾被更改过的文件或目录，单位以分钟计算\n* `-mtime N`，查找在指定时间曾被更改过的文件或目录，单位以 24 小时计算\n* `-name PATTERN`，按照**文件名**查找，支持`*`通配符\n* `-newer FILE`，查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录\n* `-nouser`，找出不属于本地主机用户识别码的文件或目录\n* `-nogroup`，找出不属于本地主机群组识别码的文件或目录\n* `-path PATTERN`，类似`-name`，匹配的是整个相对路径\n* `-perm [-/]MODE`，按照文件权限查找\n* `-regex PATTERN`，正则\n* `-readable`，可读文件\n* `-writable`，可写文件\n* `-executable`，可执行文件\n* `-wholename PATTERN`，完全名字匹配\n* `-size N[bcwkMG]`，按照文件大小查找\n* `-true`，回传值都为true\n* `-type [bcdpflsD]`，按照文件类型查找\n* `-uid N`，按照文件拥有者ID查找\n* `-used N`，查找文件或目录被更改之后在指定时间曾被存取过的文件或目录，单位以日计算\n* `-user NAME`，按照文件拥有者查找\n* `-xtype [bcdpfls]`，类似`-type`，针对符号连接检查\n* `-context CONTEXT`\n\nactions：\n* `-delete`\n* `-print0`，假设`find`指令的回传值为`ture`，就将文件或目录名称列出到标准输出，格式为全部的名称皆在同一行\n* `-printf FORMAT`，假设`find`指令的回传值为`ture`，就将文件或目录名称列出到标准输出，格式由`FORMAT`指定\n* `-fprintf FILE FORMAT`，类似`-printf`，格式化输出到文件\n* `-print`，假设`find`指令的回传值为`ture`，就将文件或目录名称列出到标准输出，格式为每列一个名称\n* `-fprint0 FILE`，类似`-print0`，将输出写入文件\n* `-fprint FILE`，类似`-print`，将输出写入文件\n* `-ls`，打印查找结果详细信息\n* `-fls FILE`，类似`-ls`，将输出写入文件\n* `-prune`，不寻找字符串作为寻找文件或目录的范本样式\n* `-quit`，什么也不打印\n* `-exec COMMAND`、`-exec COMMAND {} + -ok COMMAND`、`-execdir COMMAND`、`-execdir COMMAND {} + -okdir COMMAND`，将`find`出的结果执行其他命令，`{}`表示find后的集合，在`COMMAND`后面需要加上`\\;`来标记`COMMAND`结束。`ok`类似`exec`，在执行`COMMAND`之前会询问是否执行。\n\n文件类型：\n* b，块设备\n* c，字符设备\n* d，目录\n* p，管道\n* f，普通文件\n* l，链接文件\n* s，套接字\n* D，未知\n\n大小单位：\n* b，块（512 字节）\n* c，字节\n* w，字（2 字节）\n* k，千字节\n* M，兆字节\n* G，吉字节\n\n# 参考文献\n* [Linux 命令之 find：查找文件](https://blog.csdn.net/qq_35246620/article/details/79104520)\n","slug":"linux-find命令","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckh351duy001r19z4g7mj3l6b","content":"<p>在linux中find是一个非常有用的命令，它可以快速查找指定目录下符合条件的文件。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">➜ find --help\nUsage: find [-H] [-L] [-P] [-Olevel] [-D help|tree|search|stat|rates|opt|exec] [path...] [expression]\n\ndefault path is the current directory; default expression is -print\nexpression may consist of: operators, options, tests, and actions:\n\noperators (decreasing precedence; -and is implicit where no others are given):\n      ( EXPR )   ! EXPR   -not EXPR   EXPR1 -a EXPR2   EXPR1 -and EXPR2\n      EXPR1 -o EXPR2   EXPR1 -or EXPR2   EXPR1 , EXPR2\n\npositional options (always true): -daystart -follow -regextype\n\nnormal options (always true, specified before other expressions):\n      -depth --help -maxdepth LEVELS -mindepth LEVELS -mount -noleaf\n      --version -xautofs -xdev -ignore_readdir_race -noignore_readdir_race\n\ntests (N can be +N or -N or N): -amin N -anewer FILE -atime N -cmin N\n      -cnewer FILE -ctime N -empty -false -fstype TYPE -gid N -group NAME\n      -ilname PATTERN -iname PATTERN -inum N -iwholename PATTERN -iregex PATTERN\n      -links N -lname PATTERN -mmin N -mtime N -name PATTERN -newer FILE\n      -nouser -nogroup -path PATTERN -perm [-/]MODE -regex PATTERN\n      -readable -writable -executable\n      -wholename PATTERN -size N[bcwkMG] -true -type [bcdpflsD] -uid N\n      -used N -user NAME -xtype [bcdpfls]\n      -context CONTEXT\n\n\nactions: -delete -print0 -printf FORMAT -fprintf FILE FORMAT -print\n      -fprint0 FILE -fprint FILE -ls -fls FILE -prune -quit\n      -exec COMMAND ; -exec COMMAND {} + -ok COMMAND ;\n      -execdir COMMAND ; -execdir COMMAND {} + -okdir COMMAND ;</code></pre>\n<p>find的语法：<code>find [option] [path ... ] [expression]</code><br>默认<code>path</code>是当前路径，默认<code>expression</code>是<code>-print</code>。<code>expression</code>还可以是<code>operators</code>，<code>options</code>，<code>tests</code>，<code>actions</code>。</p>\n<p>operators：优先级递减，默认是<code>-and</code></p>\n<ul>\n<li><code>()</code>，集合</li>\n<li><code>!</code>，<code>-not</code>，非</li>\n<li><code>-a</code>，<code>-and</code>，且</li>\n<li><code>-o</code>，<code>-or</code>，或</li>\n<li><code>,</code>，合并</li>\n</ul>\n<p>positional options：总是true</p>\n<ul>\n<li><code>-daystart</code>，从本日开始计算时间</li>\n<li><code>-follow</code>，排除符号连接</li>\n<li><code>-regextype</code></li>\n</ul>\n<p>normal options：总是true，在其他表达式之前指定</p>\n<ul>\n<li><code>-depth</code>，限制递归深度</li>\n<li><code>--help</code>，打印usage</li>\n<li><code>-maxdepth LEVELS</code>，</li>\n<li><code>-mindepth LEVELS</code>，</li>\n<li><code>-mount</code>，同<code>-xdev</code></li>\n<li><code>-noleaf</code>，不去考虑目录至少需拥有两个硬连接存在</li>\n<li><code>--version</code>，打印版本</li>\n<li><code>-xautofs</code>，</li>\n<li><code>-xdev</code>，将范围局限在先行的文件系统中<br><code>-ignore_readdir_race</code>，<code>-noignore_readdir_race</code></li>\n</ul>\n<p>tests：（N可以是+N -N N，+表示大于N，-表示小于N，不带符号表示等于N）</p>\n<ul>\n<li><code>-amin N</code>，查找在指定时间曾被存取过的文件或目录，单位以分钟计算</li>\n<li><code>-anewer FILE</code>，查找其存取时间较指定文件或目录的存取时间更接近现在的文件或目录</li>\n<li><code>-atime N</code>，查找在指定时间曾被存取过的文件或目录，单位以 24 小时计算</li>\n<li><code>-cmin N</code>，查找在指定时间之时被更改过的文件或目录</li>\n<li><code>-cnewer FILE</code>，查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录</li>\n<li><code>-ctime N</code>，查找在指定时间之时被更改的文件或目录，单位以 24 小时计算</li>\n<li><code>-empty</code>，寻找文件大小为 0 Byte 的文件，或目录下没有任何子目录或文件的空目录</li>\n<li><code>-false</code>，回传值都为false</li>\n<li><code>-fstype TYPE</code>，只寻找该文件系统类型下的文件或目录</li>\n<li><code>-gid N</code>，所属组id的文件</li>\n<li><code>-group NAME</code>，所属组名称的文件</li>\n<li><code>-ilname PATTERN</code>，类似<code>-lname</code>，忽略大小写</li>\n<li><code>-iname PATTERN</code>，类似<code>-name</code>，忽略大小写</li>\n<li><code>-inum N</code>，查找符合指定的<code>inode</code>编号的文件或目录</li>\n<li><code>-iwholename PATTERN</code> </li>\n<li><code>-iregex PATTERN</code>，类似<code>-regex</code>，忽略大小写</li>\n<li><code>-links N</code>，查找符合指定的硬连接数目的文件或目录</li>\n<li><code>-lname PATTERN</code>，类似<code>-name</code>，只获取连接文件</li>\n<li><code>-mmin N</code>，查找在指定时间曾被更改过的文件或目录，单位以分钟计算</li>\n<li><code>-mtime N</code>，查找在指定时间曾被更改过的文件或目录，单位以 24 小时计算</li>\n<li><code>-name PATTERN</code>，按照<strong>文件名</strong>查找，支持<code>*</code>通配符</li>\n<li><code>-newer FILE</code>，查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录</li>\n<li><code>-nouser</code>，找出不属于本地主机用户识别码的文件或目录</li>\n<li><code>-nogroup</code>，找出不属于本地主机群组识别码的文件或目录</li>\n<li><code>-path PATTERN</code>，类似<code>-name</code>，匹配的是整个相对路径</li>\n<li><code>-perm [-/]MODE</code>，按照文件权限查找</li>\n<li><code>-regex PATTERN</code>，正则</li>\n<li><code>-readable</code>，可读文件</li>\n<li><code>-writable</code>，可写文件</li>\n<li><code>-executable</code>，可执行文件</li>\n<li><code>-wholename PATTERN</code>，完全名字匹配</li>\n<li><code>-size N[bcwkMG]</code>，按照文件大小查找</li>\n<li><code>-true</code>，回传值都为true</li>\n<li><code>-type [bcdpflsD]</code>，按照文件类型查找</li>\n<li><code>-uid N</code>，按照文件拥有者ID查找</li>\n<li><code>-used N</code>，查找文件或目录被更改之后在指定时间曾被存取过的文件或目录，单位以日计算</li>\n<li><code>-user NAME</code>，按照文件拥有者查找</li>\n<li><code>-xtype [bcdpfls]</code>，类似<code>-type</code>，针对符号连接检查</li>\n<li><code>-context CONTEXT</code></li>\n</ul>\n<p>actions：</p>\n<ul>\n<li><code>-delete</code></li>\n<li><code>-print0</code>，假设<code>find</code>指令的回传值为<code>ture</code>，就将文件或目录名称列出到标准输出，格式为全部的名称皆在同一行</li>\n<li><code>-printf FORMAT</code>，假设<code>find</code>指令的回传值为<code>ture</code>，就将文件或目录名称列出到标准输出，格式由<code>FORMAT</code>指定</li>\n<li><code>-fprintf FILE FORMAT</code>，类似<code>-printf</code>，格式化输出到文件</li>\n<li><code>-print</code>，假设<code>find</code>指令的回传值为<code>ture</code>，就将文件或目录名称列出到标准输出，格式为每列一个名称</li>\n<li><code>-fprint0 FILE</code>，类似<code>-print0</code>，将输出写入文件</li>\n<li><code>-fprint FILE</code>，类似<code>-print</code>，将输出写入文件</li>\n<li><code>-ls</code>，打印查找结果详细信息</li>\n<li><code>-fls FILE</code>，类似<code>-ls</code>，将输出写入文件</li>\n<li><code>-prune</code>，不寻找字符串作为寻找文件或目录的范本样式</li>\n<li><code>-quit</code>，什么也不打印</li>\n<li><code>-exec COMMAND</code>、<code>-exec COMMAND {} + -ok COMMAND</code>、<code>-execdir COMMAND</code>、<code>-execdir COMMAND {} + -okdir COMMAND</code>，将<code>find</code>出的结果执行其他命令，<code>{}</code>表示find后的集合，在<code>COMMAND</code>后面需要加上<code>\\;</code>来标记<code>COMMAND</code>结束。<code>ok</code>类似<code>exec</code>，在执行<code>COMMAND</code>之前会询问是否执行。</li>\n</ul>\n<p>文件类型：</p>\n<ul>\n<li>b，块设备</li>\n<li>c，字符设备</li>\n<li>d，目录</li>\n<li>p，管道</li>\n<li>f，普通文件</li>\n<li>l，链接文件</li>\n<li>s，套接字</li>\n<li>D，未知</li>\n</ul>\n<p>大小单位：</p>\n<ul>\n<li>b，块（512 字节）</li>\n<li>c，字节</li>\n<li>w，字（2 字节）</li>\n<li>k，千字节</li>\n<li>M，兆字节</li>\n<li>G，吉字节</li>\n</ul>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ul>\n<li><a href=\"https://blog.csdn.net/qq_35246620/article/details/79104520\" target=\"_blank\" rel=\"noopener\">Linux 命令之 find：查找文件</a></li>\n</ul>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"friends":[{"avatar":"https://img-1251474779.cos.ap-beijing.myqcloud.com/icon.png","name":"djaigo","introduction":"好好学习，天天向上","url":"/","title":"前去学习"},{"avatar":"https://awps-assets.meituan.net/mit/blog/v20190629/asset/icon/favicon.ico?v=Whistle&t=20181017-1r","name":"美团技术团队","introduction":"一行代码，亿万生活。","url":"https://tech.meituan.com/","title":"点个外卖-->"},{"avatar":"","name":"鸟窝","introduction":"rpcx作者","url":"https://colobu.com/","title":"进个鸟窝-->"},{"avatar":"https://d1j8pt39hxlh3d.cloudfront.net/emoji/emojione/5.0/png/unicode/32/1f92a.png","name":"labuladong的算法小抄","introduction":"算法大神","url":"https://labuladong.gitbook.io/algo/","title":"学个算法-->"}]}},"excerpt":"","more":"<p>在linux中find是一个非常有用的命令，它可以快速查找指定目录下符合条件的文件。</p>\n<pre><code class=\"sh\">➜ find --help\nUsage: find [-H] [-L] [-P] [-Olevel] [-D help|tree|search|stat|rates|opt|exec] [path...] [expression]\n\ndefault path is the current directory; default expression is -print\nexpression may consist of: operators, options, tests, and actions:\n\noperators (decreasing precedence; -and is implicit where no others are given):\n      ( EXPR )   ! EXPR   -not EXPR   EXPR1 -a EXPR2   EXPR1 -and EXPR2\n      EXPR1 -o EXPR2   EXPR1 -or EXPR2   EXPR1 , EXPR2\n\npositional options (always true): -daystart -follow -regextype\n\nnormal options (always true, specified before other expressions):\n      -depth --help -maxdepth LEVELS -mindepth LEVELS -mount -noleaf\n      --version -xautofs -xdev -ignore_readdir_race -noignore_readdir_race\n\ntests (N can be +N or -N or N): -amin N -anewer FILE -atime N -cmin N\n      -cnewer FILE -ctime N -empty -false -fstype TYPE -gid N -group NAME\n      -ilname PATTERN -iname PATTERN -inum N -iwholename PATTERN -iregex PATTERN\n      -links N -lname PATTERN -mmin N -mtime N -name PATTERN -newer FILE\n      -nouser -nogroup -path PATTERN -perm [-/]MODE -regex PATTERN\n      -readable -writable -executable\n      -wholename PATTERN -size N[bcwkMG] -true -type [bcdpflsD] -uid N\n      -used N -user NAME -xtype [bcdpfls]\n      -context CONTEXT\n\n\nactions: -delete -print0 -printf FORMAT -fprintf FILE FORMAT -print\n      -fprint0 FILE -fprint FILE -ls -fls FILE -prune -quit\n      -exec COMMAND ; -exec COMMAND {} + -ok COMMAND ;\n      -execdir COMMAND ; -execdir COMMAND {} + -okdir COMMAND ;</code></pre>\n<p>find的语法：<code>find [option] [path ... ] [expression]</code><br>默认<code>path</code>是当前路径，默认<code>expression</code>是<code>-print</code>。<code>expression</code>还可以是<code>operators</code>，<code>options</code>，<code>tests</code>，<code>actions</code>。</p>\n<p>operators：优先级递减，默认是<code>-and</code></p>\n<ul>\n<li><code>()</code>，集合</li>\n<li><code>!</code>，<code>-not</code>，非</li>\n<li><code>-a</code>，<code>-and</code>，且</li>\n<li><code>-o</code>，<code>-or</code>，或</li>\n<li><code>,</code>，合并</li>\n</ul>\n<p>positional options：总是true</p>\n<ul>\n<li><code>-daystart</code>，从本日开始计算时间</li>\n<li><code>-follow</code>，排除符号连接</li>\n<li><code>-regextype</code></li>\n</ul>\n<p>normal options：总是true，在其他表达式之前指定</p>\n<ul>\n<li><code>-depth</code>，限制递归深度</li>\n<li><code>--help</code>，打印usage</li>\n<li><code>-maxdepth LEVELS</code>，</li>\n<li><code>-mindepth LEVELS</code>，</li>\n<li><code>-mount</code>，同<code>-xdev</code></li>\n<li><code>-noleaf</code>，不去考虑目录至少需拥有两个硬连接存在</li>\n<li><code>--version</code>，打印版本</li>\n<li><code>-xautofs</code>，</li>\n<li><code>-xdev</code>，将范围局限在先行的文件系统中<br><code>-ignore_readdir_race</code>，<code>-noignore_readdir_race</code></li>\n</ul>\n<p>tests：（N可以是+N -N N，+表示大于N，-表示小于N，不带符号表示等于N）</p>\n<ul>\n<li><code>-amin N</code>，查找在指定时间曾被存取过的文件或目录，单位以分钟计算</li>\n<li><code>-anewer FILE</code>，查找其存取时间较指定文件或目录的存取时间更接近现在的文件或目录</li>\n<li><code>-atime N</code>，查找在指定时间曾被存取过的文件或目录，单位以 24 小时计算</li>\n<li><code>-cmin N</code>，查找在指定时间之时被更改过的文件或目录</li>\n<li><code>-cnewer FILE</code>，查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录</li>\n<li><code>-ctime N</code>，查找在指定时间之时被更改的文件或目录，单位以 24 小时计算</li>\n<li><code>-empty</code>，寻找文件大小为 0 Byte 的文件，或目录下没有任何子目录或文件的空目录</li>\n<li><code>-false</code>，回传值都为false</li>\n<li><code>-fstype TYPE</code>，只寻找该文件系统类型下的文件或目录</li>\n<li><code>-gid N</code>，所属组id的文件</li>\n<li><code>-group NAME</code>，所属组名称的文件</li>\n<li><code>-ilname PATTERN</code>，类似<code>-lname</code>，忽略大小写</li>\n<li><code>-iname PATTERN</code>，类似<code>-name</code>，忽略大小写</li>\n<li><code>-inum N</code>，查找符合指定的<code>inode</code>编号的文件或目录</li>\n<li><code>-iwholename PATTERN</code> </li>\n<li><code>-iregex PATTERN</code>，类似<code>-regex</code>，忽略大小写</li>\n<li><code>-links N</code>，查找符合指定的硬连接数目的文件或目录</li>\n<li><code>-lname PATTERN</code>，类似<code>-name</code>，只获取连接文件</li>\n<li><code>-mmin N</code>，查找在指定时间曾被更改过的文件或目录，单位以分钟计算</li>\n<li><code>-mtime N</code>，查找在指定时间曾被更改过的文件或目录，单位以 24 小时计算</li>\n<li><code>-name PATTERN</code>，按照<strong>文件名</strong>查找，支持<code>*</code>通配符</li>\n<li><code>-newer FILE</code>，查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录</li>\n<li><code>-nouser</code>，找出不属于本地主机用户识别码的文件或目录</li>\n<li><code>-nogroup</code>，找出不属于本地主机群组识别码的文件或目录</li>\n<li><code>-path PATTERN</code>，类似<code>-name</code>，匹配的是整个相对路径</li>\n<li><code>-perm [-/]MODE</code>，按照文件权限查找</li>\n<li><code>-regex PATTERN</code>，正则</li>\n<li><code>-readable</code>，可读文件</li>\n<li><code>-writable</code>，可写文件</li>\n<li><code>-executable</code>，可执行文件</li>\n<li><code>-wholename PATTERN</code>，完全名字匹配</li>\n<li><code>-size N[bcwkMG]</code>，按照文件大小查找</li>\n<li><code>-true</code>，回传值都为true</li>\n<li><code>-type [bcdpflsD]</code>，按照文件类型查找</li>\n<li><code>-uid N</code>，按照文件拥有者ID查找</li>\n<li><code>-used N</code>，查找文件或目录被更改之后在指定时间曾被存取过的文件或目录，单位以日计算</li>\n<li><code>-user NAME</code>，按照文件拥有者查找</li>\n<li><code>-xtype [bcdpfls]</code>，类似<code>-type</code>，针对符号连接检查</li>\n<li><code>-context CONTEXT</code></li>\n</ul>\n<p>actions：</p>\n<ul>\n<li><code>-delete</code></li>\n<li><code>-print0</code>，假设<code>find</code>指令的回传值为<code>ture</code>，就将文件或目录名称列出到标准输出，格式为全部的名称皆在同一行</li>\n<li><code>-printf FORMAT</code>，假设<code>find</code>指令的回传值为<code>ture</code>，就将文件或目录名称列出到标准输出，格式由<code>FORMAT</code>指定</li>\n<li><code>-fprintf FILE FORMAT</code>，类似<code>-printf</code>，格式化输出到文件</li>\n<li><code>-print</code>，假设<code>find</code>指令的回传值为<code>ture</code>，就将文件或目录名称列出到标准输出，格式为每列一个名称</li>\n<li><code>-fprint0 FILE</code>，类似<code>-print0</code>，将输出写入文件</li>\n<li><code>-fprint FILE</code>，类似<code>-print</code>，将输出写入文件</li>\n<li><code>-ls</code>，打印查找结果详细信息</li>\n<li><code>-fls FILE</code>，类似<code>-ls</code>，将输出写入文件</li>\n<li><code>-prune</code>，不寻找字符串作为寻找文件或目录的范本样式</li>\n<li><code>-quit</code>，什么也不打印</li>\n<li><code>-exec COMMAND</code>、<code>-exec COMMAND {} + -ok COMMAND</code>、<code>-execdir COMMAND</code>、<code>-execdir COMMAND {} + -okdir COMMAND</code>，将<code>find</code>出的结果执行其他命令，<code>{}</code>表示find后的集合，在<code>COMMAND</code>后面需要加上<code>\\;</code>来标记<code>COMMAND</code>结束。<code>ok</code>类似<code>exec</code>，在执行<code>COMMAND</code>之前会询问是否执行。</li>\n</ul>\n<p>文件类型：</p>\n<ul>\n<li>b，块设备</li>\n<li>c，字符设备</li>\n<li>d，目录</li>\n<li>p，管道</li>\n<li>f，普通文件</li>\n<li>l，链接文件</li>\n<li>s，套接字</li>\n<li>D，未知</li>\n</ul>\n<p>大小单位：</p>\n<ul>\n<li>b，块（512 字节）</li>\n<li>c，字节</li>\n<li>w，字（2 字节）</li>\n<li>k，千字节</li>\n<li>M，兆字节</li>\n<li>G，吉字节</li>\n</ul>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ul>\n<li><a href=\"https://blog.csdn.net/qq_35246620/article/details/79104520\" target=\"_blank\" rel=\"noopener\">Linux 命令之 find：查找文件</a></li>\n</ul>\n"},{"author":"djaigo","title":"linux-sar命令","img":"https://img-1251474779.cos.ap-beijing.myqcloud.com/linux.png","date":"2020-10-14T11:50:16.000Z","_content":"\n# sar简介\ncentos安装sar命令\n```sh\n➜ yum install sysstat -y\n```\n\n安装后执行sar会报错找不到`/var/log/sa/sa14`文件，需要等几分钟就好了。\n\n```sh\n➜ sar -h\n用法: sar [ 选项 ] [ <时间间隔> [ <次数> ] ]\n主选项和报告：\n\t-b\tI/O 和传输速率信息状况\n\t-B\t分页状况\n\t-d\t块设备状况\n\t-F [ MOUNT ]\n\t\tFilesystems statistics\n\t-H\t交换空间利用率\n\t-I { <中断> | SUM | ALL | XALL }\n\t\t中断信息状况\n\t-m { <关键词> [,...] | ALL }\n\t\t电源管理统计信息\n\t\t关键字:\n\t\tCPU\tCPU 频率\n\t\tFAN\t风扇速度\n\\t\\tFREQ\\tCPU 平均时钟频率\n\t\tIN\t输入电压\n\t\tTEMP\t设备温度\n\\t\\tUSB\\t连接的USB 设备\n\t-n { <关键词> [,...] | ALL }\n\t\t网络统计信息\n\t\t关键词可以是：\n\t\tDEV\t网卡\n\t\tEDEV\t网卡 (错误)\n\t\tNFS\tNFS 客户端\n\t\tNFSD\tNFS 服务器\n\t\tSOCK\tSockets (套接字)\t(v4)\n\t\tIP\tIP 流\t(v4)\n\t\tEIP\tIP 流\t(v4) (错误)\n\t\tICMP\tICMP 流\t(v4)\n\t\tEICMP\tICMP 流\t(v4) (错误)\n\t\tTCP\tTCP 流\t(v4)\n\t\tETCP\tTCP 流\t(v4) (错误)\n\t\tUDP\tUDP 流\t(v4)\n\t\tSOCK6\tSockets (套接字)\t(v6)\n\t\tIP6\tIP 流\t(v6)\n\t\tEIP6\tIP 流\t(v6) (错误)\n\t\tICMP6\tICMP 流\t(v6)\n\t\tEICMP6\tICMP 流\t(v6) (错误)\n\t\tUDP6\tUDP 流\t(v6)\n\t-q\t队列长度和平均负载\n\t-r\t内存利用率\n\t-R\t内存状况\n\t-S\t交换空间利用率\n\t-u [ ALL ]\n\t\tCPU 利用率\n\t-v\tKernel table 状况\n\t-w\t任务创建与系统转换统计信息\n\t-W\t交换信息\n\t-y\tTTY 设备状况\n```\n\n# sar参数\n## 查看CPU使用情况\n当选项为空时则打印CPU使用情况，或使用`sar -u n m`每过n获取一次cpu指标，总共获取m次\n\n指标说明\n* `%user`：用户模式下消耗的CPU时间的比例\n* `%nice`：通过nice改变了进程调度优先级的进程，在用户模式下消耗的CPU时间的比例\n* `%system`：系统模式下消耗的CPU时间的比例\n* `%iowait`：CPU等待磁盘I/O导致空闲状态消耗的时间比例\n* `%steal`：利用Xen等操作系统虚拟化技术，等待其它虚拟CPU计算占用的时间比例\n* `%idle`：CPU空闲时间比例\n\n## 查看内存使用情况\n使用`sar -r n m`可以每过n秒获取一次内存指标，总共获取m次\n\n* `kbmemfree`：这个值和free命令中的free值基本一致,所以它不包括buffer和cache的空间.\n* `kbmemused`：这个值和free命令中的used值基本一致,所以它包括buffer和cache的空间.\n* `%memused`：物理内存使用率，这个值是kbmemused和内存总量(不包括swap)的一个百分比.\n* `kbbuffers`和`kbcached`：这两个值就是free命令中的buffer和cache.\n* `kbcommit`：保证当前系统所需要的内存,即为了确保不溢出而需要的内存(RAM+swap).\n* `%commit`：这个值是kbcommit与内存总量(包括swap)的一个百分比.\n\n## 查看网卡使用情况\n使用`sar -n DEV n m`可以每过n秒获取一次网卡指标，总共获取m次\n\n指标说明\n* `IFACE`：网卡名\n* `rxpck/s`：每秒钟接收的数据包\n* `txpck/s`：每秒钟发送的数据包\n* `rxbyt/s`：每秒钟接收的字节数\n* `txbyt/s`：每秒钟发送的字节数\n* `rxcmp/s`：每秒钟接收的压缩数据包\n* `txcmp/s`：每秒钟发送的压缩数据包\n* `rxmcst/s`：每秒钟接收的多播数据包\n\n`-n`选项下面还有一些子选项，可以更细致的获取相关数据的指标\n\n## 查看系统负载情况\n使用`sar -r n m`可以每过n秒获取一次内存指标，总共获取m次\n\n指标说明\n* `runq-sz`：运行队列的长度（等待运行的进程数）\n* `plist-sz`：进程列表中进程（processes）和线程（threads）的数量\n* `ldavg-1`：最后1分钟的系统平均负载 \n* `ldavg-5`：过去5分钟的系统平均负载\n* `ldavg-15`：过去15分钟的系统平均负载\n\n# 参考文献\n* [12\\. sar 找出系统瓶颈的利器](https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/sar.html)","source":"_posts/linux-sar命令.md","raw":"---\nauthor: djaigo\ntitle: linux-sar命令\nimg: 'https://img-1251474779.cos.ap-beijing.myqcloud.com/linux.png'\ncategories:\n  - linux\ntags:\n  - cmd\n  - command\ndate: 2020-10-14 19:50:16\n---\n\n# sar简介\ncentos安装sar命令\n```sh\n➜ yum install sysstat -y\n```\n\n安装后执行sar会报错找不到`/var/log/sa/sa14`文件，需要等几分钟就好了。\n\n```sh\n➜ sar -h\n用法: sar [ 选项 ] [ <时间间隔> [ <次数> ] ]\n主选项和报告：\n\t-b\tI/O 和传输速率信息状况\n\t-B\t分页状况\n\t-d\t块设备状况\n\t-F [ MOUNT ]\n\t\tFilesystems statistics\n\t-H\t交换空间利用率\n\t-I { <中断> | SUM | ALL | XALL }\n\t\t中断信息状况\n\t-m { <关键词> [,...] | ALL }\n\t\t电源管理统计信息\n\t\t关键字:\n\t\tCPU\tCPU 频率\n\t\tFAN\t风扇速度\n\\t\\tFREQ\\tCPU 平均时钟频率\n\t\tIN\t输入电压\n\t\tTEMP\t设备温度\n\\t\\tUSB\\t连接的USB 设备\n\t-n { <关键词> [,...] | ALL }\n\t\t网络统计信息\n\t\t关键词可以是：\n\t\tDEV\t网卡\n\t\tEDEV\t网卡 (错误)\n\t\tNFS\tNFS 客户端\n\t\tNFSD\tNFS 服务器\n\t\tSOCK\tSockets (套接字)\t(v4)\n\t\tIP\tIP 流\t(v4)\n\t\tEIP\tIP 流\t(v4) (错误)\n\t\tICMP\tICMP 流\t(v4)\n\t\tEICMP\tICMP 流\t(v4) (错误)\n\t\tTCP\tTCP 流\t(v4)\n\t\tETCP\tTCP 流\t(v4) (错误)\n\t\tUDP\tUDP 流\t(v4)\n\t\tSOCK6\tSockets (套接字)\t(v6)\n\t\tIP6\tIP 流\t(v6)\n\t\tEIP6\tIP 流\t(v6) (错误)\n\t\tICMP6\tICMP 流\t(v6)\n\t\tEICMP6\tICMP 流\t(v6) (错误)\n\t\tUDP6\tUDP 流\t(v6)\n\t-q\t队列长度和平均负载\n\t-r\t内存利用率\n\t-R\t内存状况\n\t-S\t交换空间利用率\n\t-u [ ALL ]\n\t\tCPU 利用率\n\t-v\tKernel table 状况\n\t-w\t任务创建与系统转换统计信息\n\t-W\t交换信息\n\t-y\tTTY 设备状况\n```\n\n# sar参数\n## 查看CPU使用情况\n当选项为空时则打印CPU使用情况，或使用`sar -u n m`每过n获取一次cpu指标，总共获取m次\n\n指标说明\n* `%user`：用户模式下消耗的CPU时间的比例\n* `%nice`：通过nice改变了进程调度优先级的进程，在用户模式下消耗的CPU时间的比例\n* `%system`：系统模式下消耗的CPU时间的比例\n* `%iowait`：CPU等待磁盘I/O导致空闲状态消耗的时间比例\n* `%steal`：利用Xen等操作系统虚拟化技术，等待其它虚拟CPU计算占用的时间比例\n* `%idle`：CPU空闲时间比例\n\n## 查看内存使用情况\n使用`sar -r n m`可以每过n秒获取一次内存指标，总共获取m次\n\n* `kbmemfree`：这个值和free命令中的free值基本一致,所以它不包括buffer和cache的空间.\n* `kbmemused`：这个值和free命令中的used值基本一致,所以它包括buffer和cache的空间.\n* `%memused`：物理内存使用率，这个值是kbmemused和内存总量(不包括swap)的一个百分比.\n* `kbbuffers`和`kbcached`：这两个值就是free命令中的buffer和cache.\n* `kbcommit`：保证当前系统所需要的内存,即为了确保不溢出而需要的内存(RAM+swap).\n* `%commit`：这个值是kbcommit与内存总量(包括swap)的一个百分比.\n\n## 查看网卡使用情况\n使用`sar -n DEV n m`可以每过n秒获取一次网卡指标，总共获取m次\n\n指标说明\n* `IFACE`：网卡名\n* `rxpck/s`：每秒钟接收的数据包\n* `txpck/s`：每秒钟发送的数据包\n* `rxbyt/s`：每秒钟接收的字节数\n* `txbyt/s`：每秒钟发送的字节数\n* `rxcmp/s`：每秒钟接收的压缩数据包\n* `txcmp/s`：每秒钟发送的压缩数据包\n* `rxmcst/s`：每秒钟接收的多播数据包\n\n`-n`选项下面还有一些子选项，可以更细致的获取相关数据的指标\n\n## 查看系统负载情况\n使用`sar -r n m`可以每过n秒获取一次内存指标，总共获取m次\n\n指标说明\n* `runq-sz`：运行队列的长度（等待运行的进程数）\n* `plist-sz`：进程列表中进程（processes）和线程（threads）的数量\n* `ldavg-1`：最后1分钟的系统平均负载 \n* `ldavg-5`：过去5分钟的系统平均负载\n* `ldavg-15`：过去15分钟的系统平均负载\n\n# 参考文献\n* [12\\. sar 找出系统瓶颈的利器](https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/sar.html)","slug":"linux-sar命令","published":1,"updated":"2020-10-14T11:50:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh351duz001t19z424gyhnck","content":"<h1 id=\"sar简介\"><a href=\"#sar简介\" class=\"headerlink\" title=\"sar简介\"></a>sar简介</h1><p>centos安装sar命令</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">➜ yum install sysstat -y</code></pre>\n<p>安装后执行sar会报错找不到<code>/var/log/sa/sa14</code>文件，需要等几分钟就好了。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">➜ sar -h\n用法: sar [ 选项 ] [ <时间间隔> [ <次数> ] ]\n主选项和报告：\n    -b    I/O 和传输速率信息状况\n    -B    分页状况\n    -d    块设备状况\n    -F [ MOUNT ]\n        Filesystems statistics\n    -H    交换空间利用率\n    -I { <中断> | SUM | ALL | XALL }\n        中断信息状况\n    -m { <关键词> [,...] | ALL }\n        电源管理统计信息\n        关键字:\n        CPU    CPU 频率\n        FAN    风扇速度\n\\t\\tFREQ\\tCPU 平均时钟频率\n        IN    输入电压\n        TEMP    设备温度\n\\t\\tUSB\\t连接的USB 设备\n    -n { <关键词> [,...] | ALL }\n        网络统计信息\n        关键词可以是：\n        DEV    网卡\n        EDEV    网卡 (错误)\n        NFS    NFS 客户端\n        NFSD    NFS 服务器\n        SOCK    Sockets (套接字)    (v4)\n        IP    IP 流    (v4)\n        EIP    IP 流    (v4) (错误)\n        ICMP    ICMP 流    (v4)\n        EICMP    ICMP 流    (v4) (错误)\n        TCP    TCP 流    (v4)\n        ETCP    TCP 流    (v4) (错误)\n        UDP    UDP 流    (v4)\n        SOCK6    Sockets (套接字)    (v6)\n        IP6    IP 流    (v6)\n        EIP6    IP 流    (v6) (错误)\n        ICMP6    ICMP 流    (v6)\n        EICMP6    ICMP 流    (v6) (错误)\n        UDP6    UDP 流    (v6)\n    -q    队列长度和平均负载\n    -r    内存利用率\n    -R    内存状况\n    -S    交换空间利用率\n    -u [ ALL ]\n        CPU 利用率\n    -v    Kernel table 状况\n    -w    任务创建与系统转换统计信息\n    -W    交换信息\n    -y    TTY 设备状况</code></pre>\n<h1 id=\"sar参数\"><a href=\"#sar参数\" class=\"headerlink\" title=\"sar参数\"></a>sar参数</h1><h2 id=\"查看CPU使用情况\"><a href=\"#查看CPU使用情况\" class=\"headerlink\" title=\"查看CPU使用情况\"></a>查看CPU使用情况</h2><p>当选项为空时则打印CPU使用情况，或使用<code>sar -u n m</code>每过n获取一次cpu指标，总共获取m次</p>\n<p>指标说明</p>\n<ul>\n<li><code>%user</code>：用户模式下消耗的CPU时间的比例</li>\n<li><code>%nice</code>：通过nice改变了进程调度优先级的进程，在用户模式下消耗的CPU时间的比例</li>\n<li><code>%system</code>：系统模式下消耗的CPU时间的比例</li>\n<li><code>%iowait</code>：CPU等待磁盘I/O导致空闲状态消耗的时间比例</li>\n<li><code>%steal</code>：利用Xen等操作系统虚拟化技术，等待其它虚拟CPU计算占用的时间比例</li>\n<li><code>%idle</code>：CPU空闲时间比例</li>\n</ul>\n<h2 id=\"查看内存使用情况\"><a href=\"#查看内存使用情况\" class=\"headerlink\" title=\"查看内存使用情况\"></a>查看内存使用情况</h2><p>使用<code>sar -r n m</code>可以每过n秒获取一次内存指标，总共获取m次</p>\n<ul>\n<li><code>kbmemfree</code>：这个值和free命令中的free值基本一致,所以它不包括buffer和cache的空间.</li>\n<li><code>kbmemused</code>：这个值和free命令中的used值基本一致,所以它包括buffer和cache的空间.</li>\n<li><code>%memused</code>：物理内存使用率，这个值是kbmemused和内存总量(不包括swap)的一个百分比.</li>\n<li><code>kbbuffers</code>和<code>kbcached</code>：这两个值就是free命令中的buffer和cache.</li>\n<li><code>kbcommit</code>：保证当前系统所需要的内存,即为了确保不溢出而需要的内存(RAM+swap).</li>\n<li><code>%commit</code>：这个值是kbcommit与内存总量(包括swap)的一个百分比.</li>\n</ul>\n<h2 id=\"查看网卡使用情况\"><a href=\"#查看网卡使用情况\" class=\"headerlink\" title=\"查看网卡使用情况\"></a>查看网卡使用情况</h2><p>使用<code>sar -n DEV n m</code>可以每过n秒获取一次网卡指标，总共获取m次</p>\n<p>指标说明</p>\n<ul>\n<li><code>IFACE</code>：网卡名</li>\n<li><code>rxpck/s</code>：每秒钟接收的数据包</li>\n<li><code>txpck/s</code>：每秒钟发送的数据包</li>\n<li><code>rxbyt/s</code>：每秒钟接收的字节数</li>\n<li><code>txbyt/s</code>：每秒钟发送的字节数</li>\n<li><code>rxcmp/s</code>：每秒钟接收的压缩数据包</li>\n<li><code>txcmp/s</code>：每秒钟发送的压缩数据包</li>\n<li><code>rxmcst/s</code>：每秒钟接收的多播数据包</li>\n</ul>\n<p><code>-n</code>选项下面还有一些子选项，可以更细致的获取相关数据的指标</p>\n<h2 id=\"查看系统负载情况\"><a href=\"#查看系统负载情况\" class=\"headerlink\" title=\"查看系统负载情况\"></a>查看系统负载情况</h2><p>使用<code>sar -r n m</code>可以每过n秒获取一次内存指标，总共获取m次</p>\n<p>指标说明</p>\n<ul>\n<li><code>runq-sz</code>：运行队列的长度（等待运行的进程数）</li>\n<li><code>plist-sz</code>：进程列表中进程（processes）和线程（threads）的数量</li>\n<li><code>ldavg-1</code>：最后1分钟的系统平均负载 </li>\n<li><code>ldavg-5</code>：过去5分钟的系统平均负载</li>\n<li><code>ldavg-15</code>：过去15分钟的系统平均负载</li>\n</ul>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ul>\n<li><a href=\"https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/sar.html\" target=\"_blank\" rel=\"noopener\">12. sar 找出系统瓶颈的利器</a></li>\n</ul>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"friends":[{"avatar":"https://img-1251474779.cos.ap-beijing.myqcloud.com/icon.png","name":"djaigo","introduction":"好好学习，天天向上","url":"/","title":"前去学习"},{"avatar":"https://awps-assets.meituan.net/mit/blog/v20190629/asset/icon/favicon.ico?v=Whistle&t=20181017-1r","name":"美团技术团队","introduction":"一行代码，亿万生活。","url":"https://tech.meituan.com/","title":"点个外卖-->"},{"avatar":"","name":"鸟窝","introduction":"rpcx作者","url":"https://colobu.com/","title":"进个鸟窝-->"},{"avatar":"https://d1j8pt39hxlh3d.cloudfront.net/emoji/emojione/5.0/png/unicode/32/1f92a.png","name":"labuladong的算法小抄","introduction":"算法大神","url":"https://labuladong.gitbook.io/algo/","title":"学个算法-->"}]}},"excerpt":"","more":"<h1 id=\"sar简介\"><a href=\"#sar简介\" class=\"headerlink\" title=\"sar简介\"></a>sar简介</h1><p>centos安装sar命令</p>\n<pre><code class=\"sh\">➜ yum install sysstat -y</code></pre>\n<p>安装后执行sar会报错找不到<code>/var/log/sa/sa14</code>文件，需要等几分钟就好了。</p>\n<pre><code class=\"sh\">➜ sar -h\n用法: sar [ 选项 ] [ &lt;时间间隔&gt; [ &lt;次数&gt; ] ]\n主选项和报告：\n    -b    I/O 和传输速率信息状况\n    -B    分页状况\n    -d    块设备状况\n    -F [ MOUNT ]\n        Filesystems statistics\n    -H    交换空间利用率\n    -I { &lt;中断&gt; | SUM | ALL | XALL }\n        中断信息状况\n    -m { &lt;关键词&gt; [,...] | ALL }\n        电源管理统计信息\n        关键字:\n        CPU    CPU 频率\n        FAN    风扇速度\n\\t\\tFREQ\\tCPU 平均时钟频率\n        IN    输入电压\n        TEMP    设备温度\n\\t\\tUSB\\t连接的USB 设备\n    -n { &lt;关键词&gt; [,...] | ALL }\n        网络统计信息\n        关键词可以是：\n        DEV    网卡\n        EDEV    网卡 (错误)\n        NFS    NFS 客户端\n        NFSD    NFS 服务器\n        SOCK    Sockets (套接字)    (v4)\n        IP    IP 流    (v4)\n        EIP    IP 流    (v4) (错误)\n        ICMP    ICMP 流    (v4)\n        EICMP    ICMP 流    (v4) (错误)\n        TCP    TCP 流    (v4)\n        ETCP    TCP 流    (v4) (错误)\n        UDP    UDP 流    (v4)\n        SOCK6    Sockets (套接字)    (v6)\n        IP6    IP 流    (v6)\n        EIP6    IP 流    (v6) (错误)\n        ICMP6    ICMP 流    (v6)\n        EICMP6    ICMP 流    (v6) (错误)\n        UDP6    UDP 流    (v6)\n    -q    队列长度和平均负载\n    -r    内存利用率\n    -R    内存状况\n    -S    交换空间利用率\n    -u [ ALL ]\n        CPU 利用率\n    -v    Kernel table 状况\n    -w    任务创建与系统转换统计信息\n    -W    交换信息\n    -y    TTY 设备状况</code></pre>\n<h1 id=\"sar参数\"><a href=\"#sar参数\" class=\"headerlink\" title=\"sar参数\"></a>sar参数</h1><h2 id=\"查看CPU使用情况\"><a href=\"#查看CPU使用情况\" class=\"headerlink\" title=\"查看CPU使用情况\"></a>查看CPU使用情况</h2><p>当选项为空时则打印CPU使用情况，或使用<code>sar -u n m</code>每过n获取一次cpu指标，总共获取m次</p>\n<p>指标说明</p>\n<ul>\n<li><code>%user</code>：用户模式下消耗的CPU时间的比例</li>\n<li><code>%nice</code>：通过nice改变了进程调度优先级的进程，在用户模式下消耗的CPU时间的比例</li>\n<li><code>%system</code>：系统模式下消耗的CPU时间的比例</li>\n<li><code>%iowait</code>：CPU等待磁盘I/O导致空闲状态消耗的时间比例</li>\n<li><code>%steal</code>：利用Xen等操作系统虚拟化技术，等待其它虚拟CPU计算占用的时间比例</li>\n<li><code>%idle</code>：CPU空闲时间比例</li>\n</ul>\n<h2 id=\"查看内存使用情况\"><a href=\"#查看内存使用情况\" class=\"headerlink\" title=\"查看内存使用情况\"></a>查看内存使用情况</h2><p>使用<code>sar -r n m</code>可以每过n秒获取一次内存指标，总共获取m次</p>\n<ul>\n<li><code>kbmemfree</code>：这个值和free命令中的free值基本一致,所以它不包括buffer和cache的空间.</li>\n<li><code>kbmemused</code>：这个值和free命令中的used值基本一致,所以它包括buffer和cache的空间.</li>\n<li><code>%memused</code>：物理内存使用率，这个值是kbmemused和内存总量(不包括swap)的一个百分比.</li>\n<li><code>kbbuffers</code>和<code>kbcached</code>：这两个值就是free命令中的buffer和cache.</li>\n<li><code>kbcommit</code>：保证当前系统所需要的内存,即为了确保不溢出而需要的内存(RAM+swap).</li>\n<li><code>%commit</code>：这个值是kbcommit与内存总量(包括swap)的一个百分比.</li>\n</ul>\n<h2 id=\"查看网卡使用情况\"><a href=\"#查看网卡使用情况\" class=\"headerlink\" title=\"查看网卡使用情况\"></a>查看网卡使用情况</h2><p>使用<code>sar -n DEV n m</code>可以每过n秒获取一次网卡指标，总共获取m次</p>\n<p>指标说明</p>\n<ul>\n<li><code>IFACE</code>：网卡名</li>\n<li><code>rxpck/s</code>：每秒钟接收的数据包</li>\n<li><code>txpck/s</code>：每秒钟发送的数据包</li>\n<li><code>rxbyt/s</code>：每秒钟接收的字节数</li>\n<li><code>txbyt/s</code>：每秒钟发送的字节数</li>\n<li><code>rxcmp/s</code>：每秒钟接收的压缩数据包</li>\n<li><code>txcmp/s</code>：每秒钟发送的压缩数据包</li>\n<li><code>rxmcst/s</code>：每秒钟接收的多播数据包</li>\n</ul>\n<p><code>-n</code>选项下面还有一些子选项，可以更细致的获取相关数据的指标</p>\n<h2 id=\"查看系统负载情况\"><a href=\"#查看系统负载情况\" class=\"headerlink\" title=\"查看系统负载情况\"></a>查看系统负载情况</h2><p>使用<code>sar -r n m</code>可以每过n秒获取一次内存指标，总共获取m次</p>\n<p>指标说明</p>\n<ul>\n<li><code>runq-sz</code>：运行队列的长度（等待运行的进程数）</li>\n<li><code>plist-sz</code>：进程列表中进程（processes）和线程（threads）的数量</li>\n<li><code>ldavg-1</code>：最后1分钟的系统平均负载 </li>\n<li><code>ldavg-5</code>：过去5分钟的系统平均负载</li>\n<li><code>ldavg-15</code>：过去15分钟的系统平均负载</li>\n</ul>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ul>\n<li><a href=\"https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/sar.html\" target=\"_blank\" rel=\"noopener\">12. sar 找出系统瓶颈的利器</a></li>\n</ul>\n"},{"author":"djaigo","title":"linux sort命令","img":"https://img-1251474779.cos.ap-beijing.myqcloud.com/linux.png","date":"2019-12-23T09:17:47.000Z","_content":"\n# 简介\nsort命令是将制定文件内容以行为单位进行ASCII码值排序，最后将他们按升序输出。\nsort的帮助文档：\n```text\nsort --help\n用法：sort [选项]... [文件]...\n　或：sort [选项]... --files0-from=F\nWrite sorted concatenation of all FILE(s) to standard output.\n\nMandatory arguments to long options are mandatory for short options too.\n排序选项：\n\n  -b, --ignore-leading-blanks\t忽略前导的空白区域\n  -d, --dictionary-order\t只考虑空白区域和字母字符\n  -f, --ignore-case\t\t忽略字母大小写\n  -g, --general-numeric-sort  compare according to general numerical value\n  -i, --ignore-nonprinting    consider only printable characters\n  -M, --month-sort            compare (unknown) < 'JAN' < ... < 'DEC'\n  -h, --human-numeric-sort    使用易读性数字(例如： 2K 1G)\n  -n, --numeric-sort\t\t根据字符串数值比较\n  -R, --random-sort\t\t根据随机hash 排序\n      --random-source=文件\t从指定文件中获得随机字节\n  -r, --reverse\t\t\t逆序输出排序结果\n      --sort=WORD\t\t按照WORD 指定的格式排序：\n\t\t\t\t\t一般数字-g，高可读性-h，月份-M，数字-n，\n\t\t\t\t\t随机-R，版本-V\n  -V, --version-sort\t\t在文本内进行自然版本排序\n\n其他选项：\n\n      --batch-size=NMERGE\t一次最多合并NMERGE 个输入；如果输入更多\n\t\t\t\t\t则使用临时文件\n  -c, --check, --check=diagnose-first\t检查输入是否已排序，若已有序则不进行操作\n  -C, --check=quiet, --check=silent\t类似-c，但不报告第一个无序行\n      --compress-program=程序\t使用指定程序压缩临时文件；使用该程序\n\t\t\t\t\t的-d 参数解压缩文件\n      --debug\t\t\t为用于排序的行添加注释，并将有可能有问题的\n\t\t\t\t\t用法输出到标准错误输出\n      --files0-from=文件\t从指定文件读取以NUL 终止的名称，如果该文件被\n\t\t\t\t\t指定为\"-\"则从标准输入读文件名\n  -k, --key=KEYDEF          sort via a key; KEYDEF gives location and type\n  -m, --merge               merge already sorted files; do not sort\n  -o, --output=文件\t\t将结果写入到文件而非标准输出\n  -s, --stable\t\t\t禁用last-resort 比较以稳定比较算法\n  -S, --buffer-size=大小\t指定主内存缓存大小\n  -t, --field-separator=分隔符\t使用指定的分隔符代替非空格到空格的转换\n  -T, --temporary-directory=目录\t使用指定目录而非$TMPDIR 或/tmp 作为\n\t\t\t\t\t临时目录，可用多个选项指定多个目录\n      --parallel=N\t\t将同时运行的排序数改变为N\n  -u, --unique\t\t配合-c，严格校验排序；不配合-c，则只输出一次排序结果\n  -z, --zero-terminated\t以0 字节而非新行作为行尾标志\n      --help\t\t显示此帮助信息并退出\n      --version\t\t显示版本信息并退出\n\nKEYDEF is F[.C][OPTS][,F[.C][OPTS]] for start and stop position, where F is a\nfield number and C a character position in the field; both are origin 1, and\nthe stop position defaults to the line's end.  If neither -t nor -b is in\neffect, characters in a field are counted from the beginning of the preceding\nwhitespace.  OPTS is one or more single-letter ordering options [bdfgiMhnRrV],\nwhich override global ordering options for that key.  If no key is given, use\nthe entire line as the key.\n\nSIZE may be followed by the following multiplicative suffixes:\n内存使用率% 1%，b 1、K 1024 (默认)，M、G、T、P、E、Z、Y 等依此类推。\n\n如果不指定文件，或者文件为\"-\"，则从标准输入读取数据。\n\n*** 警告 ***\n本地环境变量会影响排序结果。\n如果希望以字节的自然值获得最传统的排序结果，请设置LC_ALL=C。\n```\n\n# 常用命令\n## -b 忽略前置空白字符\n\n## -c 检查是否已排序\n\n## -f 忽略大小写\n\n\n## -M 按月份排序\n\n## -n 数值排序\n由于sort采用的是ASCII码值排序只会导致100在11之前，如果有需要将其数值排序可以使用-n选项，sort也只会比较最开始一直是数值的字符。\n示例：\n```sh\n➜ seq 20 | sort\n1\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n2\n20\n3\n4\n5\n6\n7\n8\n9\n\n➜ seq 20 | sort -n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n```\n\n## -o 输出重定向\nsort默认输出位置是标准输出，可以使用-o重定向输出位置。\n\n\n## -t -k 列项排序\nsort支持列项排序，即对相同列项进行排序，以当前列项值为排序的索引，排序所有行。\n-t指定列项分隔符，默认是空白字符，-k指定按照分隔符划分出的第几列。\n示例：\n```sh\n➜ netstat -an | grep tcp | awk '{print $1,$2,$3,$6}' | sort -k4\ntcp 0 0 ESTABLISHED\ntcp 0 0 ESTABLISHED\ntcp 0 0 ESTABLISHED\ntcp 0 0 ESTABLISHED\ntcp 0 0 ESTABLISHED\ntcp 0 140 ESTABLISHED\ntcp6 0 0 ESTABLISHED\ntcp6 0 0 ESTABLISHED\ntcp 0 0 LISTEN\ntcp 0 0 LISTEN\ntcp 0 0 LISTEN\ntcp6 0 0 LISTEN\ntcp6 0 0 LISTEN\ntcp6 0 0 LISTEN\ntcp 0 0 TIME_WAIT\ntcp 0 0 TIME_WAIT\ntcp 0 0 TIME_WAIT\ntcp 0 0 TIME_WAIT\n```\n\n\n## -r 逆序\nsort默认输出是升序，如果我们需要降序就可以利用-r参数。\n示例：\n```sh\n➜ seq 9 | sort -r\n9\n8\n7\n6\n5\n4\n3\n2\n1\n```\n\n\n## -R 随机排序\n乱序。\n```sh\n➜ seq 9 | sort -R\n1\n6\n8\n5\n4\n9\n7\n2\n3\n```\n\n\n## -u 去重\nsort排序内容如果有很多重复行，可以使用去重，排序后，在输出行中去除重复行。\n\n\n","source":"_posts/linux-sort命令.md","raw":"---\nauthor: djaigo\ntitle: linux sort命令\nimg: 'https://img-1251474779.cos.ap-beijing.myqcloud.com/linux.png'\ncategories:\n  - linux\ntags:\n  - cmd\n  - command\ndate: 2019-12-23 17:17:47\n---\n\n# 简介\nsort命令是将制定文件内容以行为单位进行ASCII码值排序，最后将他们按升序输出。\nsort的帮助文档：\n```text\nsort --help\n用法：sort [选项]... [文件]...\n　或：sort [选项]... --files0-from=F\nWrite sorted concatenation of all FILE(s) to standard output.\n\nMandatory arguments to long options are mandatory for short options too.\n排序选项：\n\n  -b, --ignore-leading-blanks\t忽略前导的空白区域\n  -d, --dictionary-order\t只考虑空白区域和字母字符\n  -f, --ignore-case\t\t忽略字母大小写\n  -g, --general-numeric-sort  compare according to general numerical value\n  -i, --ignore-nonprinting    consider only printable characters\n  -M, --month-sort            compare (unknown) < 'JAN' < ... < 'DEC'\n  -h, --human-numeric-sort    使用易读性数字(例如： 2K 1G)\n  -n, --numeric-sort\t\t根据字符串数值比较\n  -R, --random-sort\t\t根据随机hash 排序\n      --random-source=文件\t从指定文件中获得随机字节\n  -r, --reverse\t\t\t逆序输出排序结果\n      --sort=WORD\t\t按照WORD 指定的格式排序：\n\t\t\t\t\t一般数字-g，高可读性-h，月份-M，数字-n，\n\t\t\t\t\t随机-R，版本-V\n  -V, --version-sort\t\t在文本内进行自然版本排序\n\n其他选项：\n\n      --batch-size=NMERGE\t一次最多合并NMERGE 个输入；如果输入更多\n\t\t\t\t\t则使用临时文件\n  -c, --check, --check=diagnose-first\t检查输入是否已排序，若已有序则不进行操作\n  -C, --check=quiet, --check=silent\t类似-c，但不报告第一个无序行\n      --compress-program=程序\t使用指定程序压缩临时文件；使用该程序\n\t\t\t\t\t的-d 参数解压缩文件\n      --debug\t\t\t为用于排序的行添加注释，并将有可能有问题的\n\t\t\t\t\t用法输出到标准错误输出\n      --files0-from=文件\t从指定文件读取以NUL 终止的名称，如果该文件被\n\t\t\t\t\t指定为\"-\"则从标准输入读文件名\n  -k, --key=KEYDEF          sort via a key; KEYDEF gives location and type\n  -m, --merge               merge already sorted files; do not sort\n  -o, --output=文件\t\t将结果写入到文件而非标准输出\n  -s, --stable\t\t\t禁用last-resort 比较以稳定比较算法\n  -S, --buffer-size=大小\t指定主内存缓存大小\n  -t, --field-separator=分隔符\t使用指定的分隔符代替非空格到空格的转换\n  -T, --temporary-directory=目录\t使用指定目录而非$TMPDIR 或/tmp 作为\n\t\t\t\t\t临时目录，可用多个选项指定多个目录\n      --parallel=N\t\t将同时运行的排序数改变为N\n  -u, --unique\t\t配合-c，严格校验排序；不配合-c，则只输出一次排序结果\n  -z, --zero-terminated\t以0 字节而非新行作为行尾标志\n      --help\t\t显示此帮助信息并退出\n      --version\t\t显示版本信息并退出\n\nKEYDEF is F[.C][OPTS][,F[.C][OPTS]] for start and stop position, where F is a\nfield number and C a character position in the field; both are origin 1, and\nthe stop position defaults to the line's end.  If neither -t nor -b is in\neffect, characters in a field are counted from the beginning of the preceding\nwhitespace.  OPTS is one or more single-letter ordering options [bdfgiMhnRrV],\nwhich override global ordering options for that key.  If no key is given, use\nthe entire line as the key.\n\nSIZE may be followed by the following multiplicative suffixes:\n内存使用率% 1%，b 1、K 1024 (默认)，M、G、T、P、E、Z、Y 等依此类推。\n\n如果不指定文件，或者文件为\"-\"，则从标准输入读取数据。\n\n*** 警告 ***\n本地环境变量会影响排序结果。\n如果希望以字节的自然值获得最传统的排序结果，请设置LC_ALL=C。\n```\n\n# 常用命令\n## -b 忽略前置空白字符\n\n## -c 检查是否已排序\n\n## -f 忽略大小写\n\n\n## -M 按月份排序\n\n## -n 数值排序\n由于sort采用的是ASCII码值排序只会导致100在11之前，如果有需要将其数值排序可以使用-n选项，sort也只会比较最开始一直是数值的字符。\n示例：\n```sh\n➜ seq 20 | sort\n1\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n2\n20\n3\n4\n5\n6\n7\n8\n9\n\n➜ seq 20 | sort -n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n```\n\n## -o 输出重定向\nsort默认输出位置是标准输出，可以使用-o重定向输出位置。\n\n\n## -t -k 列项排序\nsort支持列项排序，即对相同列项进行排序，以当前列项值为排序的索引，排序所有行。\n-t指定列项分隔符，默认是空白字符，-k指定按照分隔符划分出的第几列。\n示例：\n```sh\n➜ netstat -an | grep tcp | awk '{print $1,$2,$3,$6}' | sort -k4\ntcp 0 0 ESTABLISHED\ntcp 0 0 ESTABLISHED\ntcp 0 0 ESTABLISHED\ntcp 0 0 ESTABLISHED\ntcp 0 0 ESTABLISHED\ntcp 0 140 ESTABLISHED\ntcp6 0 0 ESTABLISHED\ntcp6 0 0 ESTABLISHED\ntcp 0 0 LISTEN\ntcp 0 0 LISTEN\ntcp 0 0 LISTEN\ntcp6 0 0 LISTEN\ntcp6 0 0 LISTEN\ntcp6 0 0 LISTEN\ntcp 0 0 TIME_WAIT\ntcp 0 0 TIME_WAIT\ntcp 0 0 TIME_WAIT\ntcp 0 0 TIME_WAIT\n```\n\n\n## -r 逆序\nsort默认输出是升序，如果我们需要降序就可以利用-r参数。\n示例：\n```sh\n➜ seq 9 | sort -r\n9\n8\n7\n6\n5\n4\n3\n2\n1\n```\n\n\n## -R 随机排序\n乱序。\n```sh\n➜ seq 9 | sort -R\n1\n6\n8\n5\n4\n9\n7\n2\n3\n```\n\n\n## -u 去重\nsort排序内容如果有很多重复行，可以使用去重，排序后，在输出行中去除重复行。\n\n\n","slug":"linux-sort命令","published":1,"updated":"2019-12-23T09:17:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh351dv0001v19z42qmc2wgl","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>sort命令是将制定文件内容以行为单位进行ASCII码值排序，最后将他们按升序输出。<br>sort的帮助文档：</p>\n<pre class=\" language-text\"><code class=\"language-text\">sort --help\n用法：sort [选项]... [文件]...\n　或：sort [选项]... --files0-from=F\nWrite sorted concatenation of all FILE(s) to standard output.\n\nMandatory arguments to long options are mandatory for short options too.\n排序选项：\n\n  -b, --ignore-leading-blanks    忽略前导的空白区域\n  -d, --dictionary-order    只考虑空白区域和字母字符\n  -f, --ignore-case        忽略字母大小写\n  -g, --general-numeric-sort  compare according to general numerical value\n  -i, --ignore-nonprinting    consider only printable characters\n  -M, --month-sort            compare (unknown) < 'JAN' < ... < 'DEC'\n  -h, --human-numeric-sort    使用易读性数字(例如： 2K 1G)\n  -n, --numeric-sort        根据字符串数值比较\n  -R, --random-sort        根据随机hash 排序\n      --random-source=文件    从指定文件中获得随机字节\n  -r, --reverse            逆序输出排序结果\n      --sort=WORD        按照WORD 指定的格式排序：\n                    一般数字-g，高可读性-h，月份-M，数字-n，\n                    随机-R，版本-V\n  -V, --version-sort        在文本内进行自然版本排序\n\n其他选项：\n\n      --batch-size=NMERGE    一次最多合并NMERGE 个输入；如果输入更多\n                    则使用临时文件\n  -c, --check, --check=diagnose-first    检查输入是否已排序，若已有序则不进行操作\n  -C, --check=quiet, --check=silent    类似-c，但不报告第一个无序行\n      --compress-program=程序    使用指定程序压缩临时文件；使用该程序\n                    的-d 参数解压缩文件\n      --debug            为用于排序的行添加注释，并将有可能有问题的\n                    用法输出到标准错误输出\n      --files0-from=文件    从指定文件读取以NUL 终止的名称，如果该文件被\n                    指定为\"-\"则从标准输入读文件名\n  -k, --key=KEYDEF          sort via a key; KEYDEF gives location and type\n  -m, --merge               merge already sorted files; do not sort\n  -o, --output=文件        将结果写入到文件而非标准输出\n  -s, --stable            禁用last-resort 比较以稳定比较算法\n  -S, --buffer-size=大小    指定主内存缓存大小\n  -t, --field-separator=分隔符    使用指定的分隔符代替非空格到空格的转换\n  -T, --temporary-directory=目录    使用指定目录而非$TMPDIR 或/tmp 作为\n                    临时目录，可用多个选项指定多个目录\n      --parallel=N        将同时运行的排序数改变为N\n  -u, --unique        配合-c，严格校验排序；不配合-c，则只输出一次排序结果\n  -z, --zero-terminated    以0 字节而非新行作为行尾标志\n      --help        显示此帮助信息并退出\n      --version        显示版本信息并退出\n\nKEYDEF is F[.C][OPTS][,F[.C][OPTS]] for start and stop position, where F is a\nfield number and C a character position in the field; both are origin 1, and\nthe stop position defaults to the line's end.  If neither -t nor -b is in\neffect, characters in a field are counted from the beginning of the preceding\nwhitespace.  OPTS is one or more single-letter ordering options [bdfgiMhnRrV],\nwhich override global ordering options for that key.  If no key is given, use\nthe entire line as the key.\n\nSIZE may be followed by the following multiplicative suffixes:\n内存使用率% 1%，b 1、K 1024 (默认)，M、G、T、P、E、Z、Y 等依此类推。\n\n如果不指定文件，或者文件为\"-\"，则从标准输入读取数据。\n\n*** 警告 ***\n本地环境变量会影响排序结果。\n如果希望以字节的自然值获得最传统的排序结果，请设置LC_ALL=C。</code></pre>\n<h1 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h1><h2 id=\"b-忽略前置空白字符\"><a href=\"#b-忽略前置空白字符\" class=\"headerlink\" title=\"-b 忽略前置空白字符\"></a>-b 忽略前置空白字符</h2><h2 id=\"c-检查是否已排序\"><a href=\"#c-检查是否已排序\" class=\"headerlink\" title=\"-c 检查是否已排序\"></a>-c 检查是否已排序</h2><h2 id=\"f-忽略大小写\"><a href=\"#f-忽略大小写\" class=\"headerlink\" title=\"-f 忽略大小写\"></a>-f 忽略大小写</h2><h2 id=\"M-按月份排序\"><a href=\"#M-按月份排序\" class=\"headerlink\" title=\"-M 按月份排序\"></a>-M 按月份排序</h2><h2 id=\"n-数值排序\"><a href=\"#n-数值排序\" class=\"headerlink\" title=\"-n 数值排序\"></a>-n 数值排序</h2><p>由于sort采用的是ASCII码值排序只会导致100在11之前，如果有需要将其数值排序可以使用-n选项，sort也只会比较最开始一直是数值的字符。<br>示例：</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">➜ seq 20 | sort\n1\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n2\n20\n3\n4\n5\n6\n7\n8\n9\n\n➜ seq 20 | sort -n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20</code></pre>\n<h2 id=\"o-输出重定向\"><a href=\"#o-输出重定向\" class=\"headerlink\" title=\"-o 输出重定向\"></a>-o 输出重定向</h2><p>sort默认输出位置是标准输出，可以使用-o重定向输出位置。</p>\n<h2 id=\"t-k-列项排序\"><a href=\"#t-k-列项排序\" class=\"headerlink\" title=\"-t -k 列项排序\"></a>-t -k 列项排序</h2><p>sort支持列项排序，即对相同列项进行排序，以当前列项值为排序的索引，排序所有行。<br>-t指定列项分隔符，默认是空白字符，-k指定按照分隔符划分出的第几列。<br>示例：</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">➜ netstat -an | grep tcp | awk '{print $1,$2,$3,$6}' | sort -k4\ntcp 0 0 ESTABLISHED\ntcp 0 0 ESTABLISHED\ntcp 0 0 ESTABLISHED\ntcp 0 0 ESTABLISHED\ntcp 0 0 ESTABLISHED\ntcp 0 140 ESTABLISHED\ntcp6 0 0 ESTABLISHED\ntcp6 0 0 ESTABLISHED\ntcp 0 0 LISTEN\ntcp 0 0 LISTEN\ntcp 0 0 LISTEN\ntcp6 0 0 LISTEN\ntcp6 0 0 LISTEN\ntcp6 0 0 LISTEN\ntcp 0 0 TIME_WAIT\ntcp 0 0 TIME_WAIT\ntcp 0 0 TIME_WAIT\ntcp 0 0 TIME_WAIT</code></pre>\n<h2 id=\"r-逆序\"><a href=\"#r-逆序\" class=\"headerlink\" title=\"-r 逆序\"></a>-r 逆序</h2><p>sort默认输出是升序，如果我们需要降序就可以利用-r参数。<br>示例：</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">➜ seq 9 | sort -r\n9\n8\n7\n6\n5\n4\n3\n2\n1</code></pre>\n<h2 id=\"R-随机排序\"><a href=\"#R-随机排序\" class=\"headerlink\" title=\"-R 随机排序\"></a>-R 随机排序</h2><p>乱序。</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">➜ seq 9 | sort -R\n1\n6\n8\n5\n4\n9\n7\n2\n3</code></pre>\n<h2 id=\"u-去重\"><a href=\"#u-去重\" class=\"headerlink\" title=\"-u 去重\"></a>-u 去重</h2><p>sort排序内容如果有很多重复行，可以使用去重，排序后，在输出行中去除重复行。</p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"friends":[{"avatar":"https://img-1251474779.cos.ap-beijing.myqcloud.com/icon.png","name":"djaigo","introduction":"好好学习，天天向上","url":"/","title":"前去学习"},{"avatar":"https://awps-assets.meituan.net/mit/blog/v20190629/asset/icon/favicon.ico?v=Whistle&t=20181017-1r","name":"美团技术团队","introduction":"一行代码，亿万生活。","url":"https://tech.meituan.com/","title":"点个外卖-->"},{"avatar":"","name":"鸟窝","introduction":"rpcx作者","url":"https://colobu.com/","title":"进个鸟窝-->"},{"avatar":"https://d1j8pt39hxlh3d.cloudfront.net/emoji/emojione/5.0/png/unicode/32/1f92a.png","name":"labuladong的算法小抄","introduction":"算法大神","url":"https://labuladong.gitbook.io/algo/","title":"学个算法-->"}]}},"excerpt":"","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>sort命令是将制定文件内容以行为单位进行ASCII码值排序，最后将他们按升序输出。<br>sort的帮助文档：</p>\n<pre><code class=\"text\">sort --help\n用法：sort [选项]... [文件]...\n　或：sort [选项]... --files0-from=F\nWrite sorted concatenation of all FILE(s) to standard output.\n\nMandatory arguments to long options are mandatory for short options too.\n排序选项：\n\n  -b, --ignore-leading-blanks    忽略前导的空白区域\n  -d, --dictionary-order    只考虑空白区域和字母字符\n  -f, --ignore-case        忽略字母大小写\n  -g, --general-numeric-sort  compare according to general numerical value\n  -i, --ignore-nonprinting    consider only printable characters\n  -M, --month-sort            compare (unknown) &lt; &#39;JAN&#39; &lt; ... &lt; &#39;DEC&#39;\n  -h, --human-numeric-sort    使用易读性数字(例如： 2K 1G)\n  -n, --numeric-sort        根据字符串数值比较\n  -R, --random-sort        根据随机hash 排序\n      --random-source=文件    从指定文件中获得随机字节\n  -r, --reverse            逆序输出排序结果\n      --sort=WORD        按照WORD 指定的格式排序：\n                    一般数字-g，高可读性-h，月份-M，数字-n，\n                    随机-R，版本-V\n  -V, --version-sort        在文本内进行自然版本排序\n\n其他选项：\n\n      --batch-size=NMERGE    一次最多合并NMERGE 个输入；如果输入更多\n                    则使用临时文件\n  -c, --check, --check=diagnose-first    检查输入是否已排序，若已有序则不进行操作\n  -C, --check=quiet, --check=silent    类似-c，但不报告第一个无序行\n      --compress-program=程序    使用指定程序压缩临时文件；使用该程序\n                    的-d 参数解压缩文件\n      --debug            为用于排序的行添加注释，并将有可能有问题的\n                    用法输出到标准错误输出\n      --files0-from=文件    从指定文件读取以NUL 终止的名称，如果该文件被\n                    指定为&quot;-&quot;则从标准输入读文件名\n  -k, --key=KEYDEF          sort via a key; KEYDEF gives location and type\n  -m, --merge               merge already sorted files; do not sort\n  -o, --output=文件        将结果写入到文件而非标准输出\n  -s, --stable            禁用last-resort 比较以稳定比较算法\n  -S, --buffer-size=大小    指定主内存缓存大小\n  -t, --field-separator=分隔符    使用指定的分隔符代替非空格到空格的转换\n  -T, --temporary-directory=目录    使用指定目录而非$TMPDIR 或/tmp 作为\n                    临时目录，可用多个选项指定多个目录\n      --parallel=N        将同时运行的排序数改变为N\n  -u, --unique        配合-c，严格校验排序；不配合-c，则只输出一次排序结果\n  -z, --zero-terminated    以0 字节而非新行作为行尾标志\n      --help        显示此帮助信息并退出\n      --version        显示版本信息并退出\n\nKEYDEF is F[.C][OPTS][,F[.C][OPTS]] for start and stop position, where F is a\nfield number and C a character position in the field; both are origin 1, and\nthe stop position defaults to the line&#39;s end.  If neither -t nor -b is in\neffect, characters in a field are counted from the beginning of the preceding\nwhitespace.  OPTS is one or more single-letter ordering options [bdfgiMhnRrV],\nwhich override global ordering options for that key.  If no key is given, use\nthe entire line as the key.\n\nSIZE may be followed by the following multiplicative suffixes:\n内存使用率% 1%，b 1、K 1024 (默认)，M、G、T、P、E、Z、Y 等依此类推。\n\n如果不指定文件，或者文件为&quot;-&quot;，则从标准输入读取数据。\n\n*** 警告 ***\n本地环境变量会影响排序结果。\n如果希望以字节的自然值获得最传统的排序结果，请设置LC_ALL=C。</code></pre>\n<h1 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h1><h2 id=\"b-忽略前置空白字符\"><a href=\"#b-忽略前置空白字符\" class=\"headerlink\" title=\"-b 忽略前置空白字符\"></a>-b 忽略前置空白字符</h2><h2 id=\"c-检查是否已排序\"><a href=\"#c-检查是否已排序\" class=\"headerlink\" title=\"-c 检查是否已排序\"></a>-c 检查是否已排序</h2><h2 id=\"f-忽略大小写\"><a href=\"#f-忽略大小写\" class=\"headerlink\" title=\"-f 忽略大小写\"></a>-f 忽略大小写</h2><h2 id=\"M-按月份排序\"><a href=\"#M-按月份排序\" class=\"headerlink\" title=\"-M 按月份排序\"></a>-M 按月份排序</h2><h2 id=\"n-数值排序\"><a href=\"#n-数值排序\" class=\"headerlink\" title=\"-n 数值排序\"></a>-n 数值排序</h2><p>由于sort采用的是ASCII码值排序只会导致100在11之前，如果有需要将其数值排序可以使用-n选项，sort也只会比较最开始一直是数值的字符。<br>示例：</p>\n<pre><code class=\"sh\">➜ seq 20 | sort\n1\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n2\n20\n3\n4\n5\n6\n7\n8\n9\n\n➜ seq 20 | sort -n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20</code></pre>\n<h2 id=\"o-输出重定向\"><a href=\"#o-输出重定向\" class=\"headerlink\" title=\"-o 输出重定向\"></a>-o 输出重定向</h2><p>sort默认输出位置是标准输出，可以使用-o重定向输出位置。</p>\n<h2 id=\"t-k-列项排序\"><a href=\"#t-k-列项排序\" class=\"headerlink\" title=\"-t -k 列项排序\"></a>-t -k 列项排序</h2><p>sort支持列项排序，即对相同列项进行排序，以当前列项值为排序的索引，排序所有行。<br>-t指定列项分隔符，默认是空白字符，-k指定按照分隔符划分出的第几列。<br>示例：</p>\n<pre><code class=\"sh\">➜ netstat -an | grep tcp | awk &#39;{print $1,$2,$3,$6}&#39; | sort -k4\ntcp 0 0 ESTABLISHED\ntcp 0 0 ESTABLISHED\ntcp 0 0 ESTABLISHED\ntcp 0 0 ESTABLISHED\ntcp 0 0 ESTABLISHED\ntcp 0 140 ESTABLISHED\ntcp6 0 0 ESTABLISHED\ntcp6 0 0 ESTABLISHED\ntcp 0 0 LISTEN\ntcp 0 0 LISTEN\ntcp 0 0 LISTEN\ntcp6 0 0 LISTEN\ntcp6 0 0 LISTEN\ntcp6 0 0 LISTEN\ntcp 0 0 TIME_WAIT\ntcp 0 0 TIME_WAIT\ntcp 0 0 TIME_WAIT\ntcp 0 0 TIME_WAIT</code></pre>\n<h2 id=\"r-逆序\"><a href=\"#r-逆序\" class=\"headerlink\" title=\"-r 逆序\"></a>-r 逆序</h2><p>sort默认输出是升序，如果我们需要降序就可以利用-r参数。<br>示例：</p>\n<pre><code class=\"sh\">➜ seq 9 | sort -r\n9\n8\n7\n6\n5\n4\n3\n2\n1</code></pre>\n<h2 id=\"R-随机排序\"><a href=\"#R-随机排序\" class=\"headerlink\" title=\"-R 随机排序\"></a>-R 随机排序</h2><p>乱序。</p>\n<pre><code class=\"sh\">➜ seq 9 | sort -R\n1\n6\n8\n5\n4\n9\n7\n2\n3</code></pre>\n<h2 id=\"u-去重\"><a href=\"#u-去重\" class=\"headerlink\" title=\"-u 去重\"></a>-u 去重</h2><p>sort排序内容如果有很多重复行，可以使用去重，排序后，在输出行中去除重复行。</p>\n"},{"author":"djaigo","title":"linux-sed命令","img":"https://img-1251474779.cos.ap-beijing.myqcloud.com/golang.png","date":"2020-09-17T10:18:17.000Z","updated":"2020-09-17T10:18:17.000Z","_content":"\nsed是linux行文本处理命令，默认选项是`-e`\n```sh\n➜ sed --help\n用法: sed [选项]... {脚本(如果没有其他脚本)} [输入文件]...\n\n  -n, --quiet, --silent\n                 取消自动打印模式空间\n  -e 脚本, --expression=脚本\n                 添加“脚本”到程序的运行列表\n  -f 脚本文件, --file=脚本文件\n                 添加“脚本文件”到程序的运行列表\n  --follow-symlinks\n                 直接修改文件时跟随软链接\n  -i[SUFFIX], --in-place[=SUFFIX]\n                 edit files in place (makes backup if SUFFIX supplied)\n  -c, --copy\n                 use copy instead of rename when shuffling files in -i mode\n  -b, --binary\n                 does nothing; for compatibility with WIN32/CYGWIN/MSDOS/EMX (\n                 open files in binary mode (CR+LFs are not treated specially))\n  -l N, --line-length=N\n                 指定“l”命令的换行期望长度\n  --posix\n                 关闭所有 GNU 扩展\n  -r, --regexp-extended\n                 在脚本中使用扩展正则表达式\n  -s, --separate\n                 将输入文件视为各个独立的文件而不是一个长的连续输入\n  -u, --unbuffered\n                 从输入文件读取最少的数据，更频繁的刷新输出\n  -z, --null-data\n                 separate lines by NUL characters\n  --help\n                 display this help and exit\n  --version\n                 output version information and exit\n\n如果没有 -e, --expression, -f 或 --file 选项，那么第一个非选项参数被视为\nsed脚本。其他非选项参数被视为输入文件，如果没有输入文件，那么程序将从标准\n输入读取数据。\n```\n\n# sed 命令\n## 行为命令\n行为命令为sed匹配到指定的行后的操作，多个操作用`;`进行间隔：\n* `!`，反向选取\n* `:`，声明标签\n* `a`，向下新增一行数据\n* `b`，跳转标签，需要在标签前\n* `c`，替换匹配行\n* `d`，删除匹配行\n* `g`，将保持空间复制到模式空间\n* `G`，将保持空间追加到模式空间\n* `h`，将模式空间的值复制到保持空间\n* `H`，将模式空间的值追加到保持空间\n* `i`，向上新增一行数据\n* `n`，读取下一行到追加到模式空间，相当于模式空间有两行数据，但后续操作只会影响新读取的行\n* `N`，读取下一行到追加到模式空间，与原有数据合并成一行，后续操作会影响新的一行\n* `p`，打印匹配行\n* `q`，退出\n* `r`，从文件读取输入行\n* `s`，替换，按照规则替换匹配行中的字符串，附加命令`g`表示行内全部替换\n* `w`，将所选的行写入文件\n* `x`，将模式空间和保持空间互换\n* `y`，将字符替换为另一个字符\n\n## 操作对象\n操作对象表示sed匹配的行\n* 数字，表示指定行，用`,`隔开表示连续的行\n* `$`，表示最后一行\n* `//{}`，之间的内容进行正则匹配，对匹配的行进行`{}`的操作，也可以不用`{}`，直接使用简化的行为命令也可以，还可以和数字一起使用，例如`/^s/,10p`，打印第一个以`s`开头的行到第10行\n\n## sed正则表达式\n正则操作符，用于匹配复杂的行\n* `^`，行首匹配\n* `$`，行尾匹配\n* `.`，匹配除换行符外的任意字符\n* `*`，贪心匹配，即匹配前一字符零次或多次，匹配直到最后出现的一次\n* `?`，非贪心匹配，即匹配零次或一次\n* `[]`，匹配任一字符\n* `[^]`，不能匹配到任一字符\n* `\\(\\)`，保存已匹配的字符，最多可匹配9次，编号为1到9，通过\\1来引用\n* `&`，表示已匹配的行\n* `\\<`，词首定位符\n* `\\>`，词尾定位符\n* `\\{n\\}`，匹配前一字符出现n次\n* `\\{n,\\}`，匹配前一字符至少出现n次\n* `\\{n,m\\}`，匹配前一字符至少出现n次，但不超过m次\n\n# 模式空间与保持空间\n上面的操作都是在默认的模式空间中进行的，sed为了能够同时处理多行数据，提供了保持空间。\n模式空间是指，匹配到一行后执行相应的操作，然后模式空间清空，直到文件处理完毕。\n保持空间是指，存储指定数据，可以通过行为命令将模式空间的数据覆盖、追加、互换操作。\n\n## 实现tac\n```sh\n➜ seq 3 | sed -n '1!G;h;$p'\n3\n2\n1\n```\n\n模式空间读入第一行，将模式空间复制到保持空间，删除模式空间\n模式空间读入第二行，将保持空间追加到模式空间，将模式空间复制到保持空间，删除模式空间\n其他行重复第二行的操作\n模式空间读入最后一行，将保持空间追加到模式空间，将模式空间复制到保持空间，打印模式空间\n\n## 实现xargs\n```sh\n➜ seq 3 | sed -n 'H;${x;s/\\n/ /g;p}'\n```\n\n每一行都将模式空间追加到保持空间，最后一行将模式空间和保持空间数据对换，替换所有换行符为空格，打印模式空间。\n正常情况下sed按行处理文本，是不会读到换行符，可以通过这种方式获取带换行符的多行数据。\n\n# 标签\n在sed脚本中`:`表示声明一个标签，b表示跳转标签。利用标签可以实现类似循环的操作。\n\n## 实现xargs\n```sh\n➜ seq 3 | sed ':a;N;$!ba;${s/\\n/ /g}'\n```\n\n设置标签a，读取下一行，与原有数据当做一行，不是最后一行跳转到标签a，直到最后一行，不跳转到标签a，替换所有的换行符为空格，sed自动打印模式空间内容\n\n# 参考文献\n* [菜鸟教程-Linux sed 命令](https://www.runoob.com/linux/linux-comm-sed.html)\n","source":"_posts/linux-sed命令.md","raw":"---\nauthor: djaigo\ntitle: linux-sed命令\nimg: 'https://img-1251474779.cos.ap-beijing.myqcloud.com/golang.png'\ncategories:\n  - linux\ntags:\n  - cmd\n  - command\ndate: 2020-09-17 18:18:17\nupdated: 2020-09-17 18:18:17\n---\n\nsed是linux行文本处理命令，默认选项是`-e`\n```sh\n➜ sed --help\n用法: sed [选项]... {脚本(如果没有其他脚本)} [输入文件]...\n\n  -n, --quiet, --silent\n                 取消自动打印模式空间\n  -e 脚本, --expression=脚本\n                 添加“脚本”到程序的运行列表\n  -f 脚本文件, --file=脚本文件\n                 添加“脚本文件”到程序的运行列表\n  --follow-symlinks\n                 直接修改文件时跟随软链接\n  -i[SUFFIX], --in-place[=SUFFIX]\n                 edit files in place (makes backup if SUFFIX supplied)\n  -c, --copy\n                 use copy instead of rename when shuffling files in -i mode\n  -b, --binary\n                 does nothing; for compatibility with WIN32/CYGWIN/MSDOS/EMX (\n                 open files in binary mode (CR+LFs are not treated specially))\n  -l N, --line-length=N\n                 指定“l”命令的换行期望长度\n  --posix\n                 关闭所有 GNU 扩展\n  -r, --regexp-extended\n                 在脚本中使用扩展正则表达式\n  -s, --separate\n                 将输入文件视为各个独立的文件而不是一个长的连续输入\n  -u, --unbuffered\n                 从输入文件读取最少的数据，更频繁的刷新输出\n  -z, --null-data\n                 separate lines by NUL characters\n  --help\n                 display this help and exit\n  --version\n                 output version information and exit\n\n如果没有 -e, --expression, -f 或 --file 选项，那么第一个非选项参数被视为\nsed脚本。其他非选项参数被视为输入文件，如果没有输入文件，那么程序将从标准\n输入读取数据。\n```\n\n# sed 命令\n## 行为命令\n行为命令为sed匹配到指定的行后的操作，多个操作用`;`进行间隔：\n* `!`，反向选取\n* `:`，声明标签\n* `a`，向下新增一行数据\n* `b`，跳转标签，需要在标签前\n* `c`，替换匹配行\n* `d`，删除匹配行\n* `g`，将保持空间复制到模式空间\n* `G`，将保持空间追加到模式空间\n* `h`，将模式空间的值复制到保持空间\n* `H`，将模式空间的值追加到保持空间\n* `i`，向上新增一行数据\n* `n`，读取下一行到追加到模式空间，相当于模式空间有两行数据，但后续操作只会影响新读取的行\n* `N`，读取下一行到追加到模式空间，与原有数据合并成一行，后续操作会影响新的一行\n* `p`，打印匹配行\n* `q`，退出\n* `r`，从文件读取输入行\n* `s`，替换，按照规则替换匹配行中的字符串，附加命令`g`表示行内全部替换\n* `w`，将所选的行写入文件\n* `x`，将模式空间和保持空间互换\n* `y`，将字符替换为另一个字符\n\n## 操作对象\n操作对象表示sed匹配的行\n* 数字，表示指定行，用`,`隔开表示连续的行\n* `$`，表示最后一行\n* `//{}`，之间的内容进行正则匹配，对匹配的行进行`{}`的操作，也可以不用`{}`，直接使用简化的行为命令也可以，还可以和数字一起使用，例如`/^s/,10p`，打印第一个以`s`开头的行到第10行\n\n## sed正则表达式\n正则操作符，用于匹配复杂的行\n* `^`，行首匹配\n* `$`，行尾匹配\n* `.`，匹配除换行符外的任意字符\n* `*`，贪心匹配，即匹配前一字符零次或多次，匹配直到最后出现的一次\n* `?`，非贪心匹配，即匹配零次或一次\n* `[]`，匹配任一字符\n* `[^]`，不能匹配到任一字符\n* `\\(\\)`，保存已匹配的字符，最多可匹配9次，编号为1到9，通过\\1来引用\n* `&`，表示已匹配的行\n* `\\<`，词首定位符\n* `\\>`，词尾定位符\n* `\\{n\\}`，匹配前一字符出现n次\n* `\\{n,\\}`，匹配前一字符至少出现n次\n* `\\{n,m\\}`，匹配前一字符至少出现n次，但不超过m次\n\n# 模式空间与保持空间\n上面的操作都是在默认的模式空间中进行的，sed为了能够同时处理多行数据，提供了保持空间。\n模式空间是指，匹配到一行后执行相应的操作，然后模式空间清空，直到文件处理完毕。\n保持空间是指，存储指定数据，可以通过行为命令将模式空间的数据覆盖、追加、互换操作。\n\n## 实现tac\n```sh\n➜ seq 3 | sed -n '1!G;h;$p'\n3\n2\n1\n```\n\n模式空间读入第一行，将模式空间复制到保持空间，删除模式空间\n模式空间读入第二行，将保持空间追加到模式空间，将模式空间复制到保持空间，删除模式空间\n其他行重复第二行的操作\n模式空间读入最后一行，将保持空间追加到模式空间，将模式空间复制到保持空间，打印模式空间\n\n## 实现xargs\n```sh\n➜ seq 3 | sed -n 'H;${x;s/\\n/ /g;p}'\n```\n\n每一行都将模式空间追加到保持空间，最后一行将模式空间和保持空间数据对换，替换所有换行符为空格，打印模式空间。\n正常情况下sed按行处理文本，是不会读到换行符，可以通过这种方式获取带换行符的多行数据。\n\n# 标签\n在sed脚本中`:`表示声明一个标签，b表示跳转标签。利用标签可以实现类似循环的操作。\n\n## 实现xargs\n```sh\n➜ seq 3 | sed ':a;N;$!ba;${s/\\n/ /g}'\n```\n\n设置标签a，读取下一行，与原有数据当做一行，不是最后一行跳转到标签a，直到最后一行，不跳转到标签a，替换所有的换行符为空格，sed自动打印模式空间内容\n\n# 参考文献\n* [菜鸟教程-Linux sed 命令](https://www.runoob.com/linux/linux-comm-sed.html)\n","slug":"linux-sed命令","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckh351dv3001z19z47mb2bf5b","content":"<p>sed是linux行文本处理命令，默认选项是<code>-e</code></p>\n<pre class=\" language-sh\"><code class=\"language-sh\">➜ sed --help\n用法: sed [选项]... {脚本(如果没有其他脚本)} [输入文件]...\n\n  -n, --quiet, --silent\n                 取消自动打印模式空间\n  -e 脚本, --expression=脚本\n                 添加“脚本”到程序的运行列表\n  -f 脚本文件, --file=脚本文件\n                 添加“脚本文件”到程序的运行列表\n  --follow-symlinks\n                 直接修改文件时跟随软链接\n  -i[SUFFIX], --in-place[=SUFFIX]\n                 edit files in place (makes backup if SUFFIX supplied)\n  -c, --copy\n                 use copy instead of rename when shuffling files in -i mode\n  -b, --binary\n                 does nothing; for compatibility with WIN32/CYGWIN/MSDOS/EMX (\n                 open files in binary mode (CR+LFs are not treated specially))\n  -l N, --line-length=N\n                 指定“l”命令的换行期望长度\n  --posix\n                 关闭所有 GNU 扩展\n  -r, --regexp-extended\n                 在脚本中使用扩展正则表达式\n  -s, --separate\n                 将输入文件视为各个独立的文件而不是一个长的连续输入\n  -u, --unbuffered\n                 从输入文件读取最少的数据，更频繁的刷新输出\n  -z, --null-data\n                 separate lines by NUL characters\n  --help\n                 display this help and exit\n  --version\n                 output version information and exit\n\n如果没有 -e, --expression, -f 或 --file 选项，那么第一个非选项参数被视为\nsed脚本。其他非选项参数被视为输入文件，如果没有输入文件，那么程序将从标准\n输入读取数据。</code></pre>\n<h1 id=\"sed-命令\"><a href=\"#sed-命令\" class=\"headerlink\" title=\"sed 命令\"></a>sed 命令</h1><h2 id=\"行为命令\"><a href=\"#行为命令\" class=\"headerlink\" title=\"行为命令\"></a>行为命令</h2><p>行为命令为sed匹配到指定的行后的操作，多个操作用<code>;</code>进行间隔：</p>\n<ul>\n<li><code>!</code>，反向选取</li>\n<li><code>:</code>，声明标签</li>\n<li><code>a</code>，向下新增一行数据</li>\n<li><code>b</code>，跳转标签，需要在标签前</li>\n<li><code>c</code>，替换匹配行</li>\n<li><code>d</code>，删除匹配行</li>\n<li><code>g</code>，将保持空间复制到模式空间</li>\n<li><code>G</code>，将保持空间追加到模式空间</li>\n<li><code>h</code>，将模式空间的值复制到保持空间</li>\n<li><code>H</code>，将模式空间的值追加到保持空间</li>\n<li><code>i</code>，向上新增一行数据</li>\n<li><code>n</code>，读取下一行到追加到模式空间，相当于模式空间有两行数据，但后续操作只会影响新读取的行</li>\n<li><code>N</code>，读取下一行到追加到模式空间，与原有数据合并成一行，后续操作会影响新的一行</li>\n<li><code>p</code>，打印匹配行</li>\n<li><code>q</code>，退出</li>\n<li><code>r</code>，从文件读取输入行</li>\n<li><code>s</code>，替换，按照规则替换匹配行中的字符串，附加命令<code>g</code>表示行内全部替换</li>\n<li><code>w</code>，将所选的行写入文件</li>\n<li><code>x</code>，将模式空间和保持空间互换</li>\n<li><code>y</code>，将字符替换为另一个字符</li>\n</ul>\n<h2 id=\"操作对象\"><a href=\"#操作对象\" class=\"headerlink\" title=\"操作对象\"></a>操作对象</h2><p>操作对象表示sed匹配的行</p>\n<ul>\n<li>数字，表示指定行，用<code>,</code>隔开表示连续的行</li>\n<li><code>$</code>，表示最后一行</li>\n<li><code>//{}</code>，之间的内容进行正则匹配，对匹配的行进行<code>{}</code>的操作，也可以不用<code>{}</code>，直接使用简化的行为命令也可以，还可以和数字一起使用，例如<code>/^s/,10p</code>，打印第一个以<code>s</code>开头的行到第10行</li>\n</ul>\n<h2 id=\"sed正则表达式\"><a href=\"#sed正则表达式\" class=\"headerlink\" title=\"sed正则表达式\"></a>sed正则表达式</h2><p>正则操作符，用于匹配复杂的行</p>\n<ul>\n<li><code>^</code>，行首匹配</li>\n<li><code>$</code>，行尾匹配</li>\n<li><code>.</code>，匹配除换行符外的任意字符</li>\n<li><code>*</code>，贪心匹配，即匹配前一字符零次或多次，匹配直到最后出现的一次</li>\n<li><code>?</code>，非贪心匹配，即匹配零次或一次</li>\n<li><code>[]</code>，匹配任一字符</li>\n<li><code>[^]</code>，不能匹配到任一字符</li>\n<li><code>\\(\\)</code>，保存已匹配的字符，最多可匹配9次，编号为1到9，通过\\1来引用</li>\n<li><code>&amp;</code>，表示已匹配的行</li>\n<li><code>\\&lt;</code>，词首定位符</li>\n<li><code>\\&gt;</code>，词尾定位符</li>\n<li><code>\\{n\\}</code>，匹配前一字符出现n次</li>\n<li><code>\\{n,\\}</code>，匹配前一字符至少出现n次</li>\n<li><code>\\{n,m\\}</code>，匹配前一字符至少出现n次，但不超过m次</li>\n</ul>\n<h1 id=\"模式空间与保持空间\"><a href=\"#模式空间与保持空间\" class=\"headerlink\" title=\"模式空间与保持空间\"></a>模式空间与保持空间</h1><p>上面的操作都是在默认的模式空间中进行的，sed为了能够同时处理多行数据，提供了保持空间。<br>模式空间是指，匹配到一行后执行相应的操作，然后模式空间清空，直到文件处理完毕。<br>保持空间是指，存储指定数据，可以通过行为命令将模式空间的数据覆盖、追加、互换操作。</p>\n<h2 id=\"实现tac\"><a href=\"#实现tac\" class=\"headerlink\" title=\"实现tac\"></a>实现tac</h2><pre class=\" language-sh\"><code class=\"language-sh\">➜ seq 3 | sed -n '1!G;h;$p'\n3\n2\n1</code></pre>\n<p>模式空间读入第一行，将模式空间复制到保持空间，删除模式空间<br>模式空间读入第二行，将保持空间追加到模式空间，将模式空间复制到保持空间，删除模式空间<br>其他行重复第二行的操作<br>模式空间读入最后一行，将保持空间追加到模式空间，将模式空间复制到保持空间，打印模式空间</p>\n<h2 id=\"实现xargs\"><a href=\"#实现xargs\" class=\"headerlink\" title=\"实现xargs\"></a>实现xargs</h2><pre class=\" language-sh\"><code class=\"language-sh\">➜ seq 3 | sed -n 'H;${x;s/\\n/ /g;p}'</code></pre>\n<p>每一行都将模式空间追加到保持空间，最后一行将模式空间和保持空间数据对换，替换所有换行符为空格，打印模式空间。<br>正常情况下sed按行处理文本，是不会读到换行符，可以通过这种方式获取带换行符的多行数据。</p>\n<h1 id=\"标签\"><a href=\"#标签\" class=\"headerlink\" title=\"标签\"></a>标签</h1><p>在sed脚本中<code>:</code>表示声明一个标签，b表示跳转标签。利用标签可以实现类似循环的操作。</p>\n<h2 id=\"实现xargs-1\"><a href=\"#实现xargs-1\" class=\"headerlink\" title=\"实现xargs\"></a>实现xargs</h2><pre class=\" language-sh\"><code class=\"language-sh\">➜ seq 3 | sed ':a;N;$!ba;${s/\\n/ /g}'</code></pre>\n<p>设置标签a，读取下一行，与原有数据当做一行，不是最后一行跳转到标签a，直到最后一行，不跳转到标签a，替换所有的换行符为空格，sed自动打印模式空间内容</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ul>\n<li><a href=\"https://www.runoob.com/linux/linux-comm-sed.html\" target=\"_blank\" rel=\"noopener\">菜鸟教程-Linux sed 命令</a></li>\n</ul>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"friends":[{"avatar":"https://img-1251474779.cos.ap-beijing.myqcloud.com/icon.png","name":"djaigo","introduction":"好好学习，天天向上","url":"/","title":"前去学习"},{"avatar":"https://awps-assets.meituan.net/mit/blog/v20190629/asset/icon/favicon.ico?v=Whistle&t=20181017-1r","name":"美团技术团队","introduction":"一行代码，亿万生活。","url":"https://tech.meituan.com/","title":"点个外卖-->"},{"avatar":"","name":"鸟窝","introduction":"rpcx作者","url":"https://colobu.com/","title":"进个鸟窝-->"},{"avatar":"https://d1j8pt39hxlh3d.cloudfront.net/emoji/emojione/5.0/png/unicode/32/1f92a.png","name":"labuladong的算法小抄","introduction":"算法大神","url":"https://labuladong.gitbook.io/algo/","title":"学个算法-->"}]}},"excerpt":"","more":"<p>sed是linux行文本处理命令，默认选项是<code>-e</code></p>\n<pre><code class=\"sh\">➜ sed --help\n用法: sed [选项]... {脚本(如果没有其他脚本)} [输入文件]...\n\n  -n, --quiet, --silent\n                 取消自动打印模式空间\n  -e 脚本, --expression=脚本\n                 添加“脚本”到程序的运行列表\n  -f 脚本文件, --file=脚本文件\n                 添加“脚本文件”到程序的运行列表\n  --follow-symlinks\n                 直接修改文件时跟随软链接\n  -i[SUFFIX], --in-place[=SUFFIX]\n                 edit files in place (makes backup if SUFFIX supplied)\n  -c, --copy\n                 use copy instead of rename when shuffling files in -i mode\n  -b, --binary\n                 does nothing; for compatibility with WIN32/CYGWIN/MSDOS/EMX (\n                 open files in binary mode (CR+LFs are not treated specially))\n  -l N, --line-length=N\n                 指定“l”命令的换行期望长度\n  --posix\n                 关闭所有 GNU 扩展\n  -r, --regexp-extended\n                 在脚本中使用扩展正则表达式\n  -s, --separate\n                 将输入文件视为各个独立的文件而不是一个长的连续输入\n  -u, --unbuffered\n                 从输入文件读取最少的数据，更频繁的刷新输出\n  -z, --null-data\n                 separate lines by NUL characters\n  --help\n                 display this help and exit\n  --version\n                 output version information and exit\n\n如果没有 -e, --expression, -f 或 --file 选项，那么第一个非选项参数被视为\nsed脚本。其他非选项参数被视为输入文件，如果没有输入文件，那么程序将从标准\n输入读取数据。</code></pre>\n<h1 id=\"sed-命令\"><a href=\"#sed-命令\" class=\"headerlink\" title=\"sed 命令\"></a>sed 命令</h1><h2 id=\"行为命令\"><a href=\"#行为命令\" class=\"headerlink\" title=\"行为命令\"></a>行为命令</h2><p>行为命令为sed匹配到指定的行后的操作，多个操作用<code>;</code>进行间隔：</p>\n<ul>\n<li><code>!</code>，反向选取</li>\n<li><code>:</code>，声明标签</li>\n<li><code>a</code>，向下新增一行数据</li>\n<li><code>b</code>，跳转标签，需要在标签前</li>\n<li><code>c</code>，替换匹配行</li>\n<li><code>d</code>，删除匹配行</li>\n<li><code>g</code>，将保持空间复制到模式空间</li>\n<li><code>G</code>，将保持空间追加到模式空间</li>\n<li><code>h</code>，将模式空间的值复制到保持空间</li>\n<li><code>H</code>，将模式空间的值追加到保持空间</li>\n<li><code>i</code>，向上新增一行数据</li>\n<li><code>n</code>，读取下一行到追加到模式空间，相当于模式空间有两行数据，但后续操作只会影响新读取的行</li>\n<li><code>N</code>，读取下一行到追加到模式空间，与原有数据合并成一行，后续操作会影响新的一行</li>\n<li><code>p</code>，打印匹配行</li>\n<li><code>q</code>，退出</li>\n<li><code>r</code>，从文件读取输入行</li>\n<li><code>s</code>，替换，按照规则替换匹配行中的字符串，附加命令<code>g</code>表示行内全部替换</li>\n<li><code>w</code>，将所选的行写入文件</li>\n<li><code>x</code>，将模式空间和保持空间互换</li>\n<li><code>y</code>，将字符替换为另一个字符</li>\n</ul>\n<h2 id=\"操作对象\"><a href=\"#操作对象\" class=\"headerlink\" title=\"操作对象\"></a>操作对象</h2><p>操作对象表示sed匹配的行</p>\n<ul>\n<li>数字，表示指定行，用<code>,</code>隔开表示连续的行</li>\n<li><code>$</code>，表示最后一行</li>\n<li><code>//{}</code>，之间的内容进行正则匹配，对匹配的行进行<code>{}</code>的操作，也可以不用<code>{}</code>，直接使用简化的行为命令也可以，还可以和数字一起使用，例如<code>/^s/,10p</code>，打印第一个以<code>s</code>开头的行到第10行</li>\n</ul>\n<h2 id=\"sed正则表达式\"><a href=\"#sed正则表达式\" class=\"headerlink\" title=\"sed正则表达式\"></a>sed正则表达式</h2><p>正则操作符，用于匹配复杂的行</p>\n<ul>\n<li><code>^</code>，行首匹配</li>\n<li><code>$</code>，行尾匹配</li>\n<li><code>.</code>，匹配除换行符外的任意字符</li>\n<li><code>*</code>，贪心匹配，即匹配前一字符零次或多次，匹配直到最后出现的一次</li>\n<li><code>?</code>，非贪心匹配，即匹配零次或一次</li>\n<li><code>[]</code>，匹配任一字符</li>\n<li><code>[^]</code>，不能匹配到任一字符</li>\n<li><code>\\(\\)</code>，保存已匹配的字符，最多可匹配9次，编号为1到9，通过\\1来引用</li>\n<li><code>&amp;</code>，表示已匹配的行</li>\n<li><code>\\&lt;</code>，词首定位符</li>\n<li><code>\\&gt;</code>，词尾定位符</li>\n<li><code>\\{n\\}</code>，匹配前一字符出现n次</li>\n<li><code>\\{n,\\}</code>，匹配前一字符至少出现n次</li>\n<li><code>\\{n,m\\}</code>，匹配前一字符至少出现n次，但不超过m次</li>\n</ul>\n<h1 id=\"模式空间与保持空间\"><a href=\"#模式空间与保持空间\" class=\"headerlink\" title=\"模式空间与保持空间\"></a>模式空间与保持空间</h1><p>上面的操作都是在默认的模式空间中进行的，sed为了能够同时处理多行数据，提供了保持空间。<br>模式空间是指，匹配到一行后执行相应的操作，然后模式空间清空，直到文件处理完毕。<br>保持空间是指，存储指定数据，可以通过行为命令将模式空间的数据覆盖、追加、互换操作。</p>\n<h2 id=\"实现tac\"><a href=\"#实现tac\" class=\"headerlink\" title=\"实现tac\"></a>实现tac</h2><pre><code class=\"sh\">➜ seq 3 | sed -n &#39;1!G;h;$p&#39;\n3\n2\n1</code></pre>\n<p>模式空间读入第一行，将模式空间复制到保持空间，删除模式空间<br>模式空间读入第二行，将保持空间追加到模式空间，将模式空间复制到保持空间，删除模式空间<br>其他行重复第二行的操作<br>模式空间读入最后一行，将保持空间追加到模式空间，将模式空间复制到保持空间，打印模式空间</p>\n<h2 id=\"实现xargs\"><a href=\"#实现xargs\" class=\"headerlink\" title=\"实现xargs\"></a>实现xargs</h2><pre><code class=\"sh\">➜ seq 3 | sed -n &#39;H;${x;s/\\n/ /g;p}&#39;</code></pre>\n<p>每一行都将模式空间追加到保持空间，最后一行将模式空间和保持空间数据对换，替换所有换行符为空格，打印模式空间。<br>正常情况下sed按行处理文本，是不会读到换行符，可以通过这种方式获取带换行符的多行数据。</p>\n<h1 id=\"标签\"><a href=\"#标签\" class=\"headerlink\" title=\"标签\"></a>标签</h1><p>在sed脚本中<code>:</code>表示声明一个标签，b表示跳转标签。利用标签可以实现类似循环的操作。</p>\n<h2 id=\"实现xargs-1\"><a href=\"#实现xargs-1\" class=\"headerlink\" title=\"实现xargs\"></a>实现xargs</h2><pre><code class=\"sh\">➜ seq 3 | sed &#39;:a;N;$!ba;${s/\\n/ /g}&#39;</code></pre>\n<p>设置标签a，读取下一行，与原有数据当做一行，不是最后一行跳转到标签a，直到最后一行，不跳转到标签a，替换所有的换行符为空格，sed自动打印模式空间内容</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ul>\n<li><a href=\"https://www.runoob.com/linux/linux-comm-sed.html\" target=\"_blank\" rel=\"noopener\">菜鸟教程-Linux sed 命令</a></li>\n</ul>\n"},{"author":"djaigo","title":"linux watch命令","img":"https://img-1251474779.cos.ap-beijing.myqcloud.com/golang.png","date":"2020-01-15T02:09:36.000Z","updated":"2020-01-14T16:00:00.000Z","enable html":false,"_content":"\nwatch 是监视某个shell命令控制台输出。\n```text\nUsage:\n watch [options] command\n\nOptions:\n  -b, --beep             beep if command has a non-zero exit\n  -c, --color            interpret ANSI color and style sequences\n  -d, --differences[=&lt;permanent&gt;]\n                         highlight changes between updates\n  -e, --errexit          exit if command has a non-zero exit\n  -g, --chgexit          exit when output from command changes\n  -n, --interval &lt;secs&gt;  seconds to wait between updates\n  -p, --precise          attempt run command in precise intervals\n  -t, --no-title         turn off header\n  -x, --exec             pass command to exec instead of \"sh -c\"\n\n -h, --help     display this help and exit\n -v, --version  output version information and exit\n\n```\n\n参数说明：\n\n| 选项 | 说明 |\n| --- | --- |\n|`-b, --beep`|忽略命令有非零返回码| \n|`-c, --color`|  解释ANSI颜色和样式序列   |\n|`-d, --differences[=<permanent>]`|高亮变化的部分|\n|`-e, --errexit`|  当命令返回非零错误码时退出   |\n|`-g, --chgexit`| 当输出有变化时退出    |\n|`-n, --interval <secs>`|  执行命令的时间间隔，单位秒   |\n|`-p, --precise`|尝试以精确的间隔运行命令|\n|`-t, --no-title`| 不显示头部标题 |\n|`-x, --exec`| 利用exec执行命令|\n|`-h, --help`|  打印帮助文档并退出   |\n|`-v, --version`|   打印版本并退出  |\n\n示例：\n```sh\n~ watch -b -c -d -p -t -n 1 'date;exit 1'\n```\n\n\n","source":"_posts/linux-watch命令.md","raw":"---\nauthor: djaigo\ntitle: linux watch命令\nimg: 'https://img-1251474779.cos.ap-beijing.myqcloud.com/golang.png'\ncategories:\n  - linux\ntags:\n  - cmd\n  - command\ndate: 2020-01-15 10:09:36\nupdated: 2020-01-15\nenable html: false\n---\n\nwatch 是监视某个shell命令控制台输出。\n```text\nUsage:\n watch [options] command\n\nOptions:\n  -b, --beep             beep if command has a non-zero exit\n  -c, --color            interpret ANSI color and style sequences\n  -d, --differences[=&lt;permanent&gt;]\n                         highlight changes between updates\n  -e, --errexit          exit if command has a non-zero exit\n  -g, --chgexit          exit when output from command changes\n  -n, --interval &lt;secs&gt;  seconds to wait between updates\n  -p, --precise          attempt run command in precise intervals\n  -t, --no-title         turn off header\n  -x, --exec             pass command to exec instead of \"sh -c\"\n\n -h, --help     display this help and exit\n -v, --version  output version information and exit\n\n```\n\n参数说明：\n\n| 选项 | 说明 |\n| --- | --- |\n|`-b, --beep`|忽略命令有非零返回码| \n|`-c, --color`|  解释ANSI颜色和样式序列   |\n|`-d, --differences[=<permanent>]`|高亮变化的部分|\n|`-e, --errexit`|  当命令返回非零错误码时退出   |\n|`-g, --chgexit`| 当输出有变化时退出    |\n|`-n, --interval <secs>`|  执行命令的时间间隔，单位秒   |\n|`-p, --precise`|尝试以精确的间隔运行命令|\n|`-t, --no-title`| 不显示头部标题 |\n|`-x, --exec`| 利用exec执行命令|\n|`-h, --help`|  打印帮助文档并退出   |\n|`-v, --version`|   打印版本并退出  |\n\n示例：\n```sh\n~ watch -b -c -d -p -t -n 1 'date;exit 1'\n```\n\n\n","slug":"linux-watch命令","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckh351dv4002119z4h1d23cjy","content":"<p>watch 是监视某个shell命令控制台输出。</p>\n<pre class=\" language-text\"><code class=\"language-text\">Usage:\n watch [options] command\n\nOptions:\n  -b, --beep             beep if command has a non-zero exit\n  -c, --color            interpret ANSI color and style sequences\n  -d, --differences[=&lt;permanent&gt;]\n                         highlight changes between updates\n  -e, --errexit          exit if command has a non-zero exit\n  -g, --chgexit          exit when output from command changes\n  -n, --interval &lt;secs&gt;  seconds to wait between updates\n  -p, --precise          attempt run command in precise intervals\n  -t, --no-title         turn off header\n  -x, --exec             pass command to exec instead of \"sh -c\"\n\n -h, --help     display this help and exit\n -v, --version  output version information and exit\n</code></pre>\n<p>参数说明：</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>-b, --beep</code></td>\n<td>忽略命令有非零返回码</td>\n</tr>\n<tr>\n<td><code>-c, --color</code></td>\n<td>解释ANSI颜色和样式序列</td>\n</tr>\n<tr>\n<td><code>-d, --differences[=&lt;permanent&gt;]</code></td>\n<td>高亮变化的部分</td>\n</tr>\n<tr>\n<td><code>-e, --errexit</code></td>\n<td>当命令返回非零错误码时退出</td>\n</tr>\n<tr>\n<td><code>-g, --chgexit</code></td>\n<td>当输出有变化时退出</td>\n</tr>\n<tr>\n<td><code>-n, --interval &lt;secs&gt;</code></td>\n<td>执行命令的时间间隔，单位秒</td>\n</tr>\n<tr>\n<td><code>-p, --precise</code></td>\n<td>尝试以精确的间隔运行命令</td>\n</tr>\n<tr>\n<td><code>-t, --no-title</code></td>\n<td>不显示头部标题</td>\n</tr>\n<tr>\n<td><code>-x, --exec</code></td>\n<td>利用exec执行命令</td>\n</tr>\n<tr>\n<td><code>-h, --help</code></td>\n<td>打印帮助文档并退出</td>\n</tr>\n<tr>\n<td><code>-v, --version</code></td>\n<td>打印版本并退出</td>\n</tr>\n</tbody></table>\n<p>示例：</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">~ watch -b -c -d -p -t -n 1 'date;exit 1'</code></pre>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"friends":[{"avatar":"https://img-1251474779.cos.ap-beijing.myqcloud.com/icon.png","name":"djaigo","introduction":"好好学习，天天向上","url":"/","title":"前去学习"},{"avatar":"https://awps-assets.meituan.net/mit/blog/v20190629/asset/icon/favicon.ico?v=Whistle&t=20181017-1r","name":"美团技术团队","introduction":"一行代码，亿万生活。","url":"https://tech.meituan.com/","title":"点个外卖-->"},{"avatar":"","name":"鸟窝","introduction":"rpcx作者","url":"https://colobu.com/","title":"进个鸟窝-->"},{"avatar":"https://d1j8pt39hxlh3d.cloudfront.net/emoji/emojione/5.0/png/unicode/32/1f92a.png","name":"labuladong的算法小抄","introduction":"算法大神","url":"https://labuladong.gitbook.io/algo/","title":"学个算法-->"}]}},"excerpt":"","more":"<p>watch 是监视某个shell命令控制台输出。</p>\n<pre><code class=\"text\">Usage:\n watch [options] command\n\nOptions:\n  -b, --beep             beep if command has a non-zero exit\n  -c, --color            interpret ANSI color and style sequences\n  -d, --differences[=&amp;lt;permanent&amp;gt;]\n                         highlight changes between updates\n  -e, --errexit          exit if command has a non-zero exit\n  -g, --chgexit          exit when output from command changes\n  -n, --interval &amp;lt;secs&amp;gt;  seconds to wait between updates\n  -p, --precise          attempt run command in precise intervals\n  -t, --no-title         turn off header\n  -x, --exec             pass command to exec instead of &quot;sh -c&quot;\n\n -h, --help     display this help and exit\n -v, --version  output version information and exit\n</code></pre>\n<p>参数说明：</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>-b, --beep</code></td>\n<td>忽略命令有非零返回码</td>\n</tr>\n<tr>\n<td><code>-c, --color</code></td>\n<td>解释ANSI颜色和样式序列</td>\n</tr>\n<tr>\n<td><code>-d, --differences[=&lt;permanent&gt;]</code></td>\n<td>高亮变化的部分</td>\n</tr>\n<tr>\n<td><code>-e, --errexit</code></td>\n<td>当命令返回非零错误码时退出</td>\n</tr>\n<tr>\n<td><code>-g, --chgexit</code></td>\n<td>当输出有变化时退出</td>\n</tr>\n<tr>\n<td><code>-n, --interval &lt;secs&gt;</code></td>\n<td>执行命令的时间间隔，单位秒</td>\n</tr>\n<tr>\n<td><code>-p, --precise</code></td>\n<td>尝试以精确的间隔运行命令</td>\n</tr>\n<tr>\n<td><code>-t, --no-title</code></td>\n<td>不显示头部标题</td>\n</tr>\n<tr>\n<td><code>-x, --exec</code></td>\n<td>利用exec执行命令</td>\n</tr>\n<tr>\n<td><code>-h, --help</code></td>\n<td>打印帮助文档并退出</td>\n</tr>\n<tr>\n<td><code>-v, --version</code></td>\n<td>打印版本并退出</td>\n</tr>\n</tbody></table>\n<p>示例：</p>\n<pre><code class=\"sh\">~ watch -b -c -d -p -t -n 1 &#39;date;exit 1&#39;</code></pre>\n"},{"author":"djaigo","title":"linux软链接和硬链接","img":"https://img-1251474779.cos.ap-beijing.myqcloud.com/linux.png","date":"2020-04-09T05:00:43.000Z","updated":"2020-04-09T05:00:43.000Z","_content":"\n我们知道文件都有文件名与数据，这在 Linux 上被分成两个部分：用户数据 (user data) 与元数据 (metadata)。用户数据，即文件数据块 (data block)，数据块是记录文件真实内容的地方；而元数据则是文件的附加属性，如文件大小、创建时间、所有者等信息。在 Linux 中，元数据中的 inode 号（inode 是文件元数据的一部分但其并不包含文件名，inode 号即索引节点号）才是文件的唯一标识而非文件名。文件名仅是为了方便人们的记忆和使用，系统或程序通过 inode 号寻找正确的文件数据块。\n为解决文件的共享使用，Linux 系统引入了两种链接：硬链接 (hard link) 与软链接（又称符号链接，即 soft link 或 symbolic link）。链接为 Linux 系统解决了文件的共享使用，还带来了隐藏文件路径、增加权限安全及节省存储等好处。若一个 inode 号对应多个文件名，则称这些文件为硬链接。换言之，硬链接就是同一个文件使用了多个别名他们有共同的 inode。硬链接可由命令 link 或 ln 创建。\n\n# 硬链接\n由于硬链接是有着相同 inode 号仅文件名不同的文件，因此硬链接存在以下几点特性：\n\n*   文件有相同的 inode 及 data block；\n*   只能对已存在的文件进行创建；\n*   不能交叉文件系统进行硬链接的创建；\n*   不能对目录进行创建，只可对文件创建；\n*   删除一个硬链接文件并不影响其他有相同 inode 号的文件。\n\n# 软链接\n软链接与硬链接不同，若文件用户数据块中存放的内容是另一文件的路径名的指向，则该文件就是软连接。软链接就是一个普通文件，只是数据块内容有点特殊。软链接有着自己的 inode 号以及用户数据块。因此软链接的创建与使用没有类似硬链接的诸多限制：\n\n*   软链接有自己的文件属性及权限等；\n*   可对不存在的文件或目录创建软链接；\n*   软链接可交叉文件系统；\n*   软链接可对文件或目录创建；\n*   创建软链接时，链接计数 i_nlink 不会增加；\n*   删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）。\n\n# inode\n在 Linux 中，索引节点结构存在于系统内存及磁盘，其可区分成 VFS inode 与实际文件系统的 inode。VFS inode 作为实际文件系统中 inode 的抽象，定义了结构体 inode 与其相关的操作 inode_operations（见内核源码 include/linux/fs.h）。\n\n```c\nstruct inode { \n   ... \n   const struct inode_operations   *i_op; // 索引节点操作\n   unsigned long           i_ino;      // 索引节点号\n   atomic_t                i_count;    // 引用计数器\n   unsigned int            i_nlink;    // 硬链接数目\n   ... \n} \n \nstruct inode_operations { \n   ... \n   int (*create) (struct inode *,struct dentry *,int, struct nameidata *); \n   int (*link) (struct dentry *,struct inode *,struct dentry *); \n   int (*unlink) (struct inode *,struct dentry *); \n   int (*symlink) (struct inode *,struct dentry *,const char *); \n   int (*mkdir) (struct inode *,struct dentry *,int); \n   int (*rmdir) (struct inode *,struct dentry *); \n   ... \n}\n```\n\n如清单 10. 所见，每个文件存在两个计数器：`i_count` 与 `i_nlink`，即引用计数与硬链接计数。结构体 inode 中的 `i_count` 用于跟踪文件被访问的数量，而 `i_nlink` 则是上述使用 ls -l 等命令查看到的文件硬链接数。或者说 `i_count` 跟踪文件在内存中的情况，而 `i_nlink` 则是磁盘计数器。当文件被删除时，则 `i_nlink` 先被设置成 0。文件的这两个计数器使得 Linux 系统升级或程序更新变的容易。系统或程序可在不关闭的情况下（即文件 `i_count` 不为 0），将新文件以同样的文件名进行替换，新文件有自己的 inode 及 data block，旧文件会在相关进程关闭后被完整的删除。\n\n文件系统 ext4 中的 inode\n```c\nstruct ext4_inode { \n   ... \n   __le32  i_atime;        // 文件内容最后一次访问时间\n   __le32  i_ctime;        // inode 修改时间\n   __le32  i_mtime;        // 文件内容最后一次修改时间\n   __le16  i_links_count;  // 硬链接计数\n   __le32  i_blocks_lo;    // Block 计数\n   __le32  i_block[EXT4_N_BLOCKS];  // 指向具体的 block \n   ... \n};\n```\n\n其中三个时间的定义可对应与命令 stat 中查看到三个时间。`i_links_count` 不仅用于文件的硬链接计数，也用于目录的子目录数跟踪（目录并不显示硬链接数，命令 ls -ld 查看到的是子目录数）。由于文件系统 ext3 对 `i_links_count` 有限制，其最大数为：32000（该限制在 ext4 中被取消）。尝试在 ext3 文件系统上验证目录子目录及普通文件硬链接最大数可见的错误信息。因此实际文件系统的 inode 之间及与 VFS inode 相较是有差异的。\n\n# 参考文献\n[理解 Linux 的硬链接与软链接](https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/index.html)\n","source":"_posts/linux软链接和硬链接.md","raw":"---\nauthor: djaigo\ntitle: linux软链接和硬链接\nimg: 'https://img-1251474779.cos.ap-beijing.myqcloud.com/linux.png'\ncategories:\n  - linux\ntags:\n  - link\ndate: 2020-04-09 13:00:43\nupdated: 2020-04-09 13:00:43\n---\n\n我们知道文件都有文件名与数据，这在 Linux 上被分成两个部分：用户数据 (user data) 与元数据 (metadata)。用户数据，即文件数据块 (data block)，数据块是记录文件真实内容的地方；而元数据则是文件的附加属性，如文件大小、创建时间、所有者等信息。在 Linux 中，元数据中的 inode 号（inode 是文件元数据的一部分但其并不包含文件名，inode 号即索引节点号）才是文件的唯一标识而非文件名。文件名仅是为了方便人们的记忆和使用，系统或程序通过 inode 号寻找正确的文件数据块。\n为解决文件的共享使用，Linux 系统引入了两种链接：硬链接 (hard link) 与软链接（又称符号链接，即 soft link 或 symbolic link）。链接为 Linux 系统解决了文件的共享使用，还带来了隐藏文件路径、增加权限安全及节省存储等好处。若一个 inode 号对应多个文件名，则称这些文件为硬链接。换言之，硬链接就是同一个文件使用了多个别名他们有共同的 inode。硬链接可由命令 link 或 ln 创建。\n\n# 硬链接\n由于硬链接是有着相同 inode 号仅文件名不同的文件，因此硬链接存在以下几点特性：\n\n*   文件有相同的 inode 及 data block；\n*   只能对已存在的文件进行创建；\n*   不能交叉文件系统进行硬链接的创建；\n*   不能对目录进行创建，只可对文件创建；\n*   删除一个硬链接文件并不影响其他有相同 inode 号的文件。\n\n# 软链接\n软链接与硬链接不同，若文件用户数据块中存放的内容是另一文件的路径名的指向，则该文件就是软连接。软链接就是一个普通文件，只是数据块内容有点特殊。软链接有着自己的 inode 号以及用户数据块。因此软链接的创建与使用没有类似硬链接的诸多限制：\n\n*   软链接有自己的文件属性及权限等；\n*   可对不存在的文件或目录创建软链接；\n*   软链接可交叉文件系统；\n*   软链接可对文件或目录创建；\n*   创建软链接时，链接计数 i_nlink 不会增加；\n*   删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）。\n\n# inode\n在 Linux 中，索引节点结构存在于系统内存及磁盘，其可区分成 VFS inode 与实际文件系统的 inode。VFS inode 作为实际文件系统中 inode 的抽象，定义了结构体 inode 与其相关的操作 inode_operations（见内核源码 include/linux/fs.h）。\n\n```c\nstruct inode { \n   ... \n   const struct inode_operations   *i_op; // 索引节点操作\n   unsigned long           i_ino;      // 索引节点号\n   atomic_t                i_count;    // 引用计数器\n   unsigned int            i_nlink;    // 硬链接数目\n   ... \n} \n \nstruct inode_operations { \n   ... \n   int (*create) (struct inode *,struct dentry *,int, struct nameidata *); \n   int (*link) (struct dentry *,struct inode *,struct dentry *); \n   int (*unlink) (struct inode *,struct dentry *); \n   int (*symlink) (struct inode *,struct dentry *,const char *); \n   int (*mkdir) (struct inode *,struct dentry *,int); \n   int (*rmdir) (struct inode *,struct dentry *); \n   ... \n}\n```\n\n如清单 10. 所见，每个文件存在两个计数器：`i_count` 与 `i_nlink`，即引用计数与硬链接计数。结构体 inode 中的 `i_count` 用于跟踪文件被访问的数量，而 `i_nlink` 则是上述使用 ls -l 等命令查看到的文件硬链接数。或者说 `i_count` 跟踪文件在内存中的情况，而 `i_nlink` 则是磁盘计数器。当文件被删除时，则 `i_nlink` 先被设置成 0。文件的这两个计数器使得 Linux 系统升级或程序更新变的容易。系统或程序可在不关闭的情况下（即文件 `i_count` 不为 0），将新文件以同样的文件名进行替换，新文件有自己的 inode 及 data block，旧文件会在相关进程关闭后被完整的删除。\n\n文件系统 ext4 中的 inode\n```c\nstruct ext4_inode { \n   ... \n   __le32  i_atime;        // 文件内容最后一次访问时间\n   __le32  i_ctime;        // inode 修改时间\n   __le32  i_mtime;        // 文件内容最后一次修改时间\n   __le16  i_links_count;  // 硬链接计数\n   __le32  i_blocks_lo;    // Block 计数\n   __le32  i_block[EXT4_N_BLOCKS];  // 指向具体的 block \n   ... \n};\n```\n\n其中三个时间的定义可对应与命令 stat 中查看到三个时间。`i_links_count` 不仅用于文件的硬链接计数，也用于目录的子目录数跟踪（目录并不显示硬链接数，命令 ls -ld 查看到的是子目录数）。由于文件系统 ext3 对 `i_links_count` 有限制，其最大数为：32000（该限制在 ext4 中被取消）。尝试在 ext3 文件系统上验证目录子目录及普通文件硬链接最大数可见的错误信息。因此实际文件系统的 inode 之间及与 VFS inode 相较是有差异的。\n\n# 参考文献\n[理解 Linux 的硬链接与软链接](https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/index.html)\n","slug":"linux软链接和硬链接","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckh351dv6002619z4ab9lfl8b","content":"<p>我们知道文件都有文件名与数据，这在 Linux 上被分成两个部分：用户数据 (user data) 与元数据 (metadata)。用户数据，即文件数据块 (data block)，数据块是记录文件真实内容的地方；而元数据则是文件的附加属性，如文件大小、创建时间、所有者等信息。在 Linux 中，元数据中的 inode 号（inode 是文件元数据的一部分但其并不包含文件名，inode 号即索引节点号）才是文件的唯一标识而非文件名。文件名仅是为了方便人们的记忆和使用，系统或程序通过 inode 号寻找正确的文件数据块。<br>为解决文件的共享使用，Linux 系统引入了两种链接：硬链接 (hard link) 与软链接（又称符号链接，即 soft link 或 symbolic link）。链接为 Linux 系统解决了文件的共享使用，还带来了隐藏文件路径、增加权限安全及节省存储等好处。若一个 inode 号对应多个文件名，则称这些文件为硬链接。换言之，硬链接就是同一个文件使用了多个别名他们有共同的 inode。硬链接可由命令 link 或 ln 创建。</p>\n<h1 id=\"硬链接\"><a href=\"#硬链接\" class=\"headerlink\" title=\"硬链接\"></a>硬链接</h1><p>由于硬链接是有着相同 inode 号仅文件名不同的文件，因此硬链接存在以下几点特性：</p>\n<ul>\n<li>文件有相同的 inode 及 data block；</li>\n<li>只能对已存在的文件进行创建；</li>\n<li>不能交叉文件系统进行硬链接的创建；</li>\n<li>不能对目录进行创建，只可对文件创建；</li>\n<li>删除一个硬链接文件并不影响其他有相同 inode 号的文件。</li>\n</ul>\n<h1 id=\"软链接\"><a href=\"#软链接\" class=\"headerlink\" title=\"软链接\"></a>软链接</h1><p>软链接与硬链接不同，若文件用户数据块中存放的内容是另一文件的路径名的指向，则该文件就是软连接。软链接就是一个普通文件，只是数据块内容有点特殊。软链接有着自己的 inode 号以及用户数据块。因此软链接的创建与使用没有类似硬链接的诸多限制：</p>\n<ul>\n<li>软链接有自己的文件属性及权限等；</li>\n<li>可对不存在的文件或目录创建软链接；</li>\n<li>软链接可交叉文件系统；</li>\n<li>软链接可对文件或目录创建；</li>\n<li>创建软链接时，链接计数 i_nlink 不会增加；</li>\n<li>删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）。</li>\n</ul>\n<h1 id=\"inode\"><a href=\"#inode\" class=\"headerlink\" title=\"inode\"></a>inode</h1><p>在 Linux 中，索引节点结构存在于系统内存及磁盘，其可区分成 VFS inode 与实际文件系统的 inode。VFS inode 作为实际文件系统中 inode 的抽象，定义了结构体 inode 与其相关的操作 inode_operations（见内核源码 include/linux/fs.h）。</p>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> inode <span class=\"token punctuation\">{</span> \n   <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> \n   <span class=\"token keyword\">const</span> <span class=\"token keyword\">struct</span> inode_operations   <span class=\"token operator\">*</span>i_op<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 索引节点操作</span>\n   <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span>           i_ino<span class=\"token punctuation\">;</span>      <span class=\"token comment\" spellcheck=\"true\">// 索引节点号</span>\n   atomic_t                i_count<span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">// 引用计数器</span>\n   <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span>            i_nlink<span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">// 硬链接数目</span>\n   <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> \n<span class=\"token punctuation\">}</span> \n\n<span class=\"token keyword\">struct</span> inode_operations <span class=\"token punctuation\">{</span> \n   <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> \n   <span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>create<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> inode <span class=\"token operator\">*</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">struct</span> dentry <span class=\"token operator\">*</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">struct</span> nameidata <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n   <span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>link<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> dentry <span class=\"token operator\">*</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">struct</span> inode <span class=\"token operator\">*</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">struct</span> dentry <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n   <span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>unlink<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> inode <span class=\"token operator\">*</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">struct</span> dentry <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n   <span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>symlink<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> inode <span class=\"token operator\">*</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">struct</span> dentry <span class=\"token operator\">*</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n   <span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>mkdir<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> inode <span class=\"token operator\">*</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">struct</span> dentry <span class=\"token operator\">*</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n   <span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>rmdir<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> inode <span class=\"token operator\">*</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">struct</span> dentry <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n   <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> \n<span class=\"token punctuation\">}</span></code></pre>\n<p>如清单 10. 所见，每个文件存在两个计数器：<code>i_count</code> 与 <code>i_nlink</code>，即引用计数与硬链接计数。结构体 inode 中的 <code>i_count</code> 用于跟踪文件被访问的数量，而 <code>i_nlink</code> 则是上述使用 ls -l 等命令查看到的文件硬链接数。或者说 <code>i_count</code> 跟踪文件在内存中的情况，而 <code>i_nlink</code> 则是磁盘计数器。当文件被删除时，则 <code>i_nlink</code> 先被设置成 0。文件的这两个计数器使得 Linux 系统升级或程序更新变的容易。系统或程序可在不关闭的情况下（即文件 <code>i_count</code> 不为 0），将新文件以同样的文件名进行替换，新文件有自己的 inode 及 data block，旧文件会在相关进程关闭后被完整的删除。</p>\n<p>文件系统 ext4 中的 inode</p>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> ext4_inode <span class=\"token punctuation\">{</span> \n   <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> \n   __le32  i_atime<span class=\"token punctuation\">;</span>        <span class=\"token comment\" spellcheck=\"true\">// 文件内容最后一次访问时间</span>\n   __le32  i_ctime<span class=\"token punctuation\">;</span>        <span class=\"token comment\" spellcheck=\"true\">// inode 修改时间</span>\n   __le32  i_mtime<span class=\"token punctuation\">;</span>        <span class=\"token comment\" spellcheck=\"true\">// 文件内容最后一次修改时间</span>\n   __le16  i_links_count<span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 硬链接计数</span>\n   __le32  i_blocks_lo<span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">// Block 计数</span>\n   __le32  i_block<span class=\"token punctuation\">[</span>EXT4_N_BLOCKS<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 指向具体的 block </span>\n   <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre>\n<p>其中三个时间的定义可对应与命令 stat 中查看到三个时间。<code>i_links_count</code> 不仅用于文件的硬链接计数，也用于目录的子目录数跟踪（目录并不显示硬链接数，命令 ls -ld 查看到的是子目录数）。由于文件系统 ext3 对 <code>i_links_count</code> 有限制，其最大数为：32000（该限制在 ext4 中被取消）。尝试在 ext3 文件系统上验证目录子目录及普通文件硬链接最大数可见的错误信息。因此实际文件系统的 inode 之间及与 VFS inode 相较是有差异的。</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p><a href=\"https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/index.html\" target=\"_blank\" rel=\"noopener\">理解 Linux 的硬链接与软链接</a></p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"friends":[{"avatar":"https://img-1251474779.cos.ap-beijing.myqcloud.com/icon.png","name":"djaigo","introduction":"好好学习，天天向上","url":"/","title":"前去学习"},{"avatar":"https://awps-assets.meituan.net/mit/blog/v20190629/asset/icon/favicon.ico?v=Whistle&t=20181017-1r","name":"美团技术团队","introduction":"一行代码，亿万生活。","url":"https://tech.meituan.com/","title":"点个外卖-->"},{"avatar":"","name":"鸟窝","introduction":"rpcx作者","url":"https://colobu.com/","title":"进个鸟窝-->"},{"avatar":"https://d1j8pt39hxlh3d.cloudfront.net/emoji/emojione/5.0/png/unicode/32/1f92a.png","name":"labuladong的算法小抄","introduction":"算法大神","url":"https://labuladong.gitbook.io/algo/","title":"学个算法-->"}]}},"excerpt":"","more":"<p>我们知道文件都有文件名与数据，这在 Linux 上被分成两个部分：用户数据 (user data) 与元数据 (metadata)。用户数据，即文件数据块 (data block)，数据块是记录文件真实内容的地方；而元数据则是文件的附加属性，如文件大小、创建时间、所有者等信息。在 Linux 中，元数据中的 inode 号（inode 是文件元数据的一部分但其并不包含文件名，inode 号即索引节点号）才是文件的唯一标识而非文件名。文件名仅是为了方便人们的记忆和使用，系统或程序通过 inode 号寻找正确的文件数据块。<br>为解决文件的共享使用，Linux 系统引入了两种链接：硬链接 (hard link) 与软链接（又称符号链接，即 soft link 或 symbolic link）。链接为 Linux 系统解决了文件的共享使用，还带来了隐藏文件路径、增加权限安全及节省存储等好处。若一个 inode 号对应多个文件名，则称这些文件为硬链接。换言之，硬链接就是同一个文件使用了多个别名他们有共同的 inode。硬链接可由命令 link 或 ln 创建。</p>\n<h1 id=\"硬链接\"><a href=\"#硬链接\" class=\"headerlink\" title=\"硬链接\"></a>硬链接</h1><p>由于硬链接是有着相同 inode 号仅文件名不同的文件，因此硬链接存在以下几点特性：</p>\n<ul>\n<li>文件有相同的 inode 及 data block；</li>\n<li>只能对已存在的文件进行创建；</li>\n<li>不能交叉文件系统进行硬链接的创建；</li>\n<li>不能对目录进行创建，只可对文件创建；</li>\n<li>删除一个硬链接文件并不影响其他有相同 inode 号的文件。</li>\n</ul>\n<h1 id=\"软链接\"><a href=\"#软链接\" class=\"headerlink\" title=\"软链接\"></a>软链接</h1><p>软链接与硬链接不同，若文件用户数据块中存放的内容是另一文件的路径名的指向，则该文件就是软连接。软链接就是一个普通文件，只是数据块内容有点特殊。软链接有着自己的 inode 号以及用户数据块。因此软链接的创建与使用没有类似硬链接的诸多限制：</p>\n<ul>\n<li>软链接有自己的文件属性及权限等；</li>\n<li>可对不存在的文件或目录创建软链接；</li>\n<li>软链接可交叉文件系统；</li>\n<li>软链接可对文件或目录创建；</li>\n<li>创建软链接时，链接计数 i_nlink 不会增加；</li>\n<li>删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）。</li>\n</ul>\n<h1 id=\"inode\"><a href=\"#inode\" class=\"headerlink\" title=\"inode\"></a>inode</h1><p>在 Linux 中，索引节点结构存在于系统内存及磁盘，其可区分成 VFS inode 与实际文件系统的 inode。VFS inode 作为实际文件系统中 inode 的抽象，定义了结构体 inode 与其相关的操作 inode_operations（见内核源码 include/linux/fs.h）。</p>\n<pre><code class=\"c\">struct inode { \n   ... \n   const struct inode_operations   *i_op; // 索引节点操作\n   unsigned long           i_ino;      // 索引节点号\n   atomic_t                i_count;    // 引用计数器\n   unsigned int            i_nlink;    // 硬链接数目\n   ... \n} \n\nstruct inode_operations { \n   ... \n   int (*create) (struct inode *,struct dentry *,int, struct nameidata *); \n   int (*link) (struct dentry *,struct inode *,struct dentry *); \n   int (*unlink) (struct inode *,struct dentry *); \n   int (*symlink) (struct inode *,struct dentry *,const char *); \n   int (*mkdir) (struct inode *,struct dentry *,int); \n   int (*rmdir) (struct inode *,struct dentry *); \n   ... \n}</code></pre>\n<p>如清单 10. 所见，每个文件存在两个计数器：<code>i_count</code> 与 <code>i_nlink</code>，即引用计数与硬链接计数。结构体 inode 中的 <code>i_count</code> 用于跟踪文件被访问的数量，而 <code>i_nlink</code> 则是上述使用 ls -l 等命令查看到的文件硬链接数。或者说 <code>i_count</code> 跟踪文件在内存中的情况，而 <code>i_nlink</code> 则是磁盘计数器。当文件被删除时，则 <code>i_nlink</code> 先被设置成 0。文件的这两个计数器使得 Linux 系统升级或程序更新变的容易。系统或程序可在不关闭的情况下（即文件 <code>i_count</code> 不为 0），将新文件以同样的文件名进行替换，新文件有自己的 inode 及 data block，旧文件会在相关进程关闭后被完整的删除。</p>\n<p>文件系统 ext4 中的 inode</p>\n<pre><code class=\"c\">struct ext4_inode { \n   ... \n   __le32  i_atime;        // 文件内容最后一次访问时间\n   __le32  i_ctime;        // inode 修改时间\n   __le32  i_mtime;        // 文件内容最后一次修改时间\n   __le16  i_links_count;  // 硬链接计数\n   __le32  i_blocks_lo;    // Block 计数\n   __le32  i_block[EXT4_N_BLOCKS];  // 指向具体的 block \n   ... \n};</code></pre>\n<p>其中三个时间的定义可对应与命令 stat 中查看到三个时间。<code>i_links_count</code> 不仅用于文件的硬链接计数，也用于目录的子目录数跟踪（目录并不显示硬链接数，命令 ls -ld 查看到的是子目录数）。由于文件系统 ext3 对 <code>i_links_count</code> 有限制，其最大数为：32000（该限制在 ext4 中被取消）。尝试在 ext3 文件系统上验证目录子目录及普通文件硬链接最大数可见的错误信息。因此实际文件系统的 inode 之间及与 VFS inode 相较是有差异的。</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p><a href=\"https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/index.html\" target=\"_blank\" rel=\"noopener\">理解 Linux 的硬链接与软链接</a></p>\n"},{"author":"djaigo","title":"protocol buffer","img":"https://img-1251474779.cos.ap-beijing.myqcloud.com/golang.png","date":"2020-04-23T07:32:37.000Z","updated":"2020-04-23T07:32:37.000Z","_content":"# 简介\n`protocol buffer`是一种与语言无关，与平台无关的可扩展机制，用于序列化结构化数据。它通过定义`.proto`文件，使用`protoc`工具生成指定代码的文件，让程序猿没有了心智负担。与json相比，它编码和解码快，生成数据体积小。\n# protobuf类型\n\n| .proto Type | Notes | Go Type |\n| --- | --- | --- |\n| double |  | float64 |\n| float |   | float32 |\n| int32 | 使用可变长度编码。负数编码效率低下–如果您的字段可能具有负值，请改用sint32。 | int32 |\n| int64 |  使用可变长度编码。负数编码效率低下，如果您的字段可能具有负值，请改用sint64。 | int64 |\n| uint32 | 使用可变长度编码。 | uint32 |\n| uint64 | 使用可变长度编码。 | uint64 |\n| sint32 | 使用可变长度编码。有符号的int值。与常规int32相比，它们更有效地编码负数。 | int32 |\n| sint64 | 使用可变长度编码。有符号的int值。与常规int64相比，它们更有效地编码负数。 |  int64 |\n| fixed32 | 始终为八个字节。如果值通常大于$2^{28}$，则比uint32更有效。 | uint32 |\n| fixed64 | 始终为八个字节。如果值通常大于$2^{56}$，则比uint64更有效。 |  uint64 |\n| sfixed32 | 始终为4字节。 |  int32 |\n| sfixed64 | 始终为8字节。 |  int64 |\n| bool |  |  bool |\n| string | 字符串必须始终包含UTF-8编码或7位ASCII文本，并且不能超过$2^{32}$。 |  string |\n| bytes | 可以包含不超过$2^{32}$的字节序列。 | []byte | \n\n* sint，对负数的编码结果更优秀，如果用int存小负数会占用4字节，用sint能像正数一样占少量空间\n* fixed，对应位数占固定字节数\n* sfixed，对应位数占固定字节数，使用sint的编码格式\n\n# 参考文献\n* [proto3 guide](https://developers.google.com/protocol-buffers/docs/proto3)\n","source":"_posts/protocol-buffer.md","raw":"---\nauthor: djaigo\ntitle: protocol buffer\nimg: 'https://img-1251474779.cos.ap-beijing.myqcloud.com/golang.png'\ncategories:\n  - protobuf\ntags:\n  - protobuf\n  - proto3\ndate: 2020-04-23 15:32:37\nupdated: 2020-04-23 15:32:37\n---\n# 简介\n`protocol buffer`是一种与语言无关，与平台无关的可扩展机制，用于序列化结构化数据。它通过定义`.proto`文件，使用`protoc`工具生成指定代码的文件，让程序猿没有了心智负担。与json相比，它编码和解码快，生成数据体积小。\n# protobuf类型\n\n| .proto Type | Notes | Go Type |\n| --- | --- | --- |\n| double |  | float64 |\n| float |   | float32 |\n| int32 | 使用可变长度编码。负数编码效率低下–如果您的字段可能具有负值，请改用sint32。 | int32 |\n| int64 |  使用可变长度编码。负数编码效率低下，如果您的字段可能具有负值，请改用sint64。 | int64 |\n| uint32 | 使用可变长度编码。 | uint32 |\n| uint64 | 使用可变长度编码。 | uint64 |\n| sint32 | 使用可变长度编码。有符号的int值。与常规int32相比，它们更有效地编码负数。 | int32 |\n| sint64 | 使用可变长度编码。有符号的int值。与常规int64相比，它们更有效地编码负数。 |  int64 |\n| fixed32 | 始终为八个字节。如果值通常大于$2^{28}$，则比uint32更有效。 | uint32 |\n| fixed64 | 始终为八个字节。如果值通常大于$2^{56}$，则比uint64更有效。 |  uint64 |\n| sfixed32 | 始终为4字节。 |  int32 |\n| sfixed64 | 始终为8字节。 |  int64 |\n| bool |  |  bool |\n| string | 字符串必须始终包含UTF-8编码或7位ASCII文本，并且不能超过$2^{32}$。 |  string |\n| bytes | 可以包含不超过$2^{32}$的字节序列。 | []byte | \n\n* sint，对负数的编码结果更优秀，如果用int存小负数会占用4字节，用sint能像正数一样占少量空间\n* fixed，对应位数占固定字节数\n* sfixed，对应位数占固定字节数，使用sint的编码格式\n\n# 参考文献\n* [proto3 guide](https://developers.google.com/protocol-buffers/docs/proto3)\n","slug":"protocol-buffer","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckh351dv7002919z43rq93mkl","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p><code>protocol buffer</code>是一种与语言无关，与平台无关的可扩展机制，用于序列化结构化数据。它通过定义<code>.proto</code>文件，使用<code>protoc</code>工具生成指定代码的文件，让程序猿没有了心智负担。与json相比，它编码和解码快，生成数据体积小。</p>\n<h1 id=\"protobuf类型\"><a href=\"#protobuf类型\" class=\"headerlink\" title=\"protobuf类型\"></a>protobuf类型</h1><table>\n<thead>\n<tr>\n<th>.proto Type</th>\n<th>Notes</th>\n<th>Go Type</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>double</td>\n<td></td>\n<td>float64</td>\n</tr>\n<tr>\n<td>float</td>\n<td></td>\n<td>float32</td>\n</tr>\n<tr>\n<td>int32</td>\n<td>使用可变长度编码。负数编码效率低下–如果您的字段可能具有负值，请改用sint32。</td>\n<td>int32</td>\n</tr>\n<tr>\n<td>int64</td>\n<td>使用可变长度编码。负数编码效率低下，如果您的字段可能具有负值，请改用sint64。</td>\n<td>int64</td>\n</tr>\n<tr>\n<td>uint32</td>\n<td>使用可变长度编码。</td>\n<td>uint32</td>\n</tr>\n<tr>\n<td>uint64</td>\n<td>使用可变长度编码。</td>\n<td>uint64</td>\n</tr>\n<tr>\n<td>sint32</td>\n<td>使用可变长度编码。有符号的int值。与常规int32相比，它们更有效地编码负数。</td>\n<td>int32</td>\n</tr>\n<tr>\n<td>sint64</td>\n<td>使用可变长度编码。有符号的int值。与常规int64相比，它们更有效地编码负数。</td>\n<td>int64</td>\n</tr>\n<tr>\n<td>fixed32</td>\n<td>始终为八个字节。如果值通常大于$2^{28}$，则比uint32更有效。</td>\n<td>uint32</td>\n</tr>\n<tr>\n<td>fixed64</td>\n<td>始终为八个字节。如果值通常大于$2^{56}$，则比uint64更有效。</td>\n<td>uint64</td>\n</tr>\n<tr>\n<td>sfixed32</td>\n<td>始终为4字节。</td>\n<td>int32</td>\n</tr>\n<tr>\n<td>sfixed64</td>\n<td>始终为8字节。</td>\n<td>int64</td>\n</tr>\n<tr>\n<td>bool</td>\n<td></td>\n<td>bool</td>\n</tr>\n<tr>\n<td>string</td>\n<td>字符串必须始终包含UTF-8编码或7位ASCII文本，并且不能超过$2^{32}$。</td>\n<td>string</td>\n</tr>\n<tr>\n<td>bytes</td>\n<td>可以包含不超过$2^{32}$的字节序列。</td>\n<td>[]byte</td>\n</tr>\n</tbody></table>\n<ul>\n<li>sint，对负数的编码结果更优秀，如果用int存小负数会占用4字节，用sint能像正数一样占少量空间</li>\n<li>fixed，对应位数占固定字节数</li>\n<li>sfixed，对应位数占固定字节数，使用sint的编码格式</li>\n</ul>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ul>\n<li><a href=\"https://developers.google.com/protocol-buffers/docs/proto3\" target=\"_blank\" rel=\"noopener\">proto3 guide</a></li>\n</ul>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"friends":[{"avatar":"https://img-1251474779.cos.ap-beijing.myqcloud.com/icon.png","name":"djaigo","introduction":"好好学习，天天向上","url":"/","title":"前去学习"},{"avatar":"https://awps-assets.meituan.net/mit/blog/v20190629/asset/icon/favicon.ico?v=Whistle&t=20181017-1r","name":"美团技术团队","introduction":"一行代码，亿万生活。","url":"https://tech.meituan.com/","title":"点个外卖-->"},{"avatar":"","name":"鸟窝","introduction":"rpcx作者","url":"https://colobu.com/","title":"进个鸟窝-->"},{"avatar":"https://d1j8pt39hxlh3d.cloudfront.net/emoji/emojione/5.0/png/unicode/32/1f92a.png","name":"labuladong的算法小抄","introduction":"算法大神","url":"https://labuladong.gitbook.io/algo/","title":"学个算法-->"}]}},"excerpt":"","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p><code>protocol buffer</code>是一种与语言无关，与平台无关的可扩展机制，用于序列化结构化数据。它通过定义<code>.proto</code>文件，使用<code>protoc</code>工具生成指定代码的文件，让程序猿没有了心智负担。与json相比，它编码和解码快，生成数据体积小。</p>\n<h1 id=\"protobuf类型\"><a href=\"#protobuf类型\" class=\"headerlink\" title=\"protobuf类型\"></a>protobuf类型</h1><table>\n<thead>\n<tr>\n<th>.proto Type</th>\n<th>Notes</th>\n<th>Go Type</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>double</td>\n<td></td>\n<td>float64</td>\n</tr>\n<tr>\n<td>float</td>\n<td></td>\n<td>float32</td>\n</tr>\n<tr>\n<td>int32</td>\n<td>使用可变长度编码。负数编码效率低下–如果您的字段可能具有负值，请改用sint32。</td>\n<td>int32</td>\n</tr>\n<tr>\n<td>int64</td>\n<td>使用可变长度编码。负数编码效率低下，如果您的字段可能具有负值，请改用sint64。</td>\n<td>int64</td>\n</tr>\n<tr>\n<td>uint32</td>\n<td>使用可变长度编码。</td>\n<td>uint32</td>\n</tr>\n<tr>\n<td>uint64</td>\n<td>使用可变长度编码。</td>\n<td>uint64</td>\n</tr>\n<tr>\n<td>sint32</td>\n<td>使用可变长度编码。有符号的int值。与常规int32相比，它们更有效地编码负数。</td>\n<td>int32</td>\n</tr>\n<tr>\n<td>sint64</td>\n<td>使用可变长度编码。有符号的int值。与常规int64相比，它们更有效地编码负数。</td>\n<td>int64</td>\n</tr>\n<tr>\n<td>fixed32</td>\n<td>始终为八个字节。如果值通常大于$2^{28}$，则比uint32更有效。</td>\n<td>uint32</td>\n</tr>\n<tr>\n<td>fixed64</td>\n<td>始终为八个字节。如果值通常大于$2^{56}$，则比uint64更有效。</td>\n<td>uint64</td>\n</tr>\n<tr>\n<td>sfixed32</td>\n<td>始终为4字节。</td>\n<td>int32</td>\n</tr>\n<tr>\n<td>sfixed64</td>\n<td>始终为8字节。</td>\n<td>int64</td>\n</tr>\n<tr>\n<td>bool</td>\n<td></td>\n<td>bool</td>\n</tr>\n<tr>\n<td>string</td>\n<td>字符串必须始终包含UTF-8编码或7位ASCII文本，并且不能超过$2^{32}$。</td>\n<td>string</td>\n</tr>\n<tr>\n<td>bytes</td>\n<td>可以包含不超过$2^{32}$的字节序列。</td>\n<td>[]byte</td>\n</tr>\n</tbody></table>\n<ul>\n<li>sint，对负数的编码结果更优秀，如果用int存小负数会占用4字节，用sint能像正数一样占少量空间</li>\n<li>fixed，对应位数占固定字节数</li>\n<li>sfixed，对应位数占固定字节数，使用sint的编码格式</li>\n</ul>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ul>\n<li><a href=\"https://developers.google.com/protocol-buffers/docs/proto3\" target=\"_blank\" rel=\"noopener\">proto3 guide</a></li>\n</ul>\n"},{"author":"djaigo","title":"redis大key处理","img":"https://img-1251474779.cos.ap-beijing.myqcloud.com/redis.png","date":"2020-04-02T10:14:10.000Z","updated":"2020-04-02T10:14:10.000Z","_content":"\nRedis是一个高性能的key-value数据库。性能的关键点在于使用内存存储和单进程操作，如果Redis中存储了一个大key在内存使用和操作上都会有很大的风险。\n\n# 大key的风险：\n\n1.  读写大key会导致超时严重，甚至阻塞服务。\n2.  如果删除大key，`DEL`命令可能阻塞Redis进程数十秒，使得其他请求阻塞，对应用程序和Redis集群可用性造成严重的影响。\n3.  建议每个key不要超过M级别。\n\n# 处理方式\n## valve数据多但单条数据不大\n可以按照一定的方法，聚合一些key\n## valve数据少但单条数据量大\n## valve数据多且单条数据量大\n处理方式的核心思想就是将一个大key进行某种程度的拆分，常见的有：\n* 分段，将数据按照规则递增的插入，超过阈值则插入新键，以此类推，key的数量不可控，但从根本上解决了大key的问题\n* 哈希，将数据计算出对应的哈希值，分别存储到对应的key上，key的数量可控，但依旧会产生大key问题\n\n# 淘汰策略\n当内存到达maxmemory的限制时，可以采用以下选项清理内存：\n*   volatile-lru，在具有过期集的密钥中使用近似的LRU逐出。\n*   allkeys-lru，使用近似的LRU逐出任何密钥。\n*   volatile-lfu，在具有过期集的键中使用近似的逐出。\n*   allkeys-lfu，使用近似的LFU逐出任何键。\n*   volatile-random，在有过期集的密钥中删除一个随机密钥。\n*   allkeys-random，随机删除任意键。\n*   volatile-ttl，删除最接近过期时间的密钥（次要TTL）。\n*   noeviction，不要逐出任何内容，只返回写操作错误。\n\n在不同的场景使用不同的淘汰策略，也可以充分利用redis的缓存作用。\n\n# 优雅的删除大key\nRedis数据类型除了字符串，都支持key的部分删除，运用多次少量的删除可以减少redis单次执行操作时间。\n* hash，提供了`HDEL`方法进行批量删除，如果不清楚该`hash key`有哪些`field`，可以使用`HSCAN`先迭代部分`field`然后`HDEL`批量删除\n* list，提供了`LTRIM`方法进行删除非指定list区间的value，可以先通过`LLEN`获取当前list的长度，再根据实际情况进行`LTRIM`\n* set，提供了`SREM`方法进行批量删除，可以先通过`SSCAN`进行迭代出部分member，再通过`SREM`进行删除\n* zset，提供`ZREM`方法进行批量删除，可以先通过`ZSCAN`进行迭代出部分member，再通过`ZREM`进行删除。除此之外zset还支持`ZREMRANGEBYLEX`、`ZREMRANGEBYRANK`和`ZREMRANGEBYSCORE`，分别通过member区间，score排名和score区间进行批量删除\n\n# 参考文献\n[Redis大Key优化](https://blog.csdn.net/u013474436/article/details/88808914)\n","source":"_posts/redis大key处理.md","raw":"---\nauthor: djaigo\ntitle: redis大key处理\nimg: 'https://img-1251474779.cos.ap-beijing.myqcloud.com/redis.png'\ncategories:\n  - redis\ntags:\n  - redis\n  - key\ndate: 2020-04-02 18:14:10\nupdated: 2020-04-02 18:14:10\n---\n\nRedis是一个高性能的key-value数据库。性能的关键点在于使用内存存储和单进程操作，如果Redis中存储了一个大key在内存使用和操作上都会有很大的风险。\n\n# 大key的风险：\n\n1.  读写大key会导致超时严重，甚至阻塞服务。\n2.  如果删除大key，`DEL`命令可能阻塞Redis进程数十秒，使得其他请求阻塞，对应用程序和Redis集群可用性造成严重的影响。\n3.  建议每个key不要超过M级别。\n\n# 处理方式\n## valve数据多但单条数据不大\n可以按照一定的方法，聚合一些key\n## valve数据少但单条数据量大\n## valve数据多且单条数据量大\n处理方式的核心思想就是将一个大key进行某种程度的拆分，常见的有：\n* 分段，将数据按照规则递增的插入，超过阈值则插入新键，以此类推，key的数量不可控，但从根本上解决了大key的问题\n* 哈希，将数据计算出对应的哈希值，分别存储到对应的key上，key的数量可控，但依旧会产生大key问题\n\n# 淘汰策略\n当内存到达maxmemory的限制时，可以采用以下选项清理内存：\n*   volatile-lru，在具有过期集的密钥中使用近似的LRU逐出。\n*   allkeys-lru，使用近似的LRU逐出任何密钥。\n*   volatile-lfu，在具有过期集的键中使用近似的逐出。\n*   allkeys-lfu，使用近似的LFU逐出任何键。\n*   volatile-random，在有过期集的密钥中删除一个随机密钥。\n*   allkeys-random，随机删除任意键。\n*   volatile-ttl，删除最接近过期时间的密钥（次要TTL）。\n*   noeviction，不要逐出任何内容，只返回写操作错误。\n\n在不同的场景使用不同的淘汰策略，也可以充分利用redis的缓存作用。\n\n# 优雅的删除大key\nRedis数据类型除了字符串，都支持key的部分删除，运用多次少量的删除可以减少redis单次执行操作时间。\n* hash，提供了`HDEL`方法进行批量删除，如果不清楚该`hash key`有哪些`field`，可以使用`HSCAN`先迭代部分`field`然后`HDEL`批量删除\n* list，提供了`LTRIM`方法进行删除非指定list区间的value，可以先通过`LLEN`获取当前list的长度，再根据实际情况进行`LTRIM`\n* set，提供了`SREM`方法进行批量删除，可以先通过`SSCAN`进行迭代出部分member，再通过`SREM`进行删除\n* zset，提供`ZREM`方法进行批量删除，可以先通过`ZSCAN`进行迭代出部分member，再通过`ZREM`进行删除。除此之外zset还支持`ZREMRANGEBYLEX`、`ZREMRANGEBYRANK`和`ZREMRANGEBYSCORE`，分别通过member区间，score排名和score区间进行批量删除\n\n# 参考文献\n[Redis大Key优化](https://blog.csdn.net/u013474436/article/details/88808914)\n","slug":"redis大key处理","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckh351dv8002d19z4gsmq30is","content":"<p>Redis是一个高性能的key-value数据库。性能的关键点在于使用内存存储和单进程操作，如果Redis中存储了一个大key在内存使用和操作上都会有很大的风险。</p>\n<h1 id=\"大key的风险：\"><a href=\"#大key的风险：\" class=\"headerlink\" title=\"大key的风险：\"></a>大key的风险：</h1><ol>\n<li>读写大key会导致超时严重，甚至阻塞服务。</li>\n<li>如果删除大key，<code>DEL</code>命令可能阻塞Redis进程数十秒，使得其他请求阻塞，对应用程序和Redis集群可用性造成严重的影响。</li>\n<li>建议每个key不要超过M级别。</li>\n</ol>\n<h1 id=\"处理方式\"><a href=\"#处理方式\" class=\"headerlink\" title=\"处理方式\"></a>处理方式</h1><h2 id=\"valve数据多但单条数据不大\"><a href=\"#valve数据多但单条数据不大\" class=\"headerlink\" title=\"valve数据多但单条数据不大\"></a>valve数据多但单条数据不大</h2><p>可以按照一定的方法，聚合一些key</p>\n<h2 id=\"valve数据少但单条数据量大\"><a href=\"#valve数据少但单条数据量大\" class=\"headerlink\" title=\"valve数据少但单条数据量大\"></a>valve数据少但单条数据量大</h2><h2 id=\"valve数据多且单条数据量大\"><a href=\"#valve数据多且单条数据量大\" class=\"headerlink\" title=\"valve数据多且单条数据量大\"></a>valve数据多且单条数据量大</h2><p>处理方式的核心思想就是将一个大key进行某种程度的拆分，常见的有：</p>\n<ul>\n<li>分段，将数据按照规则递增的插入，超过阈值则插入新键，以此类推，key的数量不可控，但从根本上解决了大key的问题</li>\n<li>哈希，将数据计算出对应的哈希值，分别存储到对应的key上，key的数量可控，但依旧会产生大key问题</li>\n</ul>\n<h1 id=\"淘汰策略\"><a href=\"#淘汰策略\" class=\"headerlink\" title=\"淘汰策略\"></a>淘汰策略</h1><p>当内存到达maxmemory的限制时，可以采用以下选项清理内存：</p>\n<ul>\n<li>volatile-lru，在具有过期集的密钥中使用近似的LRU逐出。</li>\n<li>allkeys-lru，使用近似的LRU逐出任何密钥。</li>\n<li>volatile-lfu，在具有过期集的键中使用近似的逐出。</li>\n<li>allkeys-lfu，使用近似的LFU逐出任何键。</li>\n<li>volatile-random，在有过期集的密钥中删除一个随机密钥。</li>\n<li>allkeys-random，随机删除任意键。</li>\n<li>volatile-ttl，删除最接近过期时间的密钥（次要TTL）。</li>\n<li>noeviction，不要逐出任何内容，只返回写操作错误。</li>\n</ul>\n<p>在不同的场景使用不同的淘汰策略，也可以充分利用redis的缓存作用。</p>\n<h1 id=\"优雅的删除大key\"><a href=\"#优雅的删除大key\" class=\"headerlink\" title=\"优雅的删除大key\"></a>优雅的删除大key</h1><p>Redis数据类型除了字符串，都支持key的部分删除，运用多次少量的删除可以减少redis单次执行操作时间。</p>\n<ul>\n<li>hash，提供了<code>HDEL</code>方法进行批量删除，如果不清楚该<code>hash key</code>有哪些<code>field</code>，可以使用<code>HSCAN</code>先迭代部分<code>field</code>然后<code>HDEL</code>批量删除</li>\n<li>list，提供了<code>LTRIM</code>方法进行删除非指定list区间的value，可以先通过<code>LLEN</code>获取当前list的长度，再根据实际情况进行<code>LTRIM</code></li>\n<li>set，提供了<code>SREM</code>方法进行批量删除，可以先通过<code>SSCAN</code>进行迭代出部分member，再通过<code>SREM</code>进行删除</li>\n<li>zset，提供<code>ZREM</code>方法进行批量删除，可以先通过<code>ZSCAN</code>进行迭代出部分member，再通过<code>ZREM</code>进行删除。除此之外zset还支持<code>ZREMRANGEBYLEX</code>、<code>ZREMRANGEBYRANK</code>和<code>ZREMRANGEBYSCORE</code>，分别通过member区间，score排名和score区间进行批量删除</li>\n</ul>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p><a href=\"https://blog.csdn.net/u013474436/article/details/88808914\" target=\"_blank\" rel=\"noopener\">Redis大Key优化</a></p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"friends":[{"avatar":"https://img-1251474779.cos.ap-beijing.myqcloud.com/icon.png","name":"djaigo","introduction":"好好学习，天天向上","url":"/","title":"前去学习"},{"avatar":"https://awps-assets.meituan.net/mit/blog/v20190629/asset/icon/favicon.ico?v=Whistle&t=20181017-1r","name":"美团技术团队","introduction":"一行代码，亿万生活。","url":"https://tech.meituan.com/","title":"点个外卖-->"},{"avatar":"","name":"鸟窝","introduction":"rpcx作者","url":"https://colobu.com/","title":"进个鸟窝-->"},{"avatar":"https://d1j8pt39hxlh3d.cloudfront.net/emoji/emojione/5.0/png/unicode/32/1f92a.png","name":"labuladong的算法小抄","introduction":"算法大神","url":"https://labuladong.gitbook.io/algo/","title":"学个算法-->"}]}},"excerpt":"","more":"<p>Redis是一个高性能的key-value数据库。性能的关键点在于使用内存存储和单进程操作，如果Redis中存储了一个大key在内存使用和操作上都会有很大的风险。</p>\n<h1 id=\"大key的风险：\"><a href=\"#大key的风险：\" class=\"headerlink\" title=\"大key的风险：\"></a>大key的风险：</h1><ol>\n<li>读写大key会导致超时严重，甚至阻塞服务。</li>\n<li>如果删除大key，<code>DEL</code>命令可能阻塞Redis进程数十秒，使得其他请求阻塞，对应用程序和Redis集群可用性造成严重的影响。</li>\n<li>建议每个key不要超过M级别。</li>\n</ol>\n<h1 id=\"处理方式\"><a href=\"#处理方式\" class=\"headerlink\" title=\"处理方式\"></a>处理方式</h1><h2 id=\"valve数据多但单条数据不大\"><a href=\"#valve数据多但单条数据不大\" class=\"headerlink\" title=\"valve数据多但单条数据不大\"></a>valve数据多但单条数据不大</h2><p>可以按照一定的方法，聚合一些key</p>\n<h2 id=\"valve数据少但单条数据量大\"><a href=\"#valve数据少但单条数据量大\" class=\"headerlink\" title=\"valve数据少但单条数据量大\"></a>valve数据少但单条数据量大</h2><h2 id=\"valve数据多且单条数据量大\"><a href=\"#valve数据多且单条数据量大\" class=\"headerlink\" title=\"valve数据多且单条数据量大\"></a>valve数据多且单条数据量大</h2><p>处理方式的核心思想就是将一个大key进行某种程度的拆分，常见的有：</p>\n<ul>\n<li>分段，将数据按照规则递增的插入，超过阈值则插入新键，以此类推，key的数量不可控，但从根本上解决了大key的问题</li>\n<li>哈希，将数据计算出对应的哈希值，分别存储到对应的key上，key的数量可控，但依旧会产生大key问题</li>\n</ul>\n<h1 id=\"淘汰策略\"><a href=\"#淘汰策略\" class=\"headerlink\" title=\"淘汰策略\"></a>淘汰策略</h1><p>当内存到达maxmemory的限制时，可以采用以下选项清理内存：</p>\n<ul>\n<li>volatile-lru，在具有过期集的密钥中使用近似的LRU逐出。</li>\n<li>allkeys-lru，使用近似的LRU逐出任何密钥。</li>\n<li>volatile-lfu，在具有过期集的键中使用近似的逐出。</li>\n<li>allkeys-lfu，使用近似的LFU逐出任何键。</li>\n<li>volatile-random，在有过期集的密钥中删除一个随机密钥。</li>\n<li>allkeys-random，随机删除任意键。</li>\n<li>volatile-ttl，删除最接近过期时间的密钥（次要TTL）。</li>\n<li>noeviction，不要逐出任何内容，只返回写操作错误。</li>\n</ul>\n<p>在不同的场景使用不同的淘汰策略，也可以充分利用redis的缓存作用。</p>\n<h1 id=\"优雅的删除大key\"><a href=\"#优雅的删除大key\" class=\"headerlink\" title=\"优雅的删除大key\"></a>优雅的删除大key</h1><p>Redis数据类型除了字符串，都支持key的部分删除，运用多次少量的删除可以减少redis单次执行操作时间。</p>\n<ul>\n<li>hash，提供了<code>HDEL</code>方法进行批量删除，如果不清楚该<code>hash key</code>有哪些<code>field</code>，可以使用<code>HSCAN</code>先迭代部分<code>field</code>然后<code>HDEL</code>批量删除</li>\n<li>list，提供了<code>LTRIM</code>方法进行删除非指定list区间的value，可以先通过<code>LLEN</code>获取当前list的长度，再根据实际情况进行<code>LTRIM</code></li>\n<li>set，提供了<code>SREM</code>方法进行批量删除，可以先通过<code>SSCAN</code>进行迭代出部分member，再通过<code>SREM</code>进行删除</li>\n<li>zset，提供<code>ZREM</code>方法进行批量删除，可以先通过<code>ZSCAN</code>进行迭代出部分member，再通过<code>ZREM</code>进行删除。除此之外zset还支持<code>ZREMRANGEBYLEX</code>、<code>ZREMRANGEBYRANK</code>和<code>ZREMRANGEBYSCORE</code>，分别通过member区间，score排名和score区间进行批量删除</li>\n</ul>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p><a href=\"https://blog.csdn.net/u013474436/article/details/88808914\" target=\"_blank\" rel=\"noopener\">Redis大Key优化</a></p>\n"},{"author":"djaigo","title":"sync包","img":"https://img-1251474779.cos.ap-beijing.myqcloud.com/golang.png","date":"2020-01-13T06:54:12.000Z","_content":"\n# atomic\n## Add\nAdd族函数是原子的加值操作，第一个参数是被操作值的地址，第二参数是要加的值是多少，返回值是加之后的值。\n如果要在无符号上减操作，建议的方法`delta=^uint32(delta-1)`，特别的如果要递减使用`delta=^uint32(0)`。\n\n```go\nfunc AddInt32(addr *int32, delta int32) (new int32)\nfunc AddUint32(addr *uint32, delta uint32) (new uint32)\nfunc AddInt64(addr *int64, delta int64) (new int64)\nfunc AddUint64(addr *uint64, delta uint64) (new uint64)\nfunc AddUintptr(addr *uintptr, delta uintptr) (new uintptr)\n```\n\n## CAS\nCAS族函数是比较并替换操作，第一个参数被操作值的地址，第二个参数是被操作数的原值，第三个参数是被操作数的新值。\n如果被操作数值不等于旧值则不进行替换，返回false，如果成功替换返回true。\n```go\nfunc CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)\nfunc CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool)\nfunc CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool)\nfunc CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool)\nfunc CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool)\nfunc CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)\n```\n\n\n## Load\nLoad族函数是原子的取出被操作数，第一个参数是被操作数的地址，返回值是地址执行的值。\n```go\nfunc LoadInt32(addr *int32) (val int32)\nfunc LoadInt64(addr *int64) (val int64)\nfunc LoadUint32(addr *uint32) (val uint32)\nfunc LoadUint64(addr *uint64) (val uint64)\nfunc LoadUintptr(addr *uintptr) (val uintptr)\nfunc LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)\n```\n\n## Store\nStore族函数是原子的存储被操作数，第一个参数是操作数的地址，第二个参数是被设置的值。\n```go\nfunc StoreInt32(addr *int32, val int32)\nfunc StoreInt64(addr *int64, val int64)\nfunc StoreUint32(addr *uint32, val uint32)\nfunc StoreUint64(addr *uint64, val uint64)\nfunc StoreUintptr(addr *uintptr, val uintptr)\nfunc StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)\n```\n\n## Swap\nSwap族函数是原子替换操作，第一个参数是操作数的地址，第二个参数是需要替换的新值，返回值是原来的旧值。\n```go\nfunc SwapInt32(addr *int32, new int32) (old int32)\nfunc SwapInt64(addr *int64, new int64) (old int64)\nfunc SwapUint32(addr *uint32, new uint32) (old uint32)\nfunc SwapUint64(addr *uint64, new uint64) (old uint64)\nfunc SwapUintptr(addr *uintptr, new uintptr) (old uintptr)\nfunc SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)\n```\n\n# Mutex\nMutex实现了互斥锁，即锁住的代码同一时间只有一个协程在执行。\n提供函数：\n```go\nfunc (m *Mutex) Lock()\nfunc (m *Mutex) Unlock()\n```\n\nMutex实现了Locker接口。\n```go\n// A Locker represents an object that can be locked and unlocked.\ntype Locker interface {\n    Lock()\n    Unlock()\n}\n```\n\n# RWMutex\nRWMutex是读写锁，适用于读多写少的场景。\n提供函数：\n```go\nfunc (rw *RWMutex) RLock()\nfunc (rw *RWMutex) RUnlock()\nfunc (rw *RWMutex) Lock()\nfunc (rw *RWMutex) Unlock()\nfunc (rw *RWMutex) RLocker() Locker\n```\n\nRLocker()函数返回读锁的接口对象，用于传入NewCond返回一个读锁的条件变量。\n\n# Cond\nCond是条件变量，条件变量的作用并不是保证在同一时刻仅有一个线程访问某一个共享数据，而是在对应的共享数据的状态发生变化时，通知其他因此而被阻塞的线程。\n提供函数：\n```go\nfunc NewCond(l Locker) *Cond\nfunc (c *Cond) Wait()\nfunc (c *Cond) Signal()\nfunc (c *Cond) Broadcast()\n```\n\n*   `cond.L.Lock()`和`cond.L.Unlock()`：也可以使用`lock.Lock()`和`lock.Unlock()`，完全一样，因为是指针转递\n*   `cond.Wait()`：Unlock()->**_阻塞等待通知(即等待Signal()或Broadcast()的通知)->收到通知_**->Lock()\n*   `cond.Signal()`：通知一个Wait()了的，若没有Wait()，也不会报错。**Signal()通知的顺序是根据原来加入通知列表(Wait())的先入先出**\n*   `cond.Broadcast()`: 通知所有Wait()了的，若没有Wait()，也不会报错\n\n示例：\n```go\nfunc main() {\n    data := []int{2, 4, 5, 6, 8, 9}\n    tmp := 0\n    c := sync.NewCond(new(sync.Mutex))\n    c.L.Lock()\n    defer c.L.Unlock()\n    \n    ctx, cancel := context.WithCancel(context.Background())\n    // 生产者\n    go func() {\n        for _, d := range data {\n            tmp = d\n            c.Signal()\n            time.Sleep(1 * time.Second)\n        }\n        cancel()\n        c.Signal() // 防止消费者进入wait死锁，但是会重复消费一次数据\n    }()\n    \n    // 消费者\n    for {\n        select {\n        case <-ctx.Done():\n            return\n        default:\n            c.Wait()\n            fmt.Println(tmp)\n            if tmp%2 != 0 {\n                fmt.Println(time.Now(), tmp)\n                continue\n            }\n        }\n    }\n}\n```\n\n上例可以看到Cond的使用并没有channel方便，所以一般还是使用channel进行顺序调用。Cond一般使用场景是唤起一个Wait协程，或者唤起所有Wait协程。\n\n# WaitGroup\nWaitGroup是等待一组进程运行完成。\n提供函数：\n```go\nfunc (wg *WaitGroup) Add(delta int)\nfunc (wg *WaitGroup) Done()\nfunc (wg *WaitGroup) Wait()\n```\n\nAdd函数delta类型是int，所以支持参数为负数的值，但是不能让计数器为负数，否则会panic。\nDone函数是递减1，也不能使计数器为负数，否则会panic。\nWait函数阻塞等待计数器为0。\n\nWaitGroup一个计数周期，即计数器从0转到正数开始，到计数器从正数到0结束，即为一个周期。当计数器为0时，Wait函数停止阻塞返回，在后面仍可以调用Add函数进行加计数器，即开启下一个周期，可以调用Wait函数等待下一次周期的结束。\n\n# Once\nOnce提供一个只执行一次的保护罩。\n提供函数：\n```go\nfunc (o *Once) Do(f func())\n```\n\n重复的调用同一Once对象的Do函数f只会执行一次，不管f是否相同。常用于init函数不能执行的执行一次操作，例如创建单例对象，初始化连接池，全局变量赋值等等。\n\n# Pool\nPool表示一个临时对象池，常用于同类型对象重复利用的场景。\n提供函数：\n```go\nfunc (p *Pool) Put(x interface{})\nfunc (p *Pool) Get()\n```\n\nPool有个成员`New func() interface{}`表示如果Get的时候没有对象则使用New新建一个对象。\nGet函数取到的值是随机的，不应该对Get函数取出的对象抱有任何假设，即在获取Get函数返回对象之后应该做一次重新赋值成默认值状态。\n\n> 摘自参考文献[1]\n这样一个临时对象池在功能上与一个通用的缓存池有几分相似。但是实际上，临时对象池本身的特性决定了它是一个很独特的同步工具。下面讲一下它的两个非常突出的特性。\n第一个特性，临时对象池可以把由其中的对象值产生的存储压力进行分摊。更进一步说，它会专门为每一个与操作它的goroutine相关联的P建立本地池。在临时对象池的Get方法被调用时，它一般会先尝试从与本地P对应的那个本地私有池和本地共享池中获取一个对象值。如果获取失败，它就会试图从其他P的本地共享池中偷一个对象值并直接返回给调用方。如果依然未果，它就只能把希望寄托于当前临时对象池的对象值生成函数了。注意，这个对象值生成函数产生的对象值永远不会被放置到池中，而是会被直接返回给调用方。另一方面，临时对象池的Put方法会把它的参数值存放到本地P的本地池中。每个相关P的本地共享池中的所有对象值，都是在当前临时对象池的范围内共享的。也就是说，它们随时可能会被偷走。\n临时对象池的第二个突出特性是对垃圾回收友好。垃圾回收的执行一般会使临时对象池中的对象值全部被移除。也就是说，即使我们永远不会显式地从临时对象池取走某个对象值，该对象值也不会永远待在临时对象池中，它的生命周期取决于垃圾回收任务下一次的执行时间。\n\n示例：垃圾回收清空临时对象池中的数据\n```go\nfunc main() {\n    // 禁用GC，并保证在main函数执行结束前恢复GC\n    defer debug.SetGCPercent(debug.SetGCPercent(-1))\n    var count int32\n    newFunc := func() interface{} {\n        return atomic.AddInt32(&count, 1)\n    }\n    pool := sync.Pool{New: newFunc}\n\n    // New字段值的作用\n    v1 := pool.Get()\n    fmt.Printf(\"Value 1: %v\\n\", v1)\n\n    // 临时对象池的存取\n    pool.Put(10)\n    pool.Put(11)\n    pool.Put(12)\n    v2 := pool.Get()\n    fmt.Printf(\"Value 2: %v\\n\", v2)\n\n    // 垃圾回收对临时对象池的影响\n    debug.SetGCPercent(100)\n    runtime.GC()\n    v3 := pool.Get()\n    fmt.Printf(\"Value 3: %v\\n\", v3)\n    pool.New = nil\n    v4 := pool.Get()\n    fmt.Printf(\"Value 4: %v\\n\", v4)\n}\n```\n\n# Map\nMap提供一个并发安全的map，由于golang的map并发操作会panic。\n提供函数：\n```go\nfunc (m *Map) Load(key interface{}) (value interface{}, ok bool)\nfunc (m *Map) Store(key, value interface{})\nfunc (m *Map) LoadOrStore(key, value interface{}) (actual interface{}, loaded bool)\nfunc (m *Map) Delete(key interface{})\nfunc (m *Map) Range(f func(key, value interface{}) bool)\n```\n\n由于Map的性能并没有`map+mutex`的性能好，所以一般用的比较少。\n\n# 参考文献\n1. [Go并发编程实战（第2版）](https://www.ituring.com.cn/book/tupubarticle/13514)\n2. [Golang中如何正确使用条件变量sync.Cond](https://ieevee.com/tech/2019/06/15/cond.html)\n3. [Go语言学习 - cyent笔记](https://cyent.github.io/golang/goroutine/sync_cond/)\n4. [由浅入深聊聊Golang的sync.Map](https://juejin.im/post/5d36a7cbf265da1bb47da444)","source":"_posts/sync包.md","raw":"---\nauthor: djaigo\ntitle: sync包\nimg: 'https://img-1251474779.cos.ap-beijing.myqcloud.com/golang.png'\ncategories:\n  - golang\ntags:\n  - sync\n  - mutex\n  - condition variable\n  - atomic\ndate: 2020-01-13 14:54:12\n---\n\n# atomic\n## Add\nAdd族函数是原子的加值操作，第一个参数是被操作值的地址，第二参数是要加的值是多少，返回值是加之后的值。\n如果要在无符号上减操作，建议的方法`delta=^uint32(delta-1)`，特别的如果要递减使用`delta=^uint32(0)`。\n\n```go\nfunc AddInt32(addr *int32, delta int32) (new int32)\nfunc AddUint32(addr *uint32, delta uint32) (new uint32)\nfunc AddInt64(addr *int64, delta int64) (new int64)\nfunc AddUint64(addr *uint64, delta uint64) (new uint64)\nfunc AddUintptr(addr *uintptr, delta uintptr) (new uintptr)\n```\n\n## CAS\nCAS族函数是比较并替换操作，第一个参数被操作值的地址，第二个参数是被操作数的原值，第三个参数是被操作数的新值。\n如果被操作数值不等于旧值则不进行替换，返回false，如果成功替换返回true。\n```go\nfunc CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)\nfunc CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool)\nfunc CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool)\nfunc CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool)\nfunc CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool)\nfunc CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)\n```\n\n\n## Load\nLoad族函数是原子的取出被操作数，第一个参数是被操作数的地址，返回值是地址执行的值。\n```go\nfunc LoadInt32(addr *int32) (val int32)\nfunc LoadInt64(addr *int64) (val int64)\nfunc LoadUint32(addr *uint32) (val uint32)\nfunc LoadUint64(addr *uint64) (val uint64)\nfunc LoadUintptr(addr *uintptr) (val uintptr)\nfunc LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)\n```\n\n## Store\nStore族函数是原子的存储被操作数，第一个参数是操作数的地址，第二个参数是被设置的值。\n```go\nfunc StoreInt32(addr *int32, val int32)\nfunc StoreInt64(addr *int64, val int64)\nfunc StoreUint32(addr *uint32, val uint32)\nfunc StoreUint64(addr *uint64, val uint64)\nfunc StoreUintptr(addr *uintptr, val uintptr)\nfunc StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)\n```\n\n## Swap\nSwap族函数是原子替换操作，第一个参数是操作数的地址，第二个参数是需要替换的新值，返回值是原来的旧值。\n```go\nfunc SwapInt32(addr *int32, new int32) (old int32)\nfunc SwapInt64(addr *int64, new int64) (old int64)\nfunc SwapUint32(addr *uint32, new uint32) (old uint32)\nfunc SwapUint64(addr *uint64, new uint64) (old uint64)\nfunc SwapUintptr(addr *uintptr, new uintptr) (old uintptr)\nfunc SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)\n```\n\n# Mutex\nMutex实现了互斥锁，即锁住的代码同一时间只有一个协程在执行。\n提供函数：\n```go\nfunc (m *Mutex) Lock()\nfunc (m *Mutex) Unlock()\n```\n\nMutex实现了Locker接口。\n```go\n// A Locker represents an object that can be locked and unlocked.\ntype Locker interface {\n    Lock()\n    Unlock()\n}\n```\n\n# RWMutex\nRWMutex是读写锁，适用于读多写少的场景。\n提供函数：\n```go\nfunc (rw *RWMutex) RLock()\nfunc (rw *RWMutex) RUnlock()\nfunc (rw *RWMutex) Lock()\nfunc (rw *RWMutex) Unlock()\nfunc (rw *RWMutex) RLocker() Locker\n```\n\nRLocker()函数返回读锁的接口对象，用于传入NewCond返回一个读锁的条件变量。\n\n# Cond\nCond是条件变量，条件变量的作用并不是保证在同一时刻仅有一个线程访问某一个共享数据，而是在对应的共享数据的状态发生变化时，通知其他因此而被阻塞的线程。\n提供函数：\n```go\nfunc NewCond(l Locker) *Cond\nfunc (c *Cond) Wait()\nfunc (c *Cond) Signal()\nfunc (c *Cond) Broadcast()\n```\n\n*   `cond.L.Lock()`和`cond.L.Unlock()`：也可以使用`lock.Lock()`和`lock.Unlock()`，完全一样，因为是指针转递\n*   `cond.Wait()`：Unlock()->**_阻塞等待通知(即等待Signal()或Broadcast()的通知)->收到通知_**->Lock()\n*   `cond.Signal()`：通知一个Wait()了的，若没有Wait()，也不会报错。**Signal()通知的顺序是根据原来加入通知列表(Wait())的先入先出**\n*   `cond.Broadcast()`: 通知所有Wait()了的，若没有Wait()，也不会报错\n\n示例：\n```go\nfunc main() {\n    data := []int{2, 4, 5, 6, 8, 9}\n    tmp := 0\n    c := sync.NewCond(new(sync.Mutex))\n    c.L.Lock()\n    defer c.L.Unlock()\n    \n    ctx, cancel := context.WithCancel(context.Background())\n    // 生产者\n    go func() {\n        for _, d := range data {\n            tmp = d\n            c.Signal()\n            time.Sleep(1 * time.Second)\n        }\n        cancel()\n        c.Signal() // 防止消费者进入wait死锁，但是会重复消费一次数据\n    }()\n    \n    // 消费者\n    for {\n        select {\n        case <-ctx.Done():\n            return\n        default:\n            c.Wait()\n            fmt.Println(tmp)\n            if tmp%2 != 0 {\n                fmt.Println(time.Now(), tmp)\n                continue\n            }\n        }\n    }\n}\n```\n\n上例可以看到Cond的使用并没有channel方便，所以一般还是使用channel进行顺序调用。Cond一般使用场景是唤起一个Wait协程，或者唤起所有Wait协程。\n\n# WaitGroup\nWaitGroup是等待一组进程运行完成。\n提供函数：\n```go\nfunc (wg *WaitGroup) Add(delta int)\nfunc (wg *WaitGroup) Done()\nfunc (wg *WaitGroup) Wait()\n```\n\nAdd函数delta类型是int，所以支持参数为负数的值，但是不能让计数器为负数，否则会panic。\nDone函数是递减1，也不能使计数器为负数，否则会panic。\nWait函数阻塞等待计数器为0。\n\nWaitGroup一个计数周期，即计数器从0转到正数开始，到计数器从正数到0结束，即为一个周期。当计数器为0时，Wait函数停止阻塞返回，在后面仍可以调用Add函数进行加计数器，即开启下一个周期，可以调用Wait函数等待下一次周期的结束。\n\n# Once\nOnce提供一个只执行一次的保护罩。\n提供函数：\n```go\nfunc (o *Once) Do(f func())\n```\n\n重复的调用同一Once对象的Do函数f只会执行一次，不管f是否相同。常用于init函数不能执行的执行一次操作，例如创建单例对象，初始化连接池，全局变量赋值等等。\n\n# Pool\nPool表示一个临时对象池，常用于同类型对象重复利用的场景。\n提供函数：\n```go\nfunc (p *Pool) Put(x interface{})\nfunc (p *Pool) Get()\n```\n\nPool有个成员`New func() interface{}`表示如果Get的时候没有对象则使用New新建一个对象。\nGet函数取到的值是随机的，不应该对Get函数取出的对象抱有任何假设，即在获取Get函数返回对象之后应该做一次重新赋值成默认值状态。\n\n> 摘自参考文献[1]\n这样一个临时对象池在功能上与一个通用的缓存池有几分相似。但是实际上，临时对象池本身的特性决定了它是一个很独特的同步工具。下面讲一下它的两个非常突出的特性。\n第一个特性，临时对象池可以把由其中的对象值产生的存储压力进行分摊。更进一步说，它会专门为每一个与操作它的goroutine相关联的P建立本地池。在临时对象池的Get方法被调用时，它一般会先尝试从与本地P对应的那个本地私有池和本地共享池中获取一个对象值。如果获取失败，它就会试图从其他P的本地共享池中偷一个对象值并直接返回给调用方。如果依然未果，它就只能把希望寄托于当前临时对象池的对象值生成函数了。注意，这个对象值生成函数产生的对象值永远不会被放置到池中，而是会被直接返回给调用方。另一方面，临时对象池的Put方法会把它的参数值存放到本地P的本地池中。每个相关P的本地共享池中的所有对象值，都是在当前临时对象池的范围内共享的。也就是说，它们随时可能会被偷走。\n临时对象池的第二个突出特性是对垃圾回收友好。垃圾回收的执行一般会使临时对象池中的对象值全部被移除。也就是说，即使我们永远不会显式地从临时对象池取走某个对象值，该对象值也不会永远待在临时对象池中，它的生命周期取决于垃圾回收任务下一次的执行时间。\n\n示例：垃圾回收清空临时对象池中的数据\n```go\nfunc main() {\n    // 禁用GC，并保证在main函数执行结束前恢复GC\n    defer debug.SetGCPercent(debug.SetGCPercent(-1))\n    var count int32\n    newFunc := func() interface{} {\n        return atomic.AddInt32(&count, 1)\n    }\n    pool := sync.Pool{New: newFunc}\n\n    // New字段值的作用\n    v1 := pool.Get()\n    fmt.Printf(\"Value 1: %v\\n\", v1)\n\n    // 临时对象池的存取\n    pool.Put(10)\n    pool.Put(11)\n    pool.Put(12)\n    v2 := pool.Get()\n    fmt.Printf(\"Value 2: %v\\n\", v2)\n\n    // 垃圾回收对临时对象池的影响\n    debug.SetGCPercent(100)\n    runtime.GC()\n    v3 := pool.Get()\n    fmt.Printf(\"Value 3: %v\\n\", v3)\n    pool.New = nil\n    v4 := pool.Get()\n    fmt.Printf(\"Value 4: %v\\n\", v4)\n}\n```\n\n# Map\nMap提供一个并发安全的map，由于golang的map并发操作会panic。\n提供函数：\n```go\nfunc (m *Map) Load(key interface{}) (value interface{}, ok bool)\nfunc (m *Map) Store(key, value interface{})\nfunc (m *Map) LoadOrStore(key, value interface{}) (actual interface{}, loaded bool)\nfunc (m *Map) Delete(key interface{})\nfunc (m *Map) Range(f func(key, value interface{}) bool)\n```\n\n由于Map的性能并没有`map+mutex`的性能好，所以一般用的比较少。\n\n# 参考文献\n1. [Go并发编程实战（第2版）](https://www.ituring.com.cn/book/tupubarticle/13514)\n2. [Golang中如何正确使用条件变量sync.Cond](https://ieevee.com/tech/2019/06/15/cond.html)\n3. [Go语言学习 - cyent笔记](https://cyent.github.io/golang/goroutine/sync_cond/)\n4. [由浅入深聊聊Golang的sync.Map](https://juejin.im/post/5d36a7cbf265da1bb47da444)","slug":"sync包","published":1,"updated":"2020-01-13T06:54:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh351dv9002g19z4hg3j9md2","content":"<h1 id=\"atomic\"><a href=\"#atomic\" class=\"headerlink\" title=\"atomic\"></a>atomic</h1><h2 id=\"Add\"><a href=\"#Add\" class=\"headerlink\" title=\"Add\"></a>Add</h2><p>Add族函数是原子的加值操作，第一个参数是被操作值的地址，第二参数是要加的值是多少，返回值是加之后的值。<br>如果要在无符号上减操作，建议的方法<code>delta=^uint32(delta-1)</code>，特别的如果要递减使用<code>delta=^uint32(0)</code>。</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">AddInt32</span><span class=\"token punctuation\">(</span>addr <span class=\"token operator\">*</span><span class=\"token builtin\">int32</span><span class=\"token punctuation\">,</span> delta <span class=\"token builtin\">int32</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">new</span> <span class=\"token builtin\">int32</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">AddUint32</span><span class=\"token punctuation\">(</span>addr <span class=\"token operator\">*</span><span class=\"token builtin\">uint32</span><span class=\"token punctuation\">,</span> delta <span class=\"token builtin\">uint32</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">new</span> <span class=\"token builtin\">uint32</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">AddInt64</span><span class=\"token punctuation\">(</span>addr <span class=\"token operator\">*</span><span class=\"token builtin\">int64</span><span class=\"token punctuation\">,</span> delta <span class=\"token builtin\">int64</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">new</span> <span class=\"token builtin\">int64</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">AddUint64</span><span class=\"token punctuation\">(</span>addr <span class=\"token operator\">*</span><span class=\"token builtin\">uint64</span><span class=\"token punctuation\">,</span> delta <span class=\"token builtin\">uint64</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">new</span> <span class=\"token builtin\">uint64</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">AddUintptr</span><span class=\"token punctuation\">(</span>addr <span class=\"token operator\">*</span><span class=\"token builtin\">uintptr</span><span class=\"token punctuation\">,</span> delta <span class=\"token builtin\">uintptr</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">new</span> <span class=\"token builtin\">uintptr</span><span class=\"token punctuation\">)</span></code></pre>\n<h2 id=\"CAS\"><a href=\"#CAS\" class=\"headerlink\" title=\"CAS\"></a>CAS</h2><p>CAS族函数是比较并替换操作，第一个参数被操作值的地址，第二个参数是被操作数的原值，第三个参数是被操作数的新值。<br>如果被操作数值不等于旧值则不进行替换，返回false，如果成功替换返回true。</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">CompareAndSwapInt32</span><span class=\"token punctuation\">(</span>addr <span class=\"token operator\">*</span><span class=\"token builtin\">int32</span><span class=\"token punctuation\">,</span> old<span class=\"token punctuation\">,</span> <span class=\"token builtin\">new</span> <span class=\"token builtin\">int32</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>swapped <span class=\"token builtin\">bool</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">CompareAndSwapInt64</span><span class=\"token punctuation\">(</span>addr <span class=\"token operator\">*</span><span class=\"token builtin\">int64</span><span class=\"token punctuation\">,</span> old<span class=\"token punctuation\">,</span> <span class=\"token builtin\">new</span> <span class=\"token builtin\">int64</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>swapped <span class=\"token builtin\">bool</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">CompareAndSwapUint32</span><span class=\"token punctuation\">(</span>addr <span class=\"token operator\">*</span><span class=\"token builtin\">uint32</span><span class=\"token punctuation\">,</span> old<span class=\"token punctuation\">,</span> <span class=\"token builtin\">new</span> <span class=\"token builtin\">uint32</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>swapped <span class=\"token builtin\">bool</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">CompareAndSwapUint64</span><span class=\"token punctuation\">(</span>addr <span class=\"token operator\">*</span><span class=\"token builtin\">uint64</span><span class=\"token punctuation\">,</span> old<span class=\"token punctuation\">,</span> <span class=\"token builtin\">new</span> <span class=\"token builtin\">uint64</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>swapped <span class=\"token builtin\">bool</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">CompareAndSwapUintptr</span><span class=\"token punctuation\">(</span>addr <span class=\"token operator\">*</span><span class=\"token builtin\">uintptr</span><span class=\"token punctuation\">,</span> old<span class=\"token punctuation\">,</span> <span class=\"token builtin\">new</span> <span class=\"token builtin\">uintptr</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>swapped <span class=\"token builtin\">bool</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">CompareAndSwapPointer</span><span class=\"token punctuation\">(</span>addr <span class=\"token operator\">*</span>unsafe<span class=\"token punctuation\">.</span>Pointer<span class=\"token punctuation\">,</span> old<span class=\"token punctuation\">,</span> <span class=\"token builtin\">new</span> unsafe<span class=\"token punctuation\">.</span>Pointer<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>swapped <span class=\"token builtin\">bool</span><span class=\"token punctuation\">)</span></code></pre>\n<h2 id=\"Load\"><a href=\"#Load\" class=\"headerlink\" title=\"Load\"></a>Load</h2><p>Load族函数是原子的取出被操作数，第一个参数是被操作数的地址，返回值是地址执行的值。</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">LoadInt32</span><span class=\"token punctuation\">(</span>addr <span class=\"token operator\">*</span><span class=\"token builtin\">int32</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>val <span class=\"token builtin\">int32</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">LoadInt64</span><span class=\"token punctuation\">(</span>addr <span class=\"token operator\">*</span><span class=\"token builtin\">int64</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>val <span class=\"token builtin\">int64</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">LoadUint32</span><span class=\"token punctuation\">(</span>addr <span class=\"token operator\">*</span><span class=\"token builtin\">uint32</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>val <span class=\"token builtin\">uint32</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">LoadUint64</span><span class=\"token punctuation\">(</span>addr <span class=\"token operator\">*</span><span class=\"token builtin\">uint64</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>val <span class=\"token builtin\">uint64</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">LoadUintptr</span><span class=\"token punctuation\">(</span>addr <span class=\"token operator\">*</span><span class=\"token builtin\">uintptr</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>val <span class=\"token builtin\">uintptr</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">LoadPointer</span><span class=\"token punctuation\">(</span>addr <span class=\"token operator\">*</span>unsafe<span class=\"token punctuation\">.</span>Pointer<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>val unsafe<span class=\"token punctuation\">.</span>Pointer<span class=\"token punctuation\">)</span></code></pre>\n<h2 id=\"Store\"><a href=\"#Store\" class=\"headerlink\" title=\"Store\"></a>Store</h2><p>Store族函数是原子的存储被操作数，第一个参数是操作数的地址，第二个参数是被设置的值。</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">StoreInt32</span><span class=\"token punctuation\">(</span>addr <span class=\"token operator\">*</span><span class=\"token builtin\">int32</span><span class=\"token punctuation\">,</span> val <span class=\"token builtin\">int32</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">StoreInt64</span><span class=\"token punctuation\">(</span>addr <span class=\"token operator\">*</span><span class=\"token builtin\">int64</span><span class=\"token punctuation\">,</span> val <span class=\"token builtin\">int64</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">StoreUint32</span><span class=\"token punctuation\">(</span>addr <span class=\"token operator\">*</span><span class=\"token builtin\">uint32</span><span class=\"token punctuation\">,</span> val <span class=\"token builtin\">uint32</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">StoreUint64</span><span class=\"token punctuation\">(</span>addr <span class=\"token operator\">*</span><span class=\"token builtin\">uint64</span><span class=\"token punctuation\">,</span> val <span class=\"token builtin\">uint64</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">StoreUintptr</span><span class=\"token punctuation\">(</span>addr <span class=\"token operator\">*</span><span class=\"token builtin\">uintptr</span><span class=\"token punctuation\">,</span> val <span class=\"token builtin\">uintptr</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">StorePointer</span><span class=\"token punctuation\">(</span>addr <span class=\"token operator\">*</span>unsafe<span class=\"token punctuation\">.</span>Pointer<span class=\"token punctuation\">,</span> val unsafe<span class=\"token punctuation\">.</span>Pointer<span class=\"token punctuation\">)</span></code></pre>\n<h2 id=\"Swap\"><a href=\"#Swap\" class=\"headerlink\" title=\"Swap\"></a>Swap</h2><p>Swap族函数是原子替换操作，第一个参数是操作数的地址，第二个参数是需要替换的新值，返回值是原来的旧值。</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">SwapInt32</span><span class=\"token punctuation\">(</span>addr <span class=\"token operator\">*</span><span class=\"token builtin\">int32</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">new</span> <span class=\"token builtin\">int32</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>old <span class=\"token builtin\">int32</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">SwapInt64</span><span class=\"token punctuation\">(</span>addr <span class=\"token operator\">*</span><span class=\"token builtin\">int64</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">new</span> <span class=\"token builtin\">int64</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>old <span class=\"token builtin\">int64</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">SwapUint32</span><span class=\"token punctuation\">(</span>addr <span class=\"token operator\">*</span><span class=\"token builtin\">uint32</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">new</span> <span class=\"token builtin\">uint32</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>old <span class=\"token builtin\">uint32</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">SwapUint64</span><span class=\"token punctuation\">(</span>addr <span class=\"token operator\">*</span><span class=\"token builtin\">uint64</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">new</span> <span class=\"token builtin\">uint64</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>old <span class=\"token builtin\">uint64</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">SwapUintptr</span><span class=\"token punctuation\">(</span>addr <span class=\"token operator\">*</span><span class=\"token builtin\">uintptr</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">new</span> <span class=\"token builtin\">uintptr</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>old <span class=\"token builtin\">uintptr</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">SwapPointer</span><span class=\"token punctuation\">(</span>addr <span class=\"token operator\">*</span>unsafe<span class=\"token punctuation\">.</span>Pointer<span class=\"token punctuation\">,</span> <span class=\"token builtin\">new</span> unsafe<span class=\"token punctuation\">.</span>Pointer<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>old unsafe<span class=\"token punctuation\">.</span>Pointer<span class=\"token punctuation\">)</span></code></pre>\n<h1 id=\"Mutex\"><a href=\"#Mutex\" class=\"headerlink\" title=\"Mutex\"></a>Mutex</h1><p>Mutex实现了互斥锁，即锁住的代码同一时间只有一个协程在执行。<br>提供函数：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>m <span class=\"token operator\">*</span>Mutex<span class=\"token punctuation\">)</span> <span class=\"token function\">Lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>m <span class=\"token operator\">*</span>Mutex<span class=\"token punctuation\">)</span> <span class=\"token function\">Unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre>\n<p>Mutex实现了Locker接口。</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token comment\" spellcheck=\"true\">// A Locker represents an object that can be locked and unlocked.</span>\n<span class=\"token keyword\">type</span> Locker <span class=\"token keyword\">interface</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">Lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">Unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"RWMutex\"><a href=\"#RWMutex\" class=\"headerlink\" title=\"RWMutex\"></a>RWMutex</h1><p>RWMutex是读写锁，适用于读多写少的场景。<br>提供函数：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>rw <span class=\"token operator\">*</span>RWMutex<span class=\"token punctuation\">)</span> <span class=\"token function\">RLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>rw <span class=\"token operator\">*</span>RWMutex<span class=\"token punctuation\">)</span> <span class=\"token function\">RUnlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>rw <span class=\"token operator\">*</span>RWMutex<span class=\"token punctuation\">)</span> <span class=\"token function\">Lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>rw <span class=\"token operator\">*</span>RWMutex<span class=\"token punctuation\">)</span> <span class=\"token function\">Unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>rw <span class=\"token operator\">*</span>RWMutex<span class=\"token punctuation\">)</span> <span class=\"token function\">RLocker</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> Locker</code></pre>\n<p>RLocker()函数返回读锁的接口对象，用于传入NewCond返回一个读锁的条件变量。</p>\n<h1 id=\"Cond\"><a href=\"#Cond\" class=\"headerlink\" title=\"Cond\"></a>Cond</h1><p>Cond是条件变量，条件变量的作用并不是保证在同一时刻仅有一个线程访问某一个共享数据，而是在对应的共享数据的状态发生变化时，通知其他因此而被阻塞的线程。<br>提供函数：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">NewCond</span><span class=\"token punctuation\">(</span>l Locker<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span>Cond\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>c <span class=\"token operator\">*</span>Cond<span class=\"token punctuation\">)</span> <span class=\"token function\">Wait</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>c <span class=\"token operator\">*</span>Cond<span class=\"token punctuation\">)</span> <span class=\"token function\">Signal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>c <span class=\"token operator\">*</span>Cond<span class=\"token punctuation\">)</span> <span class=\"token function\">Broadcast</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre>\n<ul>\n<li><code>cond.L.Lock()</code>和<code>cond.L.Unlock()</code>：也可以使用<code>lock.Lock()</code>和<code>lock.Unlock()</code>，完全一样，因为是指针转递</li>\n<li><code>cond.Wait()</code>：Unlock()-&gt;<strong><em>阻塞等待通知(即等待Signal()或Broadcast()的通知)-&gt;收到通知</em></strong>-&gt;Lock()</li>\n<li><code>cond.Signal()</code>：通知一个Wait()了的，若没有Wait()，也不会报错。<strong>Signal()通知的顺序是根据原来加入通知列表(Wait())的先入先出</strong></li>\n<li><code>cond.Broadcast()</code>: 通知所有Wait()了的，若没有Wait()，也不会报错</li>\n</ul>\n<p>示例：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    data <span class=\"token operator\">:=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">{</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8</span><span class=\"token punctuation\">,</span> <span class=\"token number\">9</span><span class=\"token punctuation\">}</span>\n    tmp <span class=\"token operator\">:=</span> <span class=\"token number\">0</span>\n    c <span class=\"token operator\">:=</span> sync<span class=\"token punctuation\">.</span><span class=\"token function\">NewCond</span><span class=\"token punctuation\">(</span><span class=\"token function\">new</span><span class=\"token punctuation\">(</span>sync<span class=\"token punctuation\">.</span>Mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    c<span class=\"token punctuation\">.</span>L<span class=\"token punctuation\">.</span><span class=\"token function\">Lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">defer</span> c<span class=\"token punctuation\">.</span>L<span class=\"token punctuation\">.</span><span class=\"token function\">Unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    ctx<span class=\"token punctuation\">,</span> cancel <span class=\"token operator\">:=</span> context<span class=\"token punctuation\">.</span><span class=\"token function\">WithCancel</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">.</span><span class=\"token function\">Background</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 生产者</span>\n    <span class=\"token keyword\">go</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> <span class=\"token boolean\">_</span><span class=\"token punctuation\">,</span> d <span class=\"token operator\">:=</span> <span class=\"token keyword\">range</span> data <span class=\"token punctuation\">{</span>\n            tmp <span class=\"token operator\">=</span> d\n            c<span class=\"token punctuation\">.</span><span class=\"token function\">Signal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n            time<span class=\"token punctuation\">.</span><span class=\"token function\">Sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span> <span class=\"token operator\">*</span> time<span class=\"token punctuation\">.</span>Second<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token function\">cancel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        c<span class=\"token punctuation\">.</span><span class=\"token function\">Signal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 防止消费者进入wait死锁，但是会重复消费一次数据</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 消费者</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">select</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">case</span> <span class=\"token operator\">&lt;-</span>ctx<span class=\"token punctuation\">.</span><span class=\"token function\">Done</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">return</span>\n        <span class=\"token keyword\">default</span><span class=\"token punctuation\">:</span>\n            c<span class=\"token punctuation\">.</span><span class=\"token function\">Wait</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n            fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>tmp<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">if</span> tmp<span class=\"token operator\">%</span><span class=\"token number\">2</span> <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n                fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>time<span class=\"token punctuation\">.</span><span class=\"token function\">Now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> tmp<span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">continue</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>上例可以看到Cond的使用并没有channel方便，所以一般还是使用channel进行顺序调用。Cond一般使用场景是唤起一个Wait协程，或者唤起所有Wait协程。</p>\n<h1 id=\"WaitGroup\"><a href=\"#WaitGroup\" class=\"headerlink\" title=\"WaitGroup\"></a>WaitGroup</h1><p>WaitGroup是等待一组进程运行完成。<br>提供函数：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>wg <span class=\"token operator\">*</span>WaitGroup<span class=\"token punctuation\">)</span> <span class=\"token function\">Add</span><span class=\"token punctuation\">(</span>delta <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>wg <span class=\"token operator\">*</span>WaitGroup<span class=\"token punctuation\">)</span> <span class=\"token function\">Done</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>wg <span class=\"token operator\">*</span>WaitGroup<span class=\"token punctuation\">)</span> <span class=\"token function\">Wait</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre>\n<p>Add函数delta类型是int，所以支持参数为负数的值，但是不能让计数器为负数，否则会panic。<br>Done函数是递减1，也不能使计数器为负数，否则会panic。<br>Wait函数阻塞等待计数器为0。</p>\n<p>WaitGroup一个计数周期，即计数器从0转到正数开始，到计数器从正数到0结束，即为一个周期。当计数器为0时，Wait函数停止阻塞返回，在后面仍可以调用Add函数进行加计数器，即开启下一个周期，可以调用Wait函数等待下一次周期的结束。</p>\n<h1 id=\"Once\"><a href=\"#Once\" class=\"headerlink\" title=\"Once\"></a>Once</h1><p>Once提供一个只执行一次的保护罩。<br>提供函数：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>o <span class=\"token operator\">*</span>Once<span class=\"token punctuation\">)</span> <span class=\"token function\">Do</span><span class=\"token punctuation\">(</span>f <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre>\n<p>重复的调用同一Once对象的Do函数f只会执行一次，不管f是否相同。常用于init函数不能执行的执行一次操作，例如创建单例对象，初始化连接池，全局变量赋值等等。</p>\n<h1 id=\"Pool\"><a href=\"#Pool\" class=\"headerlink\" title=\"Pool\"></a>Pool</h1><p>Pool表示一个临时对象池，常用于同类型对象重复利用的场景。<br>提供函数：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>p <span class=\"token operator\">*</span>Pool<span class=\"token punctuation\">)</span> <span class=\"token function\">Put</span><span class=\"token punctuation\">(</span>x <span class=\"token keyword\">interface</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>p <span class=\"token operator\">*</span>Pool<span class=\"token punctuation\">)</span> <span class=\"token function\">Get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre>\n<p>Pool有个成员<code>New func() interface{}</code>表示如果Get的时候没有对象则使用New新建一个对象。<br>Get函数取到的值是随机的，不应该对Get函数取出的对象抱有任何假设，即在获取Get函数返回对象之后应该做一次重新赋值成默认值状态。</p>\n<blockquote>\n<p>摘自参考文献[1]<br>这样一个临时对象池在功能上与一个通用的缓存池有几分相似。但是实际上，临时对象池本身的特性决定了它是一个很独特的同步工具。下面讲一下它的两个非常突出的特性。<br>第一个特性，临时对象池可以把由其中的对象值产生的存储压力进行分摊。更进一步说，它会专门为每一个与操作它的goroutine相关联的P建立本地池。在临时对象池的Get方法被调用时，它一般会先尝试从与本地P对应的那个本地私有池和本地共享池中获取一个对象值。如果获取失败，它就会试图从其他P的本地共享池中偷一个对象值并直接返回给调用方。如果依然未果，它就只能把希望寄托于当前临时对象池的对象值生成函数了。注意，这个对象值生成函数产生的对象值永远不会被放置到池中，而是会被直接返回给调用方。另一方面，临时对象池的Put方法会把它的参数值存放到本地P的本地池中。每个相关P的本地共享池中的所有对象值，都是在当前临时对象池的范围内共享的。也就是说，它们随时可能会被偷走。<br>临时对象池的第二个突出特性是对垃圾回收友好。垃圾回收的执行一般会使临时对象池中的对象值全部被移除。也就是说，即使我们永远不会显式地从临时对象池取走某个对象值，该对象值也不会永远待在临时对象池中，它的生命周期取决于垃圾回收任务下一次的执行时间。</p>\n</blockquote>\n<p>示例：垃圾回收清空临时对象池中的数据</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 禁用GC，并保证在main函数执行结束前恢复GC</span>\n    <span class=\"token keyword\">defer</span> debug<span class=\"token punctuation\">.</span><span class=\"token function\">SetGCPercent</span><span class=\"token punctuation\">(</span>debug<span class=\"token punctuation\">.</span><span class=\"token function\">SetGCPercent</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">var</span> count <span class=\"token builtin\">int32</span>\n    newFunc <span class=\"token operator\">:=</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">interface</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> atomic<span class=\"token punctuation\">.</span><span class=\"token function\">AddInt32</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>count<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    pool <span class=\"token operator\">:=</span> sync<span class=\"token punctuation\">.</span>Pool<span class=\"token punctuation\">{</span>New<span class=\"token punctuation\">:</span> newFunc<span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// New字段值的作用</span>\n    v1 <span class=\"token operator\">:=</span> pool<span class=\"token punctuation\">.</span><span class=\"token function\">Get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Value 1: %v\\n\"</span><span class=\"token punctuation\">,</span> v1<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 临时对象池的存取</span>\n    pool<span class=\"token punctuation\">.</span><span class=\"token function\">Put</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span>\n    pool<span class=\"token punctuation\">.</span><span class=\"token function\">Put</span><span class=\"token punctuation\">(</span><span class=\"token number\">11</span><span class=\"token punctuation\">)</span>\n    pool<span class=\"token punctuation\">.</span><span class=\"token function\">Put</span><span class=\"token punctuation\">(</span><span class=\"token number\">12</span><span class=\"token punctuation\">)</span>\n    v2 <span class=\"token operator\">:=</span> pool<span class=\"token punctuation\">.</span><span class=\"token function\">Get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Value 2: %v\\n\"</span><span class=\"token punctuation\">,</span> v2<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 垃圾回收对临时对象池的影响</span>\n    debug<span class=\"token punctuation\">.</span><span class=\"token function\">SetGCPercent</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span>\n    runtime<span class=\"token punctuation\">.</span><span class=\"token function\">GC</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    v3 <span class=\"token operator\">:=</span> pool<span class=\"token punctuation\">.</span><span class=\"token function\">Get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Value 3: %v\\n\"</span><span class=\"token punctuation\">,</span> v3<span class=\"token punctuation\">)</span>\n    pool<span class=\"token punctuation\">.</span>New <span class=\"token operator\">=</span> <span class=\"token boolean\">nil</span>\n    v4 <span class=\"token operator\">:=</span> pool<span class=\"token punctuation\">.</span><span class=\"token function\">Get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Value 4: %v\\n\"</span><span class=\"token punctuation\">,</span> v4<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h1><p>Map提供一个并发安全的map，由于golang的map并发操作会panic。<br>提供函数：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>m <span class=\"token operator\">*</span>Map<span class=\"token punctuation\">)</span> <span class=\"token function\">Load</span><span class=\"token punctuation\">(</span>key <span class=\"token keyword\">interface</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>value <span class=\"token keyword\">interface</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> ok <span class=\"token builtin\">bool</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>m <span class=\"token operator\">*</span>Map<span class=\"token punctuation\">)</span> <span class=\"token function\">Store</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> value <span class=\"token keyword\">interface</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>m <span class=\"token operator\">*</span>Map<span class=\"token punctuation\">)</span> <span class=\"token function\">LoadOrStore</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> value <span class=\"token keyword\">interface</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>actual <span class=\"token keyword\">interface</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> loaded <span class=\"token builtin\">bool</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>m <span class=\"token operator\">*</span>Map<span class=\"token punctuation\">)</span> <span class=\"token function\">Delete</span><span class=\"token punctuation\">(</span>key <span class=\"token keyword\">interface</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>m <span class=\"token operator\">*</span>Map<span class=\"token punctuation\">)</span> <span class=\"token function\">Range</span><span class=\"token punctuation\">(</span>f <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> value <span class=\"token keyword\">interface</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">bool</span><span class=\"token punctuation\">)</span></code></pre>\n<p>由于Map的性能并没有<code>map+mutex</code>的性能好，所以一般用的比较少。</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ol>\n<li><a href=\"https://www.ituring.com.cn/book/tupubarticle/13514\" target=\"_blank\" rel=\"noopener\">Go并发编程实战（第2版）</a></li>\n<li><a href=\"https://ieevee.com/tech/2019/06/15/cond.html\" target=\"_blank\" rel=\"noopener\">Golang中如何正确使用条件变量sync.Cond</a></li>\n<li><a href=\"https://cyent.github.io/golang/goroutine/sync_cond/\" target=\"_blank\" rel=\"noopener\">Go语言学习 - cyent笔记</a></li>\n<li><a href=\"https://juejin.im/post/5d36a7cbf265da1bb47da444\" target=\"_blank\" rel=\"noopener\">由浅入深聊聊Golang的sync.Map</a></li>\n</ol>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"friends":[{"avatar":"https://img-1251474779.cos.ap-beijing.myqcloud.com/icon.png","name":"djaigo","introduction":"好好学习，天天向上","url":"/","title":"前去学习"},{"avatar":"https://awps-assets.meituan.net/mit/blog/v20190629/asset/icon/favicon.ico?v=Whistle&t=20181017-1r","name":"美团技术团队","introduction":"一行代码，亿万生活。","url":"https://tech.meituan.com/","title":"点个外卖-->"},{"avatar":"","name":"鸟窝","introduction":"rpcx作者","url":"https://colobu.com/","title":"进个鸟窝-->"},{"avatar":"https://d1j8pt39hxlh3d.cloudfront.net/emoji/emojione/5.0/png/unicode/32/1f92a.png","name":"labuladong的算法小抄","introduction":"算法大神","url":"https://labuladong.gitbook.io/algo/","title":"学个算法-->"}]}},"excerpt":"","more":"<h1 id=\"atomic\"><a href=\"#atomic\" class=\"headerlink\" title=\"atomic\"></a>atomic</h1><h2 id=\"Add\"><a href=\"#Add\" class=\"headerlink\" title=\"Add\"></a>Add</h2><p>Add族函数是原子的加值操作，第一个参数是被操作值的地址，第二参数是要加的值是多少，返回值是加之后的值。<br>如果要在无符号上减操作，建议的方法<code>delta=^uint32(delta-1)</code>，特别的如果要递减使用<code>delta=^uint32(0)</code>。</p>\n<pre><code class=\"go\">func AddInt32(addr *int32, delta int32) (new int32)\nfunc AddUint32(addr *uint32, delta uint32) (new uint32)\nfunc AddInt64(addr *int64, delta int64) (new int64)\nfunc AddUint64(addr *uint64, delta uint64) (new uint64)\nfunc AddUintptr(addr *uintptr, delta uintptr) (new uintptr)</code></pre>\n<h2 id=\"CAS\"><a href=\"#CAS\" class=\"headerlink\" title=\"CAS\"></a>CAS</h2><p>CAS族函数是比较并替换操作，第一个参数被操作值的地址，第二个参数是被操作数的原值，第三个参数是被操作数的新值。<br>如果被操作数值不等于旧值则不进行替换，返回false，如果成功替换返回true。</p>\n<pre><code class=\"go\">func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)\nfunc CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool)\nfunc CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool)\nfunc CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool)\nfunc CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool)\nfunc CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)</code></pre>\n<h2 id=\"Load\"><a href=\"#Load\" class=\"headerlink\" title=\"Load\"></a>Load</h2><p>Load族函数是原子的取出被操作数，第一个参数是被操作数的地址，返回值是地址执行的值。</p>\n<pre><code class=\"go\">func LoadInt32(addr *int32) (val int32)\nfunc LoadInt64(addr *int64) (val int64)\nfunc LoadUint32(addr *uint32) (val uint32)\nfunc LoadUint64(addr *uint64) (val uint64)\nfunc LoadUintptr(addr *uintptr) (val uintptr)\nfunc LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)</code></pre>\n<h2 id=\"Store\"><a href=\"#Store\" class=\"headerlink\" title=\"Store\"></a>Store</h2><p>Store族函数是原子的存储被操作数，第一个参数是操作数的地址，第二个参数是被设置的值。</p>\n<pre><code class=\"go\">func StoreInt32(addr *int32, val int32)\nfunc StoreInt64(addr *int64, val int64)\nfunc StoreUint32(addr *uint32, val uint32)\nfunc StoreUint64(addr *uint64, val uint64)\nfunc StoreUintptr(addr *uintptr, val uintptr)\nfunc StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)</code></pre>\n<h2 id=\"Swap\"><a href=\"#Swap\" class=\"headerlink\" title=\"Swap\"></a>Swap</h2><p>Swap族函数是原子替换操作，第一个参数是操作数的地址，第二个参数是需要替换的新值，返回值是原来的旧值。</p>\n<pre><code class=\"go\">func SwapInt32(addr *int32, new int32) (old int32)\nfunc SwapInt64(addr *int64, new int64) (old int64)\nfunc SwapUint32(addr *uint32, new uint32) (old uint32)\nfunc SwapUint64(addr *uint64, new uint64) (old uint64)\nfunc SwapUintptr(addr *uintptr, new uintptr) (old uintptr)\nfunc SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)</code></pre>\n<h1 id=\"Mutex\"><a href=\"#Mutex\" class=\"headerlink\" title=\"Mutex\"></a>Mutex</h1><p>Mutex实现了互斥锁，即锁住的代码同一时间只有一个协程在执行。<br>提供函数：</p>\n<pre><code class=\"go\">func (m *Mutex) Lock()\nfunc (m *Mutex) Unlock()</code></pre>\n<p>Mutex实现了Locker接口。</p>\n<pre><code class=\"go\">// A Locker represents an object that can be locked and unlocked.\ntype Locker interface {\n    Lock()\n    Unlock()\n}</code></pre>\n<h1 id=\"RWMutex\"><a href=\"#RWMutex\" class=\"headerlink\" title=\"RWMutex\"></a>RWMutex</h1><p>RWMutex是读写锁，适用于读多写少的场景。<br>提供函数：</p>\n<pre><code class=\"go\">func (rw *RWMutex) RLock()\nfunc (rw *RWMutex) RUnlock()\nfunc (rw *RWMutex) Lock()\nfunc (rw *RWMutex) Unlock()\nfunc (rw *RWMutex) RLocker() Locker</code></pre>\n<p>RLocker()函数返回读锁的接口对象，用于传入NewCond返回一个读锁的条件变量。</p>\n<h1 id=\"Cond\"><a href=\"#Cond\" class=\"headerlink\" title=\"Cond\"></a>Cond</h1><p>Cond是条件变量，条件变量的作用并不是保证在同一时刻仅有一个线程访问某一个共享数据，而是在对应的共享数据的状态发生变化时，通知其他因此而被阻塞的线程。<br>提供函数：</p>\n<pre><code class=\"go\">func NewCond(l Locker) *Cond\nfunc (c *Cond) Wait()\nfunc (c *Cond) Signal()\nfunc (c *Cond) Broadcast()</code></pre>\n<ul>\n<li><code>cond.L.Lock()</code>和<code>cond.L.Unlock()</code>：也可以使用<code>lock.Lock()</code>和<code>lock.Unlock()</code>，完全一样，因为是指针转递</li>\n<li><code>cond.Wait()</code>：Unlock()-&gt;<strong><em>阻塞等待通知(即等待Signal()或Broadcast()的通知)-&gt;收到通知</em></strong>-&gt;Lock()</li>\n<li><code>cond.Signal()</code>：通知一个Wait()了的，若没有Wait()，也不会报错。<strong>Signal()通知的顺序是根据原来加入通知列表(Wait())的先入先出</strong></li>\n<li><code>cond.Broadcast()</code>: 通知所有Wait()了的，若没有Wait()，也不会报错</li>\n</ul>\n<p>示例：</p>\n<pre><code class=\"go\">func main() {\n    data := []int{2, 4, 5, 6, 8, 9}\n    tmp := 0\n    c := sync.NewCond(new(sync.Mutex))\n    c.L.Lock()\n    defer c.L.Unlock()\n\n    ctx, cancel := context.WithCancel(context.Background())\n    // 生产者\n    go func() {\n        for _, d := range data {\n            tmp = d\n            c.Signal()\n            time.Sleep(1 * time.Second)\n        }\n        cancel()\n        c.Signal() // 防止消费者进入wait死锁，但是会重复消费一次数据\n    }()\n\n    // 消费者\n    for {\n        select {\n        case &lt;-ctx.Done():\n            return\n        default:\n            c.Wait()\n            fmt.Println(tmp)\n            if tmp%2 != 0 {\n                fmt.Println(time.Now(), tmp)\n                continue\n            }\n        }\n    }\n}</code></pre>\n<p>上例可以看到Cond的使用并没有channel方便，所以一般还是使用channel进行顺序调用。Cond一般使用场景是唤起一个Wait协程，或者唤起所有Wait协程。</p>\n<h1 id=\"WaitGroup\"><a href=\"#WaitGroup\" class=\"headerlink\" title=\"WaitGroup\"></a>WaitGroup</h1><p>WaitGroup是等待一组进程运行完成。<br>提供函数：</p>\n<pre><code class=\"go\">func (wg *WaitGroup) Add(delta int)\nfunc (wg *WaitGroup) Done()\nfunc (wg *WaitGroup) Wait()</code></pre>\n<p>Add函数delta类型是int，所以支持参数为负数的值，但是不能让计数器为负数，否则会panic。<br>Done函数是递减1，也不能使计数器为负数，否则会panic。<br>Wait函数阻塞等待计数器为0。</p>\n<p>WaitGroup一个计数周期，即计数器从0转到正数开始，到计数器从正数到0结束，即为一个周期。当计数器为0时，Wait函数停止阻塞返回，在后面仍可以调用Add函数进行加计数器，即开启下一个周期，可以调用Wait函数等待下一次周期的结束。</p>\n<h1 id=\"Once\"><a href=\"#Once\" class=\"headerlink\" title=\"Once\"></a>Once</h1><p>Once提供一个只执行一次的保护罩。<br>提供函数：</p>\n<pre><code class=\"go\">func (o *Once) Do(f func())</code></pre>\n<p>重复的调用同一Once对象的Do函数f只会执行一次，不管f是否相同。常用于init函数不能执行的执行一次操作，例如创建单例对象，初始化连接池，全局变量赋值等等。</p>\n<h1 id=\"Pool\"><a href=\"#Pool\" class=\"headerlink\" title=\"Pool\"></a>Pool</h1><p>Pool表示一个临时对象池，常用于同类型对象重复利用的场景。<br>提供函数：</p>\n<pre><code class=\"go\">func (p *Pool) Put(x interface{})\nfunc (p *Pool) Get()</code></pre>\n<p>Pool有个成员<code>New func() interface{}</code>表示如果Get的时候没有对象则使用New新建一个对象。<br>Get函数取到的值是随机的，不应该对Get函数取出的对象抱有任何假设，即在获取Get函数返回对象之后应该做一次重新赋值成默认值状态。</p>\n<blockquote>\n<p>摘自参考文献[1]<br>这样一个临时对象池在功能上与一个通用的缓存池有几分相似。但是实际上，临时对象池本身的特性决定了它是一个很独特的同步工具。下面讲一下它的两个非常突出的特性。<br>第一个特性，临时对象池可以把由其中的对象值产生的存储压力进行分摊。更进一步说，它会专门为每一个与操作它的goroutine相关联的P建立本地池。在临时对象池的Get方法被调用时，它一般会先尝试从与本地P对应的那个本地私有池和本地共享池中获取一个对象值。如果获取失败，它就会试图从其他P的本地共享池中偷一个对象值并直接返回给调用方。如果依然未果，它就只能把希望寄托于当前临时对象池的对象值生成函数了。注意，这个对象值生成函数产生的对象值永远不会被放置到池中，而是会被直接返回给调用方。另一方面，临时对象池的Put方法会把它的参数值存放到本地P的本地池中。每个相关P的本地共享池中的所有对象值，都是在当前临时对象池的范围内共享的。也就是说，它们随时可能会被偷走。<br>临时对象池的第二个突出特性是对垃圾回收友好。垃圾回收的执行一般会使临时对象池中的对象值全部被移除。也就是说，即使我们永远不会显式地从临时对象池取走某个对象值，该对象值也不会永远待在临时对象池中，它的生命周期取决于垃圾回收任务下一次的执行时间。</p>\n</blockquote>\n<p>示例：垃圾回收清空临时对象池中的数据</p>\n<pre><code class=\"go\">func main() {\n    // 禁用GC，并保证在main函数执行结束前恢复GC\n    defer debug.SetGCPercent(debug.SetGCPercent(-1))\n    var count int32\n    newFunc := func() interface{} {\n        return atomic.AddInt32(&amp;count, 1)\n    }\n    pool := sync.Pool{New: newFunc}\n\n    // New字段值的作用\n    v1 := pool.Get()\n    fmt.Printf(&quot;Value 1: %v\\n&quot;, v1)\n\n    // 临时对象池的存取\n    pool.Put(10)\n    pool.Put(11)\n    pool.Put(12)\n    v2 := pool.Get()\n    fmt.Printf(&quot;Value 2: %v\\n&quot;, v2)\n\n    // 垃圾回收对临时对象池的影响\n    debug.SetGCPercent(100)\n    runtime.GC()\n    v3 := pool.Get()\n    fmt.Printf(&quot;Value 3: %v\\n&quot;, v3)\n    pool.New = nil\n    v4 := pool.Get()\n    fmt.Printf(&quot;Value 4: %v\\n&quot;, v4)\n}</code></pre>\n<h1 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h1><p>Map提供一个并发安全的map，由于golang的map并发操作会panic。<br>提供函数：</p>\n<pre><code class=\"go\">func (m *Map) Load(key interface{}) (value interface{}, ok bool)\nfunc (m *Map) Store(key, value interface{})\nfunc (m *Map) LoadOrStore(key, value interface{}) (actual interface{}, loaded bool)\nfunc (m *Map) Delete(key interface{})\nfunc (m *Map) Range(f func(key, value interface{}) bool)</code></pre>\n<p>由于Map的性能并没有<code>map+mutex</code>的性能好，所以一般用的比较少。</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ol>\n<li><a href=\"https://www.ituring.com.cn/book/tupubarticle/13514\" target=\"_blank\" rel=\"noopener\">Go并发编程实战（第2版）</a></li>\n<li><a href=\"https://ieevee.com/tech/2019/06/15/cond.html\" target=\"_blank\" rel=\"noopener\">Golang中如何正确使用条件变量sync.Cond</a></li>\n<li><a href=\"https://cyent.github.io/golang/goroutine/sync_cond/\" target=\"_blank\" rel=\"noopener\">Go语言学习 - cyent笔记</a></li>\n<li><a href=\"https://juejin.im/post/5d36a7cbf265da1bb47da444\" target=\"_blank\" rel=\"noopener\">由浅入深聊聊Golang的sync.Map</a></li>\n</ol>\n"},{"author":"djaigo","title":"wireshark解析自定义协议","img":"https://img-1251474779.cos.ap-beijing.myqcloud.com/golang.png","date":"2020-07-23T07:10:11.000Z","updated":"2020-07-23T07:10:11.000Z","_content":"\n# lua脚本\nwireshark插件有代码固定的格式\n```lua\ndo\n    -- 定义协议\n    local PROTO = Proto('proto', 'Proto')\n\n    -- 定义协议字段\n    local field = ProtoField.char(\"field\", \"proto field\", base.NONE)\n\n    -- 协议绑定字段\n    PROTO.fields = {\n        field,\n    }\n\n    -- 获取源数据\n    local data_dis = Dissector.get(\"data\")\n\n    -- 协议解剖函数\n    local function proto_dissector(buf, pinfo, root)\n        -- 自定义协议dissector\n    end\n\n    -- 让wireshark调用的解剖函数\n    function PROTO.dissector(buf, pinfo, root)\n        if proto_dissector(buf, pinfo, root) then\n            -- 自定义解剖函数执行成功\n        else\n            -- 自定义解剖函数执行失败，让其他底层协议解剖\n            data_dis:call(buf, pinfo, root)\n        end\n    end\n\n    -- 监听端口\n    local listen_port = {\n        8000,\n    }\n\n    -- 获取tcp.port的解剖器\n    local dissectors = DissectorTable.get('tcp.port')\n    for _, port in ipairs(listen_port) do\n        -- 将自定义协议绑定到指定端口的解剖器\n        dissectors:add(port, PROTO)\n    end\nend\n```\n\n# 实践\n参考[https://github.com/jzwinck/redis-wireshark](https://github.com/jzwinck/redis-wireshark)\n自己实现了一个[wireshark-redis](https://github.com/djaigoo/wireshark-redis)\n\n# 参考文献\n* [Chapter 11. Wireshark’s Lua API Reference Manual](https://www.wireshark.org/docs/wsdg_html_chunked/wsluarm_modules.html)\n","source":"_posts/wireshark解析自定义协议.md","raw":"---\nauthor: djaigo\ntitle: wireshark解析自定义协议\nimg: 'https://img-1251474779.cos.ap-beijing.myqcloud.com/golang.png'\ncategories:\n  - wireshark\ntags:\n  - lua\ndate: 2020-07-23 15:10:11\nupdated: 2020-07-23 15:10:11\n---\n\n# lua脚本\nwireshark插件有代码固定的格式\n```lua\ndo\n    -- 定义协议\n    local PROTO = Proto('proto', 'Proto')\n\n    -- 定义协议字段\n    local field = ProtoField.char(\"field\", \"proto field\", base.NONE)\n\n    -- 协议绑定字段\n    PROTO.fields = {\n        field,\n    }\n\n    -- 获取源数据\n    local data_dis = Dissector.get(\"data\")\n\n    -- 协议解剖函数\n    local function proto_dissector(buf, pinfo, root)\n        -- 自定义协议dissector\n    end\n\n    -- 让wireshark调用的解剖函数\n    function PROTO.dissector(buf, pinfo, root)\n        if proto_dissector(buf, pinfo, root) then\n            -- 自定义解剖函数执行成功\n        else\n            -- 自定义解剖函数执行失败，让其他底层协议解剖\n            data_dis:call(buf, pinfo, root)\n        end\n    end\n\n    -- 监听端口\n    local listen_port = {\n        8000,\n    }\n\n    -- 获取tcp.port的解剖器\n    local dissectors = DissectorTable.get('tcp.port')\n    for _, port in ipairs(listen_port) do\n        -- 将自定义协议绑定到指定端口的解剖器\n        dissectors:add(port, PROTO)\n    end\nend\n```\n\n# 实践\n参考[https://github.com/jzwinck/redis-wireshark](https://github.com/jzwinck/redis-wireshark)\n自己实现了一个[wireshark-redis](https://github.com/djaigoo/wireshark-redis)\n\n# 参考文献\n* [Chapter 11. Wireshark’s Lua API Reference Manual](https://www.wireshark.org/docs/wsdg_html_chunked/wsluarm_modules.html)\n","slug":"wireshark解析自定义协议","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckh351dvb002j19z4ean61pdl","content":"<h1 id=\"lua脚本\"><a href=\"#lua脚本\" class=\"headerlink\" title=\"lua脚本\"></a>lua脚本</h1><p>wireshark插件有代码固定的格式</p>\n<pre class=\" language-lua\"><code class=\"language-lua\"><span class=\"token keyword\">do</span>\n    <span class=\"token comment\" spellcheck=\"true\">-- 定义协议</span>\n    <span class=\"token keyword\">local</span> PROTO <span class=\"token operator\">=</span> <span class=\"token function\">Proto</span><span class=\"token punctuation\">(</span><span class=\"token string\">'proto'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Proto'</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">-- 定义协议字段</span>\n    <span class=\"token keyword\">local</span> field <span class=\"token operator\">=</span> ProtoField<span class=\"token punctuation\">.</span><span class=\"token function\">char</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"field\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"proto field\"</span><span class=\"token punctuation\">,</span> base<span class=\"token punctuation\">.</span>NONE<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">-- 协议绑定字段</span>\n    PROTO<span class=\"token punctuation\">.</span>fields <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n        field<span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">-- 获取源数据</span>\n    <span class=\"token keyword\">local</span> data_dis <span class=\"token operator\">=</span> Dissector<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"data\"</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">-- 协议解剖函数</span>\n    <span class=\"token keyword\">local</span> <span class=\"token keyword\">function</span> <span class=\"token function\">proto_dissector</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">,</span> pinfo<span class=\"token punctuation\">,</span> root<span class=\"token punctuation\">)</span>\n        <span class=\"token comment\" spellcheck=\"true\">-- 自定义协议dissector</span>\n    <span class=\"token keyword\">end</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">-- 让wireshark调用的解剖函数</span>\n    <span class=\"token keyword\">function</span> PROTO<span class=\"token punctuation\">.</span><span class=\"token function\">dissector</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">,</span> pinfo<span class=\"token punctuation\">,</span> root<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span> <span class=\"token function\">proto_dissector</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">,</span> pinfo<span class=\"token punctuation\">,</span> root<span class=\"token punctuation\">)</span> <span class=\"token keyword\">then</span>\n            <span class=\"token comment\" spellcheck=\"true\">-- 自定义解剖函数执行成功</span>\n        <span class=\"token keyword\">else</span>\n            <span class=\"token comment\" spellcheck=\"true\">-- 自定义解剖函数执行失败，让其他底层协议解剖</span>\n            data_dis<span class=\"token punctuation\">:</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">,</span> pinfo<span class=\"token punctuation\">,</span> root<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">end</span>\n    <span class=\"token keyword\">end</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">-- 监听端口</span>\n    <span class=\"token keyword\">local</span> listen_port <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token number\">8000</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">-- 获取tcp.port的解剖器</span>\n    <span class=\"token keyword\">local</span> dissectors <span class=\"token operator\">=</span> DissectorTable<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">'tcp.port'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">for</span> _<span class=\"token punctuation\">,</span> port <span class=\"token keyword\">in</span> <span class=\"token function\">ipairs</span><span class=\"token punctuation\">(</span>listen_port<span class=\"token punctuation\">)</span> <span class=\"token keyword\">do</span>\n        <span class=\"token comment\" spellcheck=\"true\">-- 将自定义协议绑定到指定端口的解剖器</span>\n        dissectors<span class=\"token punctuation\">:</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>port<span class=\"token punctuation\">,</span> PROTO<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span></code></pre>\n<h1 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h1><p>参考<a href=\"https://github.com/jzwinck/redis-wireshark\" target=\"_blank\" rel=\"noopener\">https://github.com/jzwinck/redis-wireshark</a><br>自己实现了一个<a href=\"https://github.com/djaigoo/wireshark-redis\" target=\"_blank\" rel=\"noopener\">wireshark-redis</a></p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ul>\n<li><a href=\"https://www.wireshark.org/docs/wsdg_html_chunked/wsluarm_modules.html\" target=\"_blank\" rel=\"noopener\">Chapter 11. Wireshark’s Lua API Reference Manual</a></li>\n</ul>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"friends":[{"avatar":"https://img-1251474779.cos.ap-beijing.myqcloud.com/icon.png","name":"djaigo","introduction":"好好学习，天天向上","url":"/","title":"前去学习"},{"avatar":"https://awps-assets.meituan.net/mit/blog/v20190629/asset/icon/favicon.ico?v=Whistle&t=20181017-1r","name":"美团技术团队","introduction":"一行代码，亿万生活。","url":"https://tech.meituan.com/","title":"点个外卖-->"},{"avatar":"","name":"鸟窝","introduction":"rpcx作者","url":"https://colobu.com/","title":"进个鸟窝-->"},{"avatar":"https://d1j8pt39hxlh3d.cloudfront.net/emoji/emojione/5.0/png/unicode/32/1f92a.png","name":"labuladong的算法小抄","introduction":"算法大神","url":"https://labuladong.gitbook.io/algo/","title":"学个算法-->"}]}},"excerpt":"","more":"<h1 id=\"lua脚本\"><a href=\"#lua脚本\" class=\"headerlink\" title=\"lua脚本\"></a>lua脚本</h1><p>wireshark插件有代码固定的格式</p>\n<pre><code class=\"lua\">do\n    -- 定义协议\n    local PROTO = Proto(&#39;proto&#39;, &#39;Proto&#39;)\n\n    -- 定义协议字段\n    local field = ProtoField.char(&quot;field&quot;, &quot;proto field&quot;, base.NONE)\n\n    -- 协议绑定字段\n    PROTO.fields = {\n        field,\n    }\n\n    -- 获取源数据\n    local data_dis = Dissector.get(&quot;data&quot;)\n\n    -- 协议解剖函数\n    local function proto_dissector(buf, pinfo, root)\n        -- 自定义协议dissector\n    end\n\n    -- 让wireshark调用的解剖函数\n    function PROTO.dissector(buf, pinfo, root)\n        if proto_dissector(buf, pinfo, root) then\n            -- 自定义解剖函数执行成功\n        else\n            -- 自定义解剖函数执行失败，让其他底层协议解剖\n            data_dis:call(buf, pinfo, root)\n        end\n    end\n\n    -- 监听端口\n    local listen_port = {\n        8000,\n    }\n\n    -- 获取tcp.port的解剖器\n    local dissectors = DissectorTable.get(&#39;tcp.port&#39;)\n    for _, port in ipairs(listen_port) do\n        -- 将自定义协议绑定到指定端口的解剖器\n        dissectors:add(port, PROTO)\n    end\nend</code></pre>\n<h1 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h1><p>参考<a href=\"https://github.com/jzwinck/redis-wireshark\" target=\"_blank\" rel=\"noopener\">https://github.com/jzwinck/redis-wireshark</a><br>自己实现了一个<a href=\"https://github.com/djaigoo/wireshark-redis\" target=\"_blank\" rel=\"noopener\">wireshark-redis</a></p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ul>\n<li><a href=\"https://www.wireshark.org/docs/wsdg_html_chunked/wsluarm_modules.html\" target=\"_blank\" rel=\"noopener\">Chapter 11. Wireshark’s Lua API Reference Manual</a></li>\n</ul>\n"},{"author":"djaigo","title":"常见负载均衡算法","date":"2019-12-10T06:43:35.000Z","update":null,"img":"https://img-1251474779.cos.ap-beijing.myqcloud.com/golang.png","_content":"\n# 常见负载均衡算法\n\n## Random\n随机负载均衡\n随机，按权重设置随机概率。\n在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。\n### Weight Random\n不同的服务器性能不同，所以不能一概而论，需要给性能低的服务器给比较低的\n权重，性能高的给跟高的权重。\n\n## Round Robin\n轮询负载均衡\n轮循，按公约后的权重设置轮循比率。\n存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。\n### Weight Round Robin\n加权轮询\n不同的服务器性能不同，所以不能一概而论，需要给性能低的服务器给比较低的\n权重，性能高的给跟高的权重。\n\n## Least Connections\n最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。\n使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。\n\n## Hash\n哈希负载均衡\n\n### Parameter Hash\n利用参数进行哈希\n\n### Source IP Hash\n源地址hash法的思想是获取客户端访问的ip地址，通过hash函数计算出一个hash值，用该hash值对服\n务器列表的大小进行取模运算，得到的值就是要访问的服务器的序号。\n\n### ConsistentHash\n一致性哈希\n一致性 Hash，相同参数的请求总是发到同一提供者。\n当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。\n\n## Message Queue\n消息队列\n\n\n# 参考文献\n1. [dubbo loadbalance](https://dubbo.gitbooks.io/dubbo-user-book/content/demos/loadbalance.html)","source":"_posts/常见负载均衡算法.md","raw":"---\nauthor: djaigo\ntitle: 常见负载均衡算法\ndate: 2019-12-10 14:43:35\nupdate: \nimg: https://img-1251474779.cos.ap-beijing.myqcloud.com/golang.png\ncategories: \n  - program\ntags: \n  - load balance\n---\n\n# 常见负载均衡算法\n\n## Random\n随机负载均衡\n随机，按权重设置随机概率。\n在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。\n### Weight Random\n不同的服务器性能不同，所以不能一概而论，需要给性能低的服务器给比较低的\n权重，性能高的给跟高的权重。\n\n## Round Robin\n轮询负载均衡\n轮循，按公约后的权重设置轮循比率。\n存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。\n### Weight Round Robin\n加权轮询\n不同的服务器性能不同，所以不能一概而论，需要给性能低的服务器给比较低的\n权重，性能高的给跟高的权重。\n\n## Least Connections\n最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。\n使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。\n\n## Hash\n哈希负载均衡\n\n### Parameter Hash\n利用参数进行哈希\n\n### Source IP Hash\n源地址hash法的思想是获取客户端访问的ip地址，通过hash函数计算出一个hash值，用该hash值对服\n务器列表的大小进行取模运算，得到的值就是要访问的服务器的序号。\n\n### ConsistentHash\n一致性哈希\n一致性 Hash，相同参数的请求总是发到同一提供者。\n当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。\n\n## Message Queue\n消息队列\n\n\n# 参考文献\n1. [dubbo loadbalance](https://dubbo.gitbooks.io/dubbo-user-book/content/demos/loadbalance.html)","slug":"常见负载均衡算法","published":1,"updated":"2019-12-10T06:43:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh351dvd002m19z41mjhe4xo","content":"<h1 id=\"常见负载均衡算法\"><a href=\"#常见负载均衡算法\" class=\"headerlink\" title=\"常见负载均衡算法\"></a>常见负载均衡算法</h1><h2 id=\"Random\"><a href=\"#Random\" class=\"headerlink\" title=\"Random\"></a>Random</h2><p>随机负载均衡<br>随机，按权重设置随机概率。<br>在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</p>\n<h3 id=\"Weight-Random\"><a href=\"#Weight-Random\" class=\"headerlink\" title=\"Weight Random\"></a>Weight Random</h3><p>不同的服务器性能不同，所以不能一概而论，需要给性能低的服务器给比较低的<br>权重，性能高的给跟高的权重。</p>\n<h2 id=\"Round-Robin\"><a href=\"#Round-Robin\" class=\"headerlink\" title=\"Round Robin\"></a>Round Robin</h2><p>轮询负载均衡<br>轮循，按公约后的权重设置轮循比率。<br>存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</p>\n<h3 id=\"Weight-Round-Robin\"><a href=\"#Weight-Round-Robin\" class=\"headerlink\" title=\"Weight Round Robin\"></a>Weight Round Robin</h3><p>加权轮询<br>不同的服务器性能不同，所以不能一概而论，需要给性能低的服务器给比较低的<br>权重，性能高的给跟高的权重。</p>\n<h2 id=\"Least-Connections\"><a href=\"#Least-Connections\" class=\"headerlink\" title=\"Least Connections\"></a>Least Connections</h2><p>最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。<br>使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</p>\n<h2 id=\"Hash\"><a href=\"#Hash\" class=\"headerlink\" title=\"Hash\"></a>Hash</h2><p>哈希负载均衡</p>\n<h3 id=\"Parameter-Hash\"><a href=\"#Parameter-Hash\" class=\"headerlink\" title=\"Parameter Hash\"></a>Parameter Hash</h3><p>利用参数进行哈希</p>\n<h3 id=\"Source-IP-Hash\"><a href=\"#Source-IP-Hash\" class=\"headerlink\" title=\"Source IP Hash\"></a>Source IP Hash</h3><p>源地址hash法的思想是获取客户端访问的ip地址，通过hash函数计算出一个hash值，用该hash值对服<br>务器列表的大小进行取模运算，得到的值就是要访问的服务器的序号。</p>\n<h3 id=\"ConsistentHash\"><a href=\"#ConsistentHash\" class=\"headerlink\" title=\"ConsistentHash\"></a>ConsistentHash</h3><p>一致性哈希<br>一致性 Hash，相同参数的请求总是发到同一提供者。<br>当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</p>\n<h2 id=\"Message-Queue\"><a href=\"#Message-Queue\" class=\"headerlink\" title=\"Message Queue\"></a>Message Queue</h2><p>消息队列</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ol>\n<li><a href=\"https://dubbo.gitbooks.io/dubbo-user-book/content/demos/loadbalance.html\" target=\"_blank\" rel=\"noopener\">dubbo loadbalance</a></li>\n</ol>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"friends":[{"avatar":"https://img-1251474779.cos.ap-beijing.myqcloud.com/icon.png","name":"djaigo","introduction":"好好学习，天天向上","url":"/","title":"前去学习"},{"avatar":"https://awps-assets.meituan.net/mit/blog/v20190629/asset/icon/favicon.ico?v=Whistle&t=20181017-1r","name":"美团技术团队","introduction":"一行代码，亿万生活。","url":"https://tech.meituan.com/","title":"点个外卖-->"},{"avatar":"","name":"鸟窝","introduction":"rpcx作者","url":"https://colobu.com/","title":"进个鸟窝-->"},{"avatar":"https://d1j8pt39hxlh3d.cloudfront.net/emoji/emojione/5.0/png/unicode/32/1f92a.png","name":"labuladong的算法小抄","introduction":"算法大神","url":"https://labuladong.gitbook.io/algo/","title":"学个算法-->"}]}},"excerpt":"","more":"<h1 id=\"常见负载均衡算法\"><a href=\"#常见负载均衡算法\" class=\"headerlink\" title=\"常见负载均衡算法\"></a>常见负载均衡算法</h1><h2 id=\"Random\"><a href=\"#Random\" class=\"headerlink\" title=\"Random\"></a>Random</h2><p>随机负载均衡<br>随机，按权重设置随机概率。<br>在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</p>\n<h3 id=\"Weight-Random\"><a href=\"#Weight-Random\" class=\"headerlink\" title=\"Weight Random\"></a>Weight Random</h3><p>不同的服务器性能不同，所以不能一概而论，需要给性能低的服务器给比较低的<br>权重，性能高的给跟高的权重。</p>\n<h2 id=\"Round-Robin\"><a href=\"#Round-Robin\" class=\"headerlink\" title=\"Round Robin\"></a>Round Robin</h2><p>轮询负载均衡<br>轮循，按公约后的权重设置轮循比率。<br>存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</p>\n<h3 id=\"Weight-Round-Robin\"><a href=\"#Weight-Round-Robin\" class=\"headerlink\" title=\"Weight Round Robin\"></a>Weight Round Robin</h3><p>加权轮询<br>不同的服务器性能不同，所以不能一概而论，需要给性能低的服务器给比较低的<br>权重，性能高的给跟高的权重。</p>\n<h2 id=\"Least-Connections\"><a href=\"#Least-Connections\" class=\"headerlink\" title=\"Least Connections\"></a>Least Connections</h2><p>最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。<br>使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</p>\n<h2 id=\"Hash\"><a href=\"#Hash\" class=\"headerlink\" title=\"Hash\"></a>Hash</h2><p>哈希负载均衡</p>\n<h3 id=\"Parameter-Hash\"><a href=\"#Parameter-Hash\" class=\"headerlink\" title=\"Parameter Hash\"></a>Parameter Hash</h3><p>利用参数进行哈希</p>\n<h3 id=\"Source-IP-Hash\"><a href=\"#Source-IP-Hash\" class=\"headerlink\" title=\"Source IP Hash\"></a>Source IP Hash</h3><p>源地址hash法的思想是获取客户端访问的ip地址，通过hash函数计算出一个hash值，用该hash值对服<br>务器列表的大小进行取模运算，得到的值就是要访问的服务器的序号。</p>\n<h3 id=\"ConsistentHash\"><a href=\"#ConsistentHash\" class=\"headerlink\" title=\"ConsistentHash\"></a>ConsistentHash</h3><p>一致性哈希<br>一致性 Hash，相同参数的请求总是发到同一提供者。<br>当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</p>\n<h2 id=\"Message-Queue\"><a href=\"#Message-Queue\" class=\"headerlink\" title=\"Message Queue\"></a>Message Queue</h2><p>消息队列</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ol>\n<li><a href=\"https://dubbo.gitbooks.io/dubbo-user-book/content/demos/loadbalance.html\" target=\"_blank\" rel=\"noopener\">dubbo loadbalance</a></li>\n</ol>\n"},{"author":"djaigo","title":"创建私有docker-image服务器","date":"2018-08-08T09:13:41.000Z","img":"https://img-1251474779.cos.ap-beijing.myqcloud.com/docker.png","_content":"\n本文介绍怎样搭建和使用私有化的docker image服务器。\n# docker hub image server\n## pull官方registry镜像\n首先需要获取官方的registry镜像包。\n```shell\n$ docker pull registry:2.6.2\nTrying to pull repository docker.io/library/registry ... \n2.6.2: Pulling from docker.io/library/registry\n4064ffdc82fe: Pull complete \nc12c92d1c5a2: Pull complete \n4fbc9b6835cc: Pull complete \n765973b0f65f: Pull complete \n3968771a7c3a: Pull complete \nDigest: sha256:51bb55f23ef7e25ac9b8313b139a8dd45baa832943c8ad8f7da2ddad6355b3c8\n```\n## insecure registry\ndocker默认image server使用https协议传输，但是内网传输可以简单的使用http，所以我们可以在`/etc/docker/daemon.json`添加`\"insecure-registries\": [\"image_server_ip:port\"]`，这样我们的image server就支持http传输了。\n## 数据持久化\n为了让docker image server的数据持久化，我们需要将本地磁盘映射到容器内部的`/var/lib/registry`，这样方便我们的image server迁移。\n## 运行registry镜像\n```shell\n$ docker run -d -p 5000:5000 -v `pwd`/data:/var/lib/registry --restart=always --name registry docker.io/registry:2.6.2\ndccda7ae748e2b0a485ea9e501e09567c012acb392412727b7ee0e73ffff5961\n```\n这样我们就可以启动我们的镜像服务器了，映射端口5000，映射本地磁盘。\n# docker client\n## image 命名\n镜像命名格式image-hub-ip:port/image_name，例如：`172.16.220.41:5000/myhub/nginx`。这样我们就可以往我们自己的image server推送我们私有的image了。\n```shell\n$ docker push 172.16.220.41:5000/myhub/nginx:v0.1\nThe push refers to a repository [172.16.220.41:5000/myhub/nginx]\n08d25fa0442e: Pushed \na8c4aeeaa045: Pushed \ncdb3f9544e4c: Pushed \nv0.1: digest: sha256:4ffd9758ea9ea360fd87d0cee7a2d1cf9dba630bb57ca36b3108dcd3708dc189 size: 948\n```\n## 测试\n删除本地镜像\n```shell\n$ docker rmi 172.16.220.41:5000/myhub/nginx:v0.1\nUntagged: 172.16.220.41:5000/myhub/nginx:v0.1\nUntagged: 172.16.220.41:5000/myhub/nginx@sha256:4ffd9758ea9ea360fd87d0cee7a2d1cf9dba630bb57ca36b3108dcd3708dc189\n```\n拉取image\n```shell\n$ docker pull 172.16.220.41:5000/myhub/nginx:v0.1\nTrying to pull repository 172.16.220.41:5000/myhub/nginx ... \nv0.1: Pulling from 172.16.220.41:5000/myhub/nginx\nDigest: sha256:4ffd9758ea9ea360fd87d0cee7a2d1cf9dba630bb57ca36b3108dcd3708dc189\nStatus: Downloaded newer image for 172.16.220.41:5000/myhub/nginx:v0.1\n```\n可以看到我们又重新获取到了镜像，这样我们的image server就搭建完成了。\n\n\n","source":"_posts/创建私有docker-image服务器.md","raw":"---\nauthor: djaigo\ntitle: 创建私有docker-image服务器\ndate: 2018-08-08 17:13:41\nimg: https://img-1251474779.cos.ap-beijing.myqcloud.com/docker.png\ncategories: \n  - docker\ntags: \n  - image\n  - registry\n  - server\n---\n\n本文介绍怎样搭建和使用私有化的docker image服务器。\n# docker hub image server\n## pull官方registry镜像\n首先需要获取官方的registry镜像包。\n```shell\n$ docker pull registry:2.6.2\nTrying to pull repository docker.io/library/registry ... \n2.6.2: Pulling from docker.io/library/registry\n4064ffdc82fe: Pull complete \nc12c92d1c5a2: Pull complete \n4fbc9b6835cc: Pull complete \n765973b0f65f: Pull complete \n3968771a7c3a: Pull complete \nDigest: sha256:51bb55f23ef7e25ac9b8313b139a8dd45baa832943c8ad8f7da2ddad6355b3c8\n```\n## insecure registry\ndocker默认image server使用https协议传输，但是内网传输可以简单的使用http，所以我们可以在`/etc/docker/daemon.json`添加`\"insecure-registries\": [\"image_server_ip:port\"]`，这样我们的image server就支持http传输了。\n## 数据持久化\n为了让docker image server的数据持久化，我们需要将本地磁盘映射到容器内部的`/var/lib/registry`，这样方便我们的image server迁移。\n## 运行registry镜像\n```shell\n$ docker run -d -p 5000:5000 -v `pwd`/data:/var/lib/registry --restart=always --name registry docker.io/registry:2.6.2\ndccda7ae748e2b0a485ea9e501e09567c012acb392412727b7ee0e73ffff5961\n```\n这样我们就可以启动我们的镜像服务器了，映射端口5000，映射本地磁盘。\n# docker client\n## image 命名\n镜像命名格式image-hub-ip:port/image_name，例如：`172.16.220.41:5000/myhub/nginx`。这样我们就可以往我们自己的image server推送我们私有的image了。\n```shell\n$ docker push 172.16.220.41:5000/myhub/nginx:v0.1\nThe push refers to a repository [172.16.220.41:5000/myhub/nginx]\n08d25fa0442e: Pushed \na8c4aeeaa045: Pushed \ncdb3f9544e4c: Pushed \nv0.1: digest: sha256:4ffd9758ea9ea360fd87d0cee7a2d1cf9dba630bb57ca36b3108dcd3708dc189 size: 948\n```\n## 测试\n删除本地镜像\n```shell\n$ docker rmi 172.16.220.41:5000/myhub/nginx:v0.1\nUntagged: 172.16.220.41:5000/myhub/nginx:v0.1\nUntagged: 172.16.220.41:5000/myhub/nginx@sha256:4ffd9758ea9ea360fd87d0cee7a2d1cf9dba630bb57ca36b3108dcd3708dc189\n```\n拉取image\n```shell\n$ docker pull 172.16.220.41:5000/myhub/nginx:v0.1\nTrying to pull repository 172.16.220.41:5000/myhub/nginx ... \nv0.1: Pulling from 172.16.220.41:5000/myhub/nginx\nDigest: sha256:4ffd9758ea9ea360fd87d0cee7a2d1cf9dba630bb57ca36b3108dcd3708dc189\nStatus: Downloaded newer image for 172.16.220.41:5000/myhub/nginx:v0.1\n```\n可以看到我们又重新获取到了镜像，这样我们的image server就搭建完成了。\n\n\n","slug":"创建私有docker-image服务器","published":1,"updated":"2018-08-08T09:13:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh351dvf002r19z4bytg1bmz","content":"<p>本文介绍怎样搭建和使用私有化的docker image服务器。</p>\n<h1 id=\"docker-hub-image-server\"><a href=\"#docker-hub-image-server\" class=\"headerlink\" title=\"docker hub image server\"></a>docker hub image server</h1><h2 id=\"pull官方registry镜像\"><a href=\"#pull官方registry镜像\" class=\"headerlink\" title=\"pull官方registry镜像\"></a>pull官方registry镜像</h2><p>首先需要获取官方的registry镜像包。</p>\n<pre class=\" language-shell\"><code class=\"language-shell\">$ docker pull registry:2.6.2\nTrying to pull repository docker.io/library/registry ... \n2.6.2: Pulling from docker.io/library/registry\n4064ffdc82fe: Pull complete \nc12c92d1c5a2: Pull complete \n4fbc9b6835cc: Pull complete \n765973b0f65f: Pull complete \n3968771a7c3a: Pull complete \nDigest: sha256:51bb55f23ef7e25ac9b8313b139a8dd45baa832943c8ad8f7da2ddad6355b3c8</code></pre>\n<h2 id=\"insecure-registry\"><a href=\"#insecure-registry\" class=\"headerlink\" title=\"insecure registry\"></a>insecure registry</h2><p>docker默认image server使用https协议传输，但是内网传输可以简单的使用http，所以我们可以在<code>/etc/docker/daemon.json</code>添加<code>\"insecure-registries\": [\"image_server_ip:port\"]</code>，这样我们的image server就支持http传输了。</p>\n<h2 id=\"数据持久化\"><a href=\"#数据持久化\" class=\"headerlink\" title=\"数据持久化\"></a>数据持久化</h2><p>为了让docker image server的数据持久化，我们需要将本地磁盘映射到容器内部的<code>/var/lib/registry</code>，这样方便我们的image server迁移。</p>\n<h2 id=\"运行registry镜像\"><a href=\"#运行registry镜像\" class=\"headerlink\" title=\"运行registry镜像\"></a>运行registry镜像</h2><pre class=\" language-shell\"><code class=\"language-shell\">$ docker run -d -p 5000:5000 -v `pwd`/data:/var/lib/registry --restart=always --name registry docker.io/registry:2.6.2\ndccda7ae748e2b0a485ea9e501e09567c012acb392412727b7ee0e73ffff5961</code></pre>\n<p>这样我们就可以启动我们的镜像服务器了，映射端口5000，映射本地磁盘。</p>\n<h1 id=\"docker-client\"><a href=\"#docker-client\" class=\"headerlink\" title=\"docker client\"></a>docker client</h1><h2 id=\"image-命名\"><a href=\"#image-命名\" class=\"headerlink\" title=\"image 命名\"></a>image 命名</h2><p>镜像命名格式image-hub-ip:port/image_name，例如：<code>172.16.220.41:5000/myhub/nginx</code>。这样我们就可以往我们自己的image server推送我们私有的image了。</p>\n<pre class=\" language-shell\"><code class=\"language-shell\">$ docker push 172.16.220.41:5000/myhub/nginx:v0.1\nThe push refers to a repository [172.16.220.41:5000/myhub/nginx]\n08d25fa0442e: Pushed \na8c4aeeaa045: Pushed \ncdb3f9544e4c: Pushed \nv0.1: digest: sha256:4ffd9758ea9ea360fd87d0cee7a2d1cf9dba630bb57ca36b3108dcd3708dc189 size: 948</code></pre>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>删除本地镜像</p>\n<pre class=\" language-shell\"><code class=\"language-shell\">$ docker rmi 172.16.220.41:5000/myhub/nginx:v0.1\nUntagged: 172.16.220.41:5000/myhub/nginx:v0.1\nUntagged: 172.16.220.41:5000/myhub/nginx@sha256:4ffd9758ea9ea360fd87d0cee7a2d1cf9dba630bb57ca36b3108dcd3708dc189</code></pre>\n<p>拉取image</p>\n<pre class=\" language-shell\"><code class=\"language-shell\">$ docker pull 172.16.220.41:5000/myhub/nginx:v0.1\nTrying to pull repository 172.16.220.41:5000/myhub/nginx ... \nv0.1: Pulling from 172.16.220.41:5000/myhub/nginx\nDigest: sha256:4ffd9758ea9ea360fd87d0cee7a2d1cf9dba630bb57ca36b3108dcd3708dc189\nStatus: Downloaded newer image for 172.16.220.41:5000/myhub/nginx:v0.1</code></pre>\n<p>可以看到我们又重新获取到了镜像，这样我们的image server就搭建完成了。</p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"friends":[{"avatar":"https://img-1251474779.cos.ap-beijing.myqcloud.com/icon.png","name":"djaigo","introduction":"好好学习，天天向上","url":"/","title":"前去学习"},{"avatar":"https://awps-assets.meituan.net/mit/blog/v20190629/asset/icon/favicon.ico?v=Whistle&t=20181017-1r","name":"美团技术团队","introduction":"一行代码，亿万生活。","url":"https://tech.meituan.com/","title":"点个外卖-->"},{"avatar":"","name":"鸟窝","introduction":"rpcx作者","url":"https://colobu.com/","title":"进个鸟窝-->"},{"avatar":"https://d1j8pt39hxlh3d.cloudfront.net/emoji/emojione/5.0/png/unicode/32/1f92a.png","name":"labuladong的算法小抄","introduction":"算法大神","url":"https://labuladong.gitbook.io/algo/","title":"学个算法-->"}]}},"excerpt":"","more":"<p>本文介绍怎样搭建和使用私有化的docker image服务器。</p>\n<h1 id=\"docker-hub-image-server\"><a href=\"#docker-hub-image-server\" class=\"headerlink\" title=\"docker hub image server\"></a>docker hub image server</h1><h2 id=\"pull官方registry镜像\"><a href=\"#pull官方registry镜像\" class=\"headerlink\" title=\"pull官方registry镜像\"></a>pull官方registry镜像</h2><p>首先需要获取官方的registry镜像包。</p>\n<pre><code class=\"shell\">$ docker pull registry:2.6.2\nTrying to pull repository docker.io/library/registry ... \n2.6.2: Pulling from docker.io/library/registry\n4064ffdc82fe: Pull complete \nc12c92d1c5a2: Pull complete \n4fbc9b6835cc: Pull complete \n765973b0f65f: Pull complete \n3968771a7c3a: Pull complete \nDigest: sha256:51bb55f23ef7e25ac9b8313b139a8dd45baa832943c8ad8f7da2ddad6355b3c8</code></pre>\n<h2 id=\"insecure-registry\"><a href=\"#insecure-registry\" class=\"headerlink\" title=\"insecure registry\"></a>insecure registry</h2><p>docker默认image server使用https协议传输，但是内网传输可以简单的使用http，所以我们可以在<code>/etc/docker/daemon.json</code>添加<code>&quot;insecure-registries&quot;: [&quot;image_server_ip:port&quot;]</code>，这样我们的image server就支持http传输了。</p>\n<h2 id=\"数据持久化\"><a href=\"#数据持久化\" class=\"headerlink\" title=\"数据持久化\"></a>数据持久化</h2><p>为了让docker image server的数据持久化，我们需要将本地磁盘映射到容器内部的<code>/var/lib/registry</code>，这样方便我们的image server迁移。</p>\n<h2 id=\"运行registry镜像\"><a href=\"#运行registry镜像\" class=\"headerlink\" title=\"运行registry镜像\"></a>运行registry镜像</h2><pre><code class=\"shell\">$ docker run -d -p 5000:5000 -v `pwd`/data:/var/lib/registry --restart=always --name registry docker.io/registry:2.6.2\ndccda7ae748e2b0a485ea9e501e09567c012acb392412727b7ee0e73ffff5961</code></pre>\n<p>这样我们就可以启动我们的镜像服务器了，映射端口5000，映射本地磁盘。</p>\n<h1 id=\"docker-client\"><a href=\"#docker-client\" class=\"headerlink\" title=\"docker client\"></a>docker client</h1><h2 id=\"image-命名\"><a href=\"#image-命名\" class=\"headerlink\" title=\"image 命名\"></a>image 命名</h2><p>镜像命名格式image-hub-ip:port/image_name，例如：<code>172.16.220.41:5000/myhub/nginx</code>。这样我们就可以往我们自己的image server推送我们私有的image了。</p>\n<pre><code class=\"shell\">$ docker push 172.16.220.41:5000/myhub/nginx:v0.1\nThe push refers to a repository [172.16.220.41:5000/myhub/nginx]\n08d25fa0442e: Pushed \na8c4aeeaa045: Pushed \ncdb3f9544e4c: Pushed \nv0.1: digest: sha256:4ffd9758ea9ea360fd87d0cee7a2d1cf9dba630bb57ca36b3108dcd3708dc189 size: 948</code></pre>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>删除本地镜像</p>\n<pre><code class=\"shell\">$ docker rmi 172.16.220.41:5000/myhub/nginx:v0.1\nUntagged: 172.16.220.41:5000/myhub/nginx:v0.1\nUntagged: 172.16.220.41:5000/myhub/nginx@sha256:4ffd9758ea9ea360fd87d0cee7a2d1cf9dba630bb57ca36b3108dcd3708dc189</code></pre>\n<p>拉取image</p>\n<pre><code class=\"shell\">$ docker pull 172.16.220.41:5000/myhub/nginx:v0.1\nTrying to pull repository 172.16.220.41:5000/myhub/nginx ... \nv0.1: Pulling from 172.16.220.41:5000/myhub/nginx\nDigest: sha256:4ffd9758ea9ea360fd87d0cee7a2d1cf9dba630bb57ca36b3108dcd3708dc189\nStatus: Downloaded newer image for 172.16.220.41:5000/myhub/nginx:v0.1</code></pre>\n<p>可以看到我们又重新获取到了镜像，这样我们的image server就搭建完成了。</p>\n"},{"author":"djaigo","title":"技术文章","img":"https://img-1251474779.cos.ap-beijing.myqcloud.com/golang.png","date":"2020-01-13T08:04:14.000Z","_content":"\n# 记录有意思的博文\n\n1. [go mod设计原则](https://research.swtch.com/vgo-principles)，一切皆以软件工程为基础设计。\n","source":"_posts/技术文章.md","raw":"---\nauthor: djaigo\ntitle: 技术文章\nimg: 'https://img-1251474779.cos.ap-beijing.myqcloud.com/golang.png'\ncategories:\n  - article\ntags:\n  - blog\n  - explain\n  - comment\ndate: 2020-01-13 16:04:14\n---\n\n# 记录有意思的博文\n\n1. [go mod设计原则](https://research.swtch.com/vgo-principles)，一切皆以软件工程为基础设计。\n","slug":"技术文章","published":1,"updated":"2020-01-13T08:04:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh351dvg002t19z41cw17m62","content":"<h1 id=\"记录有意思的博文\"><a href=\"#记录有意思的博文\" class=\"headerlink\" title=\"记录有意思的博文\"></a>记录有意思的博文</h1><ol>\n<li><a href=\"https://research.swtch.com/vgo-principles\" target=\"_blank\" rel=\"noopener\">go mod设计原则</a>，一切皆以软件工程为基础设计。</li>\n</ol>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"friends":[{"avatar":"https://img-1251474779.cos.ap-beijing.myqcloud.com/icon.png","name":"djaigo","introduction":"好好学习，天天向上","url":"/","title":"前去学习"},{"avatar":"https://awps-assets.meituan.net/mit/blog/v20190629/asset/icon/favicon.ico?v=Whistle&t=20181017-1r","name":"美团技术团队","introduction":"一行代码，亿万生活。","url":"https://tech.meituan.com/","title":"点个外卖-->"},{"avatar":"","name":"鸟窝","introduction":"rpcx作者","url":"https://colobu.com/","title":"进个鸟窝-->"},{"avatar":"https://d1j8pt39hxlh3d.cloudfront.net/emoji/emojione/5.0/png/unicode/32/1f92a.png","name":"labuladong的算法小抄","introduction":"算法大神","url":"https://labuladong.gitbook.io/algo/","title":"学个算法-->"}]}},"excerpt":"","more":"<h1 id=\"记录有意思的博文\"><a href=\"#记录有意思的博文\" class=\"headerlink\" title=\"记录有意思的博文\"></a>记录有意思的博文</h1><ol>\n<li><a href=\"https://research.swtch.com/vgo-principles\" target=\"_blank\" rel=\"noopener\">go mod设计原则</a>，一切皆以软件工程为基础设计。</li>\n</ol>\n"},{"author":"djaigo","title":"服务注册与发现","img":"https://img-1251474779.cos.ap-beijing.myqcloud.com/golang.png","date":"2020-07-13T07:41:19.000Z","updated":"2020-07-13T07:41:19.000Z","_content":"\n# 引言\n\n聊起微服务的服务注册与发现，很多人立马就会脱口而出 zk、etcd、consul、eureka 这些组件，进而聊到 CAP 如何取舍，性能如何，高可用和容灾是怎么实现的。\n\n在这之前，站在组件使用者的角度，我想先问这么几个问题：\n\n*   注册的 IP 和端口怎么确定 ？\n\n*   实现服务治理还需要注册哪些信息 ？\n\n*   如何进行优雅的服务注册与服务下线 ？\n*   注册服务的健康检查是如何做的 ？\n*   当服务有节点退出或新的节点加入时，订阅者能不能及时收到通知 ?\n*   我能方便地查看某个应用发布和订阅了哪些服务，以及所订阅的服务有哪些节点吗 ？\n\n看完这些问题后，您也许会发现，对于服务注册与发现，首先应该关注的是服务注册发现本身的功能，然后才是性能和高可用。\n\n一个好的服务注册发现中间件，应该是能完整地满足服务开发和治理的基础功能，然后才是性能和高可用。如果没有想清楚前面的功能，再高的可用性和性能都是浮云。最后，安全也同样重要。\n\n*   服务端的性能如何 ？\n\n*   服务发现的容灾策略是怎样的 ？\n\n*   当我的应用和服务发现中心的网络连接出现问题时，会对我的调用产生什么影响 ？\n*   服务注册中心某台机器宕机或者全部宕机时，会对我的调用产生什么影响 ？\n*   服务注册和发现的链路安全吗，有没有做好权限控制 ？\n\n下面将从 服务注册、服务发现、容灾和高可用三个大方面来回答这些问题的主流做法。\n\n最后会介绍一下 ANS(Alibaba Naming Service) ， ANS 综合了这些解决方案中的优点，并在 EDAS(阿里巴巴企业级分布式应用服务) 中输出，目前完全免费！\n\n# 服务注册\n\n## 注册的 IP 和端口怎么确定 ？\n\n### IP 如何确定\n\n主流的 IP 获取有这几种方法。\n\n*   最简单粗暴的方式，手动配置需要注册的IP。当然这种方式基本无法在生产环境使用，因为微服务基本都是支持水平扩容多机部署的，在配置中写死 IP 地址的方式无法支持一份代码水平扩容，会给运维带来极大的成本。\n\n*   通过遍历网卡的方式去获取，找到第一个不为本地环回地址的 IP 地址。绝大多数情况下，这个方式比较好用，dubbo 等框架采用的就是这种方法。\n\n*   在一些网络规划比较好的标准化机房中，我们还可以通过手动指定网卡名，即 interfaceName 的方式来指定使用哪一块网卡所对应的 IP 地址进行注册。\n*   当上述三种方式都不能有效解决问题的时候，有一个方法就是直接与服务注册中心建立 socket 连接，然后通过`socket.getLocalAddress()` 这种方式来获取本机的 IP。\n\n### 端口如何确定\n\n端口的获取，没有标准化的方案。\n\n*   如果是 RPC 应用，启动的时候都有一个配置来指定服务监听的端口， 注册的时候直接使用配置项的端口值。\n\n*   传统的 WEB 容器所提供的 HTTP 的应用，同样也存在一个配置文件来配置容器的监听端口，注册时候直接使用配置项的端口值。\n\n*   特别的，在 Java 应用的 Spring Boot 框架中，可以通过 `EmbeddedServletContainerInitializedEvent. getEmbeddedServletContainer().getPort()`来获取。(Spring Boot 版本为 1.x)。\n\n## 实现服务治理还需要注册哪些信息 ？\n\n简单地将 IP 和 port 信息注册上去，可以满足基本的服务调用的需求，但是在业务发展到一定程度的时候，我们还会有这些需求：\n\n*   想知道某个 HTTP 服务是否开启了 TLS。\n\n*   对相同服务下的不同节点设置不同的权重，进行流量调度。\n\n*   将服务分成预发环境和生产环境，方便进行AB Test功能。\n*   不同机房的服务注册时加上机房的标签，以实现同机房优先的路由规则。\n\n这些高级功能的实现，本质上是依赖于客户端调用时候的负载均衡策略和调用策略，但是如果服务元数据没有注册上来，也只能是巧妇难为无米之炊。一个良好的服务注册中心在设计最初就应该支持这些扩展字段。\n\n## 如何进行优雅的服务注册与服务下线 ？\n\n### 优雅发布\n\n虽然服务注册一般发生在服务的启动阶段，但是细分的话，服务注册应该在服务已经完全启动成功，并准备对外提供服务之后才能进行注册。\n\n*   有些 RPC 框架自身提供了方法来判断服务是否已经启动完成，如 Thrift ，我们可以通过 Server.isServing() 来判断。\n\n*   有一些 RPC 框架本身没有提供服务是否启动完成的方式，这时我们可以通过检测端口是否已经处于监听状态来判断。\n\n*   而对于 HTTP 服务，服务是否启动完毕也可以通过端口是否处于监听状态来判断。\n*   特别的，在 Java 应用的 Spring Boot 框架中，可以通过事件通知的形式来通知容器已经启动完毕， EmbeddedServletContainerInitializedEvent 事件来通知容器已经启动完成 (Spring Boot 版本为 1.x)。\n\n### 优雅下线\n\n绝大多数的服务注册中心都提供了健康检查功能，在应用停止后会自动摘除服务所对应的节点。但是我们也不能完全依赖此功能，应用应该在停止时主动调用服务注册中心的服务下线接口。\n\n*   在 Java 应用中，通用的服务下线接口调用一般使用 JVM Shutdown Hook 的方式来实现。\n\n*   特别的，在 Java 应用中的 Spring 框架中，可以通过 Spring Bean LifeCycle 来实现应用停止时主动调用服务下线接口。\n\n*   当然上述两种方式还不够优雅，因为不能确保不出现 kill -9 这种粗暴的停止方式，而且应用调用服务下线接口也是尝试去调用，对于网络不通等异常场景并没有做异常处理。因此，调用客户端仍应该做好负载均衡与 failover 的处理。\n*   更优雅的方式，先将即将停止的应用所对应的权重调成 0，此时上游将不再调用此应用。这时候的停止应用的操作对服务订阅者完全没有影响，当然这种场景需要订阅者实现按权重的负载均衡和运维部署工具深度结合。\n\n## 服务的健康检查是如何做的 ？\n\n健康检查分为客户端心跳和服务端主动探测两种方式。\n\n*   客户端心跳\n\n*   客户端每隔一定时间主动发送“心跳”的方式来向服务端表明自己的服务状态正常，心跳可以是 TCP 的形式，也可以是 HTTP 的形式。\n\n*   也可以通过维持客户端和服务端的一个 socket 长连接自己实现一个客户端心跳的方式。\n\n*   ZooKeeper 并没有主动的发送心跳，而是依赖了组件本身提供的临时节点的特性，通过 ZooKeeper 连接的 session 来维持临时节点。\n\n但是客户端心跳中，长连接的维持和客户端的主动心跳都只是表明链路上的正常，不一定是服务状态正常。\n\n服务端主动调用服务进行健康检查是一个较为准确的方式，返回结果成功表明服务状态确实正常。\n\n*   服务端主动探测\n*   服务端调用服务发布者某个 HTTP 接口来完成健康检查。\n*   对于没有提供 HTTP 服务的 RPC 应用，服务端调用服务发布者的接口来完成健康检查。\n*   可以通过执行某个脚本的形式来进行综合检查。\n\n服务端主动探测也存在问题。服务注册中心主动调用 RPC 服务的某个接口无法做到通用性；在很多场景下服务注册中心到服务发布者的网络是不通的，服务端无法主动发起健康检查。\n\n所以如何取舍，还是需要根据实际情况来决定，根据不同的场景，选择不同的策略。\n\n# 服务发现\n\n## 怎么找到服务发现服务端的地址？\n\n*   在应用的配置文件中指定服务注册中心的地址，类似于 zookeeper 和 eureka。\n*   指定一个地址服务器的地址，然后通过这个地址服务器来获取服务注册中心的地址，地址服务器返回的结果会随着服务注册中心的扩缩容及时更新。\n\n## 当服务有节点退出或新的节点加入时，订阅者如何及时收到通知 ？\n\n很经典的 Push 和 Pull 问题。\n\nPush 的经典实现有两种，基于 socket 长连接的 notify，典型的实现如 zookeeper；另一种为 HTTP 连接所使用 Long Polling。\n\n但是基于 socket 长连接的 notify 和基于 HTTP 协议的 Long Polling 都会存在notify消息丢失的问题。\n\n所以通过 Pull 的方式定时轮询也必不可少，时间间隔的选择也很关键，频率越高服务注册中心所承受的压力也越大。需要结合服务端的性能和业务的规模进行权衡。\n\n还有一种方式，真实的 Push，客户端开启一个 UDP server，服务注册中心通过 UDP 的方式进行数据推送，当然这个也受限于网络的连通性。\n\n## 我能方便地查看我发布和订阅了哪些服务，订阅的服务有哪些节点吗 ？\n\n*   一个好的产品，用户使用体验和运维体验必须是优雅的，如果查看本机发布和订阅的服务，只能通过查看日志，甚至是 jmap 的方式来获取，显然体验非常糟糕。\n\n*   服务注册中心应该提供了丰富的接口，支持根据应用名、IP、订阅服务名、发布服务名，来进行多层次的组合查询。\n\n*   同时，客户端的内存里，同样也应该保留服务发布与订阅的各种信息，并提供方式供人方便地查询。\n*   比如在 Java 中的 Spring Boot 的应用，可以结合 actuator endpoint，通过 HTTP 的方式来提供本机服务查询功能，查询此应用发布的服务，以及订阅的服务及各服务的对应节点。\n\n# 容灾和高可用\n\n## 性能如何\n\n当服务节点数越来越多时，服务注册中心的性能会成为瓶颈，这时候就需要通过水平扩容来提升服务注册中心集群的性能。\n\n*   对于那些采用了类 Paxos 协议的强一致性的组件，如ZooKeeper，由于每次写操作需要过半的节点确认。水平扩容不能提升整个集群的写性能，只能提升整个集群的读性能。\n*   而对于采用最终一致性的组件来说，水平扩容可以同时提升整个集群的写性能和读性能。\n\n## 客户端容灾策略\n\n1.  首先，本地内存缓存，当运行时与服务注册中心的连接丢失或服务注册中心完全宕机，仍能正常地调用服务。\n\n2.  然后，本地缓存文件，当应用与服务注册中心发生网络分区或服务注册中心完全宕机后，应用进行了重启操作，内存里没有数据，此时应用可以通过读取本地缓存文件的数据来获取到最后一次订阅到的内容。\n\n3.  最后，本地容灾文件夹。正常的情况下，容灾文件夹内是没有内容的。当服务端完全宕机且长时间不能恢复，同时服务提供者又发生了很大的变更时，可以通过在容灾文件夹内添加文件的方式来开启本地容灾。此时客户端会忽略原有的本地缓存文件，只从本地容灾文件中读取配置。\n\n## 服务端容灾与高可用\n\n*   当有新节点加入集群时，节点启动后能自动添加到地址服务器中，并通过地址服务器找到其他节点，自动从其他节点同步数据，以达到数据的最终一致性。\n*   当某个节点宕机时，此服务注册中心节点的信息会自动地址服务器中摘除，客户端能及时感知到此节点已下线。\n\n服务端的无状态性保证了服务的容灾和高可用可以做的很薄。\n\n## 服务端安全是如何做的 ？\n\n链路安全，对于使用 HTTP 连接的服务注册中心，保护链路安全的最好方式是使用 HTTPS。而使用 TCP 连接的服务注册中心来说，由于应用层协议一般使用的是私有协议，不一定存在现成的 TLS 支持方案。\n\n在业务安全方面，应该在每一次的发布、订阅、心跳，都带上鉴权的信息就行验签和鉴权，确保业务信息的安全性。\n\n# 参考文献\n1. [聊聊微服务的服务注册与发现](http://jm.taobao.org/2018/06/26/%E8%81%8A%E8%81%8A%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/)","source":"_posts/服务注册与发现.md","raw":"---\nauthor: djaigo\ntitle: 服务注册与发现\nimg: 'https://img-1251474779.cos.ap-beijing.myqcloud.com/golang.png'\ncategories:\n  - service discovery\ntags:\n  - etcd\n  - zk\n  - zookeeper\n  - consul\n  - confd\n  - eureka\ndate: 2020-07-13 15:41:19\nupdated: 2020-07-13 15:41:19\n---\n\n# 引言\n\n聊起微服务的服务注册与发现，很多人立马就会脱口而出 zk、etcd、consul、eureka 这些组件，进而聊到 CAP 如何取舍，性能如何，高可用和容灾是怎么实现的。\n\n在这之前，站在组件使用者的角度，我想先问这么几个问题：\n\n*   注册的 IP 和端口怎么确定 ？\n\n*   实现服务治理还需要注册哪些信息 ？\n\n*   如何进行优雅的服务注册与服务下线 ？\n*   注册服务的健康检查是如何做的 ？\n*   当服务有节点退出或新的节点加入时，订阅者能不能及时收到通知 ?\n*   我能方便地查看某个应用发布和订阅了哪些服务，以及所订阅的服务有哪些节点吗 ？\n\n看完这些问题后，您也许会发现，对于服务注册与发现，首先应该关注的是服务注册发现本身的功能，然后才是性能和高可用。\n\n一个好的服务注册发现中间件，应该是能完整地满足服务开发和治理的基础功能，然后才是性能和高可用。如果没有想清楚前面的功能，再高的可用性和性能都是浮云。最后，安全也同样重要。\n\n*   服务端的性能如何 ？\n\n*   服务发现的容灾策略是怎样的 ？\n\n*   当我的应用和服务发现中心的网络连接出现问题时，会对我的调用产生什么影响 ？\n*   服务注册中心某台机器宕机或者全部宕机时，会对我的调用产生什么影响 ？\n*   服务注册和发现的链路安全吗，有没有做好权限控制 ？\n\n下面将从 服务注册、服务发现、容灾和高可用三个大方面来回答这些问题的主流做法。\n\n最后会介绍一下 ANS(Alibaba Naming Service) ， ANS 综合了这些解决方案中的优点，并在 EDAS(阿里巴巴企业级分布式应用服务) 中输出，目前完全免费！\n\n# 服务注册\n\n## 注册的 IP 和端口怎么确定 ？\n\n### IP 如何确定\n\n主流的 IP 获取有这几种方法。\n\n*   最简单粗暴的方式，手动配置需要注册的IP。当然这种方式基本无法在生产环境使用，因为微服务基本都是支持水平扩容多机部署的，在配置中写死 IP 地址的方式无法支持一份代码水平扩容，会给运维带来极大的成本。\n\n*   通过遍历网卡的方式去获取，找到第一个不为本地环回地址的 IP 地址。绝大多数情况下，这个方式比较好用，dubbo 等框架采用的就是这种方法。\n\n*   在一些网络规划比较好的标准化机房中，我们还可以通过手动指定网卡名，即 interfaceName 的方式来指定使用哪一块网卡所对应的 IP 地址进行注册。\n*   当上述三种方式都不能有效解决问题的时候，有一个方法就是直接与服务注册中心建立 socket 连接，然后通过`socket.getLocalAddress()` 这种方式来获取本机的 IP。\n\n### 端口如何确定\n\n端口的获取，没有标准化的方案。\n\n*   如果是 RPC 应用，启动的时候都有一个配置来指定服务监听的端口， 注册的时候直接使用配置项的端口值。\n\n*   传统的 WEB 容器所提供的 HTTP 的应用，同样也存在一个配置文件来配置容器的监听端口，注册时候直接使用配置项的端口值。\n\n*   特别的，在 Java 应用的 Spring Boot 框架中，可以通过 `EmbeddedServletContainerInitializedEvent. getEmbeddedServletContainer().getPort()`来获取。(Spring Boot 版本为 1.x)。\n\n## 实现服务治理还需要注册哪些信息 ？\n\n简单地将 IP 和 port 信息注册上去，可以满足基本的服务调用的需求，但是在业务发展到一定程度的时候，我们还会有这些需求：\n\n*   想知道某个 HTTP 服务是否开启了 TLS。\n\n*   对相同服务下的不同节点设置不同的权重，进行流量调度。\n\n*   将服务分成预发环境和生产环境，方便进行AB Test功能。\n*   不同机房的服务注册时加上机房的标签，以实现同机房优先的路由规则。\n\n这些高级功能的实现，本质上是依赖于客户端调用时候的负载均衡策略和调用策略，但是如果服务元数据没有注册上来，也只能是巧妇难为无米之炊。一个良好的服务注册中心在设计最初就应该支持这些扩展字段。\n\n## 如何进行优雅的服务注册与服务下线 ？\n\n### 优雅发布\n\n虽然服务注册一般发生在服务的启动阶段，但是细分的话，服务注册应该在服务已经完全启动成功，并准备对外提供服务之后才能进行注册。\n\n*   有些 RPC 框架自身提供了方法来判断服务是否已经启动完成，如 Thrift ，我们可以通过 Server.isServing() 来判断。\n\n*   有一些 RPC 框架本身没有提供服务是否启动完成的方式，这时我们可以通过检测端口是否已经处于监听状态来判断。\n\n*   而对于 HTTP 服务，服务是否启动完毕也可以通过端口是否处于监听状态来判断。\n*   特别的，在 Java 应用的 Spring Boot 框架中，可以通过事件通知的形式来通知容器已经启动完毕， EmbeddedServletContainerInitializedEvent 事件来通知容器已经启动完成 (Spring Boot 版本为 1.x)。\n\n### 优雅下线\n\n绝大多数的服务注册中心都提供了健康检查功能，在应用停止后会自动摘除服务所对应的节点。但是我们也不能完全依赖此功能，应用应该在停止时主动调用服务注册中心的服务下线接口。\n\n*   在 Java 应用中，通用的服务下线接口调用一般使用 JVM Shutdown Hook 的方式来实现。\n\n*   特别的，在 Java 应用中的 Spring 框架中，可以通过 Spring Bean LifeCycle 来实现应用停止时主动调用服务下线接口。\n\n*   当然上述两种方式还不够优雅，因为不能确保不出现 kill -9 这种粗暴的停止方式，而且应用调用服务下线接口也是尝试去调用，对于网络不通等异常场景并没有做异常处理。因此，调用客户端仍应该做好负载均衡与 failover 的处理。\n*   更优雅的方式，先将即将停止的应用所对应的权重调成 0，此时上游将不再调用此应用。这时候的停止应用的操作对服务订阅者完全没有影响，当然这种场景需要订阅者实现按权重的负载均衡和运维部署工具深度结合。\n\n## 服务的健康检查是如何做的 ？\n\n健康检查分为客户端心跳和服务端主动探测两种方式。\n\n*   客户端心跳\n\n*   客户端每隔一定时间主动发送“心跳”的方式来向服务端表明自己的服务状态正常，心跳可以是 TCP 的形式，也可以是 HTTP 的形式。\n\n*   也可以通过维持客户端和服务端的一个 socket 长连接自己实现一个客户端心跳的方式。\n\n*   ZooKeeper 并没有主动的发送心跳，而是依赖了组件本身提供的临时节点的特性，通过 ZooKeeper 连接的 session 来维持临时节点。\n\n但是客户端心跳中，长连接的维持和客户端的主动心跳都只是表明链路上的正常，不一定是服务状态正常。\n\n服务端主动调用服务进行健康检查是一个较为准确的方式，返回结果成功表明服务状态确实正常。\n\n*   服务端主动探测\n*   服务端调用服务发布者某个 HTTP 接口来完成健康检查。\n*   对于没有提供 HTTP 服务的 RPC 应用，服务端调用服务发布者的接口来完成健康检查。\n*   可以通过执行某个脚本的形式来进行综合检查。\n\n服务端主动探测也存在问题。服务注册中心主动调用 RPC 服务的某个接口无法做到通用性；在很多场景下服务注册中心到服务发布者的网络是不通的，服务端无法主动发起健康检查。\n\n所以如何取舍，还是需要根据实际情况来决定，根据不同的场景，选择不同的策略。\n\n# 服务发现\n\n## 怎么找到服务发现服务端的地址？\n\n*   在应用的配置文件中指定服务注册中心的地址，类似于 zookeeper 和 eureka。\n*   指定一个地址服务器的地址，然后通过这个地址服务器来获取服务注册中心的地址，地址服务器返回的结果会随着服务注册中心的扩缩容及时更新。\n\n## 当服务有节点退出或新的节点加入时，订阅者如何及时收到通知 ？\n\n很经典的 Push 和 Pull 问题。\n\nPush 的经典实现有两种，基于 socket 长连接的 notify，典型的实现如 zookeeper；另一种为 HTTP 连接所使用 Long Polling。\n\n但是基于 socket 长连接的 notify 和基于 HTTP 协议的 Long Polling 都会存在notify消息丢失的问题。\n\n所以通过 Pull 的方式定时轮询也必不可少，时间间隔的选择也很关键，频率越高服务注册中心所承受的压力也越大。需要结合服务端的性能和业务的规模进行权衡。\n\n还有一种方式，真实的 Push，客户端开启一个 UDP server，服务注册中心通过 UDP 的方式进行数据推送，当然这个也受限于网络的连通性。\n\n## 我能方便地查看我发布和订阅了哪些服务，订阅的服务有哪些节点吗 ？\n\n*   一个好的产品，用户使用体验和运维体验必须是优雅的，如果查看本机发布和订阅的服务，只能通过查看日志，甚至是 jmap 的方式来获取，显然体验非常糟糕。\n\n*   服务注册中心应该提供了丰富的接口，支持根据应用名、IP、订阅服务名、发布服务名，来进行多层次的组合查询。\n\n*   同时，客户端的内存里，同样也应该保留服务发布与订阅的各种信息，并提供方式供人方便地查询。\n*   比如在 Java 中的 Spring Boot 的应用，可以结合 actuator endpoint，通过 HTTP 的方式来提供本机服务查询功能，查询此应用发布的服务，以及订阅的服务及各服务的对应节点。\n\n# 容灾和高可用\n\n## 性能如何\n\n当服务节点数越来越多时，服务注册中心的性能会成为瓶颈，这时候就需要通过水平扩容来提升服务注册中心集群的性能。\n\n*   对于那些采用了类 Paxos 协议的强一致性的组件，如ZooKeeper，由于每次写操作需要过半的节点确认。水平扩容不能提升整个集群的写性能，只能提升整个集群的读性能。\n*   而对于采用最终一致性的组件来说，水平扩容可以同时提升整个集群的写性能和读性能。\n\n## 客户端容灾策略\n\n1.  首先，本地内存缓存，当运行时与服务注册中心的连接丢失或服务注册中心完全宕机，仍能正常地调用服务。\n\n2.  然后，本地缓存文件，当应用与服务注册中心发生网络分区或服务注册中心完全宕机后，应用进行了重启操作，内存里没有数据，此时应用可以通过读取本地缓存文件的数据来获取到最后一次订阅到的内容。\n\n3.  最后，本地容灾文件夹。正常的情况下，容灾文件夹内是没有内容的。当服务端完全宕机且长时间不能恢复，同时服务提供者又发生了很大的变更时，可以通过在容灾文件夹内添加文件的方式来开启本地容灾。此时客户端会忽略原有的本地缓存文件，只从本地容灾文件中读取配置。\n\n## 服务端容灾与高可用\n\n*   当有新节点加入集群时，节点启动后能自动添加到地址服务器中，并通过地址服务器找到其他节点，自动从其他节点同步数据，以达到数据的最终一致性。\n*   当某个节点宕机时，此服务注册中心节点的信息会自动地址服务器中摘除，客户端能及时感知到此节点已下线。\n\n服务端的无状态性保证了服务的容灾和高可用可以做的很薄。\n\n## 服务端安全是如何做的 ？\n\n链路安全，对于使用 HTTP 连接的服务注册中心，保护链路安全的最好方式是使用 HTTPS。而使用 TCP 连接的服务注册中心来说，由于应用层协议一般使用的是私有协议，不一定存在现成的 TLS 支持方案。\n\n在业务安全方面，应该在每一次的发布、订阅、心跳，都带上鉴权的信息就行验签和鉴权，确保业务信息的安全性。\n\n# 参考文献\n1. [聊聊微服务的服务注册与发现](http://jm.taobao.org/2018/06/26/%E8%81%8A%E8%81%8A%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/)","slug":"服务注册与发现","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckh351dvh002w19z4cg0lh0sd","content":"<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><p>聊起微服务的服务注册与发现，很多人立马就会脱口而出 zk、etcd、consul、eureka 这些组件，进而聊到 CAP 如何取舍，性能如何，高可用和容灾是怎么实现的。</p>\n<p>在这之前，站在组件使用者的角度，我想先问这么几个问题：</p>\n<ul>\n<li><p>注册的 IP 和端口怎么确定 ？</p>\n</li>\n<li><p>实现服务治理还需要注册哪些信息 ？</p>\n</li>\n<li><p>如何进行优雅的服务注册与服务下线 ？</p>\n</li>\n<li><p>注册服务的健康检查是如何做的 ？</p>\n</li>\n<li><p>当服务有节点退出或新的节点加入时，订阅者能不能及时收到通知 ?</p>\n</li>\n<li><p>我能方便地查看某个应用发布和订阅了哪些服务，以及所订阅的服务有哪些节点吗 ？</p>\n</li>\n</ul>\n<p>看完这些问题后，您也许会发现，对于服务注册与发现，首先应该关注的是服务注册发现本身的功能，然后才是性能和高可用。</p>\n<p>一个好的服务注册发现中间件，应该是能完整地满足服务开发和治理的基础功能，然后才是性能和高可用。如果没有想清楚前面的功能，再高的可用性和性能都是浮云。最后，安全也同样重要。</p>\n<ul>\n<li><p>服务端的性能如何 ？</p>\n</li>\n<li><p>服务发现的容灾策略是怎样的 ？</p>\n</li>\n<li><p>当我的应用和服务发现中心的网络连接出现问题时，会对我的调用产生什么影响 ？</p>\n</li>\n<li><p>服务注册中心某台机器宕机或者全部宕机时，会对我的调用产生什么影响 ？</p>\n</li>\n<li><p>服务注册和发现的链路安全吗，有没有做好权限控制 ？</p>\n</li>\n</ul>\n<p>下面将从 服务注册、服务发现、容灾和高可用三个大方面来回答这些问题的主流做法。</p>\n<p>最后会介绍一下 ANS(Alibaba Naming Service) ， ANS 综合了这些解决方案中的优点，并在 EDAS(阿里巴巴企业级分布式应用服务) 中输出，目前完全免费！</p>\n<h1 id=\"服务注册\"><a href=\"#服务注册\" class=\"headerlink\" title=\"服务注册\"></a>服务注册</h1><h2 id=\"注册的-IP-和端口怎么确定-？\"><a href=\"#注册的-IP-和端口怎么确定-？\" class=\"headerlink\" title=\"注册的 IP 和端口怎么确定 ？\"></a>注册的 IP 和端口怎么确定 ？</h2><h3 id=\"IP-如何确定\"><a href=\"#IP-如何确定\" class=\"headerlink\" title=\"IP 如何确定\"></a>IP 如何确定</h3><p>主流的 IP 获取有这几种方法。</p>\n<ul>\n<li><p>最简单粗暴的方式，手动配置需要注册的IP。当然这种方式基本无法在生产环境使用，因为微服务基本都是支持水平扩容多机部署的，在配置中写死 IP 地址的方式无法支持一份代码水平扩容，会给运维带来极大的成本。</p>\n</li>\n<li><p>通过遍历网卡的方式去获取，找到第一个不为本地环回地址的 IP 地址。绝大多数情况下，这个方式比较好用，dubbo 等框架采用的就是这种方法。</p>\n</li>\n<li><p>在一些网络规划比较好的标准化机房中，我们还可以通过手动指定网卡名，即 interfaceName 的方式来指定使用哪一块网卡所对应的 IP 地址进行注册。</p>\n</li>\n<li><p>当上述三种方式都不能有效解决问题的时候，有一个方法就是直接与服务注册中心建立 socket 连接，然后通过<code>socket.getLocalAddress()</code> 这种方式来获取本机的 IP。</p>\n</li>\n</ul>\n<h3 id=\"端口如何确定\"><a href=\"#端口如何确定\" class=\"headerlink\" title=\"端口如何确定\"></a>端口如何确定</h3><p>端口的获取，没有标准化的方案。</p>\n<ul>\n<li><p>如果是 RPC 应用，启动的时候都有一个配置来指定服务监听的端口， 注册的时候直接使用配置项的端口值。</p>\n</li>\n<li><p>传统的 WEB 容器所提供的 HTTP 的应用，同样也存在一个配置文件来配置容器的监听端口，注册时候直接使用配置项的端口值。</p>\n</li>\n<li><p>特别的，在 Java 应用的 Spring Boot 框架中，可以通过 <code>EmbeddedServletContainerInitializedEvent. getEmbeddedServletContainer().getPort()</code>来获取。(Spring Boot 版本为 1.x)。</p>\n</li>\n</ul>\n<h2 id=\"实现服务治理还需要注册哪些信息-？\"><a href=\"#实现服务治理还需要注册哪些信息-？\" class=\"headerlink\" title=\"实现服务治理还需要注册哪些信息 ？\"></a>实现服务治理还需要注册哪些信息 ？</h2><p>简单地将 IP 和 port 信息注册上去，可以满足基本的服务调用的需求，但是在业务发展到一定程度的时候，我们还会有这些需求：</p>\n<ul>\n<li><p>想知道某个 HTTP 服务是否开启了 TLS。</p>\n</li>\n<li><p>对相同服务下的不同节点设置不同的权重，进行流量调度。</p>\n</li>\n<li><p>将服务分成预发环境和生产环境，方便进行AB Test功能。</p>\n</li>\n<li><p>不同机房的服务注册时加上机房的标签，以实现同机房优先的路由规则。</p>\n</li>\n</ul>\n<p>这些高级功能的实现，本质上是依赖于客户端调用时候的负载均衡策略和调用策略，但是如果服务元数据没有注册上来，也只能是巧妇难为无米之炊。一个良好的服务注册中心在设计最初就应该支持这些扩展字段。</p>\n<h2 id=\"如何进行优雅的服务注册与服务下线-？\"><a href=\"#如何进行优雅的服务注册与服务下线-？\" class=\"headerlink\" title=\"如何进行优雅的服务注册与服务下线 ？\"></a>如何进行优雅的服务注册与服务下线 ？</h2><h3 id=\"优雅发布\"><a href=\"#优雅发布\" class=\"headerlink\" title=\"优雅发布\"></a>优雅发布</h3><p>虽然服务注册一般发生在服务的启动阶段，但是细分的话，服务注册应该在服务已经完全启动成功，并准备对外提供服务之后才能进行注册。</p>\n<ul>\n<li><p>有些 RPC 框架自身提供了方法来判断服务是否已经启动完成，如 Thrift ，我们可以通过 Server.isServing() 来判断。</p>\n</li>\n<li><p>有一些 RPC 框架本身没有提供服务是否启动完成的方式，这时我们可以通过检测端口是否已经处于监听状态来判断。</p>\n</li>\n<li><p>而对于 HTTP 服务，服务是否启动完毕也可以通过端口是否处于监听状态来判断。</p>\n</li>\n<li><p>特别的，在 Java 应用的 Spring Boot 框架中，可以通过事件通知的形式来通知容器已经启动完毕， EmbeddedServletContainerInitializedEvent 事件来通知容器已经启动完成 (Spring Boot 版本为 1.x)。</p>\n</li>\n</ul>\n<h3 id=\"优雅下线\"><a href=\"#优雅下线\" class=\"headerlink\" title=\"优雅下线\"></a>优雅下线</h3><p>绝大多数的服务注册中心都提供了健康检查功能，在应用停止后会自动摘除服务所对应的节点。但是我们也不能完全依赖此功能，应用应该在停止时主动调用服务注册中心的服务下线接口。</p>\n<ul>\n<li><p>在 Java 应用中，通用的服务下线接口调用一般使用 JVM Shutdown Hook 的方式来实现。</p>\n</li>\n<li><p>特别的，在 Java 应用中的 Spring 框架中，可以通过 Spring Bean LifeCycle 来实现应用停止时主动调用服务下线接口。</p>\n</li>\n<li><p>当然上述两种方式还不够优雅，因为不能确保不出现 kill -9 这种粗暴的停止方式，而且应用调用服务下线接口也是尝试去调用，对于网络不通等异常场景并没有做异常处理。因此，调用客户端仍应该做好负载均衡与 failover 的处理。</p>\n</li>\n<li><p>更优雅的方式，先将即将停止的应用所对应的权重调成 0，此时上游将不再调用此应用。这时候的停止应用的操作对服务订阅者完全没有影响，当然这种场景需要订阅者实现按权重的负载均衡和运维部署工具深度结合。</p>\n</li>\n</ul>\n<h2 id=\"服务的健康检查是如何做的-？\"><a href=\"#服务的健康检查是如何做的-？\" class=\"headerlink\" title=\"服务的健康检查是如何做的 ？\"></a>服务的健康检查是如何做的 ？</h2><p>健康检查分为客户端心跳和服务端主动探测两种方式。</p>\n<ul>\n<li><p>客户端心跳</p>\n</li>\n<li><p>客户端每隔一定时间主动发送“心跳”的方式来向服务端表明自己的服务状态正常，心跳可以是 TCP 的形式，也可以是 HTTP 的形式。</p>\n</li>\n<li><p>也可以通过维持客户端和服务端的一个 socket 长连接自己实现一个客户端心跳的方式。</p>\n</li>\n<li><p>ZooKeeper 并没有主动的发送心跳，而是依赖了组件本身提供的临时节点的特性，通过 ZooKeeper 连接的 session 来维持临时节点。</p>\n</li>\n</ul>\n<p>但是客户端心跳中，长连接的维持和客户端的主动心跳都只是表明链路上的正常，不一定是服务状态正常。</p>\n<p>服务端主动调用服务进行健康检查是一个较为准确的方式，返回结果成功表明服务状态确实正常。</p>\n<ul>\n<li>服务端主动探测</li>\n<li>服务端调用服务发布者某个 HTTP 接口来完成健康检查。</li>\n<li>对于没有提供 HTTP 服务的 RPC 应用，服务端调用服务发布者的接口来完成健康检查。</li>\n<li>可以通过执行某个脚本的形式来进行综合检查。</li>\n</ul>\n<p>服务端主动探测也存在问题。服务注册中心主动调用 RPC 服务的某个接口无法做到通用性；在很多场景下服务注册中心到服务发布者的网络是不通的，服务端无法主动发起健康检查。</p>\n<p>所以如何取舍，还是需要根据实际情况来决定，根据不同的场景，选择不同的策略。</p>\n<h1 id=\"服务发现\"><a href=\"#服务发现\" class=\"headerlink\" title=\"服务发现\"></a>服务发现</h1><h2 id=\"怎么找到服务发现服务端的地址？\"><a href=\"#怎么找到服务发现服务端的地址？\" class=\"headerlink\" title=\"怎么找到服务发现服务端的地址？\"></a>怎么找到服务发现服务端的地址？</h2><ul>\n<li>在应用的配置文件中指定服务注册中心的地址，类似于 zookeeper 和 eureka。</li>\n<li>指定一个地址服务器的地址，然后通过这个地址服务器来获取服务注册中心的地址，地址服务器返回的结果会随着服务注册中心的扩缩容及时更新。</li>\n</ul>\n<h2 id=\"当服务有节点退出或新的节点加入时，订阅者如何及时收到通知-？\"><a href=\"#当服务有节点退出或新的节点加入时，订阅者如何及时收到通知-？\" class=\"headerlink\" title=\"当服务有节点退出或新的节点加入时，订阅者如何及时收到通知 ？\"></a>当服务有节点退出或新的节点加入时，订阅者如何及时收到通知 ？</h2><p>很经典的 Push 和 Pull 问题。</p>\n<p>Push 的经典实现有两种，基于 socket 长连接的 notify，典型的实现如 zookeeper；另一种为 HTTP 连接所使用 Long Polling。</p>\n<p>但是基于 socket 长连接的 notify 和基于 HTTP 协议的 Long Polling 都会存在notify消息丢失的问题。</p>\n<p>所以通过 Pull 的方式定时轮询也必不可少，时间间隔的选择也很关键，频率越高服务注册中心所承受的压力也越大。需要结合服务端的性能和业务的规模进行权衡。</p>\n<p>还有一种方式，真实的 Push，客户端开启一个 UDP server，服务注册中心通过 UDP 的方式进行数据推送，当然这个也受限于网络的连通性。</p>\n<h2 id=\"我能方便地查看我发布和订阅了哪些服务，订阅的服务有哪些节点吗-？\"><a href=\"#我能方便地查看我发布和订阅了哪些服务，订阅的服务有哪些节点吗-？\" class=\"headerlink\" title=\"我能方便地查看我发布和订阅了哪些服务，订阅的服务有哪些节点吗 ？\"></a>我能方便地查看我发布和订阅了哪些服务，订阅的服务有哪些节点吗 ？</h2><ul>\n<li><p>一个好的产品，用户使用体验和运维体验必须是优雅的，如果查看本机发布和订阅的服务，只能通过查看日志，甚至是 jmap 的方式来获取，显然体验非常糟糕。</p>\n</li>\n<li><p>服务注册中心应该提供了丰富的接口，支持根据应用名、IP、订阅服务名、发布服务名，来进行多层次的组合查询。</p>\n</li>\n<li><p>同时，客户端的内存里，同样也应该保留服务发布与订阅的各种信息，并提供方式供人方便地查询。</p>\n</li>\n<li><p>比如在 Java 中的 Spring Boot 的应用，可以结合 actuator endpoint，通过 HTTP 的方式来提供本机服务查询功能，查询此应用发布的服务，以及订阅的服务及各服务的对应节点。</p>\n</li>\n</ul>\n<h1 id=\"容灾和高可用\"><a href=\"#容灾和高可用\" class=\"headerlink\" title=\"容灾和高可用\"></a>容灾和高可用</h1><h2 id=\"性能如何\"><a href=\"#性能如何\" class=\"headerlink\" title=\"性能如何\"></a>性能如何</h2><p>当服务节点数越来越多时，服务注册中心的性能会成为瓶颈，这时候就需要通过水平扩容来提升服务注册中心集群的性能。</p>\n<ul>\n<li>对于那些采用了类 Paxos 协议的强一致性的组件，如ZooKeeper，由于每次写操作需要过半的节点确认。水平扩容不能提升整个集群的写性能，只能提升整个集群的读性能。</li>\n<li>而对于采用最终一致性的组件来说，水平扩容可以同时提升整个集群的写性能和读性能。</li>\n</ul>\n<h2 id=\"客户端容灾策略\"><a href=\"#客户端容灾策略\" class=\"headerlink\" title=\"客户端容灾策略\"></a>客户端容灾策略</h2><ol>\n<li><p>首先，本地内存缓存，当运行时与服务注册中心的连接丢失或服务注册中心完全宕机，仍能正常地调用服务。</p>\n</li>\n<li><p>然后，本地缓存文件，当应用与服务注册中心发生网络分区或服务注册中心完全宕机后，应用进行了重启操作，内存里没有数据，此时应用可以通过读取本地缓存文件的数据来获取到最后一次订阅到的内容。</p>\n</li>\n<li><p>最后，本地容灾文件夹。正常的情况下，容灾文件夹内是没有内容的。当服务端完全宕机且长时间不能恢复，同时服务提供者又发生了很大的变更时，可以通过在容灾文件夹内添加文件的方式来开启本地容灾。此时客户端会忽略原有的本地缓存文件，只从本地容灾文件中读取配置。</p>\n</li>\n</ol>\n<h2 id=\"服务端容灾与高可用\"><a href=\"#服务端容灾与高可用\" class=\"headerlink\" title=\"服务端容灾与高可用\"></a>服务端容灾与高可用</h2><ul>\n<li>当有新节点加入集群时，节点启动后能自动添加到地址服务器中，并通过地址服务器找到其他节点，自动从其他节点同步数据，以达到数据的最终一致性。</li>\n<li>当某个节点宕机时，此服务注册中心节点的信息会自动地址服务器中摘除，客户端能及时感知到此节点已下线。</li>\n</ul>\n<p>服务端的无状态性保证了服务的容灾和高可用可以做的很薄。</p>\n<h2 id=\"服务端安全是如何做的-？\"><a href=\"#服务端安全是如何做的-？\" class=\"headerlink\" title=\"服务端安全是如何做的 ？\"></a>服务端安全是如何做的 ？</h2><p>链路安全，对于使用 HTTP 连接的服务注册中心，保护链路安全的最好方式是使用 HTTPS。而使用 TCP 连接的服务注册中心来说，由于应用层协议一般使用的是私有协议，不一定存在现成的 TLS 支持方案。</p>\n<p>在业务安全方面，应该在每一次的发布、订阅、心跳，都带上鉴权的信息就行验签和鉴权，确保业务信息的安全性。</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ol>\n<li><a href=\"http://jm.taobao.org/2018/06/26/%E8%81%8A%E8%81%8A%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/\" target=\"_blank\" rel=\"noopener\">聊聊微服务的服务注册与发现</a></li>\n</ol>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"friends":[{"avatar":"https://img-1251474779.cos.ap-beijing.myqcloud.com/icon.png","name":"djaigo","introduction":"好好学习，天天向上","url":"/","title":"前去学习"},{"avatar":"https://awps-assets.meituan.net/mit/blog/v20190629/asset/icon/favicon.ico?v=Whistle&t=20181017-1r","name":"美团技术团队","introduction":"一行代码，亿万生活。","url":"https://tech.meituan.com/","title":"点个外卖-->"},{"avatar":"","name":"鸟窝","introduction":"rpcx作者","url":"https://colobu.com/","title":"进个鸟窝-->"},{"avatar":"https://d1j8pt39hxlh3d.cloudfront.net/emoji/emojione/5.0/png/unicode/32/1f92a.png","name":"labuladong的算法小抄","introduction":"算法大神","url":"https://labuladong.gitbook.io/algo/","title":"学个算法-->"}]}},"excerpt":"","more":"<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><p>聊起微服务的服务注册与发现，很多人立马就会脱口而出 zk、etcd、consul、eureka 这些组件，进而聊到 CAP 如何取舍，性能如何，高可用和容灾是怎么实现的。</p>\n<p>在这之前，站在组件使用者的角度，我想先问这么几个问题：</p>\n<ul>\n<li><p>注册的 IP 和端口怎么确定 ？</p>\n</li>\n<li><p>实现服务治理还需要注册哪些信息 ？</p>\n</li>\n<li><p>如何进行优雅的服务注册与服务下线 ？</p>\n</li>\n<li><p>注册服务的健康检查是如何做的 ？</p>\n</li>\n<li><p>当服务有节点退出或新的节点加入时，订阅者能不能及时收到通知 ?</p>\n</li>\n<li><p>我能方便地查看某个应用发布和订阅了哪些服务，以及所订阅的服务有哪些节点吗 ？</p>\n</li>\n</ul>\n<p>看完这些问题后，您也许会发现，对于服务注册与发现，首先应该关注的是服务注册发现本身的功能，然后才是性能和高可用。</p>\n<p>一个好的服务注册发现中间件，应该是能完整地满足服务开发和治理的基础功能，然后才是性能和高可用。如果没有想清楚前面的功能，再高的可用性和性能都是浮云。最后，安全也同样重要。</p>\n<ul>\n<li><p>服务端的性能如何 ？</p>\n</li>\n<li><p>服务发现的容灾策略是怎样的 ？</p>\n</li>\n<li><p>当我的应用和服务发现中心的网络连接出现问题时，会对我的调用产生什么影响 ？</p>\n</li>\n<li><p>服务注册中心某台机器宕机或者全部宕机时，会对我的调用产生什么影响 ？</p>\n</li>\n<li><p>服务注册和发现的链路安全吗，有没有做好权限控制 ？</p>\n</li>\n</ul>\n<p>下面将从 服务注册、服务发现、容灾和高可用三个大方面来回答这些问题的主流做法。</p>\n<p>最后会介绍一下 ANS(Alibaba Naming Service) ， ANS 综合了这些解决方案中的优点，并在 EDAS(阿里巴巴企业级分布式应用服务) 中输出，目前完全免费！</p>\n<h1 id=\"服务注册\"><a href=\"#服务注册\" class=\"headerlink\" title=\"服务注册\"></a>服务注册</h1><h2 id=\"注册的-IP-和端口怎么确定-？\"><a href=\"#注册的-IP-和端口怎么确定-？\" class=\"headerlink\" title=\"注册的 IP 和端口怎么确定 ？\"></a>注册的 IP 和端口怎么确定 ？</h2><h3 id=\"IP-如何确定\"><a href=\"#IP-如何确定\" class=\"headerlink\" title=\"IP 如何确定\"></a>IP 如何确定</h3><p>主流的 IP 获取有这几种方法。</p>\n<ul>\n<li><p>最简单粗暴的方式，手动配置需要注册的IP。当然这种方式基本无法在生产环境使用，因为微服务基本都是支持水平扩容多机部署的，在配置中写死 IP 地址的方式无法支持一份代码水平扩容，会给运维带来极大的成本。</p>\n</li>\n<li><p>通过遍历网卡的方式去获取，找到第一个不为本地环回地址的 IP 地址。绝大多数情况下，这个方式比较好用，dubbo 等框架采用的就是这种方法。</p>\n</li>\n<li><p>在一些网络规划比较好的标准化机房中，我们还可以通过手动指定网卡名，即 interfaceName 的方式来指定使用哪一块网卡所对应的 IP 地址进行注册。</p>\n</li>\n<li><p>当上述三种方式都不能有效解决问题的时候，有一个方法就是直接与服务注册中心建立 socket 连接，然后通过<code>socket.getLocalAddress()</code> 这种方式来获取本机的 IP。</p>\n</li>\n</ul>\n<h3 id=\"端口如何确定\"><a href=\"#端口如何确定\" class=\"headerlink\" title=\"端口如何确定\"></a>端口如何确定</h3><p>端口的获取，没有标准化的方案。</p>\n<ul>\n<li><p>如果是 RPC 应用，启动的时候都有一个配置来指定服务监听的端口， 注册的时候直接使用配置项的端口值。</p>\n</li>\n<li><p>传统的 WEB 容器所提供的 HTTP 的应用，同样也存在一个配置文件来配置容器的监听端口，注册时候直接使用配置项的端口值。</p>\n</li>\n<li><p>特别的，在 Java 应用的 Spring Boot 框架中，可以通过 <code>EmbeddedServletContainerInitializedEvent. getEmbeddedServletContainer().getPort()</code>来获取。(Spring Boot 版本为 1.x)。</p>\n</li>\n</ul>\n<h2 id=\"实现服务治理还需要注册哪些信息-？\"><a href=\"#实现服务治理还需要注册哪些信息-？\" class=\"headerlink\" title=\"实现服务治理还需要注册哪些信息 ？\"></a>实现服务治理还需要注册哪些信息 ？</h2><p>简单地将 IP 和 port 信息注册上去，可以满足基本的服务调用的需求，但是在业务发展到一定程度的时候，我们还会有这些需求：</p>\n<ul>\n<li><p>想知道某个 HTTP 服务是否开启了 TLS。</p>\n</li>\n<li><p>对相同服务下的不同节点设置不同的权重，进行流量调度。</p>\n</li>\n<li><p>将服务分成预发环境和生产环境，方便进行AB Test功能。</p>\n</li>\n<li><p>不同机房的服务注册时加上机房的标签，以实现同机房优先的路由规则。</p>\n</li>\n</ul>\n<p>这些高级功能的实现，本质上是依赖于客户端调用时候的负载均衡策略和调用策略，但是如果服务元数据没有注册上来，也只能是巧妇难为无米之炊。一个良好的服务注册中心在设计最初就应该支持这些扩展字段。</p>\n<h2 id=\"如何进行优雅的服务注册与服务下线-？\"><a href=\"#如何进行优雅的服务注册与服务下线-？\" class=\"headerlink\" title=\"如何进行优雅的服务注册与服务下线 ？\"></a>如何进行优雅的服务注册与服务下线 ？</h2><h3 id=\"优雅发布\"><a href=\"#优雅发布\" class=\"headerlink\" title=\"优雅发布\"></a>优雅发布</h3><p>虽然服务注册一般发生在服务的启动阶段，但是细分的话，服务注册应该在服务已经完全启动成功，并准备对外提供服务之后才能进行注册。</p>\n<ul>\n<li><p>有些 RPC 框架自身提供了方法来判断服务是否已经启动完成，如 Thrift ，我们可以通过 Server.isServing() 来判断。</p>\n</li>\n<li><p>有一些 RPC 框架本身没有提供服务是否启动完成的方式，这时我们可以通过检测端口是否已经处于监听状态来判断。</p>\n</li>\n<li><p>而对于 HTTP 服务，服务是否启动完毕也可以通过端口是否处于监听状态来判断。</p>\n</li>\n<li><p>特别的，在 Java 应用的 Spring Boot 框架中，可以通过事件通知的形式来通知容器已经启动完毕， EmbeddedServletContainerInitializedEvent 事件来通知容器已经启动完成 (Spring Boot 版本为 1.x)。</p>\n</li>\n</ul>\n<h3 id=\"优雅下线\"><a href=\"#优雅下线\" class=\"headerlink\" title=\"优雅下线\"></a>优雅下线</h3><p>绝大多数的服务注册中心都提供了健康检查功能，在应用停止后会自动摘除服务所对应的节点。但是我们也不能完全依赖此功能，应用应该在停止时主动调用服务注册中心的服务下线接口。</p>\n<ul>\n<li><p>在 Java 应用中，通用的服务下线接口调用一般使用 JVM Shutdown Hook 的方式来实现。</p>\n</li>\n<li><p>特别的，在 Java 应用中的 Spring 框架中，可以通过 Spring Bean LifeCycle 来实现应用停止时主动调用服务下线接口。</p>\n</li>\n<li><p>当然上述两种方式还不够优雅，因为不能确保不出现 kill -9 这种粗暴的停止方式，而且应用调用服务下线接口也是尝试去调用，对于网络不通等异常场景并没有做异常处理。因此，调用客户端仍应该做好负载均衡与 failover 的处理。</p>\n</li>\n<li><p>更优雅的方式，先将即将停止的应用所对应的权重调成 0，此时上游将不再调用此应用。这时候的停止应用的操作对服务订阅者完全没有影响，当然这种场景需要订阅者实现按权重的负载均衡和运维部署工具深度结合。</p>\n</li>\n</ul>\n<h2 id=\"服务的健康检查是如何做的-？\"><a href=\"#服务的健康检查是如何做的-？\" class=\"headerlink\" title=\"服务的健康检查是如何做的 ？\"></a>服务的健康检查是如何做的 ？</h2><p>健康检查分为客户端心跳和服务端主动探测两种方式。</p>\n<ul>\n<li><p>客户端心跳</p>\n</li>\n<li><p>客户端每隔一定时间主动发送“心跳”的方式来向服务端表明自己的服务状态正常，心跳可以是 TCP 的形式，也可以是 HTTP 的形式。</p>\n</li>\n<li><p>也可以通过维持客户端和服务端的一个 socket 长连接自己实现一个客户端心跳的方式。</p>\n</li>\n<li><p>ZooKeeper 并没有主动的发送心跳，而是依赖了组件本身提供的临时节点的特性，通过 ZooKeeper 连接的 session 来维持临时节点。</p>\n</li>\n</ul>\n<p>但是客户端心跳中，长连接的维持和客户端的主动心跳都只是表明链路上的正常，不一定是服务状态正常。</p>\n<p>服务端主动调用服务进行健康检查是一个较为准确的方式，返回结果成功表明服务状态确实正常。</p>\n<ul>\n<li>服务端主动探测</li>\n<li>服务端调用服务发布者某个 HTTP 接口来完成健康检查。</li>\n<li>对于没有提供 HTTP 服务的 RPC 应用，服务端调用服务发布者的接口来完成健康检查。</li>\n<li>可以通过执行某个脚本的形式来进行综合检查。</li>\n</ul>\n<p>服务端主动探测也存在问题。服务注册中心主动调用 RPC 服务的某个接口无法做到通用性；在很多场景下服务注册中心到服务发布者的网络是不通的，服务端无法主动发起健康检查。</p>\n<p>所以如何取舍，还是需要根据实际情况来决定，根据不同的场景，选择不同的策略。</p>\n<h1 id=\"服务发现\"><a href=\"#服务发现\" class=\"headerlink\" title=\"服务发现\"></a>服务发现</h1><h2 id=\"怎么找到服务发现服务端的地址？\"><a href=\"#怎么找到服务发现服务端的地址？\" class=\"headerlink\" title=\"怎么找到服务发现服务端的地址？\"></a>怎么找到服务发现服务端的地址？</h2><ul>\n<li>在应用的配置文件中指定服务注册中心的地址，类似于 zookeeper 和 eureka。</li>\n<li>指定一个地址服务器的地址，然后通过这个地址服务器来获取服务注册中心的地址，地址服务器返回的结果会随着服务注册中心的扩缩容及时更新。</li>\n</ul>\n<h2 id=\"当服务有节点退出或新的节点加入时，订阅者如何及时收到通知-？\"><a href=\"#当服务有节点退出或新的节点加入时，订阅者如何及时收到通知-？\" class=\"headerlink\" title=\"当服务有节点退出或新的节点加入时，订阅者如何及时收到通知 ？\"></a>当服务有节点退出或新的节点加入时，订阅者如何及时收到通知 ？</h2><p>很经典的 Push 和 Pull 问题。</p>\n<p>Push 的经典实现有两种，基于 socket 长连接的 notify，典型的实现如 zookeeper；另一种为 HTTP 连接所使用 Long Polling。</p>\n<p>但是基于 socket 长连接的 notify 和基于 HTTP 协议的 Long Polling 都会存在notify消息丢失的问题。</p>\n<p>所以通过 Pull 的方式定时轮询也必不可少，时间间隔的选择也很关键，频率越高服务注册中心所承受的压力也越大。需要结合服务端的性能和业务的规模进行权衡。</p>\n<p>还有一种方式，真实的 Push，客户端开启一个 UDP server，服务注册中心通过 UDP 的方式进行数据推送，当然这个也受限于网络的连通性。</p>\n<h2 id=\"我能方便地查看我发布和订阅了哪些服务，订阅的服务有哪些节点吗-？\"><a href=\"#我能方便地查看我发布和订阅了哪些服务，订阅的服务有哪些节点吗-？\" class=\"headerlink\" title=\"我能方便地查看我发布和订阅了哪些服务，订阅的服务有哪些节点吗 ？\"></a>我能方便地查看我发布和订阅了哪些服务，订阅的服务有哪些节点吗 ？</h2><ul>\n<li><p>一个好的产品，用户使用体验和运维体验必须是优雅的，如果查看本机发布和订阅的服务，只能通过查看日志，甚至是 jmap 的方式来获取，显然体验非常糟糕。</p>\n</li>\n<li><p>服务注册中心应该提供了丰富的接口，支持根据应用名、IP、订阅服务名、发布服务名，来进行多层次的组合查询。</p>\n</li>\n<li><p>同时，客户端的内存里，同样也应该保留服务发布与订阅的各种信息，并提供方式供人方便地查询。</p>\n</li>\n<li><p>比如在 Java 中的 Spring Boot 的应用，可以结合 actuator endpoint，通过 HTTP 的方式来提供本机服务查询功能，查询此应用发布的服务，以及订阅的服务及各服务的对应节点。</p>\n</li>\n</ul>\n<h1 id=\"容灾和高可用\"><a href=\"#容灾和高可用\" class=\"headerlink\" title=\"容灾和高可用\"></a>容灾和高可用</h1><h2 id=\"性能如何\"><a href=\"#性能如何\" class=\"headerlink\" title=\"性能如何\"></a>性能如何</h2><p>当服务节点数越来越多时，服务注册中心的性能会成为瓶颈，这时候就需要通过水平扩容来提升服务注册中心集群的性能。</p>\n<ul>\n<li>对于那些采用了类 Paxos 协议的强一致性的组件，如ZooKeeper，由于每次写操作需要过半的节点确认。水平扩容不能提升整个集群的写性能，只能提升整个集群的读性能。</li>\n<li>而对于采用最终一致性的组件来说，水平扩容可以同时提升整个集群的写性能和读性能。</li>\n</ul>\n<h2 id=\"客户端容灾策略\"><a href=\"#客户端容灾策略\" class=\"headerlink\" title=\"客户端容灾策略\"></a>客户端容灾策略</h2><ol>\n<li><p>首先，本地内存缓存，当运行时与服务注册中心的连接丢失或服务注册中心完全宕机，仍能正常地调用服务。</p>\n</li>\n<li><p>然后，本地缓存文件，当应用与服务注册中心发生网络分区或服务注册中心完全宕机后，应用进行了重启操作，内存里没有数据，此时应用可以通过读取本地缓存文件的数据来获取到最后一次订阅到的内容。</p>\n</li>\n<li><p>最后，本地容灾文件夹。正常的情况下，容灾文件夹内是没有内容的。当服务端完全宕机且长时间不能恢复，同时服务提供者又发生了很大的变更时，可以通过在容灾文件夹内添加文件的方式来开启本地容灾。此时客户端会忽略原有的本地缓存文件，只从本地容灾文件中读取配置。</p>\n</li>\n</ol>\n<h2 id=\"服务端容灾与高可用\"><a href=\"#服务端容灾与高可用\" class=\"headerlink\" title=\"服务端容灾与高可用\"></a>服务端容灾与高可用</h2><ul>\n<li>当有新节点加入集群时，节点启动后能自动添加到地址服务器中，并通过地址服务器找到其他节点，自动从其他节点同步数据，以达到数据的最终一致性。</li>\n<li>当某个节点宕机时，此服务注册中心节点的信息会自动地址服务器中摘除，客户端能及时感知到此节点已下线。</li>\n</ul>\n<p>服务端的无状态性保证了服务的容灾和高可用可以做的很薄。</p>\n<h2 id=\"服务端安全是如何做的-？\"><a href=\"#服务端安全是如何做的-？\" class=\"headerlink\" title=\"服务端安全是如何做的 ？\"></a>服务端安全是如何做的 ？</h2><p>链路安全，对于使用 HTTP 连接的服务注册中心，保护链路安全的最好方式是使用 HTTPS。而使用 TCP 连接的服务注册中心来说，由于应用层协议一般使用的是私有协议，不一定存在现成的 TLS 支持方案。</p>\n<p>在业务安全方面，应该在每一次的发布、订阅、心跳，都带上鉴权的信息就行验签和鉴权，确保业务信息的安全性。</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ol>\n<li><a href=\"http://jm.taobao.org/2018/06/26/%E8%81%8A%E8%81%8A%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/\" target=\"_blank\" rel=\"noopener\">聊聊微服务的服务注册与发现</a></li>\n</ol>\n"},{"author":"djaigo","title":"闭包问题","date":"2019-10-10T06:43:35.000Z","update":null,"img":"https://img-1251474779.cos.ap-beijing.myqcloud.com/golang.png","enable html":true,"_content":"# 什么是闭包\n参考[闭包wikipedia](https://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)\n\n# 怎样产生闭包\n闭包可以让一个函数和一组变量产生关系，让这些变量的生命周期保持持久性。\n变量可以是在闭包内部声明，也可以引用外部变量，例如：\n```go\n// 在函数内部创建变量\nfunc incr() func() int {\n    var x int  \n    return func() int {\n        x++ \n        return x \n    } \n}\n\n// 在函数外面创建变量\nvar x int \nfunc incr() func() int { \n    return func() int {\n        x++ \n        return x \n    } \n}\n```\n\n在函数内部创建变量可以对外部进行隐藏，在外部声明变量可以在任意点修改。\n闭包特点是：函数内部有引用外部变量，且有延迟执行的特点。\n在golang中比较常见的就是遍历元素，启动一个协程去执行，例如：\n```go\nfor i := range data {\n    go func() {\n        fmt.Println(i)\n    }()\n}\n```\n\n为了防止执行时`i`的值相同，需要做一些出，例如：\n```go\nfor i := range data {\n    i := i\n    go func() {\n        fmt.Println(i)\n    }()\n}\n\n// 或者\nfor i := range data {\n    go func(i int) {\n        fmt.Println(i)\n    }(i)\n}\n```\n\n# 闭包的用处\n闭包最大的用处是利用延迟执行特性，进行一些操作。\n## go函数\n启动定时任务，且可控制关闭它，可以使用闭包：\n```go\nfunc startTicker(dur time.Duration) func() {\n    ticker := time.NewTicker(dur)\n    go func() {\n       for range ticker.C {\n            // do something\n        }\n    }()\n    return ticker.Stop\n}\n```\n\n[执行代码](https://play.golang.org/p/ZAnKV6h8PtA)\n\n## defer函数\n常用模式还是在defer中使用闭包，而且defer+return的组合经常会让人摸不清头脑。\n```go\n// 1.\nfunc increaseA() int {\n    var i int\n    defer func() {\n        i++\n    }()\n    return i\n}\n\n// 2.\nfunc increaseB() (r int) {\n    defer func() {\n        r++\n    }()\n    return r\n}\n```\n\ndefer中的函数将会在return后延迟执行，即先会确定返回值再执行defer函数。\n这样会导致increaseA函数返回时拷贝`i`值作为返回值，原有的`i`去执行defer函数，并不会影响返回值。\n而increaseB函数返回的是预先定义好的返回时的地址是确定的，这样defer函数改变的还是预先定义的`r`值。\n\n\n# 参考文献\n1. [闭包wikipedia](https://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)\n2. [5 年 Gopher 都不知道的 defer 细节，你别再掉进坑里！](https://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&mid=2648466918&idx=2&sn=151a8135f22563b7b97bf01ff480497b&chksm=f2474389c530ca9f3dc2ae1124e4e5ed3db4c45096924265bccfcb8908a829b9207b0dd26047&scene=21#wechat_redirect)\n","source":"_posts/闭包问题.md","raw":"---\nauthor: djaigo\ntitle: 闭包问题\ndate: 2019-10-10 14:43:35\nupdate: \nimg: https://img-1251474779.cos.ap-beijing.myqcloud.com/golang.png\ncategories: \n  - program\ntags: \n  - closure\nenable html: true\n---\n# 什么是闭包\n参考[闭包wikipedia](https://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)\n\n# 怎样产生闭包\n闭包可以让一个函数和一组变量产生关系，让这些变量的生命周期保持持久性。\n变量可以是在闭包内部声明，也可以引用外部变量，例如：\n```go\n// 在函数内部创建变量\nfunc incr() func() int {\n    var x int  \n    return func() int {\n        x++ \n        return x \n    } \n}\n\n// 在函数外面创建变量\nvar x int \nfunc incr() func() int { \n    return func() int {\n        x++ \n        return x \n    } \n}\n```\n\n在函数内部创建变量可以对外部进行隐藏，在外部声明变量可以在任意点修改。\n闭包特点是：函数内部有引用外部变量，且有延迟执行的特点。\n在golang中比较常见的就是遍历元素，启动一个协程去执行，例如：\n```go\nfor i := range data {\n    go func() {\n        fmt.Println(i)\n    }()\n}\n```\n\n为了防止执行时`i`的值相同，需要做一些出，例如：\n```go\nfor i := range data {\n    i := i\n    go func() {\n        fmt.Println(i)\n    }()\n}\n\n// 或者\nfor i := range data {\n    go func(i int) {\n        fmt.Println(i)\n    }(i)\n}\n```\n\n# 闭包的用处\n闭包最大的用处是利用延迟执行特性，进行一些操作。\n## go函数\n启动定时任务，且可控制关闭它，可以使用闭包：\n```go\nfunc startTicker(dur time.Duration) func() {\n    ticker := time.NewTicker(dur)\n    go func() {\n       for range ticker.C {\n            // do something\n        }\n    }()\n    return ticker.Stop\n}\n```\n\n[执行代码](https://play.golang.org/p/ZAnKV6h8PtA)\n\n## defer函数\n常用模式还是在defer中使用闭包，而且defer+return的组合经常会让人摸不清头脑。\n```go\n// 1.\nfunc increaseA() int {\n    var i int\n    defer func() {\n        i++\n    }()\n    return i\n}\n\n// 2.\nfunc increaseB() (r int) {\n    defer func() {\n        r++\n    }()\n    return r\n}\n```\n\ndefer中的函数将会在return后延迟执行，即先会确定返回值再执行defer函数。\n这样会导致increaseA函数返回时拷贝`i`值作为返回值，原有的`i`去执行defer函数，并不会影响返回值。\n而increaseB函数返回的是预先定义好的返回时的地址是确定的，这样defer函数改变的还是预先定义的`r`值。\n\n\n# 参考文献\n1. [闭包wikipedia](https://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)\n2. [5 年 Gopher 都不知道的 defer 细节，你别再掉进坑里！](https://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&mid=2648466918&idx=2&sn=151a8135f22563b7b97bf01ff480497b&chksm=f2474389c530ca9f3dc2ae1124e4e5ed3db4c45096924265bccfcb8908a829b9207b0dd26047&scene=21#wechat_redirect)\n","slug":"闭包问题","published":1,"updated":"2019-10-10T06:43:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh351dvi003019z4c0gjgw2p","content":"<h1 id=\"什么是闭包\"><a href=\"#什么是闭包\" class=\"headerlink\" title=\"什么是闭包\"></a>什么是闭包</h1><p>参考<a href=\"https://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\" target=\"_blank\" rel=\"noopener\">闭包wikipedia</a></p>\n<h1 id=\"怎样产生闭包\"><a href=\"#怎样产生闭包\" class=\"headerlink\" title=\"怎样产生闭包\"></a>怎样产生闭包</h1><p>闭包可以让一个函数和一组变量产生关系，让这些变量的生命周期保持持久性。<br>变量可以是在闭包内部声明，也可以引用外部变量，例如：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token comment\" spellcheck=\"true\">// 在函数内部创建变量</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">incr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">int</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> x <span class=\"token builtin\">int</span>  \n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">int</span> <span class=\"token punctuation\">{</span>\n        x<span class=\"token operator\">++</span> \n        <span class=\"token keyword\">return</span> x \n    <span class=\"token punctuation\">}</span> \n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 在函数外面创建变量</span>\n<span class=\"token keyword\">var</span> x <span class=\"token builtin\">int</span> \n<span class=\"token keyword\">func</span> <span class=\"token function\">incr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">int</span> <span class=\"token punctuation\">{</span> \n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">int</span> <span class=\"token punctuation\">{</span>\n        x<span class=\"token operator\">++</span> \n        <span class=\"token keyword\">return</span> x \n    <span class=\"token punctuation\">}</span> \n<span class=\"token punctuation\">}</span></code></pre>\n<p>在函数内部创建变量可以对外部进行隐藏，在外部声明变量可以在任意点修改。<br>闭包特点是：函数内部有引用外部变量，且有延迟执行的特点。<br>在golang中比较常见的就是遍历元素，启动一个协程去执行，例如：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token keyword\">range</span> data <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">go</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>为了防止执行时<code>i</code>的值相同，需要做一些出，例如：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token keyword\">range</span> data <span class=\"token punctuation\">{</span>\n    i <span class=\"token operator\">:=</span> i\n    <span class=\"token keyword\">go</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 或者</span>\n<span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token keyword\">range</span> data <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">go</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span>i <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"闭包的用处\"><a href=\"#闭包的用处\" class=\"headerlink\" title=\"闭包的用处\"></a>闭包的用处</h1><p>闭包最大的用处是利用延迟执行特性，进行一些操作。</p>\n<h2 id=\"go函数\"><a href=\"#go函数\" class=\"headerlink\" title=\"go函数\"></a>go函数</h2><p>启动定时任务，且可控制关闭它，可以使用闭包：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">startTicker</span><span class=\"token punctuation\">(</span>dur time<span class=\"token punctuation\">.</span>Duration<span class=\"token punctuation\">)</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    ticker <span class=\"token operator\">:=</span> time<span class=\"token punctuation\">.</span><span class=\"token function\">NewTicker</span><span class=\"token punctuation\">(</span>dur<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">go</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n       <span class=\"token keyword\">for</span> <span class=\"token keyword\">range</span> ticker<span class=\"token punctuation\">.</span>C <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// do something</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> ticker<span class=\"token punctuation\">.</span>Stop\n<span class=\"token punctuation\">}</span></code></pre>\n<p><a href=\"https://play.golang.org/p/ZAnKV6h8PtA\" target=\"_blank\" rel=\"noopener\">执行代码</a></p>\n<h2 id=\"defer函数\"><a href=\"#defer函数\" class=\"headerlink\" title=\"defer函数\"></a>defer函数</h2><p>常用模式还是在defer中使用闭包，而且defer+return的组合经常会让人摸不清头脑。</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token comment\" spellcheck=\"true\">// 1.</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">increaseA</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">int</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> i <span class=\"token builtin\">int</span>\n    <span class=\"token keyword\">defer</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        i<span class=\"token operator\">++</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> i\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 2.</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">increaseB</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>r <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">defer</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        r<span class=\"token operator\">++</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> r\n<span class=\"token punctuation\">}</span></code></pre>\n<p>defer中的函数将会在return后延迟执行，即先会确定返回值再执行defer函数。<br>这样会导致increaseA函数返回时拷贝<code>i</code>值作为返回值，原有的<code>i</code>去执行defer函数，并不会影响返回值。<br>而increaseB函数返回的是预先定义好的返回时的地址是确定的，这样defer函数改变的还是预先定义的<code>r</code>值。</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ol>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\" target=\"_blank\" rel=\"noopener\">闭包wikipedia</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&amp;mid=2648466918&amp;idx=2&amp;sn=151a8135f22563b7b97bf01ff480497b&amp;chksm=f2474389c530ca9f3dc2ae1124e4e5ed3db4c45096924265bccfcb8908a829b9207b0dd26047&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener\">5 年 Gopher 都不知道的 defer 细节，你别再掉进坑里！</a></li>\n</ol>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"friends":[{"avatar":"https://img-1251474779.cos.ap-beijing.myqcloud.com/icon.png","name":"djaigo","introduction":"好好学习，天天向上","url":"/","title":"前去学习"},{"avatar":"https://awps-assets.meituan.net/mit/blog/v20190629/asset/icon/favicon.ico?v=Whistle&t=20181017-1r","name":"美团技术团队","introduction":"一行代码，亿万生活。","url":"https://tech.meituan.com/","title":"点个外卖-->"},{"avatar":"","name":"鸟窝","introduction":"rpcx作者","url":"https://colobu.com/","title":"进个鸟窝-->"},{"avatar":"https://d1j8pt39hxlh3d.cloudfront.net/emoji/emojione/5.0/png/unicode/32/1f92a.png","name":"labuladong的算法小抄","introduction":"算法大神","url":"https://labuladong.gitbook.io/algo/","title":"学个算法-->"}]}},"excerpt":"","more":"<h1 id=\"什么是闭包\"><a href=\"#什么是闭包\" class=\"headerlink\" title=\"什么是闭包\"></a>什么是闭包</h1><p>参考<a href=\"https://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\" target=\"_blank\" rel=\"noopener\">闭包wikipedia</a></p>\n<h1 id=\"怎样产生闭包\"><a href=\"#怎样产生闭包\" class=\"headerlink\" title=\"怎样产生闭包\"></a>怎样产生闭包</h1><p>闭包可以让一个函数和一组变量产生关系，让这些变量的生命周期保持持久性。<br>变量可以是在闭包内部声明，也可以引用外部变量，例如：</p>\n<pre><code class=\"go\">// 在函数内部创建变量\nfunc incr() func() int {\n    var x int  \n    return func() int {\n        x++ \n        return x \n    } \n}\n\n// 在函数外面创建变量\nvar x int \nfunc incr() func() int { \n    return func() int {\n        x++ \n        return x \n    } \n}</code></pre>\n<p>在函数内部创建变量可以对外部进行隐藏，在外部声明变量可以在任意点修改。<br>闭包特点是：函数内部有引用外部变量，且有延迟执行的特点。<br>在golang中比较常见的就是遍历元素，启动一个协程去执行，例如：</p>\n<pre><code class=\"go\">for i := range data {\n    go func() {\n        fmt.Println(i)\n    }()\n}</code></pre>\n<p>为了防止执行时<code>i</code>的值相同，需要做一些出，例如：</p>\n<pre><code class=\"go\">for i := range data {\n    i := i\n    go func() {\n        fmt.Println(i)\n    }()\n}\n\n// 或者\nfor i := range data {\n    go func(i int) {\n        fmt.Println(i)\n    }(i)\n}</code></pre>\n<h1 id=\"闭包的用处\"><a href=\"#闭包的用处\" class=\"headerlink\" title=\"闭包的用处\"></a>闭包的用处</h1><p>闭包最大的用处是利用延迟执行特性，进行一些操作。</p>\n<h2 id=\"go函数\"><a href=\"#go函数\" class=\"headerlink\" title=\"go函数\"></a>go函数</h2><p>启动定时任务，且可控制关闭它，可以使用闭包：</p>\n<pre><code class=\"go\">func startTicker(dur time.Duration) func() {\n    ticker := time.NewTicker(dur)\n    go func() {\n       for range ticker.C {\n            // do something\n        }\n    }()\n    return ticker.Stop\n}</code></pre>\n<p><a href=\"https://play.golang.org/p/ZAnKV6h8PtA\" target=\"_blank\" rel=\"noopener\">执行代码</a></p>\n<h2 id=\"defer函数\"><a href=\"#defer函数\" class=\"headerlink\" title=\"defer函数\"></a>defer函数</h2><p>常用模式还是在defer中使用闭包，而且defer+return的组合经常会让人摸不清头脑。</p>\n<pre><code class=\"go\">// 1.\nfunc increaseA() int {\n    var i int\n    defer func() {\n        i++\n    }()\n    return i\n}\n\n// 2.\nfunc increaseB() (r int) {\n    defer func() {\n        r++\n    }()\n    return r\n}</code></pre>\n<p>defer中的函数将会在return后延迟执行，即先会确定返回值再执行defer函数。<br>这样会导致increaseA函数返回时拷贝<code>i</code>值作为返回值，原有的<code>i</code>去执行defer函数，并不会影响返回值。<br>而increaseB函数返回的是预先定义好的返回时的地址是确定的，这样defer函数改变的还是预先定义的<code>r</code>值。</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ol>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\" target=\"_blank\" rel=\"noopener\">闭包wikipedia</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&mid=2648466918&idx=2&sn=151a8135f22563b7b97bf01ff480497b&chksm=f2474389c530ca9f3dc2ae1124e4e5ed3db4c45096924265bccfcb8908a829b9207b0dd26047&scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener\">5 年 Gopher 都不知道的 defer 细节，你别再掉进坑里！</a></li>\n</ol>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckh351dtk000019z4gbbbahmp","category_id":"ckh351dtt000419z45z8hbfbw","_id":"ckh351du8000h19z4e5ypgjpg"},{"post_id":"ckh351du3000e19z44s7paukj","category_id":"ckh351dtt000419z45z8hbfbw","_id":"ckh351duc000n19z47vxlecj5"},{"post_id":"ckh351dtu000619z408g09ht9","category_id":"ckh351du1000b19z49o0l8344","_id":"ckh351dud000s19z41z1qa4vc"},{"post_id":"ckh351du9000k19z4h8w70ukx","category_id":"ckh351du8000i19z43plu3cg5","_id":"ckh351due000u19z4f2k64iwl"},{"post_id":"ckh351dtx000819z49rk0575z","category_id":"ckh351du8000i19z43plu3cg5","_id":"ckh351duf000y19z4am227riu"},{"post_id":"ckh351dub000m19z4exq34clg","category_id":"ckh351du8000i19z43plu3cg5","_id":"ckh351duh001119z47uko2c8m"},{"post_id":"ckh351duc000r19z48f444o4a","category_id":"ckh351duc000p19z43nsx2n2j","_id":"ckh351duk001419z4absa6v2m"},{"post_id":"ckh351du0000a19z4d0tk2cbq","category_id":"ckh351duc000p19z43nsx2n2j","_id":"ckh351dum001819z419523x92"},{"post_id":"ckh351dud000t19z4bcbmg2p0","category_id":"ckh351du8000i19z43plu3cg5","_id":"ckh351duo001a19z4dnvi1lf9"},{"post_id":"ckh351duf000x19z40tmkgqxi","category_id":"ckh351du8000i19z43plu3cg5","_id":"ckh351dup001d19z44u185kz7"},{"post_id":"ckh351dug001019z49vu98bwk","category_id":"ckh351du8000i19z43plu3cg5","_id":"ckh351dur001g19z47j8ndd3y"},{"post_id":"ckh351du7000g19z475yrckom","category_id":"ckh351due000v19z4841x79jz","_id":"ckh351duu001k19z43aecb6h1"},{"post_id":"ckh351duh001319z442gz1pbq","category_id":"ckh351du8000i19z43plu3cg5","_id":"ckh351duv001n19z4emvh8pd8"},{"post_id":"ckh351dul001719z49za51u1k","category_id":"ckh351du8000i19z43plu3cg5","_id":"ckh351duz001s19z4957nc7hy"},{"post_id":"ckh351dun001919z412iudta4","category_id":"ckh351du8000i19z43plu3cg5","_id":"ckh351duz001u19z46fyh3um3"},{"post_id":"ckh351dup001c19z4gwmp3xyw","category_id":"ckh351du8000i19z43plu3cg5","_id":"ckh351dv1001x19z4fpe1567e"},{"post_id":"ckh351duq001f19z4he7f7naa","category_id":"ckh351du8000i19z43plu3cg5","_id":"ckh351dv3002019z41od3dstx"},{"post_id":"ckh351duz001t19z424gyhnck","category_id":"ckh351duw001p19z48whxgf07","_id":"ckh351dv5002319z4h4cw6z7w"},{"post_id":"ckh351dus001j19z4ajma45u8","category_id":"ckh351duw001p19z48whxgf07","_id":"ckh351dv6002719z4e6e36pld"},{"post_id":"ckh351dv0001v19z42qmc2wgl","category_id":"ckh351duw001p19z48whxgf07","_id":"ckh351dv7002a19z42mxbe1ht"},{"post_id":"ckh351dv3001z19z47mb2bf5b","category_id":"ckh351duw001p19z48whxgf07","_id":"ckh351dv8002e19z4fqzu3gov"},{"post_id":"ckh351duu001m19z4205dd6kr","category_id":"ckh351duw001p19z48whxgf07","_id":"ckh351dv9002h19z4atclclma"},{"post_id":"ckh351dv4002119z4h1d23cjy","category_id":"ckh351duw001p19z48whxgf07","_id":"ckh351dvc002k19z41xa38ve9"},{"post_id":"ckh351dv6002619z4ab9lfl8b","category_id":"ckh351duw001p19z48whxgf07","_id":"ckh351dvd002n19z4hajlealx"},{"post_id":"ckh351duy001r19z4g7mj3l6b","category_id":"ckh351duw001p19z48whxgf07","_id":"ckh351dvf002s19z4f7rlexnf"},{"post_id":"ckh351dv8002d19z4gsmq30is","category_id":"ckh351dtt000419z45z8hbfbw","_id":"ckh351dvh002u19z4bzf9fukx"},{"post_id":"ckh351dv9002g19z4hg3j9md2","category_id":"ckh351du8000i19z43plu3cg5","_id":"ckh351dvi002y19z4al8q5322"},{"post_id":"ckh351dv7002919z43rq93mkl","category_id":"ckh351dv9002f19z4crgge859","_id":"ckh351dvj003119z47gv62n12"},{"post_id":"ckh351dvb002j19z4ean61pdl","category_id":"ckh351dve002q19z42q8taz7a","_id":"ckh351dvk003419z4atdc615i"},{"post_id":"ckh351dvi003019z4c0gjgw2p","category_id":"ckh351dvi002x19z4c162g9qs","_id":"ckh351dvk003619z4gdgo23gq"},{"post_id":"ckh351dvd002m19z41mjhe4xo","category_id":"ckh351dvi002x19z4c162g9qs","_id":"ckh351dvl003919z4fiybc9z7"},{"post_id":"ckh351dvf002r19z4bytg1bmz","category_id":"ckh351dvk003519z4c1om1men","_id":"ckh351dvl003b19z4ahaafpm7"},{"post_id":"ckh351dvg002t19z41cw17m62","category_id":"ckh351dvl003819z4djgr9gvi","_id":"ckh351dvm003g19z45ye318on"},{"post_id":"ckh351dvh002w19z4cg0lh0sd","category_id":"ckh351dvl003c19z44fys0i6u","_id":"ckh351dvn003k19z47yaghsls"}],"PostTag":[{"post_id":"ckh351dtk000019z4gbbbahmp","tag_id":"ckh351dtu000519z44hfl8rwj","_id":"ckh351dua000l19z4669o902w"},{"post_id":"ckh351dtk000019z4gbbbahmp","tag_id":"ckh351du1000c19z482nycok5","_id":"ckh351duc000o19z458fa5zbw"},{"post_id":"ckh351dtu000619z408g09ht9","tag_id":"ckh351du9000j19z46dtgc3x9","_id":"ckh351dug000z19z4dmdyhmwi"},{"post_id":"ckh351dtu000619z408g09ht9","tag_id":"ckh351duc000q19z44r5172ut","_id":"ckh351duh001219z47g6m6vov"},{"post_id":"ckh351dtx000819z49rk0575z","tag_id":"ckh351duf000w19z44zl412mm","_id":"ckh351dul001619z40cln60fj"},{"post_id":"ckh351du0000a19z4d0tk2cbq","tag_id":"ckh351duk001519z4hjrzfh20","_id":"ckh351duq001e19z4db04h15b"},{"post_id":"ckh351dun001919z412iudta4","tag_id":"ckh351duf000w19z44zl412mm","_id":"ckh351dur001h19z4bkf3beu8"},{"post_id":"ckh351du3000e19z44s7paukj","tag_id":"ckh351dtu000519z44hfl8rwj","_id":"ckh351duu001l19z4g6hg4tee"},{"post_id":"ckh351du3000e19z44s7paukj","tag_id":"ckh351duo001b19z47ij0e29s","_id":"ckh351duw001o19z4dbpydu2a"},{"post_id":"ckh351du7000g19z475yrckom","tag_id":"ckh351dur001i19z45znh5e73","_id":"ckh351dv5002519z40x3244w6"},{"post_id":"ckh351du7000g19z475yrckom","tag_id":"ckh351dux001q19z499lhavmh","_id":"ckh351dv6002819z4cbbnb0lg"},{"post_id":"ckh351du7000g19z475yrckom","tag_id":"ckh351duc000q19z44r5172ut","_id":"ckh351dv8002c19z44555en17"},{"post_id":"ckh351du9000k19z4h8w70ukx","tag_id":"ckh351dv5002419z40vw43kls","_id":"ckh351dvc002l19z42hqaf6dh"},{"post_id":"ckh351du9000k19z4h8w70ukx","tag_id":"ckh351dv7002b19z4hflxebif","_id":"ckh351dvd002o19z4foyi2xct"},{"post_id":"ckh351dub000m19z4exq34clg","tag_id":"ckh351dv5002419z40vw43kls","_id":"ckh351dvi002z19z43wp4ey49"},{"post_id":"ckh351dub000m19z4exq34clg","tag_id":"ckh351dv7002b19z4hflxebif","_id":"ckh351dvj003219z4e2jk70ui"},{"post_id":"ckh351duc000r19z48f444o4a","tag_id":"ckh351dvh002v19z4d1gg8hhz","_id":"ckh351dvm003d19z4gggoet8v"},{"post_id":"ckh351duc000r19z48f444o4a","tag_id":"ckh351dvj003319z41jlg3841","_id":"ckh351dvm003e19z4dusb6cv4"},{"post_id":"ckh351duc000r19z48f444o4a","tag_id":"ckh351dvk003719z40vn5glk4","_id":"ckh351dvm003h19z42odsci0x"},{"post_id":"ckh351dud000t19z4bcbmg2p0","tag_id":"ckh351dvl003a19z4gclo1j8o","_id":"ckh351dvn003i19z4fn182rj8"},{"post_id":"ckh351duf000x19z40tmkgqxi","tag_id":"ckh351dv5002419z40vw43kls","_id":"ckh351dvo003m19z46ppr3zj4"},{"post_id":"ckh351duf000x19z40tmkgqxi","tag_id":"ckh351dv7002b19z4hflxebif","_id":"ckh351dvo003n19z4cy1ldgz6"},{"post_id":"ckh351dug001019z49vu98bwk","tag_id":"ckh351dvn003l19z4hjel7yg5","_id":"ckh351dvq003q19z41eua7962"},{"post_id":"ckh351dug001019z49vu98bwk","tag_id":"ckh351dv7002b19z4hflxebif","_id":"ckh351dvq003r19z44evt5yuq"},{"post_id":"ckh351duh001319z442gz1pbq","tag_id":"ckh351dvp003p19z4eiu1418x","_id":"ckh351dvs003u19z412408oik"},{"post_id":"ckh351duh001319z442gz1pbq","tag_id":"ckh351duk001519z4hjrzfh20","_id":"ckh351dvs003v19z47qx1hoq9"},{"post_id":"ckh351dul001719z49za51u1k","tag_id":"ckh351dvl003a19z4gclo1j8o","_id":"ckh351dvs003x19z46bak2v1b"},{"post_id":"ckh351dup001c19z4gwmp3xyw","tag_id":"ckh351dvs003w19z4ahlvcgyv","_id":"ckh351dvv004219z4gb6329xd"},{"post_id":"ckh351dup001c19z4gwmp3xyw","tag_id":"ckh351dvs003y19z4dffi0627","_id":"ckh351dvv004319z4c370asnd"},{"post_id":"ckh351dup001c19z4gwmp3xyw","tag_id":"ckh351dvt003z19z4ccgr878v","_id":"ckh351dvv004519z4b3un69ee"},{"post_id":"ckh351dup001c19z4gwmp3xyw","tag_id":"ckh351dvu004019z4faj5hoh7","_id":"ckh351dvw004619z439dl1afj"},{"post_id":"ckh351duq001f19z4he7f7naa","tag_id":"ckh351dvu004119z46pku2h5x","_id":"ckh351dvy004b19z44pdzb633"},{"post_id":"ckh351duq001f19z4he7f7naa","tag_id":"ckh351dvv004419z40nkxanad","_id":"ckh351dvz004c19z4aldw3hp0"},{"post_id":"ckh351duq001f19z4he7f7naa","tag_id":"ckh351dvw004719z4drczerl0","_id":"ckh351dvz004e19z40ldscien"},{"post_id":"ckh351duq001f19z4he7f7naa","tag_id":"ckh351dvx004819z42hev1jxz","_id":"ckh351dvz004f19z48hkb0565"},{"post_id":"ckh351duq001f19z4he7f7naa","tag_id":"ckh351dvx004919z4cqbc2ukf","_id":"ckh351dw0004h19z4c0lkhzks"},{"post_id":"ckh351dus001j19z4ajma45u8","tag_id":"ckh351duc000q19z44r5172ut","_id":"ckh351dw0004i19z44r8u7gzm"},{"post_id":"ckh351dus001j19z4ajma45u8","tag_id":"ckh351dvy004a19z46zh7e7hz","_id":"ckh351dw1004k19z4h4h417e8"},{"post_id":"ckh351duu001m19z4205dd6kr","tag_id":"ckh351duc000q19z44r5172ut","_id":"ckh351dw1004l19z4hcsxdl5o"},{"post_id":"ckh351duu001m19z4205dd6kr","tag_id":"ckh351dvy004a19z46zh7e7hz","_id":"ckh351dw1004n19z47qpd2hzv"},{"post_id":"ckh351duy001r19z4g7mj3l6b","tag_id":"ckh351duc000q19z44r5172ut","_id":"ckh351dw1004o19z43ntb191k"},{"post_id":"ckh351duy001r19z4g7mj3l6b","tag_id":"ckh351dvy004a19z46zh7e7hz","_id":"ckh351dw2004q19z497ig0oly"},{"post_id":"ckh351duz001t19z424gyhnck","tag_id":"ckh351duc000q19z44r5172ut","_id":"ckh351dw2004r19z48fvj6v6k"},{"post_id":"ckh351duz001t19z424gyhnck","tag_id":"ckh351dvy004a19z46zh7e7hz","_id":"ckh351dw3004t19z4aw20gl0y"},{"post_id":"ckh351dv0001v19z42qmc2wgl","tag_id":"ckh351duc000q19z44r5172ut","_id":"ckh351dw4004u19z4fwl9grqd"},{"post_id":"ckh351dv0001v19z42qmc2wgl","tag_id":"ckh351dvy004a19z46zh7e7hz","_id":"ckh351dw4004w19z44r58a5jm"},{"post_id":"ckh351dv3001z19z47mb2bf5b","tag_id":"ckh351duc000q19z44r5172ut","_id":"ckh351dw4004x19z416qb72x3"},{"post_id":"ckh351dv3001z19z47mb2bf5b","tag_id":"ckh351dvy004a19z46zh7e7hz","_id":"ckh351dw5004z19z497sh4vrj"},{"post_id":"ckh351dv4002119z4h1d23cjy","tag_id":"ckh351duc000q19z44r5172ut","_id":"ckh351dw5005019z44pfu8kmw"},{"post_id":"ckh351dv4002119z4h1d23cjy","tag_id":"ckh351dvy004a19z46zh7e7hz","_id":"ckh351dw6005219z42f1r2401"},{"post_id":"ckh351dv6002619z4ab9lfl8b","tag_id":"ckh351dw4004v19z49e1l7enb","_id":"ckh351dw7005319z41avn1hqk"},{"post_id":"ckh351dv7002919z43rq93mkl","tag_id":"ckh351dw5004y19z40c4rcgxy","_id":"ckh351dw8005519z417pq21az"},{"post_id":"ckh351dv7002919z43rq93mkl","tag_id":"ckh351dw6005119z4cc5aaiat","_id":"ckh351dw8005619z4h68t46qn"},{"post_id":"ckh351dv8002d19z4gsmq30is","tag_id":"ckh351dtu000519z44hfl8rwj","_id":"ckh351dw9005819z42p25coy6"},{"post_id":"ckh351dv8002d19z4gsmq30is","tag_id":"ckh351dw8005419z4diyde84l","_id":"ckh351dw9005919z4084rgdvm"},{"post_id":"ckh351dv9002g19z4hg3j9md2","tag_id":"ckh351dw8005719z4ge7i8ww6","_id":"ckh351dwb005e19z44xbn8nkf"},{"post_id":"ckh351dv9002g19z4hg3j9md2","tag_id":"ckh351dw9005a19z4gklfhqtx","_id":"ckh351dwb005f19z443t0hjsr"},{"post_id":"ckh351dv9002g19z4hg3j9md2","tag_id":"ckh351dw9005b19z466k3hr0a","_id":"ckh351dwb005h19z4ceqf27j5"},{"post_id":"ckh351dv9002g19z4hg3j9md2","tag_id":"ckh351dwa005c19z40dpx4r5s","_id":"ckh351dwc005i19z4gy7i4nzo"},{"post_id":"ckh351dvb002j19z4ean61pdl","tag_id":"ckh351dwa005d19z46en862cf","_id":"ckh351dwc005k19z45e0e4r0f"},{"post_id":"ckh351dvd002m19z41mjhe4xo","tag_id":"ckh351dwb005g19z4a2wb5y0e","_id":"ckh351dwd005l19z42jmo1rh2"},{"post_id":"ckh351dvf002r19z4bytg1bmz","tag_id":"ckh351dwc005j19z40f7t2l25","_id":"ckh351dwe005p19z4djzq78d3"},{"post_id":"ckh351dvf002r19z4bytg1bmz","tag_id":"ckh351dwd005m19z45vv0cu6c","_id":"ckh351dwe005q19z44xtcdfhy"},{"post_id":"ckh351dvf002r19z4bytg1bmz","tag_id":"ckh351dwd005n19z4a0fz19yx","_id":"ckh351dwe005s19z4553c5bnv"},{"post_id":"ckh351dvg002t19z41cw17m62","tag_id":"ckh351dwe005o19z4h4l8304f","_id":"ckh351dwg005v19z4e6txc15n"},{"post_id":"ckh351dvg002t19z41cw17m62","tag_id":"ckh351dwe005r19z4b68y99uq","_id":"ckh351dwg005w19z43d5yfwvt"},{"post_id":"ckh351dvg002t19z41cw17m62","tag_id":"ckh351dwf005t19z4g4o675zn","_id":"ckh351dwg005y19z4d21s38z2"},{"post_id":"ckh351dvh002w19z4cg0lh0sd","tag_id":"ckh351dur001i19z45znh5e73","_id":"ckh351dwj006319z4g5y88asp"},{"post_id":"ckh351dvh002w19z4cg0lh0sd","tag_id":"ckh351dwf005u19z43qqv0sy0","_id":"ckh351dwj006419z4dvti4laf"},{"post_id":"ckh351dvh002w19z4cg0lh0sd","tag_id":"ckh351dwg005x19z4baeg1ic6","_id":"ckh351dwj006519z46ohsbmpe"},{"post_id":"ckh351dvh002w19z4cg0lh0sd","tag_id":"ckh351dwg005z19z45nr7dlu0","_id":"ckh351dwj006619z4f2054j1u"},{"post_id":"ckh351dvh002w19z4cg0lh0sd","tag_id":"ckh351dwh006019z44xyrglxs","_id":"ckh351dwj006719z4htn2gob9"},{"post_id":"ckh351dvh002w19z4cg0lh0sd","tag_id":"ckh351dwi006119z4h4jkaisw","_id":"ckh351dwj006819z4b0ol0t2c"},{"post_id":"ckh351dvi003019z4c0gjgw2p","tag_id":"ckh351dwi006219z43wkf7elf","_id":"ckh351dwj006919z4h66le6a0"}],"Tag":[{"name":"redis","_id":"ckh351dtu000519z44hfl8rwj"},{"name":"cluster","_id":"ckh351du1000c19z482nycok5"},{"name":"git","_id":"ckh351du9000j19z46dtgc3x9"},{"name":"cmd","_id":"ckh351duc000q19z44r5172ut"},{"name":"compile","_id":"ckh351duf000w19z44zl412mm"},{"name":"tcp","_id":"ckh351duk001519z4hjrzfh20"},{"name":"config","_id":"ckh351duo001b19z47ij0e29s"},{"name":"etcd","_id":"ckh351dur001i19z45znh5e73"},{"name":"etcdctl","_id":"ckh351dux001q19z499lhavmh"},{"name":"mpg","_id":"ckh351dv5002419z40vw43kls"},{"name":"infra","_id":"ckh351dv7002b19z4hflxebif"},{"name":"IP","_id":"ckh351dvh002v19z4d1gg8hhz"},{"name":"IPv4","_id":"ckh351dvj003319z41jlg3841"},{"name":"IPv6","_id":"ckh351dvk003719z40vn5glk4"},{"name":"runtime","_id":"ckh351dvl003a19z4gclo1j8o"},{"name":"memory","_id":"ckh351dvn003l19z4hjel7yg5"},{"name":"net","_id":"ckh351dvp003p19z4eiu1418x"},{"name":"ipc","_id":"ckh351dvs003w19z4ahlvcgyv"},{"name":"shmems","_id":"ckh351dvs003y19z4dffi0627"},{"name":"queues","_id":"ckh351dvt003z19z4ccgr878v"},{"name":"semaphores","_id":"ckh351dvu004019z4faj5hoh7"},{"name":"syscall","_id":"ckh351dvu004119z46pku2h5x"},{"name":"linux","_id":"ckh351dvv004419z40nkxanad"},{"name":"syscall6","_id":"ckh351dvw004719z4drczerl0"},{"name":"rawsyscall","_id":"ckh351dvx004819z42hev1jxz"},{"name":"rawsyscall6","_id":"ckh351dvx004919z4cqbc2ukf"},{"name":"command","_id":"ckh351dvy004a19z46zh7e7hz"},{"name":"link","_id":"ckh351dw4004v19z49e1l7enb"},{"name":"protobuf","_id":"ckh351dw5004y19z40c4rcgxy"},{"name":"proto3","_id":"ckh351dw6005119z4cc5aaiat"},{"name":"key","_id":"ckh351dw8005419z4diyde84l"},{"name":"sync","_id":"ckh351dw8005719z4ge7i8ww6"},{"name":"mutex","_id":"ckh351dw9005a19z4gklfhqtx"},{"name":"condition variable","_id":"ckh351dw9005b19z466k3hr0a"},{"name":"atomic","_id":"ckh351dwa005c19z40dpx4r5s"},{"name":"lua","_id":"ckh351dwa005d19z46en862cf"},{"name":"load balance","_id":"ckh351dwb005g19z4a2wb5y0e"},{"name":"image","_id":"ckh351dwc005j19z40f7t2l25"},{"name":"registry","_id":"ckh351dwd005m19z45vv0cu6c"},{"name":"server","_id":"ckh351dwd005n19z4a0fz19yx"},{"name":"blog","_id":"ckh351dwe005o19z4h4l8304f"},{"name":"explain","_id":"ckh351dwe005r19z4b68y99uq"},{"name":"comment","_id":"ckh351dwf005t19z4g4o675zn"},{"name":"zk","_id":"ckh351dwf005u19z43qqv0sy0"},{"name":"zookeeper","_id":"ckh351dwg005x19z4baeg1ic6"},{"name":"consul","_id":"ckh351dwg005z19z45nr7dlu0"},{"name":"confd","_id":"ckh351dwh006019z44xyrglxs"},{"name":"eureka","_id":"ckh351dwi006119z4h4jkaisw"},{"name":"closure","_id":"ckh351dwi006219z43wkf7elf"}]}}